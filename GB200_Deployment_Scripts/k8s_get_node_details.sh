#!/bin/bash
#
# k8s_get_nodes_details.sh - GPU Node Information Tool for OKE
#
# Description:
#   Lists GPU instances in OCI/Kubernetes with detailed information including
#   GPU memory clusters, fabrics, capacity topology, and announcements.
#
# Dependencies on the node it is run from:
#   - oci CLI (configured)
#   - kubectl (configured with cluster access)
#   - jq (JSON processor)
#   - base64, gunzip, xxd (for user-data decoding)
#   - helm
#
# Usage:
#   ./k8s_get_nodes_details.sh [OPTIONS] [resource-ocid] [OPTIONS]
#   Run with --help for full usage information.
#
# Configuration:
#   If you have a variables.sh file already precreated will use the value in it, else will prompt to create one.
#   It'll query for the resources to populate the file accordingly.
#   It assumes that you are running the components for the AI stack in the same compartment, compute, network, storage.
#   Optional: OKE_CLUSTER_ID to specify which OKE cluster to manage
#
# Author: Tim Cowen
# Version: 2.2
# Please use at your own risk.
#

set -o pipefail

#===============================================================================
# CONFIGURATION
#===============================================================================

# Color codes (readonly to prevent accidental modification)
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly LIGHT_GREEN='\033[92m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly GRAY='\033[0;90m'
readonly ORANGE='\033[38;5;208m'
readonly BOLD='\033[1m'
readonly NC='\033[0m' # No Color

# Debug mode (set via --debug command line flag)
DEBUG_MODE=false

# Cache settings
readonly CACHE_MAX_AGE=3600  # 1 hour in seconds

# Script directory and cache paths
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly CACHE_DIR="${SCRIPT_DIR}/cache"
readonly TEMP_DIR="${CACHE_DIR}/tmp"

# Cache file paths (derived from CACHE_DIR)
readonly FABRIC_CACHE="${CACHE_DIR}/gpu_fabrics.txt"
readonly CLUSTER_CACHE="${CACHE_DIR}/gpu_clusters.txt"
readonly INSTANCE_CONFIG_CACHE="${CACHE_DIR}/instance_configurations.txt"
readonly NODE_STATE_CACHE="${CACHE_DIR}/node_states.txt"
readonly CAPACITY_TOPOLOGY_CACHE="${CACHE_DIR}/capacity_topology_hosts.txt"
readonly ANNOUNCEMENTS_LIST_CACHE="${CACHE_DIR}/announcements_list.json"
readonly OKE_ENV_CACHE="${CACHE_DIR}/oke_environment.txt"
readonly COMPUTE_CLUSTER_CACHE="${CACHE_DIR}/compute_clusters.txt"
readonly NETWORK_RESOURCES_CACHE="${CACHE_DIR}/network_resources.txt"
readonly BOOT_VOLUME_CACHE="${CACHE_DIR}/boot_volumes.txt"
readonly IMAGE_CACHE="${CACHE_DIR}/images.txt"
readonly INSTANCE_CLUSTER_MAP_CACHE="${CACHE_DIR}/instance_cluster_map.txt"
readonly INSTANCE_LIST_CACHE="${CACHE_DIR}/instance_list.json"

# Network gateway cache files
readonly IGW_CACHE="${CACHE_DIR}/internet_gateways.txt"
readonly SGW_CACHE="${CACHE_DIR}/service_gateways.txt"
readonly NAT_CACHE="${CACHE_DIR}/nat_gateways.txt"
readonly DRG_CACHE="${CACHE_DIR}/drg_attachments.txt"
readonly LPG_CACHE="${CACHE_DIR}/local_peering_gateways.txt"
readonly RPC_CACHE="${CACHE_DIR}/remote_peering_connections.txt"
readonly RT_CACHE="${CACHE_DIR}/route_tables.txt"
readonly NSG_RULES_CACHE="${CACHE_DIR}/nsg_rules.txt"
readonly NSG_RULES_DETAIL_DIR="${CACHE_DIR}/nsg_rules_detail"
readonly SL_CACHE="${CACHE_DIR}/security_lists.txt"
readonly XR_CACHE_DIR="${CACHE_DIR}/xr_map"
readonly XR_CACHE_TTL=180  # 3 minutes for cross-region DRG map
readonly MAINT_EVENTS_CACHE="${CACHE_DIR}/maintenance_events.json"
readonly MAINT_EVENTS_CACHE_TTL=3600  # 1 hour TTL for maintenance events
readonly FAULT_DETAILS_CACHE="${CACHE_DIR}/fault_details.txt"
readonly OS_PE_CACHE="${CACHE_DIR}/os_private_endpoints.txt"

# FSS (File Storage Service) cache files
readonly FSS_FS_CACHE="${CACHE_DIR}/fss_file_systems.json"
readonly FSS_MT_CACHE="${CACHE_DIR}/fss_mount_targets.json"
readonly FSS_EXPORT_CACHE="${CACHE_DIR}/fss_exports.json"

# Identity cache files
readonly POLICIES_ALL_CACHE="${CACHE_DIR}/policies_all.json"
readonly POLICIES_COMPS_CACHE="${CACHE_DIR}/policies_compartments.json"
readonly IDENTITY_DOMAINS_CACHE="${CACHE_DIR}/identity_domains.json"

# Known shortnames for subnets and NSGs
readonly NETWORK_SHORTNAMES=("bastion" "cp" "operator" "int_lb" "pub_lb" "pods" "workers" "fss" "lustre")

# Global associative arrays for lookups (must use declare -gA for global scope)
declare -gA INSTANCE_ANNOUNCEMENTS
declare -gA GPU_MEM_CLUSTER_ANNOUNCEMENTS

# Global arrays for interactive GPU management selection
declare -gA FABRIC_INDEX_MAP      # f1 -> fabric_ocid
declare -gA CLUSTER_INDEX_MAP     # g1 -> cluster_ocid
declare -gA IC_INDEX_MAP          # i1 -> instance_config_ocid
declare -gA CC_INDEX_MAP          # c1 -> compute_cluster_ocid

# Global arrays for Private Endpoint actions
declare -gA PE_NSG_MAP            # 1 -> nsg_ocid for PE details
declare -gA PE_FQDN_MAP           # 1 -> fqdn|label for PE details

# Effective compartment/region (set in main after parsing args)
EFFECTIVE_COMPARTMENT_ID=""
EFFECTIVE_REGION=""

#===============================================================================
# UTILITY FUNCTIONS
#===============================================================================

# Print error message to stderr
log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Print warning message to stderr
log_warn() {
    echo -e "${YELLOW}[WARNING]${NC} $1" >&2
}

# Print info message to stderr (no color for cleaner output)
log_info() {
    echo "$1" >&2
}

# Logs directory setup
LOGS_DIR="${LOGS_DIR:-./logs}"
mkdir -p "$LOGS_DIR" 2>/dev/null

# Action log file for tracking changes (create, update, delete operations)
ACTION_LOG_FILE="${ACTION_LOG_FILE:-${LOGS_DIR}/k8s_nodes_actions_$(date +%Y%m%d).log}"

# Maintenance log file for maintenance operations
MAINTENANCE_LOG_FILE="${MAINTENANCE_LOG_FILE:-${LOGS_DIR}/k8s_maintenance_$(date +%Y%m%d).log}"

# Log action to file and display command on screen
# Args: $1 = action type (e.g., REBOOT, TERMINATE), $2 = command being executed
log_action() {
    local action_type="$1"
    local command="$2"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Display command on screen
    echo ""
    echo -e "${YELLOW}Executing:${NC}"
    echo -e "${GRAY}$command${NC}"
    echo ""
    
    # Log to file
    {
        echo "========================================"
        echo "Timestamp: $timestamp"
        echo "Action: $action_type"
        echo "Command: $command"
        echo "========================================"
        echo ""
    } >> "$ACTION_LOG_FILE" 2>/dev/null
}

# Log action result to file
# Args: $1 = result (SUCCESS/FAILED), $2 = optional details
log_action_result() {
    local result="$1"
    local details="${2:-}"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    {
        echo "Result: $result"
        [[ -n "$details" ]] && echo "Details: $details"
        echo "Completed: $timestamp"
        echo ""
    } >> "$ACTION_LOG_FILE" 2>/dev/null
}

# Check if a value is a valid OCID (not empty, not N/A, not null)
# Args: $1 = value to check
# Returns: 0 if valid, 1 if invalid
is_valid_ocid() {
    local val="$1"
    [[ -n "$val" && "$val" != "N/A" && "$val" != "null" ]]
}

# Check if cache file is fresh (less than CACHE_MAX_AGE seconds old)
# Args: $1 = cache file path
# Returns: 0 if fresh, 1 if stale or missing
is_cache_fresh() {
    local cache_file="$1"
    
    [[ ! -f "$cache_file" ]] && return 1
    
    local file_mtime
    file_mtime=$(stat -c %Y "$cache_file" 2>/dev/null) || return 1
    
    local current_time
    current_time=$(date +%s)
    
    local cache_age=$((current_time - file_mtime))
    [[ $cache_age -lt $CACHE_MAX_AGE ]]
}

# Display a compact one-liner showing which caches are in use on the current page
# Args: pairs of "cache_file|label|type_filter" where type_filter is optional
#   - Text caches: lines counted (excluding #comments and blank lines)
#   - Text caches with type_filter: only count lines starting with that prefix
#   - JSON caches (*.json): count via jq .data.items or .data length
#   - If cache missing: "-- cached, --"
# Output: single gray info line like:
#   ℹ Subnets (8, 3m) │ NSGs (12, 3m) │ OS PEs (2, 0m)
_display_cache_info() {
    local parts=()
    
    for spec in "$@"; do
        local cache_file label type_filter
        IFS='|' read -r cache_file label type_filter <<< "$spec"
        
        [[ -z "$cache_file" || -z "$label" ]] && continue
        
        if [[ ! -f "$cache_file" || ! -s "$cache_file" ]]; then
            parts+=("${label} (0, --)")
            continue
        fi
        
        # Count items
        local count=0
        local ext="${cache_file##*.}"
        if [[ "$ext" == "json" ]]; then
            # JSON: try .data.items[] first, then .data[]
            count=$(jq -r '(.data.items // .data // []) | length' "$cache_file" 2>/dev/null || echo 0)
        elif [[ -n "$type_filter" ]]; then
            # Text with prefix filter (e.g. SUBNET, NSG)
            count=$(grep -c "^${type_filter}|" "$cache_file" 2>/dev/null || true)
        else
            # Text: count non-comment non-blank lines
            count=$(grep -cvE '^#|^$' "$cache_file" 2>/dev/null || true)
        fi
        count=${count:-0}
        count=$(echo "$count" | tr -d '[:space:]')
        
        # Age in minutes
        local mtime age_mins age_str
        mtime=$(stat -c %Y "$cache_file" 2>/dev/null || echo 0)
        age_mins=$(( ($(date +%s) - mtime) / 60 ))
        if [[ $age_mins -lt 1 ]]; then
            age_str="<1m"
        elif [[ $age_mins -ge 60 ]]; then
            age_str="$((age_mins / 60))h$((age_mins % 60))m"
        else
            age_str="${age_mins}m"
        fi
        
        parts+=("${label} (${count}, ${age_str})")
    done
    
    if [[ ${#parts[@]} -gt 0 ]]; then
        local line=""
        for ((i=0; i<${#parts[@]}; i++)); do
            [[ $i -gt 0 ]] && line+=" │ "
            line+="${parts[$i]}"
        done
        echo -e "  ${GRAY}ℹ ${line}${NC}"
    fi
}
# Uses trap to ensure cleanup on script exit
create_temp_file() {
    local tmp
    # Ensure temp directory exists
    [[ ! -d "$TEMP_DIR" ]] && mkdir -p "$TEMP_DIR"
    tmp=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX") || { log_error "Failed to create temp file"; return 1; }
    echo "$tmp"
}

# Show progress bar for parallel operations
# Args: $1 = output_dir, $2 = file_pattern, $3 = total_count, $4 = description
# Runs in background, call with & and capture PID, then kill when done
show_parallel_progress() {
    local output_dir="$1"
    local file_pattern="$2"
    local total="$3"
    local desc="${4:-Processing}"
    
    local spinner='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local spin_idx=0
    
    while true; do
        local completed
        completed=$(find "$output_dir" -name "$file_pattern" 2>/dev/null | wc -l)
        local pct=0
        [[ "$total" -gt 0 ]] && pct=$((completed * 100 / total))
        
        # Build progress bar (20 chars wide)
        local filled=$((pct / 5))
        local empty=$((20 - filled))
        local bar=""
        for ((i=0; i<filled; i++)); do bar+="█"; done
        for ((i=0; i<empty; i++)); do bar+="░"; done
        
        # Get spinner character
        local spin_char="${spinner:$spin_idx:1}"
        spin_idx=$(( (spin_idx + 1) % ${#spinner} ))
        
        # Print progress (carriage return to overwrite)
        printf "\r  ${CYAN}%s${NC} [${GREEN}%s${NC}] %3d%% (%d/%d) %s " "$spin_char" "$bar" "$pct" "$completed" "$total" "$desc"
        
        # Exit if complete
        [[ "$completed" -ge "$total" ]] && break
        
        sleep 0.2
    done
    printf "\r  ${GREEN}✓${NC} [████████████████████] 100%% (%d/%d) %s \n" "$total" "$total" "$desc"
}

# Run a command with a live elapsed timer display
# Streams command output in real-time while showing an updating elapsed counter
# Args: $1 = command string to execute, $2 = log file to append output
# Returns: exit code of the executed command
# Usage: run_with_elapsed_timer "my_long_command --args" "/path/to/logfile"
#        local exit_code=$?
run_with_elapsed_timer() {
    local cmd_to_run="$1"
    local timer_log_file="${2:-}"
    local timer_start=$(date +%s)
    local timer_output_tmp
    timer_output_tmp=$(mktemp "${TEMP_DIR:-/tmp}/timer_output.XXXXXXXXXX")
    
    # Show timer header
    echo -e "  ${CYAN}⏱ Timer started - tracking elapsed time${NC}"
    echo ""
    
    # Run command in background, capture all output to temp file
    eval "$cmd_to_run" > "$timer_output_tmp" 2>&1 &
    local cmd_pid=$!
    
    # Monitor loop: show timer + new output lines
    local last_line_count=0
    local spinner='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local spin_idx=0
    
    while kill -0 "$cmd_pid" 2>/dev/null; do
        # Check for new output lines
        local current_lines
        current_lines=$(wc -l < "$timer_output_tmp" 2>/dev/null || echo "0")
        
        if [[ $current_lines -gt $last_line_count ]]; then
            # Clear the timer line before showing output
            printf "\r\033[K"
            # Display new lines
            sed -n "$((last_line_count + 1)),${current_lines}p" "$timer_output_tmp"
            last_line_count=$current_lines
        fi
        
        # Update elapsed timer (overwrites itself on same line via \r)
        local elapsed=$(($(date +%s) - timer_start))
        local t_hrs=$((elapsed / 3600))
        local t_mins=$(( (elapsed % 3600) / 60 ))
        local t_secs=$((elapsed % 60))
        local spin_char="${spinner:$spin_idx:1}"
        spin_idx=$(( (spin_idx + 1) % ${#spinner} ))
        
        if [[ $t_hrs -gt 0 ]]; then
            printf "\r  \033[36m%s ⏱ Elapsed: %dh %02dm %02ds\033[0m" "$spin_char" "$t_hrs" "$t_mins" "$t_secs"
        elif [[ $t_mins -gt 0 ]]; then
            printf "\r  \033[36m%s ⏱ Elapsed: %dm %02ds\033[0m" "$spin_char" "$t_mins" "$t_secs"
        else
            printf "\r  \033[36m%s ⏱ Elapsed: %ds\033[0m" "$spin_char" "$t_secs"
        fi
        
        sleep 1
    done
    
    # Wait for process to fully exit and capture exit code
    wait "$cmd_pid"
    local cmd_exit_code=$?
    
    # Show any remaining output that arrived after last check
    local final_lines
    final_lines=$(wc -l < "$timer_output_tmp" 2>/dev/null || echo "0")
    if [[ $final_lines -gt $last_line_count ]]; then
        printf "\r\033[K"
        sed -n "$((last_line_count + 1)),${final_lines}p" "$timer_output_tmp"
    fi
    
    # Also check for any trailing partial line (no newline at end)
    local file_last_char
    file_last_char=$(tail -c 1 "$timer_output_tmp" 2>/dev/null | xxd -p 2>/dev/null)
    if [[ -n "$file_last_char" && "$file_last_char" != "0a" ]]; then
        # There's a partial line at the end without a newline
        printf "\r\033[K"
        local partial_line
        partial_line=$(tail -n 1 "$timer_output_tmp" 2>/dev/null)
        # Only show if it's different from what we already showed
        if [[ $final_lines -eq $last_line_count ]]; then
            echo "$partial_line"
        fi
    fi
    
    # Append all output to the log file
    if [[ -n "$timer_log_file" ]]; then
        cat "$timer_output_tmp" >> "$timer_log_file" 2>/dev/null
    fi
    
    # Clean up temp file
    rm -f "$timer_output_tmp"
    
    # Calculate and display final elapsed time
    local total_elapsed=$(($(date +%s) - timer_start))
    local final_hrs=$((total_elapsed / 3600))
    local final_mins=$(( (total_elapsed % 3600) / 60 ))
    local final_secs=$((total_elapsed % 60))
    
    printf "\r\033[K"
    echo ""
    if [[ $final_hrs -gt 0 ]]; then
        echo -e "  ${BOLD}${CYAN}⏱ Total elapsed: ${WHITE}${final_hrs}h ${final_mins}m ${final_secs}s${NC}"
    elif [[ $final_mins -gt 0 ]]; then
        echo -e "  ${BOLD}${CYAN}⏱ Total elapsed: ${WHITE}${final_mins}m ${final_secs}s${NC}"
    else
        echo -e "  ${BOLD}${CYAN}⏱ Total elapsed: ${WHITE}${final_secs}s${NC}"
    fi
    
    return $cmd_exit_code
}

# Lookup value from pipe-delimited cache file
# Args: $1 = cache file, $2 = key, $3 = field number (1-indexed)
# Returns: field value or "N/A" if not found
lookup_cache() {
    local cache_file="$1"
    local key="$2"
    local field="$3"
    
    [[ ! -f "$cache_file" ]] && { echo "N/A"; return 1; }
    
    local line
    line=$(grep "^${key}|" "$cache_file" 2>/dev/null | head -n1)
    
    if [[ -n "$line" ]]; then
        local value
        value=$(echo "$line" | cut -d'|' -f"$field")
        echo "${value:-N/A}"
    else
        echo "N/A"
        return 1
    fi
}

# Refresh all cache files
refresh_all_caches() {
    echo -e "${BOLD}${CYAN}Refreshing all caches...${NC}"
    
    # List of all cache files
    local cache_files=(
        "$FABRIC_CACHE"
        "$CLUSTER_CACHE"
        "$INSTANCE_CLUSTER_MAP_CACHE"
        "$INSTANCE_CONFIG_CACHE"
        "$NODE_STATE_CACHE"
        "$CAPACITY_TOPOLOGY_CACHE"
        "$ANNOUNCEMENTS_LIST_CACHE"
        "$OKE_ENV_CACHE"
        "$COMPUTE_CLUSTER_CACHE"
        "$NETWORK_RESOURCES_CACHE"
        "$IGW_CACHE"
        "$SGW_CACHE"
        "$NAT_CACHE"
        "$DRG_CACHE"
        "$LPG_CACHE"
        "$RPC_CACHE"
        "$RT_CACHE"
        "$NSG_RULES_CACHE"
        "$SL_CACHE"
        "$MAINT_EVENTS_CACHE"
        "$FAULT_DETAILS_CACHE"
        "$OS_PE_CACHE"
        "$INSTANCE_LIST_CACHE"
        "$FSS_FS_CACHE"
        "$FSS_MT_CACHE"
        "$FSS_EXPORT_CACHE"
        "$POLICIES_ALL_CACHE"
        "$POLICIES_COMPS_CACHE"
        "$IDENTITY_DOMAINS_CACHE"
    )
    
    local removed_count=0
    for cache_file in "${cache_files[@]}"; do
        if [[ -f "$cache_file" ]]; then
            rm -f "$cache_file"
            ((removed_count++))
        fi
    done
    
    echo -e "${GREEN}✓${NC} Removed ${removed_count} cache file(s) from ${CACHE_DIR}"
    echo ""
    echo -e "${WHITE}Cache will be refreshed on next command execution.${NC}"
    echo -e "${GRAY}Tip: Run without arguments to refresh and list all instances${NC}"
}

# Check if required commands are available
check_dependencies() {
    local missing=()
    
    command -v oci &>/dev/null || missing+=("oci")
    command -v kubectl &>/dev/null || missing+=("kubectl")
    command -v jq &>/dev/null || missing+=("jq")
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing required commands: ${missing[*]}"
        log_error "Please install the missing dependencies and try again."
        return 1
    fi
    return 0
}

#===============================================================================
# CACHE FETCH FUNCTIONS
#===============================================================================

# Fetch and cache GPU memory fabrics from OCI
fetch_gpu_fabrics() {
    [[ -z "$TENANCY_ID" ]] && { log_warn "TENANCY_ID not set. GPU fabric details unavailable."; return 1; }
    
    is_cache_fresh "$FABRIC_CACHE" && return 0
    
    log_info "Fetching GPU memory fabrics from OCI..."
    
    local raw_json
    raw_json=$(create_temp_file) || return 1
    
    if ! oci compute compute-gpu-memory-fabric list \
            --compartment-id "$TENANCY_ID" \
            --all \
            --output json > "$raw_json" 2>/dev/null; then
        rm -f "$raw_json"
        log_warn "Failed to fetch GPU memory fabrics"
        return 1
    fi
    
    # Write cache header and data - filter out DELETED/TERMINATED, deduplicate
    {
        echo "# GPU Memory Fabrics"
        echo "# Format: DisplayName|Last5Chars|FabricOCID|State|HealthyHosts|AvailableHosts|TotalHosts|CurrentFirmware|TargetFirmware|FirmwareUpdateState"
        jq -r '.data.items[] | select(.["lifecycle-state"] != "DELETED" and .["lifecycle-state"] != "TERMINATED") | "\(.["display-name"])|\(.id[-5:] | ascii_downcase)|\(.id)|\(.["lifecycle-state"])|\(.["healthy-host-count"] // 0)|\(.["available-host-count"] // 0)|\(.["total-host-count"] // 0)|\(.["current-firmware-bundle-id"] // "N/A")|\(.["target-firmware-bundle-id"] // "N/A")|\(.["firmware-update-state"] // "N/A")"' "$raw_json" 2>/dev/null | sort -u
    } > "$FABRIC_CACHE"
    
    rm -f "$raw_json"
    return 0
}

# Fetch and cache GPU memory clusters from OCI
fetch_gpu_clusters() {
    local compartment="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    [[ -z "$compartment" ]] && { log_warn "COMPARTMENT_ID not set. GPU cluster details unavailable."; return 1; }
    
    # Check if cache exists and is fresh
    if is_cache_fresh "$CLUSTER_CACHE" && is_cache_fresh "$INSTANCE_CLUSTER_MAP_CACHE"; then
        # Even if cache is fresh, invalidate if any cluster is in a transitional state
        # This ensures we pick up new instances when clusters are scaling
        if [[ -f "$CLUSTER_CACHE" ]]; then
            local transitional_states
            transitional_states=$(grep -E "\|UPDATING\||\|SCALING\||\|CREATING\|" "$CLUSTER_CACHE" 2>/dev/null | wc -l)
            if [[ "$transitional_states" -gt 0 ]]; then
                log_info "Detected $transitional_states cluster(s) in transitional state - refreshing cache..."
            else
                return 0
            fi
        else
            return 0
        fi
    fi
    
    log_info "Fetching GPU memory clusters from OCI..."
    
    local raw_json
    raw_json=$(create_temp_file) || return 1
    
    if ! oci compute compute-gpu-memory-cluster list \
            --compartment-id "$compartment" \
            --all \
            --output json > "$raw_json" 2>/dev/null; then
        rm -f "$raw_json"
        log_warn "Failed to fetch GPU memory clusters"
        return 1
    fi
    
    # Write cache headers
    {
        echo "# GPU Memory Clusters"
        echo "# Format: ClusterOCID|DisplayName|State|FabricSuffix|InstanceConfigurationId|ComputeClusterId|Size"
    } > "$CLUSTER_CACHE"
    
    {
        echo "# Instance to GPU Memory Cluster Mapping"
        echo "# Format: InstanceOCID|ClusterOCID|ClusterDisplayName"
    } > "$INSTANCE_CLUSTER_MAP_CACHE"
    
    # Get cluster IDs - filter out DELETED/TERMINATED states, deduplicate
    local cluster_ids
    cluster_ids=$(jq -r '.data.items[] | select(.["lifecycle-state"] != "DELETED" and .["lifecycle-state"] != "TERMINATED") | .id // empty' "$raw_json" 2>/dev/null | sort -u)
    
    local cluster_count
    cluster_count=$(echo "$cluster_ids" | grep -c . 2>/dev/null | tr -d '[:space:]')
    [[ -z "$cluster_count" ]] && cluster_count=0
    
    # Log if there were deleted clusters filtered out
    local total_in_api
    total_in_api=$(jq -r '.data.items | length // 0' "$raw_json" 2>/dev/null)
    if [[ "$total_in_api" -gt "$cluster_count" ]]; then
        local filtered_count=$((total_in_api - cluster_count))
        log_info "Filtered out $filtered_count DELETED/TERMINATED cluster(s)"
    fi
    
    if [[ "$cluster_count" -eq 0 ]]; then
        rm -f "$raw_json"
        return 0
    fi
    
    # Create temp directory for parallel outputs
    local parallel_temp="${TEMP_DIR}/gpu_cluster_parallel_$$"
    mkdir -p "$parallel_temp"
    
    # Export function and variables for xargs subshells
    export -f create_temp_file 2>/dev/null || true
    
    # Define worker function for parallel processing
    _fetch_single_cluster() {
        local cluster_id="$1"
        local output_dir="$2"
        [[ -z "$cluster_id" ]] && return
        
        local cluster_file="${output_dir}/cluster_${cluster_id##*.}.txt"
        local instance_file="${output_dir}/instances_${cluster_id##*.}.txt"
        
        # Fetch cluster details
        local cluster_json
        cluster_json=$(oci compute compute-gpu-memory-cluster get \
            --compute-gpu-memory-cluster-id "$cluster_id" \
            --output json 2>/dev/null)
        
        if [[ -n "$cluster_json" ]] && echo "$cluster_json" | jq -e '.data' > /dev/null 2>&1; then
            local cluster_display_name
            cluster_display_name=$(echo "$cluster_json" | jq -r '.data["display-name"] // "N/A"')
            
            # Write cluster cache line
            echo "$cluster_json" | jq -r '
                .data["display-name"] as $name |
                (.data["gpu-memory-fabric-id"] // "") as $fabric_id |
                (if $fabric_id != "" and $fabric_id != null then 
                    ($fabric_id[-5:] | ascii_downcase)
                 else 
                    (($name | capture("fabric-(?<suffix>[a-z0-9]{5})") // {suffix: ""}).suffix)
                 end) as $fabric_suffix |
                "\(.data.id)|\($name)|\(.data["lifecycle-state"])|\($fabric_suffix)|\(.data["instance-configuration-id"] // "N/A")|\(.data["compute-cluster-id"] // "N/A")|\(.data["size"] // 0)"
            ' > "$cluster_file" 2>/dev/null
            
            # Fetch instances for this cluster
            local instances_json
            instances_json=$(oci compute compute-gpu-memory-cluster-instance-summary list-compute-gpu-memory-cluster-instances \
                --compute-gpu-memory-cluster-id "$cluster_id" \
                --all \
                --output json 2>/dev/null)
            
            if [[ -n "$instances_json" ]]; then
                echo "$instances_json" | jq -r --arg cluster_id "$cluster_id" --arg cluster_name "$cluster_display_name" '
                    (.data.items // .data // [])[] | 
                    "\(.["instance-id"] // .id)|\($cluster_id)|\($cluster_name)"
                ' > "$instance_file" 2>/dev/null
            fi
        fi
    }
    export -f _fetch_single_cluster
    
    # Determine parallelism (max 8 to avoid API throttling)
    local parallel_jobs=8
    [[ "$cluster_count" -lt "$parallel_jobs" ]] && parallel_jobs="$cluster_count"
    
    log_info "Fetching $cluster_count clusters in parallel (jobs=$parallel_jobs)..."
    
    # Start progress bar in background
    show_parallel_progress "$parallel_temp" "cluster_*.txt" "$cluster_count" "GPU clusters" &
    local progress_pid=$!
    
    # Run parallel fetch
    echo "$cluster_ids" | xargs -P "$parallel_jobs" -I {} bash -c '_fetch_single_cluster "$@"' _ {} "$parallel_temp"
    
    # Stop progress bar
    kill "$progress_pid" 2>/dev/null
    wait "$progress_pid" 2>/dev/null
    printf "\r  ${GREEN}✓${NC} [████████████████████] 100%% (%d/%d) GPU clusters \n" "$cluster_count" "$cluster_count"
    
    # Aggregate results from parallel outputs
    cat "$parallel_temp"/cluster_*.txt >> "$CLUSTER_CACHE" 2>/dev/null
    cat "$parallel_temp"/instances_*.txt >> "$INSTANCE_CLUSTER_MAP_CACHE" 2>/dev/null
    
    # Cleanup
    rm -rf "$parallel_temp"
    rm -f "$raw_json"
    
    return 0
}

# Lookup GPU memory cluster OCID for an instance
get_instance_gpu_cluster() {
    local instance_ocid="$1"
    [[ -z "$instance_ocid" || ! -f "$INSTANCE_CLUSTER_MAP_CACHE" ]] && { echo "N/A"; return 1; }
    
    local result
    result=$(grep "^${instance_ocid}|" "$INSTANCE_CLUSTER_MAP_CACHE" 2>/dev/null | head -1 | cut -d'|' -f2)
    
    if [[ -n "$result" ]]; then
        echo "$result"
    else
        echo "N/A"
    fi
}

# Fetch and cache all instance configurations from OCI
fetch_instance_configurations() {
    local compartment="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    [[ -z "$compartment" ]] && { log_warn "COMPARTMENT_ID not set. Instance configurations unavailable."; return 1; }
    
    is_cache_fresh "$INSTANCE_CONFIG_CACHE" && return 0
    
    log_info "Fetching instance configurations from OCI..."
    
    local raw_json
    raw_json=$(create_temp_file) || return 1
    
    if ! oci compute-management instance-configuration list \
            --compartment-id "$compartment" \
            --all \
            --output json > "$raw_json" 2>/dev/null; then
        rm -f "$raw_json"
        log_warn "Failed to fetch instance configurations"
        return 1
    fi
    
    # Write cache header and data (now includes time-created)
    {
        echo "# Instance Configurations"
        echo "# Format: InstanceConfigOCID|DisplayName|TimeCreated"
        jq -r '.data[]? | "\(.id)|\(.["display-name"] // "N/A")|\(.["time-created"] // "N/A")"' "$raw_json" 2>/dev/null
    } > "$INSTANCE_CONFIG_CACHE"
    
    rm -f "$raw_json"
    return 0
}

# Get instance configuration name from cache
# Args: $1 = instance configuration OCID
get_instance_config_name() {
    local config_id="$1"
    
    [[ -z "$config_id" || "$config_id" == "N/A" || "$config_id" == "null" ]] && { echo "N/A"; return 1; }
    
    # Ensure cache is populated
    fetch_instance_configurations
    
    # Lookup from cache
    lookup_cache "$INSTANCE_CONFIG_CACHE" "$config_id" 2
}

# Extract and display user-data (cloud-init) from an instance configuration
# Args: $1 = instance configuration OCID
get_instance_config_user_data() {
    local ic_ocid="$1"
    
    if [[ -z "$ic_ocid" ]]; then
        log_error "Instance configuration OCID required"
        return 1
    fi
    
    # Validate OCID format
    if [[ ! "$ic_ocid" =~ ^ocid1\.instanceconfiguration\. ]]; then
        log_error "Invalid instance configuration OCID format: $ic_ocid"
        echo "Expected format: ocid1.instanceconfiguration.oc1.<region>.<unique-id>" >&2
        return 1
    fi
    
    log_info "Fetching instance configuration..." >&2
    
    local ic_json
    ic_json=$(oci compute-management instance-configuration get \
        --instance-configuration-id "$ic_ocid" \
        --output json 2>/dev/null)
    
    if [[ -z "$ic_json" ]] || ! echo "$ic_json" | jq -e '.data' > /dev/null 2>&1; then
        log_error "Failed to fetch instance configuration: $ic_ocid"
        return 1
    fi
    
    local ic_name
    ic_name=$(echo "$ic_json" | jq -r '.data["display-name"] // "N/A"')
    
    # Extract user_data (base64 encoded)
    local user_data_b64
    user_data_b64=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["metadata"]["user_data"] // empty' 2>/dev/null)
    
    if [[ -z "$user_data_b64" ]]; then
        echo "# No user-data found in instance configuration: $ic_name" >&2
        echo "# OCID: $ic_ocid" >&2
        return 0
    fi
    
    # Output header as comments (to stderr so stdout is just the yaml)
    echo "# Instance Configuration: $ic_name" >&2
    echo "# OCID: $ic_ocid" >&2
    echo "# Decoded cloud-init user-data:" >&2
    echo "#" >&2
    
    # Decode and output to stdout (handles gzip compressed data)
    decode_user_data "$user_data_b64"
    
    return 0
}

#--------------------------------------------------------------------------------
# Decode base64 user_data, handling gzip compression
# Args: $1 = base64 encoded user_data
# Output: decoded (and decompressed if gzip) data to stdout
#--------------------------------------------------------------------------------
decode_user_data() {
    local user_data_b64="$1"
    
    [[ -z "$user_data_b64" ]] && return 1
    
    # Decode to temp file
    local tmp_decoded
    tmp_decoded=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    echo "$user_data_b64" | base64 -d > "$tmp_decoded" 2>/dev/null
    
    # Check if gzip compressed (magic bytes: 1f 8b)
    local magic_bytes
    magic_bytes=$(xxd -l 2 -p "$tmp_decoded" 2>/dev/null)
    
    if [[ "$magic_bytes" == "1f8b" ]]; then
        # Gzip compressed - decompress
        gunzip -c "$tmp_decoded" 2>/dev/null
    else
        # Plain text
        cat "$tmp_decoded"
    fi
    
    rm -f "$tmp_decoded"
    return 0
}

#--------------------------------------------------------------------------------
# Decode base64 user_data to file, handling gzip compression
# Args: $1 = base64 encoded user_data, $2 = output filename
# Returns: 0 on success, 1 on failure
#--------------------------------------------------------------------------------
decode_user_data_to_file() {
    local user_data_b64="$1"
    local output_file="$2"
    
    [[ -z "$user_data_b64" || -z "$output_file" ]] && return 1
    
    # Decode to temp file
    local tmp_decoded
    tmp_decoded=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    echo "$user_data_b64" | base64 -d > "$tmp_decoded" 2>/dev/null
    
    # Check if gzip compressed (magic bytes: 1f 8b)
    local magic_bytes
    magic_bytes=$(xxd -l 2 -p "$tmp_decoded" 2>/dev/null)
    
    local result=0
    if [[ "$magic_bytes" == "1f8b" ]]; then
        # Gzip compressed - decompress
        if gunzip -c "$tmp_decoded" > "$output_file" 2>/dev/null; then
            result=0
        else
            result=1
        fi
    else
        # Plain text
        if cp "$tmp_decoded" "$output_file" 2>/dev/null; then
            result=0
        else
            result=1
        fi
    fi
    
    rm -f "$tmp_decoded"
    return $result
}

#--------------------------------------------------------------------------------
# Check if user_data is gzip compressed
# Args: $1 = base64 encoded user_data
# Returns: 0 if gzip compressed, 1 if not
#--------------------------------------------------------------------------------
is_user_data_gzip() {
    local user_data_b64="$1"
    
    [[ -z "$user_data_b64" ]] && return 1
    
    # Decode to temp file and check magic bytes
    local tmp_decoded
    tmp_decoded=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    echo "$user_data_b64" | base64 -d > "$tmp_decoded" 2>/dev/null
    
    local magic_bytes
    magic_bytes=$(xxd -l 2 -p "$tmp_decoded" 2>/dev/null)
    
    rm -f "$tmp_decoded"
    
    [[ "$magic_bytes" == "1f8b" ]]
}

#--------------------------------------------------------------------------------
# Interactive instance termination with details and confirmation
# Args: $1 = instance OCID
# Shows: instance details, running pods, termination command, confirmation
#--------------------------------------------------------------------------------
terminate_instance_interactive() {
    local instance_ocid="$1"
    
    if [[ -z "$instance_ocid" ]]; then
        log_error "Instance OCID required"
        return 1
    fi
    
    echo ""
    echo -e "${BOLD}${RED}═══════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${RED}                              INSTANCE TERMINATION                                      ${NC}"
    echo -e "${BOLD}${RED}═══════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Fetch instance details
    log_info "Fetching instance details..."
    local instance_json
    instance_json=$(oci compute instance get --instance-id "$instance_ocid" --output json 2>/dev/null)
    
    if [[ -z "$instance_json" || "$instance_json" == "null" ]]; then
        log_error "Failed to fetch instance details. Instance may not exist or you don't have access."
        return 1
    fi
    
    # Parse instance details
    local display_name lifecycle_state shape ad fault_domain
    local compartment_id time_created
    display_name=$(echo "$instance_json" | jq -r '.data["display-name"] // "N/A"')
    lifecycle_state=$(echo "$instance_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    shape=$(echo "$instance_json" | jq -r '.data.shape // "N/A"')
    ad=$(echo "$instance_json" | jq -r '.data["availability-domain"] // "N/A"')
    fault_domain=$(echo "$instance_json" | jq -r '.data["fault-domain"] // "N/A"')
    compartment_id=$(echo "$instance_json" | jq -r '.data["compartment-id"] // "N/A"')
    time_created=$(echo "$instance_json" | jq -r '.data["time-created"] // "N/A"')
    
    # Color for state
    local state_color="$GREEN"
    case "$lifecycle_state" in
        RUNNING) state_color="$GREEN" ;;
        STOPPED) state_color="$RED" ;;
        TERMINATED) state_color="$RED" ;;
        *) state_color="$YELLOW" ;;
    esac
    
    # Display instance details
    echo -e "${BOLD}${WHITE}Instance Details:${NC}"
    echo -e "  ${CYAN}Display Name:${NC}    $display_name"
    echo -e "  ${CYAN}OCID:${NC}            ${YELLOW}$instance_ocid${NC}"
    echo -e "  ${CYAN}State:${NC}           ${state_color}$lifecycle_state${NC}"
    echo -e "  ${CYAN}Shape:${NC}           $shape"
    echo -e "  ${CYAN}AD:${NC}              $ad"
    echo -e "  ${CYAN}Fault Domain:${NC}    $fault_domain"
    echo -e "  ${CYAN}Compartment:${NC}     ${WHITE}$(resolve_compartment_name "$compartment_id")${NC} ${GRAY}($compartment_id)${NC}"
    echo -e "  ${CYAN}Created:${NC}         ${time_created:0:19}"
    echo ""
    
    # Check if already terminated
    if [[ "$lifecycle_state" == "TERMINATED" ]]; then
        echo -e "${YELLOW}Instance is already terminated.${NC}"
        return 0
    fi
    
    # Check if instance is in K8s and show pods
    local k8s_node_name=""
    log_info "Checking K8s node status..."
    
    # Find K8s node by provider ID
    local k8s_nodes_json
    k8s_nodes_json=$(kubectl get nodes -o json 2>/dev/null)
    
    if [[ -n "$k8s_nodes_json" ]]; then
        k8s_node_name=$(echo "$k8s_nodes_json" | jq -r --arg ocid "$instance_ocid" '
            .items[] | select(.spec.providerID | contains($ocid)) | .metadata.name
        ' 2>/dev/null)
    fi
    
    if [[ -n "$k8s_node_name" && "$k8s_node_name" != "null" ]]; then
        echo -e "${BOLD}${WHITE}Kubernetes Node:${NC}"
        echo -e "  ${CYAN}Node Name:${NC}       $k8s_node_name"
        
        # Get node status
        local node_ready node_schedulable
        node_ready=$(kubectl get node "$k8s_node_name" -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null)
        node_schedulable=$(kubectl get node "$k8s_node_name" -o jsonpath='{.spec.unschedulable}' 2>/dev/null)
        
        local ready_color="$GREEN"
        [[ "$node_ready" != "True" ]] && ready_color="$RED"
        echo -e "  ${CYAN}Ready:${NC}           ${ready_color}$node_ready${NC}"
        
        if [[ "$node_schedulable" == "true" ]]; then
            echo -e "  ${CYAN}Cordoned:${NC}        ${YELLOW}Yes${NC}"
        else
            echo -e "  ${CYAN}Cordoned:${NC}        No"
        fi
        echo ""
        
        # Get pods on this node
        echo -e "${BOLD}${WHITE}Pods Running on Node:${NC}"
        echo ""
        
        local node_pods
        node_pods=$(kubectl get pods --all-namespaces --field-selector "spec.nodeName=$k8s_node_name" -o wide 2>/dev/null)
        
        if [[ -n "$node_pods" ]]; then
            local pod_count
            pod_count=$(echo "$node_pods" | tail -n +2 | wc -l)
            echo -e "  ${CYAN}Total Pods:${NC} ${WHITE}$pod_count${NC}"
            echo ""
            
            # Print header
            echo "$node_pods" | head -1 | while IFS= read -r line; do
                echo -e "  ${BOLD}${WHITE}$line${NC}"
            done
            
            # Print pods with color coding
            echo "$node_pods" | tail -n +2 | while IFS= read -r line; do
                if echo "$line" | grep -q "Running"; then
                    echo -e "  ${GREEN}$line${NC}"
                elif echo "$line" | grep -q "Completed"; then
                    echo -e "  ${GRAY}$line${NC}"
                elif echo "$line" | grep -qE "Error|Failed|CrashLoopBackOff|ImagePullBackOff"; then
                    echo -e "  ${RED}$line${NC}"
                elif echo "$line" | grep -qE "Pending|ContainerCreating|Init"; then
                    echo -e "  ${YELLOW}$line${NC}"
                else
                    echo "  $line"
                fi
            done
            
            if [[ $pod_count -gt 0 ]]; then
                echo ""
                echo -e "  ${RED}⚠️  WARNING: $pod_count pod(s) are running on this node!${NC}"
                echo -e "  ${YELLOW}Consider draining the node first: kubectl drain $k8s_node_name --ignore-daemonsets --delete-emptydir-data --force${NC}"
            fi
        else
            echo -e "  ${GRAY}No pods found on this node${NC}"
        fi
        echo ""
    else
        echo -e "${GRAY}Instance is not registered as a Kubernetes node${NC}"
        echo ""
    fi
    
    # Show the command that will be executed
    local terminate_cmd="oci compute instance terminate --instance-id $instance_ocid --preserve-boot-volume false --force"
    
    echo -e "${BOLD}${WHITE}Command to Execute:${NC}"
    echo -e "  ${WHITE}$terminate_cmd${NC}"
    echo ""
    
    print_separator 90
    echo ""
    echo -e "${RED}⚠️  WARNING: This will PERMANENTLY TERMINATE the instance!${NC}"
    echo -e "${RED}    This action cannot be undone!${NC}"
    echo ""
    echo -e "${RED}    Instance: ${WHITE}$display_name${NC}"
    echo -e "${RED}    OCID:     ${WHITE}$instance_ocid${NC}"
    echo ""
    
    echo -n -e "${RED}Type 'TERMINATE' to confirm: ${NC}"
    read -r confirm
    
    if [[ "$confirm" == "TERMINATE" ]]; then
        echo ""
        echo -e "${YELLOW}Executing: $terminate_cmd${NC}"
        
        # Log the action
        local timestamp
        timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        {
            echo "========================================"
            echo "Timestamp: $timestamp"
            echo "Action: TERMINATE"
            echo "Instance: $display_name"
            echo "OCID: $instance_ocid"
            echo "K8s Node: ${k8s_node_name:-N/A}"
            echo "Command: $terminate_cmd"
            echo "========================================"
            echo ""
        } >> "$MAINTENANCE_LOG_FILE"
        
        if oci compute instance terminate --instance-id "$instance_ocid" --preserve-boot-volume false --force 2>&1; then
            echo ""
            echo -e "${GREEN}✓ Instance termination initiated${NC}"
            echo -e "${GRAY}  Instance will transition to TERMINATING state${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Terminated instance $display_name ($instance_ocid)" >> "$MAINTENANCE_LOG_FILE"
        else
            echo ""
            echo -e "${RED}✗ Failed to terminate instance${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Terminate instance $display_name ($instance_ocid)" >> "$MAINTENANCE_LOG_FILE"
        fi
        
        echo ""
        echo -e "${GRAY}Log: $MAINTENANCE_LOG_FILE${NC}"
    else
        echo -e "${YELLOW}Cancelled (must type 'TERMINATE' exactly)${NC}"
    fi
    
    echo ""
}

#--------------------------------------------------------------------------------
# Get user-data from an instance OCID
# Args: $1 = instance OCID
# Output: decoded user-data to stdout
#--------------------------------------------------------------------------------
get_instance_user_data() {
    local instance_ocid="$1"
    
    if [[ -z "$instance_ocid" ]]; then
        log_error "Instance OCID required"
        return 1
    fi
    
    # Validate OCID format
    if [[ ! "$instance_ocid" =~ ^ocid1\.instance\. ]]; then
        log_error "Invalid instance OCID format: $instance_ocid"
        echo "Expected format: ocid1.instance.oc1.<region>.<unique-id>" >&2
        return 1
    fi
    
    log_info "Fetching instance metadata..." >&2
    
    local instance_json
    instance_json=$(oci compute instance get \
        --instance-id "$instance_ocid" \
        --output json 2>/dev/null)
    
    if [[ -z "$instance_json" ]] || ! echo "$instance_json" | jq -e '.data' > /dev/null 2>&1; then
        log_error "Failed to fetch instance: $instance_ocid"
        return 1
    fi
    
    local instance_name
    instance_name=$(echo "$instance_json" | jq -r '.data["display-name"] // "N/A"')
    
    # Extract user_data (base64 encoded)
    local user_data_b64
    user_data_b64=$(echo "$instance_json" | jq -r '.data.metadata.user_data // empty' 2>/dev/null)
    
    if [[ -z "$user_data_b64" ]]; then
        echo "# No user-data found in instance metadata: $instance_name" >&2
        echo "# OCID: $instance_ocid" >&2
        echo "" >&2
        echo "# Note: user_data is typically only available if the instance was launched with" >&2
        echo "# cloud-init user-data specified in the metadata." >&2
        return 0
    fi
    
    # Output header as comments (to stderr so stdout is just the yaml)
    echo "# Instance: $instance_name" >&2
    echo "# OCID: $instance_ocid" >&2
    echo "# Decoded cloud-init user-data:" >&2
    echo "#" >&2
    
    # Decode and output to stdout (handles gzip compressed data)
    decode_user_data "$user_data_b64"
    
    return 0
}

# Fetch and cache compute clusters from OCI
fetch_compute_clusters() {
    local compartment="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    [[ -z "$compartment" ]] && { log_warn "COMPARTMENT_ID not set. Compute clusters unavailable."; return 1; }
    
    is_cache_fresh "$COMPUTE_CLUSTER_CACHE" && return 0
    
    log_info "Fetching compute clusters from OCI..."
    
    # Write cache header
    {
        echo "# Compute Clusters"
        echo "# Format: ComputeClusterOCID|DisplayName|AvailabilityDomain|LifecycleState"
    } > "$COMPUTE_CLUSTER_CACHE"
    
    # Get availability domains
    local ad_list
    ad_list=$(oci iam availability-domain list --compartment-id "$compartment" --region "$region" --query 'data[].name' --raw-output 2>/dev/null | jq -r '.[]' 2>/dev/null)
    
    # Fetch compute clusters from each AD
    local ad
    for ad in $ad_list; do
        [[ -z "$ad" ]] && continue
        
        local raw_json
        raw_json=$(create_temp_file) || continue
        
        if oci compute compute-cluster list \
                --compartment-id "$compartment" \
                --availability-domain "$ad" \
                --region "$region" \
                --all \
                --output json > "$raw_json" 2>/dev/null; then
            
            # OCI returns .data.items[] for paginated results
            jq -r '(.data.items // .data // [])[] | "\(.id)|\(.["display-name"] // "N/A")|\(.["availability-domain"] // "N/A")|\(.["lifecycle-state"] // "UNKNOWN")"' "$raw_json" >> "$COMPUTE_CLUSTER_CACHE" 2>/dev/null
        fi
        
        rm -f "$raw_json"
    done
    
    return 0
}

# Get compute cluster name from cache
# Args: $1 = compute cluster OCID
get_compute_cluster_name() {
    local cluster_id="$1"
    
    [[ -z "$cluster_id" || "$cluster_id" == "N/A" || "$cluster_id" == "null" ]] && { echo "N/A"; return 1; }
    
    # Ensure cache is populated
    fetch_compute_clusters
    
    # Lookup from cache
    lookup_cache "$COMPUTE_CLUSTER_CACHE" "$cluster_id" 2
}

# Fetch and cache Kubernetes node states
fetch_node_states() {
    {
        echo "# Node States"
        echo "# Format: ProviderID|NodeState"
        kubectl get nodes -o json 2>/dev/null | jq -r '
            .items[] | 
            "\(.spec.providerID)|\(
                .status.conditions[] | 
                select(.type=="Ready") | 
                if .status=="True" then "Ready" 
                elif .status=="False" then "NotReady" 
                else "Unknown" end
            )"' 2>/dev/null
    } > "$NODE_STATE_CACHE"
}

# Fetch and cache capacity topology bare metal hosts
fetch_capacity_topology() {
    [[ -z "$TENANCY_ID" ]] && { log_warn "TENANCY_ID not set. Capacity topology unavailable."; return 1; }
    
    is_cache_fresh "$CAPACITY_TOPOLOGY_CACHE" && return 0
    
    log_info "Fetching capacity topology from OCI..."
    
    local topologies_json
    topologies_json=$(create_temp_file) || return 1
    
    if ! oci compute capacity-topology list \
            --compartment-id "$TENANCY_ID" \
            --all \
            --output json > "$topologies_json" 2>/dev/null; then
        rm -f "$topologies_json"
        log_warn "Failed to fetch capacity topologies"
        return 1
    fi
    
    # Write cache header
    {
        echo "# Capacity Topology Hosts"
        echo "# Format: InstanceOCID|HostLifecycleState|HostLifecycleDetails|TopologyOCID"
    } > "$CAPACITY_TOPOLOGY_CACHE"
    
    # Get topology IDs - filter out DELETED/TERMINATED states, deduplicate
    local topology_ids
    topology_ids=$(jq -r '.data.items[] | select(.["lifecycle-state"] != "DELETED" and .["lifecycle-state"] != "TERMINATED") | .id // empty' "$topologies_json" 2>/dev/null | sort -u)
    
    local topo_count
    topo_count=$(echo "$topology_ids" | grep -c . 2>/dev/null | tr -d '[:space:]')
    [[ -z "$topo_count" ]] && topo_count=0
    
    # Log if there were deleted topologies filtered out
    local total_in_api
    total_in_api=$(jq -r '.data.items | length // 0' "$topologies_json" 2>/dev/null)
    if [[ "$total_in_api" -gt "$topo_count" ]]; then
        local filtered_count=$((total_in_api - topo_count))
        log_info "Filtered out $filtered_count DELETED/TERMINATED topology(ies)"
    fi
    
    if [[ "$topo_count" -eq 0 ]]; then
        rm -f "$topologies_json"
        return 0
    fi
    
    # Create temp directory for parallel outputs
    local parallel_temp="${TEMP_DIR}/capacity_topo_parallel_$$"
    mkdir -p "$parallel_temp"
    
    # Define worker function for parallel processing
    _fetch_single_topology() {
        local topo_id="$1"
        local output_dir="$2"
        [[ -z "$topo_id" ]] && return
        
        local output_file="${output_dir}/topo_${topo_id##*.}.txt"
        
        local hosts_json
        hosts_json=$(oci compute capacity-topology bare-metal-host list \
            --capacity-topology-id "$topo_id" \
            --all \
            --output json 2>/dev/null)
        
        if [[ -n "$hosts_json" ]]; then
            echo "$hosts_json" | jq -r --arg topo "$topo_id" '
                .data.items[]? | 
                "\(.["instance-id"] // "N/A")|\(.["lifecycle-state"] // "N/A")|\(.["lifecycle-details"] // "N/A")|\($topo)"
            ' > "$output_file" 2>/dev/null
        fi
    }
    export -f _fetch_single_topology
    
    # Determine parallelism (max 8 to avoid API throttling)
    local parallel_jobs=8
    [[ "$topo_count" -lt "$parallel_jobs" ]] && parallel_jobs="$topo_count"
    
    log_info "Fetching $topo_count topologies in parallel (jobs=$parallel_jobs)..."
    
    # Start progress bar in background
    show_parallel_progress "$parallel_temp" "topo_*.txt" "$topo_count" "capacity topologies" &
    local progress_pid=$!
    
    # Run parallel fetch
    echo "$topology_ids" | xargs -P "$parallel_jobs" -I {} bash -c '_fetch_single_topology "$@"' _ {} "$parallel_temp"
    
    # Stop progress bar
    kill "$progress_pid" 2>/dev/null
    wait "$progress_pid" 2>/dev/null
    printf "\r  ${GREEN}✓${NC} [████████████████████] 100%% (%d/%d) capacity topologies \n" "$topo_count" "$topo_count"
    
    # Aggregate results from parallel outputs
    cat "$parallel_temp"/topo_*.txt >> "$CAPACITY_TOPOLOGY_CACHE" 2>/dev/null
    
    # Cleanup
    rm -rf "$parallel_temp"
    rm -f "$topologies_json"
    
    return 0
}

# Fetch and cache OKE environment information
fetch_oke_environment() {
    local compartment_id="$1"
    local region="$2"
    
    # Check if OKE_CLUSTER_ID from variables.sh differs from cached value
    # If so, we need to refresh the cache
    local configured_cluster_id="${OKE_CLUSTER_ID:-}"
    local cached_cluster_id=""
    
    if [[ -f "$OKE_ENV_CACHE" ]]; then
        cached_cluster_id=$(grep "^OKE_CLUSTER_ID|" "$OKE_ENV_CACHE" 2>/dev/null | cut -d'|' -f2)
    fi
    
    # Invalidate cache if configured cluster differs from cached
    if [[ -n "$configured_cluster_id" && "$configured_cluster_id" != "N/A" && "$configured_cluster_id" != "$cached_cluster_id" ]]; then
        log_info "OKE_CLUSTER_ID changed, refreshing cache..."
        rm -f "$OKE_ENV_CACHE"
    fi
    
    is_cache_fresh "$OKE_ENV_CACHE" && return 0
    
    log_info "Fetching OKE environment information..."
    
    # Get tenancy OCID
    local tenancy_ocid="${TENANCY_ID:-}"
    if [[ -z "$tenancy_ocid" ]]; then
        # Try to get from instance metadata if running on OCI
        tenancy_ocid=$(curl -sH "Authorization: Bearer Oracle" -L http://169.254.169.254/opc/v2/instance/ 2>/dev/null | jq -r '.tenantId // empty')
    fi
    
    # Get compartment name
    local compartment_name="N/A"
    if [[ -n "$tenancy_ocid" && -n "$compartment_id" ]]; then
        compartment_name=$(oci iam compartment get --compartment-id "$compartment_id" --query 'data.name' --raw-output 2>/dev/null) || compartment_name="N/A"
    fi
    
    # Get availability domains
    local ads=""
    ads=$(oci iam availability-domain list --compartment-id "$compartment_id" --region "$region" --query 'data[].name' --raw-output 2>/dev/null | jq -r 'join(", ")') || ads="N/A"
    
    # Get OKE cluster info
    # Priority: 1) OKE_CLUSTER_ID from variables.sh, 2) Auto-discover first active cluster
    local cluster_json
    local cluster_name cluster_ocid cluster_state cluster_version pod_network vcn_ocid
    
    if [[ -n "$configured_cluster_id" && "$configured_cluster_id" != "N/A" ]]; then
        # Use specific cluster from variables.sh
        log_info "Using OKE_CLUSTER_ID from variables.sh: $configured_cluster_id"
        cluster_json=$(oci ce cluster get --cluster-id "$configured_cluster_id" --output json 2>/dev/null)
        
        if [[ -n "$cluster_json" ]]; then
            cluster_name=$(echo "$cluster_json" | jq -r '.data.name // "N/A"')
            cluster_ocid=$(echo "$cluster_json" | jq -r '.data.id // "N/A"')
            cluster_state=$(echo "$cluster_json" | jq -r '.data["lifecycle-state"] // "N/A"')
            cluster_version=$(echo "$cluster_json" | jq -r '.data["kubernetes-version"] // "N/A"')
            pod_network=$(echo "$cluster_json" | jq -r '.data["cluster-pod-network-options"][0]["cni-type"] // "N/A"')
            vcn_ocid=$(echo "$cluster_json" | jq -r '.data["vcn-id"] // "N/A"')
        else
            log_warn "Failed to fetch cluster with OKE_CLUSTER_ID from variables.sh, falling back to auto-discovery"
            # List to find cluster ID, then get full details
            cluster_json=$(oci ce cluster list --compartment-id "$compartment_id" --region "$region" --lifecycle-state ACTIVE --limit 1 --output json 2>/dev/null)
            cluster_ocid=$(echo "$cluster_json" | jq -r '.data[0].id // "N/A"')
            
            # Fetch full details using cluster get
            if [[ "$cluster_ocid" != "N/A" && -n "$cluster_ocid" ]]; then
                cluster_json=$(oci ce cluster get --cluster-id "$cluster_ocid" --output json 2>/dev/null)
                cluster_name=$(echo "$cluster_json" | jq -r '.data.name // "N/A"')
                cluster_state=$(echo "$cluster_json" | jq -r '.data["lifecycle-state"] // "N/A"')
                cluster_version=$(echo "$cluster_json" | jq -r '.data["kubernetes-version"] // "N/A"')
                pod_network=$(echo "$cluster_json" | jq -r '.data["cluster-pod-network-options"][0]["cni-type"] // "N/A"')
                vcn_ocid=$(echo "$cluster_json" | jq -r '.data["vcn-id"] // "N/A"')
            fi
        fi
    else
        # Auto-discover first active cluster - list to find ID, then get full details
        cluster_json=$(oci ce cluster list --compartment-id "$compartment_id" --region "$region" --lifecycle-state ACTIVE --limit 1 --output json 2>/dev/null)
        cluster_ocid=$(echo "$cluster_json" | jq -r '.data[0].id // "N/A"')
        
        # Fetch full details using cluster get (includes kubernetes-version)
        if [[ "$cluster_ocid" != "N/A" && -n "$cluster_ocid" ]]; then
            cluster_json=$(oci ce cluster get --cluster-id "$cluster_ocid" --output json 2>/dev/null)
            cluster_name=$(echo "$cluster_json" | jq -r '.data.name // "N/A"')
            cluster_state=$(echo "$cluster_json" | jq -r '.data["lifecycle-state"] // "N/A"')
            cluster_version=$(echo "$cluster_json" | jq -r '.data["kubernetes-version"] // "N/A"')
            pod_network=$(echo "$cluster_json" | jq -r '.data["cluster-pod-network-options"][0]["cni-type"] // "N/A"')
            vcn_ocid=$(echo "$cluster_json" | jq -r '.data["vcn-id"] // "N/A"')
        else
            cluster_name="N/A"
            cluster_state="N/A"
            cluster_version="N/A"
            pod_network="N/A"
            vcn_ocid="N/A"
        fi
    fi
    
    # Get cluster addons/plugins if we have a cluster OCID
    local cluster_addons=""
    if is_valid_ocid "$cluster_ocid"; then
        # Use OCI CE cluster list-addons to get installed addons
        local addons_json
        addons_json=$(oci ce cluster list-addons --cluster-id "$cluster_ocid" --all 2>/dev/null)
        
        if [[ -n "$addons_json" ]]; then
            # Extract active addon names with versions and join with commas
            local addon_lines
            addon_lines=$(echo "$addons_json" | jq -r '.data[] | select(.["lifecycle-state"] == "ACTIVE") | .name + " (" + (.["current-installed-version"] // "N/A") + ")"' 2>/dev/null)
            
            if [[ -n "$addon_lines" ]]; then
                # Join lines with ", "
                cluster_addons=$(echo "$addon_lines" | tr '\n' ',' | sed 's/,$//' | sed 's/,/, /g')
            else
                cluster_addons="None installed"
            fi
        else
            cluster_addons="Unable to retrieve"
        fi
    fi
    [[ -z "$cluster_addons" ]] && cluster_addons="N/A"
    
    # Get VCN name
    local vcn_name="N/A"
    if is_valid_ocid "$vcn_ocid"; then
        vcn_name=$(oci network vcn get --vcn-id "$vcn_ocid" --query 'data."display-name"' --raw-output 2>/dev/null) || vcn_name="N/A"
    fi
    
    # Get subnet and NSG info
    local worker_subnet_name="N/A" worker_subnet_ocid="N/A"
    local worker_nsg_name="N/A" worker_nsg_ocid="N/A"
    local pod_subnet_name="N/A" pod_subnet_ocid="N/A"
    local pod_nsg_name="N/A" pod_nsg_ocid="N/A"
    
    if is_valid_ocid "$vcn_ocid"; then
        local subnet_json nsg_json
        subnet_json=$(oci network subnet list --vcn-id "$vcn_ocid" --compartment-id "$compartment_id" --output json 2>/dev/null)
        nsg_json=$(oci network nsg list --compartment-id "$compartment_id" --vcn-id "$vcn_ocid" --output json 2>/dev/null)
        
        # Worker subnet
        worker_subnet_name=$(echo "$subnet_json" | jq -r '.data[] | select(."display-name" | test("worker"; "i")) | ."display-name"' 2>/dev/null | head -n1)
        worker_subnet_ocid=$(echo "$subnet_json" | jq -r '.data[] | select(."display-name" | test("worker"; "i")) | .id' 2>/dev/null | head -n1)
        worker_subnet_name="${worker_subnet_name:-N/A}"
        worker_subnet_ocid="${worker_subnet_ocid:-N/A}"
        
        # Worker NSG
        worker_nsg_name=$(echo "$nsg_json" | jq -r '.data[] | select(."display-name" | test("worker"; "i")) | ."display-name"' 2>/dev/null | head -n1)
        worker_nsg_ocid=$(echo "$nsg_json" | jq -r '.data[] | select(."display-name" | test("worker"; "i")) | .id' 2>/dev/null | head -n1)
        worker_nsg_name="${worker_nsg_name:-N/A}"
        worker_nsg_ocid="${worker_nsg_ocid:-N/A}"
        
        # Pod subnet
        pod_subnet_name=$(echo "$subnet_json" | jq -r '.data[] | select(."display-name" | test("pod"; "i")) | ."display-name"' 2>/dev/null | head -n1)
        pod_subnet_ocid=$(echo "$subnet_json" | jq -r '.data[] | select(."display-name" | test("pod"; "i")) | .id' 2>/dev/null | head -n1)
        pod_subnet_name="${pod_subnet_name:-N/A}"
        pod_subnet_ocid="${pod_subnet_ocid:-N/A}"
        
        # Pod NSG
        pod_nsg_name=$(echo "$nsg_json" | jq -r '.data[] | select(."display-name" | test("pod"; "i")) | ."display-name"' 2>/dev/null | head -n1)
        pod_nsg_ocid=$(echo "$nsg_json" | jq -r '.data[] | select(."display-name" | test("pod"; "i")) | .id' 2>/dev/null | head -n1)
        pod_nsg_name="${pod_nsg_name:-N/A}"
        pod_nsg_ocid="${pod_nsg_ocid:-N/A}"
    fi
    
    # Get availability domains for compute cluster lookup
    local ad_list
    ad_list=$(oci iam availability-domain list --compartment-id "$compartment_id" --region "$region" --query 'data[].name' --raw-output 2>/dev/null | jq -r '.[]' 2>/dev/null)
    
    # Get compute cluster info (search across all ADs)
    local compute_cluster_name="N/A" compute_cluster_ocid="N/A"
    local ad
    for ad in $ad_list; do
        [[ -z "$ad" ]] && continue
        local compute_cluster_json
        compute_cluster_json=$(oci compute compute-cluster list \
            --compartment-id "$compartment_id" \
            --availability-domain "$ad" \
            --region "$region" \
            --limit 1 \
            --output json 2>/dev/null)
        
        local found_name found_ocid
        found_name=$(echo "$compute_cluster_json" | jq -r '.data.items[0]."display-name" // empty' 2>/dev/null)
        found_ocid=$(echo "$compute_cluster_json" | jq -r '.data.items[0].id // empty' 2>/dev/null)
        
        if [[ -n "$found_name" && -n "$found_ocid" ]]; then
            compute_cluster_name="$found_name"
            compute_cluster_ocid="$found_ocid"
            break
        fi
    done
    
    # Write cache
    {
        echo "TENANCY_OCID|${tenancy_ocid:-N/A}"
        echo "COMPARTMENT_NAME|${compartment_name}"
        echo "COMPARTMENT_OCID|${compartment_id}"
        echo "REGION|${region}"
        echo "ADS|${ads}"
        echo "CLUSTER_NAME|${cluster_name}"
        echo "OKE_CLUSTER_ID|${cluster_ocid}"
        echo "CLUSTER_STATE|${cluster_state}"
        echo "CLUSTER_VERSION|${cluster_version}"
        echo "CLUSTER_ADDONS|${cluster_addons}"
        echo "POD_NETWORK|${pod_network}"
        echo "VCN_NAME|${vcn_name}"
        echo "VCN_OCID|${vcn_ocid}"
        echo "WORKER_SUBNET_NAME|${worker_subnet_name}"
        echo "WORKER_SUBNET_OCID|${worker_subnet_ocid}"
        echo "WORKER_NSG_NAME|${worker_nsg_name}"
        echo "WORKER_NSG_OCID|${worker_nsg_ocid}"
        echo "POD_SUBNET_NAME|${pod_subnet_name}"
        echo "POD_SUBNET_OCID|${pod_subnet_ocid}"
        echo "POD_NSG_NAME|${pod_nsg_name}"
        echo "POD_NSG_OCID|${pod_nsg_ocid}"
        echo "COMPUTE_CLUSTER_NAME|${compute_cluster_name}"
        echo "COMPUTE_CLUSTER_OCID|${compute_cluster_ocid}"
    } > "$OKE_ENV_CACHE"
}

# Get value from OKE environment cache
get_oke_env_value() {
    local key="$1"
    grep "^${key}|" "$OKE_ENV_CACHE" 2>/dev/null | cut -d'|' -f2
}

# Resolve subnet display name from cache, fallback to API
# Cache format: SUBNET|NAME|CIDR|ACCESS|STATE|OCID|...
# Args: $1 = subnet OCID
# Output: subnet name to stdout
resolve_subnet_name_cached() {
    local subnet_ocid="$1"
    [[ -z "$subnet_ocid" || "$subnet_ocid" == "N/A" ]] && echo "N/A" && return
    
    # Try network resources cache first (SUBNET|NAME|...|OCID is field 6)
    if [[ -f "$NETWORK_RESOURCES_CACHE" ]]; then
        local cached_name
        cached_name=$(awk -F'|' -v ocid="$subnet_ocid" '$1=="SUBNET" && $6==ocid {print $2; exit}' "$NETWORK_RESOURCES_CACHE" 2>/dev/null)
        if [[ -n "$cached_name" ]]; then
            echo "$cached_name"
            return
        fi
    fi
    
    # Fallback to API
    local api_name
    api_name=$(oci network subnet get --subnet-id "$subnet_ocid" --query 'data."display-name"' --raw-output 2>/dev/null) || api_name="N/A"
    echo "${api_name:-N/A}"
}

# Fetch and cache all network resources (subnets and NSGs)
fetch_network_resources() {
    local compartment_id="$1"
    local vcn_ocid="$2"
    
    is_cache_fresh "$NETWORK_RESOURCES_CACHE" && return 0
    
    [[ "$vcn_ocid" == "N/A" || -z "$vcn_ocid" ]] && return 1
    
    log_info "Fetching network resources..."
    
    # Fetch subnets and NSGs
    local subnet_json nsg_json
    subnet_json=$(oci network subnet list --vcn-id "$vcn_ocid" --compartment-id "$compartment_id" --output json 2>/dev/null)
    nsg_json=$(oci network nsg list --compartment-id "$compartment_id" --vcn-id "$vcn_ocid" --output json 2>/dev/null)
    
    # Write cache
    {
        echo "# Network Resources Cache"
        echo "# Format: SUBNET|NAME|CIDR|ACCESS|STATE|OCID|RT_OCID|SL_IDS|DNS_LABEL"
        echo "# Format: NSG|NAME||STATE|OCID"
        
        # Process subnets (include route-table-id, security-list-ids, and dns-label)
        echo "$subnet_json" | jq -r '.data[] | "SUBNET|\(."display-name" // "N/A")|\(."cidr-block" // "N/A")|\(if ."prohibit-public-ip-on-vnic" then "Private" else "Public" end)|\(."lifecycle-state" // "N/A")|\(.id // "N/A")|\(."route-table-id" // "N/A")|\((."security-list-ids" // []) | join(","))|\(."dns-label" // "")"' 2>/dev/null
        
        # Process NSGs
        echo "$nsg_json" | jq -r '.data[] | "NSG|\(."display-name" // "N/A")||\(."lifecycle-state" // "N/A")|\(.id // "N/A")"' 2>/dev/null
    } > "$NETWORK_RESOURCES_CACHE"
}

#===============================================================================
# NETWORK GATEWAY FUNCTIONS
#===============================================================================

# Fetch and cache Internet Gateways
fetch_internet_gateways() {
    local compartment_id="$1"
    local vcn_ocid="$2"
    
    is_cache_fresh "$IGW_CACHE" && return 0
    
    log_info "Fetching Internet Gateways..."
    
    # Cache format: VCN_ID|IGW_ID|STATE|DISPLAY_NAME
    > "$IGW_CACHE"
    local -A _seen_ids=()
    
    # Build compartment list to search
    local -a _comps=("$compartment_id")
    [[ -n "$NETWORK_COMPARTMENT_ID" && "$NETWORK_COMPARTMENT_ID" != "$compartment_id" ]] && _comps+=("$NETWORK_COMPARTMENT_ID")
    
    for _c in "${_comps[@]}"; do
        local result
        result=$(oci network internet-gateway list \
            --compartment-id "$_c" \
            --vcn-id "$vcn_ocid" \
            --all \
            --output json 2>/dev/null) || continue
        
        while IFS='|' read -r _vcn _id _state _name; do
            [[ -z "$_id" || -n "${_seen_ids[$_id]+x}" ]] && continue
            _seen_ids[$_id]=1
            echo "${_vcn}|${_id}|${_state}|${_name}" >> "$IGW_CACHE"
        done < <(echo "$result" | jq -r '.data[] | "\(.["vcn-id"])|\(.id)|\(.["lifecycle-state"])|\(.["display-name"] // "N/A")"' 2>/dev/null)
    done
    
    [[ ! -s "$IGW_CACHE" ]] && touch "$IGW_CACHE"
}

# Fetch and cache Service Gateways
fetch_service_gateways() {
    local compartment_id="$1"
    local vcn_ocid="$2"
    
    is_cache_fresh "$SGW_CACHE" && return 0
    
    log_info "Fetching Service Gateways..."
    
    # Cache format: VCN_ID|SGW_ID|STATE|DISPLAY_NAME
    > "$SGW_CACHE"
    local -A _seen_ids=()
    
    local -a _comps=("$compartment_id")
    [[ -n "$NETWORK_COMPARTMENT_ID" && "$NETWORK_COMPARTMENT_ID" != "$compartment_id" ]] && _comps+=("$NETWORK_COMPARTMENT_ID")
    
    for _c in "${_comps[@]}"; do
        local result
        result=$(oci network service-gateway list \
            --compartment-id "$_c" \
            --vcn-id "$vcn_ocid" \
            --all \
            --output json 2>/dev/null) || continue
        
        while IFS='|' read -r _vcn _id _state _name; do
            [[ -z "$_id" || -n "${_seen_ids[$_id]+x}" ]] && continue
            _seen_ids[$_id]=1
            echo "${_vcn}|${_id}|${_state}|${_name}" >> "$SGW_CACHE"
        done < <(echo "$result" | jq -r '.data[] | "\(.["vcn-id"])|\(.id)|\(.["lifecycle-state"])|\(.["display-name"] // "N/A")"' 2>/dev/null)
    done
    
    [[ ! -s "$SGW_CACHE" ]] && touch "$SGW_CACHE"
}

# Fetch and cache NAT Gateways
fetch_nat_gateways() {
    local compartment_id="$1"
    local vcn_ocid="$2"
    
    is_cache_fresh "$NAT_CACHE" && return 0
    
    log_info "Fetching NAT Gateways..."
    
    # Cache format: VCN_ID|NAT_ID|STATE|DISPLAY_NAME
    > "$NAT_CACHE"
    local -A _seen_ids=()
    
    local -a _comps=("$compartment_id")
    [[ -n "$NETWORK_COMPARTMENT_ID" && "$NETWORK_COMPARTMENT_ID" != "$compartment_id" ]] && _comps+=("$NETWORK_COMPARTMENT_ID")
    
    for _c in "${_comps[@]}"; do
        local result
        result=$(oci network nat-gateway list \
            --compartment-id "$_c" \
            --vcn-id "$vcn_ocid" \
            --all \
            --output json 2>/dev/null) || continue
        
        while IFS='|' read -r _vcn _id _state _name; do
            [[ -z "$_id" || -n "${_seen_ids[$_id]+x}" ]] && continue
            _seen_ids[$_id]=1
            echo "${_vcn}|${_id}|${_state}|${_name}" >> "$NAT_CACHE"
        done < <(echo "$result" | jq -r '.data[] | "\(.["vcn-id"])|\(.id)|\(.["lifecycle-state"])|\(.["display-name"] // "N/A")"' 2>/dev/null)
    done
    
    [[ ! -s "$NAT_CACHE" ]] && touch "$NAT_CACHE"
}

# Fetch and cache DRG Attachments
fetch_drg_attachments() {
    local compartment_id="$1"
    
    is_cache_fresh "$DRG_CACHE" && return 0
    
    log_info "Fetching DRG Attachments..."
    
    # Cache format: VCN_ID|DRG_ID|STATE|DISPLAY_NAME
    > "$DRG_CACHE"
    local -A _seen_ids=()
    
    local -a _comps=("$compartment_id")
    [[ -n "$NETWORK_COMPARTMENT_ID" && "$NETWORK_COMPARTMENT_ID" != "$compartment_id" ]] && _comps+=("$NETWORK_COMPARTMENT_ID")
    
    for _c in "${_comps[@]}"; do
        local result
        result=$(oci network drg-attachment list \
            --compartment-id "$_c" \
            --all \
            --output json 2>/dev/null) || continue
        
        # Handle both DRGv1 and DRGv2 formats
        while IFS='|' read -r _vcn _drg _state _name _id; do
            [[ -z "$_id" || -n "${_seen_ids[$_id]+x}" ]] && continue
            [[ -z "$_vcn" || "$_vcn" == "null" ]] && continue
            _seen_ids[$_id]=1
            echo "${_vcn}|${_drg}|${_state}|${_name}" >> "$DRG_CACHE"
        done < <(echo "$result" | jq -r '.data[] | 
            (if .["vcn-id"] != null then .["vcn-id"] 
             elif .["network-details"] != null and .["network-details"]["id"] != null then .["network-details"]["id"] 
             else "null" end) as $vcn |
            "\($vcn)|\(.["drg-id"])|\(.["lifecycle-state"])|\(.["display-name"] // "N/A")|\(.id)"' 2>/dev/null)
    done
    
    [[ ! -s "$DRG_CACHE" ]] && touch "$DRG_CACHE"
}

# Fetch and cache Local Peering Gateways
fetch_local_peering_gateways() {
    local compartment_id="$1"
    local vcn_ocid="$2"
    
    is_cache_fresh "$LPG_CACHE" && return 0
    
    log_info "Fetching Local Peering Gateways..."
    
    # Cache format: VCN_ID|LPG_ID|STATE|PEERING_STATUS|DISPLAY_NAME
    > "$LPG_CACHE"
    local -A _seen_ids=()
    
    local -a _comps=("$compartment_id")
    [[ -n "$NETWORK_COMPARTMENT_ID" && "$NETWORK_COMPARTMENT_ID" != "$compartment_id" ]] && _comps+=("$NETWORK_COMPARTMENT_ID")
    
    for _c in "${_comps[@]}"; do
        local result
        result=$(oci network local-peering-gateway list \
            --compartment-id "$_c" \
            --vcn-id "$vcn_ocid" \
            --all \
            --output json 2>/dev/null) || continue
        
        while IFS='|' read -r _vcn _id _state _peer _name; do
            [[ -z "$_id" || -n "${_seen_ids[$_id]+x}" ]] && continue
            _seen_ids[$_id]=1
            echo "${_vcn}|${_id}|${_state}|${_peer}|${_name}" >> "$LPG_CACHE"
        done < <(echo "$result" | jq -r '.data[] | "\(.["vcn-id"])|\(.id)|\(.["lifecycle-state"])|\(.["peering-status"])|\(.["display-name"] // "N/A")"' 2>/dev/null)
    done
    
    [[ ! -s "$LPG_CACHE" ]] && touch "$LPG_CACHE"
}

# Fetch and cache Remote Peering Connections
fetch_remote_peering_connections() {
    local compartment_id="$1"
    
    is_cache_fresh "$RPC_CACHE" && return 0
    
    log_info "Fetching Remote Peering Connections..."
    
    # Cache format: DRG_ID|RPC_ID|STATE|PEERING_STATUS
    > "$RPC_CACHE"
    local -A _seen_ids=()
    
    local -a _comps=("$compartment_id")
    [[ -n "$NETWORK_COMPARTMENT_ID" && "$NETWORK_COMPARTMENT_ID" != "$compartment_id" ]] && _comps+=("$NETWORK_COMPARTMENT_ID")
    
    for _c in "${_comps[@]}"; do
        local result
        result=$(oci network remote-peering-connection list \
            --compartment-id "$_c" \
            --all \
            --output json 2>/dev/null) || continue
        
        while IFS='|' read -r _drg _id _state _peer; do
            [[ -z "$_id" || -n "${_seen_ids[$_id]+x}" ]] && continue
            _seen_ids[$_id]=1
            echo "${_drg}|${_id}|${_state}|${_peer}" >> "$RPC_CACHE"
        done < <(echo "$result" | jq -r '.data[] | "\(.["drg-id"])|\(.id)|\(.["lifecycle-state"])|\(.["peering-status"])"' 2>/dev/null)
    done
    
    [[ ! -s "$RPC_CACHE" ]] && touch "$RPC_CACHE"
}

# Fetch and cache Route Tables
fetch_route_tables() {
    local compartment_id="$1"
    local vcn_ocid="$2"
    
    is_cache_fresh "$RT_CACHE" && return 0
    
    log_info "Fetching Route Tables..."
    
    # Cache format: RT_ID|VCN_ID|DISPLAY_NAME|STATE|ROUTE_COUNT
    > "$RT_CACHE"
    local -A _seen_ids=()
    
    local -a _comps=("$compartment_id")
    [[ -n "$NETWORK_COMPARTMENT_ID" && "$NETWORK_COMPARTMENT_ID" != "$compartment_id" ]] && _comps+=("$NETWORK_COMPARTMENT_ID")
    
    for _c in "${_comps[@]}"; do
        local result
        result=$(oci network route-table list \
            --compartment-id "$_c" \
            --vcn-id "$vcn_ocid" \
            --all \
            --output json 2>/dev/null) || continue
        
        while IFS='|' read -r _id _vcn _name _state _count; do
            [[ -z "$_id" || -n "${_seen_ids[$_id]+x}" ]] && continue
            _seen_ids[$_id]=1
            echo "${_id}|${_vcn}|${_name}|${_state}|${_count}" >> "$RT_CACHE"
        done < <(echo "$result" | jq -r '.data[] | "\(.id)|\(.["vcn-id"])|\(.["display-name"])|\(.["lifecycle-state"])|\(.["route-rules"] | length)"' 2>/dev/null)
    done
    
    [[ ! -s "$RT_CACHE" ]] && touch "$RT_CACHE"
}

# Fetch and cache NSG rules for all NSGs
fetch_nsg_rules() {
    local compartment_id="$1"
    local vcn_ocid="$2"
    
    is_cache_fresh "$NSG_RULES_CACHE" && return 0
    
    log_info "Fetching NSG rules..."
    
    # Cache format: NSG_ID|INGRESS_COUNT|EGRESS_COUNT
    > "$NSG_RULES_CACHE"
    local -A _seen_ids=()
    
    local -a _comps=("$compartment_id")
    [[ -n "$NETWORK_COMPARTMENT_ID" && "$NETWORK_COMPARTMENT_ID" != "$compartment_id" ]] && _comps+=("$NETWORK_COMPARTMENT_ID")
    
    for _c in "${_comps[@]}"; do
        # Get all NSGs in this compartment
        local nsgs_json
        nsgs_json=$(oci network nsg list \
            --compartment-id "$_c" \
            --vcn-id "$vcn_ocid" \
            --all \
            --output json 2>/dev/null) || continue
        
        echo "$nsgs_json" | jq -r '.data[].id' 2>/dev/null | while read -r nsg_id; do
            [[ -z "$nsg_id" ]] && continue
            # Dedup across compartments (subshell, so use file-based dedup)
            grep -q "^${nsg_id}|" "$NSG_RULES_CACHE" 2>/dev/null && continue
            
            local result ingress_count egress_count
            result=$(oci network nsg rules list \
                --nsg-id "$nsg_id" \
                --all \
                --output json 2>/dev/null)
            
            if [[ -n "$result" ]]; then
                ingress_count=$(echo "$result" | jq '[.data[] | select(.direction=="INGRESS")] | length' 2>/dev/null) || ingress_count=0
                egress_count=$(echo "$result" | jq '[.data[] | select(.direction=="EGRESS")] | length' 2>/dev/null) || egress_count=0
            else
                ingress_count=0
                egress_count=0
            fi
            
            echo "${nsg_id}|${ingress_count:-0}|${egress_count:-0}" >> "$NSG_RULES_CACHE"
        done
    done
    
    [[ ! -s "$NSG_RULES_CACHE" ]] && touch "$NSG_RULES_CACHE"
}

#--------------------------------------------------------------------------------
# Fetch NSG rules detail with parallel processing and caching
# Args: $1 = array of NSG IDs (space-separated or newline-separated)
# Caches full rules JSON in NSG_RULES_DETAIL_DIR/{nsg_short_id}.json
#--------------------------------------------------------------------------------
fetch_nsg_rules_detail_parallel() {
    local nsg_ids="$1"
    
    [[ -z "$nsg_ids" ]] && return 0
    
    # Create cache directory if needed
    mkdir -p "$NSG_RULES_DETAIL_DIR"
    
    # Count NSGs to fetch (skip already cached)
    local nsg_list=()
    local cached_count=0
    local to_fetch=()
    
    while read -r nsg_id; do
        [[ -z "$nsg_id" ]] && continue
        nsg_list+=("$nsg_id")
        
        local nsg_short="${nsg_id##*.}"
        local cache_file="${NSG_RULES_DETAIL_DIR}/${nsg_short}.json"
        
        # Check if cache is fresh (less than 1 hour old)
        if [[ -f "$cache_file" ]]; then
            local file_age=$(($(date +%s) - $(stat -c %Y "$cache_file" 2>/dev/null || echo 0)))
            if [[ $file_age -lt $CACHE_MAX_AGE ]]; then
                ((cached_count++))
                continue
            fi
        fi
        to_fetch+=("$nsg_id")
    done <<< "$nsg_ids"
    
    local total_count=${#nsg_list[@]}
    local fetch_count=${#to_fetch[@]}
    
    if [[ $fetch_count -eq 0 ]]; then
        echo -e "  ${GREEN}✓${NC} NSG rules: $total_count NSGs (all cached)"
        return 0
    fi
    
    echo -e "  ${CYAN}Fetching NSG rules: $fetch_count of $total_count NSGs (${cached_count} cached)${NC}"
    
    # Create temp directory for parallel outputs
    local parallel_temp="${TEMP_DIR}/nsg_rules_parallel_$$"
    mkdir -p "$parallel_temp"
    
    # Define worker function for parallel processing
    _fetch_single_nsg_rules() {
        local nsg_id="$1"
        local output_dir="$2"
        local cache_dir="$3"
        [[ -z "$nsg_id" ]] && return
        
        local nsg_short="${nsg_id##*.}"
        local status_file="${output_dir}/status_${nsg_short}.txt"
        local cache_file="${cache_dir}/${nsg_short}.json"
        
        # Fetch NSG details and rules
        local nsg_json rules_json
        nsg_json=$(oci network nsg get --nsg-id "$nsg_id" --output json 2>/dev/null)
        rules_json=$(oci network nsg rules list --nsg-id "$nsg_id" --all --output json 2>/dev/null)
        
        if [[ -n "$rules_json" ]]; then
            # Combine NSG details with rules
            local nsg_name
            nsg_name=$(echo "$nsg_json" | jq -r '.data["display-name"] // "Unknown"' 2>/dev/null)
            
            # Create combined JSON with NSG info and rules
            jq -n \
                --arg nsg_id "$nsg_id" \
                --arg nsg_name "$nsg_name" \
                --argjson rules "$(echo "$rules_json" | jq '.data // []')" \
                '{nsg_id: $nsg_id, nsg_name: $nsg_name, rules: $rules}' > "$cache_file" 2>/dev/null
            
            echo "OK" > "$status_file"
        else
            echo "FAIL" > "$status_file"
        fi
    }
    export -f _fetch_single_nsg_rules
    export NSG_RULES_DETAIL_DIR
    
    # Determine parallelism (max 8 to avoid API throttling)
    local parallel_jobs=8
    [[ "$fetch_count" -lt "$parallel_jobs" ]] && parallel_jobs="$fetch_count"
    
    # Start progress bar in background
    show_parallel_progress "$parallel_temp" "status_*.txt" "$fetch_count" "NSG rules" &
    local progress_pid=$!
    
    # Run parallel fetch
    printf '%s\n' "${to_fetch[@]}" | xargs -P "$parallel_jobs" -I {} bash -c '_fetch_single_nsg_rules "$@"' _ {} "$parallel_temp" "$NSG_RULES_DETAIL_DIR"
    
    # Stop progress bar
    kill "$progress_pid" 2>/dev/null
    wait "$progress_pid" 2>/dev/null
    
    # Count successes
    local success_count
    success_count=$(grep -l "OK" "$parallel_temp"/status_*.txt 2>/dev/null | wc -l)
    
    printf "\r  ${GREEN}✓${NC} [████████████████████] 100%% (%d/%d) NSG rules fetched \n" "$success_count" "$fetch_count"
    
    # Cleanup
    rm -rf "$parallel_temp"
    
    return 0
}

#--------------------------------------------------------------------------------
# Get cached NSG rules for a specific NSG
# Args: $1 = NSG ID
# Returns: JSON with rules or empty if not cached
#--------------------------------------------------------------------------------
get_cached_nsg_rules() {
    local nsg_id="$1"
    [[ -z "$nsg_id" ]] && return 1
    
    local nsg_short="${nsg_id##*.}"
    local cache_file="${NSG_RULES_DETAIL_DIR}/${nsg_short}.json"
    
    if [[ -f "$cache_file" ]]; then
        cat "$cache_file"
        return 0
    fi
    
    return 1
}

#--------------------------------------------------------------------------------
# Display NSG rules in table format (shared function)
# Args: $1 = rules_json (from oci network nsg rules list)
#       $2 = (optional) use_cache_lookup - if "true", use NETWORK_RESOURCES_CACHE for NSG name lookup
#--------------------------------------------------------------------------------
display_nsg_rules_table() {
    local rules_json="$1"
    local use_cache_lookup="${2:-false}"
    
    if [[ -z "$rules_json" ]] || ! echo "$rules_json" | jq -e '.data' > /dev/null 2>&1; then
        echo -e "${RED}Failed to fetch NSG rules${NC}"
        return 1
    fi
    
    local rule_count
    rule_count=$(echo "$rules_json" | jq '(.data // []) | length')
    echo -e "Found ${GREEN}$rule_count${NC} security rule(s)"
    echo ""
    
    if [[ "$rule_count" -eq 0 ]]; then
        echo -e "${YELLOW}No rules configured${NC}"
        return 0
    fi
    
    # Build NSG name lookup if using cache
    declare -A NSG_NAME_LOOKUP
    if [[ "$use_cache_lookup" == "true" && -f "$NETWORK_RESOURCES_CACHE" ]]; then
        while IFS='|' read -r type name _ state ocid; do
            [[ "$type" == "NSG" && -n "$ocid" ]] && NSG_NAME_LOOKUP["$ocid"]="$name"
        done < "$NETWORK_RESOURCES_CACHE"
    fi
    
    # Count ingress and egress
    local ingress_count egress_count
    ingress_count=$(echo "$rules_json" | jq '[(.data // [])[] | select(.direction == "INGRESS")] | length')
    egress_count=$(echo "$rules_json" | jq '[(.data // [])[] | select(.direction == "EGRESS")] | length')
    
    # Display ingress rules
    if [[ "$ingress_count" -gt 0 ]]; then
        echo -e "${BOLD}${GREEN}▼▼▼ INGRESS RULES (${ingress_count}) ▼▼▼${NC}"
        echo ""
        printf "${BOLD}%-6s | %-9s | %-8s | %-43s | %-9s | %-9s | %s${NC}\n" \
            "Rule #" "Direction" "Protocol" "Source" "Src Ports" "Dst Ports" "Description"
        printf "${WHITE}%-6s-+-%-9s-+-%-8s-+-%-43s-+-%-9s-+-%-9s-+-%s${NC}\n" \
            "------" "---------" "--------" "-------------------------------------------" "---------" "---------" "---------------------------------------------"
        
        local ingress_rules
        ingress_rules=$(echo "$rules_json" | jq -r '
            (.data // [])[] | select(.direction == "INGRESS") |
            [
                .direction,
                (if .protocol == "6" then "TCP"
                 elif .protocol == "17" then "UDP"
                 elif .protocol == "1" then "ICMP"
                 elif .protocol == "all" then "ALL"
                 else .protocol end),
                (.source // .["source-type"] // "N/A"),
                (if .["tcp-options"]["source-port-range"] then
                    "\(.["tcp-options"]["source-port-range"]["min"])-\(.["tcp-options"]["source-port-range"]["max"])"
                 elif .["udp-options"]["source-port-range"] then
                    "\(.["udp-options"]["source-port-range"]["min"])-\(.["udp-options"]["source-port-range"]["max"])"
                 else "ALL" end),
                (if .["tcp-options"]["destination-port-range"] then
                    (if .["tcp-options"]["destination-port-range"]["min"] == .["tcp-options"]["destination-port-range"]["max"] then
                        "\(.["tcp-options"]["destination-port-range"]["min"])"
                    else
                        "\(.["tcp-options"]["destination-port-range"]["min"])-\(.["tcp-options"]["destination-port-range"]["max"])"
                    end)
                 elif .["udp-options"]["destination-port-range"] then
                    (if .["udp-options"]["destination-port-range"]["min"] == .["udp-options"]["destination-port-range"]["max"] then
                        "\(.["udp-options"]["destination-port-range"]["min"])"
                    else
                        "\(.["udp-options"]["destination-port-range"]["min"])-\(.["udp-options"]["destination-port-range"]["max"])"
                    end)
                 elif .["icmp-options"] then "ALL"
                 else "ALL" end),
                (.description // "-")
            ] | @tsv
        ' 2>/dev/null)
        
        local rule_num=0
        if [[ -n "$ingress_rules" ]]; then
            while IFS=$'\t' read -r direction proto source src_ports dst_ports desc; do
                ((rule_num++))
                # Resolve NSG OCID to name if applicable
                if [[ "$source" == ocid1.networksecuritygroup.* ]]; then
                    local resolved_name="${NSG_NAME_LOOKUP[$source]:-}"
                    if [[ -z "$resolved_name" ]]; then
                        # Fetch if not in cache
                        resolved_name=$(oci network nsg get --nsg-id "$source" --query 'data."display-name"' --raw-output 2>/dev/null)
                    fi
                    [[ -n "$resolved_name" && "$resolved_name" != "null" ]] && source="NSG: $resolved_name"
                fi
                printf "${YELLOW}%-6s${NC} | ${CYAN}%-9s${NC} | ${WHITE}%-8s${NC} | ${GREEN}%-43s${NC} | %-9s | %-9s | ${WHITE}%s${NC}\n" \
                    "$rule_num" "$direction" "$proto" "${source:0:43}" "$src_ports" "$dst_ports" "${desc:0:45}"
            done <<< "$ingress_rules"
        fi
        echo ""
    fi
    
    # Display egress rules
    if [[ "$egress_count" -gt 0 ]]; then
        echo -e "${BOLD}${RED}▲▲▲ EGRESS RULES (${egress_count}) ▲▲▲${NC}"
        echo ""
        printf "${BOLD}%-6s | %-9s | %-8s | %-43s | %-9s | %-9s | %s${NC}\n" \
            "Rule #" "Direction" "Protocol" "Destination" "Src Ports" "Dst Ports" "Description"
        printf "${WHITE}%-6s-+-%-9s-+-%-8s-+-%-43s-+-%-9s-+-%-9s-+-%s${NC}\n" \
            "------" "---------" "--------" "-------------------------------------------" "---------" "---------" "---------------------------------------------"
        
        local egress_rules
        egress_rules=$(echo "$rules_json" | jq -r '
            (.data // [])[] | select(.direction == "EGRESS") |
            [
                .direction,
                (if .protocol == "6" then "TCP"
                 elif .protocol == "17" then "UDP"
                 elif .protocol == "1" then "ICMP"
                 elif .protocol == "all" then "ALL"
                 else .protocol end),
                (.destination // .["destination-type"] // "N/A"),
                (if .["tcp-options"]["source-port-range"] then
                    "\(.["tcp-options"]["source-port-range"]["min"])-\(.["tcp-options"]["source-port-range"]["max"])"
                 elif .["udp-options"]["source-port-range"] then
                    "\(.["udp-options"]["source-port-range"]["min"])-\(.["udp-options"]["source-port-range"]["max"])"
                 else "ALL" end),
                (if .["tcp-options"]["destination-port-range"] then
                    (if .["tcp-options"]["destination-port-range"]["min"] == .["tcp-options"]["destination-port-range"]["max"] then
                        "\(.["tcp-options"]["destination-port-range"]["min"])"
                    else
                        "\(.["tcp-options"]["destination-port-range"]["min"])-\(.["tcp-options"]["destination-port-range"]["max"])"
                    end)
                 elif .["udp-options"]["destination-port-range"] then
                    (if .["udp-options"]["destination-port-range"]["min"] == .["udp-options"]["destination-port-range"]["max"] then
                        "\(.["udp-options"]["destination-port-range"]["min"])"
                    else
                        "\(.["udp-options"]["destination-port-range"]["min"])-\(.["udp-options"]["destination-port-range"]["max"])"
                    end)
                 elif .["icmp-options"] then "ALL"
                 else "ALL" end),
                (.description // "-")
            ] | @tsv
        ' 2>/dev/null)
        
        local rule_num=0
        if [[ -n "$egress_rules" ]]; then
            while IFS=$'\t' read -r direction proto dest src_ports dst_ports desc; do
                ((rule_num++))
                # Resolve NSG OCID to name if applicable
                if [[ "$dest" == ocid1.networksecuritygroup.* ]]; then
                    local resolved_name="${NSG_NAME_LOOKUP[$dest]:-}"
                    if [[ -z "$resolved_name" ]]; then
                        # Fetch if not in cache
                        resolved_name=$(oci network nsg get --nsg-id "$dest" --query 'data."display-name"' --raw-output 2>/dev/null)
                    fi
                    [[ -n "$resolved_name" && "$resolved_name" != "null" ]] && dest="NSG: $resolved_name"
                fi
                printf "${YELLOW}%-6s${NC} | ${MAGENTA}%-9s${NC} | ${WHITE}%-8s${NC} | ${GREEN}%-43s${NC} | %-9s | %-9s | ${WHITE}%s${NC}\n" \
                    "$rule_num" "$direction" "$proto" "${dest:0:43}" "$src_ports" "$dst_ports" "${desc:0:45}"
            done <<< "$egress_rules"
        fi
        echo ""
    fi
    
    if [[ "$ingress_count" -eq 0 && "$egress_count" -eq 0 ]]; then
        echo -e "${YELLOW}No ingress or egress rules configured${NC}"
    fi
}

# Fetch and cache Security Lists
fetch_security_lists() {
    local compartment_id="$1"
    local vcn_ocid="$2"
    
    is_cache_fresh "$SL_CACHE" && return 0
    
    log_info "Fetching Security Lists..."
    
    # Cache format: SL_ID|VCN_ID|DISPLAY_NAME|STATE|INGRESS_COUNT|EGRESS_COUNT
    > "$SL_CACHE"
    local -A _seen_ids=()
    
    local -a _comps=("$compartment_id")
    [[ -n "$NETWORK_COMPARTMENT_ID" && "$NETWORK_COMPARTMENT_ID" != "$compartment_id" ]] && _comps+=("$NETWORK_COMPARTMENT_ID")
    
    for _c in "${_comps[@]}"; do
        local result
        result=$(oci network security-list list \
            --compartment-id "$_c" \
            --vcn-id "$vcn_ocid" \
            --all \
            --output json 2>/dev/null) || continue
        
        while IFS='|' read -r _id _vcn _name _state _in _eg; do
            [[ -z "$_id" || -n "${_seen_ids[$_id]+x}" ]] && continue
            _seen_ids[$_id]=1
            echo "${_id}|${_vcn}|${_name}|${_state}|${_in}|${_eg}" >> "$SL_CACHE"
        done < <(echo "$result" | jq -r '.data[] | "\(.id)|\(.["vcn-id"])|\(.["display-name"])|\(.["lifecycle-state"])|\(.["ingress-security-rules"] | length)|\(.["egress-security-rules"] | length)"' 2>/dev/null)
    done
    
    [[ ! -s "$SL_CACHE" ]] && touch "$SL_CACHE"
}

# Fetch all network gateway caches
fetch_all_network_gateways() {
    local compartment_id="$1"
    local vcn_ocid="$2"
    
    [[ "$vcn_ocid" == "N/A" || -z "$vcn_ocid" ]] && return 1
    
    fetch_internet_gateways "$compartment_id" "$vcn_ocid"
    fetch_service_gateways "$compartment_id" "$vcn_ocid"
    fetch_nat_gateways "$compartment_id" "$vcn_ocid"
    fetch_drg_attachments "$compartment_id"
    fetch_local_peering_gateways "$compartment_id" "$vcn_ocid"
    fetch_remote_peering_connections "$compartment_id"
    fetch_route_tables "$compartment_id" "$vcn_ocid"
    fetch_nsg_rules "$compartment_id" "$vcn_ocid"
    fetch_security_lists "$compartment_id" "$vcn_ocid"
}

#--------------------------------------------------------------------------------
# Fetch Object Storage Private Endpoints and cache them
# Accepts one or two compartment IDs (main + optional network compartment)
# Cache format: name|namespace|state|prefix|subnet-id|private-ip|pe-ocid|nsg-ids|compartment-id|time-created
#--------------------------------------------------------------------------------
fetch_os_private_endpoints() {
    local comp1="$1"
    local comp2="${2:-}"
    
    [[ -z "$comp1" ]] && return 1
    
    # Check cache TTL (reuse CACHE_MAX_AGE)
    if [[ -f "$OS_PE_CACHE" ]]; then
        local cache_mtime cache_age
        cache_mtime=$(stat -c %Y "$OS_PE_CACHE" 2>/dev/null || echo 0)
        cache_age=$(( $(date +%s) - cache_mtime ))
        if [[ $cache_age -lt ${CACHE_MAX_AGE:-3600} ]]; then
            return 0
        fi
    fi
    
    # Build unique compartment list
    local -a comp_list=("$comp1")
    [[ -n "$comp2" && "$comp2" != "$comp1" ]] && comp_list+=("$comp2")
    
    # Write cache header
    echo "# OS Private Endpoints - $(date)" > "$OS_PE_CACHE"
    
    local total_found=0
    
    for cid in "${comp_list[@]}"; do
        [[ -z "$cid" ]] && continue
        
        # List all private endpoints in this compartment
        local pe_list_json
        pe_list_json=$(oci os private-endpoint list --compartment-id "$cid" --output json 2>/dev/null)
        
        if [[ -z "$pe_list_json" ]] || ! echo "$pe_list_json" | jq -e '.data[0]' > /dev/null 2>&1; then
            continue
        fi
        
        # The list endpoint returns name, namespace, state, prefix, compartment-id
        # but NOT private-endpoint-ip or subnet-id - we need 'get' for those
        while IFS='|' read -r pe_name pe_namespace pe_state pe_prefix pe_comp; do
            [[ -z "$pe_name" ]] && continue
            
            # Fetch full details for each PE (typically 1-2 per compartment)
            local pe_detail
            pe_detail=$(oci os private-endpoint get \
                --pe-name "$pe_name" \
                --namespace-name "$pe_namespace" \
                --output json 2>/dev/null)
            
            local subnet_id="N/A" private_ip="N/A" pe_ocid="N/A" nsg_ids="" time_created="N/A"
            
            if [[ -n "$pe_detail" ]] && echo "$pe_detail" | jq -e '.data' > /dev/null 2>&1; then
                subnet_id=$(echo "$pe_detail" | jq -r '.data["subnet-id"] // "N/A"')
                private_ip=$(echo "$pe_detail" | jq -r '.data["private-endpoint-ip"] // "N/A"')
                pe_ocid=$(echo "$pe_detail" | jq -r '.data.id // "N/A"')
                time_created=$(echo "$pe_detail" | jq -r '.data["time-created"] // "N/A"')
                # Comma-separated NSG IDs
                nsg_ids=$(echo "$pe_detail" | jq -r '.data["nsg-ids"] // [] | join(",")' 2>/dev/null)
            fi
            
            echo "${pe_name}|${pe_namespace}|${pe_state}|${pe_prefix}|${subnet_id}|${private_ip}|${pe_ocid}|${nsg_ids}|${pe_comp}|${time_created}" >> "$OS_PE_CACHE"
            ((total_found++))
            
        done < <(echo "$pe_list_json" | jq -r '.data[] | "\(.name)|\(.namespace)|\(.["lifecycle-state"] // "N/A")|\(.prefix // "N/A")|\(.["compartment-id"] // "N/A")"' 2>/dev/null)
    done
    
    # Update header with count
    sed -i "1s/.*/# OS Private Endpoints - $(date) - ${total_found} found/" "$OS_PE_CACHE"
    
    return 0
}

# Check if VCN has an Internet Gateway
has_internet_gateway() {
    local vcn_id="$1"
    [[ ! -f "$IGW_CACHE" ]] && { echo "false"; return; }
    grep -q "^${vcn_id}|" "$IGW_CACHE" 2>/dev/null && echo "true" || echo "false"
}

# Check if VCN has a Service Gateway
has_service_gateway() {
    local vcn_id="$1"
    [[ ! -f "$SGW_CACHE" ]] && { echo "false"; return; }
    grep -q "^${vcn_id}|" "$SGW_CACHE" 2>/dev/null && echo "true" || echo "false"
}

# Check if VCN has a NAT Gateway
has_nat_gateway() {
    local vcn_id="$1"
    [[ ! -f "$NAT_CACHE" ]] && { echo "false"; return; }
    grep -q "^${vcn_id}|" "$NAT_CACHE" 2>/dev/null && echo "true" || echo "false"
}

# Check if VCN has a DRG Attachment
has_drg_attachment() {
    local vcn_id="$1"
    [[ ! -f "$DRG_CACHE" ]] && { echo "false"; return; }
    grep -q "^${vcn_id}|" "$DRG_CACHE" 2>/dev/null && echo "true" || echo "false"
}

# Check if VCN has a Local Peering Gateway
has_local_peering_gateway() {
    local vcn_id="$1"
    [[ ! -f "$LPG_CACHE" ]] && { echo "false"; return; }
    grep -q "^${vcn_id}|" "$LPG_CACHE" 2>/dev/null && echo "true" || echo "false"
}

# Check if VCN has a Remote Peering Connection (via DRG)
has_remote_peering_connection() {
    local vcn_id="$1"
    
    [[ ! -f "$DRG_CACHE" || ! -f "$RPC_CACHE" ]] && { echo "false"; return; }
    
    # Get DRG ID for this VCN
    local drg_id
    drg_id=$(grep "^${vcn_id}|" "$DRG_CACHE" 2>/dev/null | head -1 | cut -d'|' -f2)
    [[ -z "$drg_id" ]] && { echo "false"; return; }
    
    # Check if this DRG has an RPC
    if grep "^${drg_id}|" "$RPC_CACHE" 2>/dev/null | grep -qv "|TERMINATED|"; then
        echo "true"
    else
        echo "false"
    fi
}

# Check if VCN has Route Tables with rules
has_route_table() {
    local vcn_id="$1"
    
    [[ ! -f "$RT_CACHE" ]] && { echo "false"; return; }
    
    # Check for route tables with at least one rule
    local found="false"
    while IFS='|' read -r _ vid _ state count; do
        if [[ "$vid" == "$vcn_id" && "$state" == "AVAILABLE" && "$count" -gt 0 ]]; then
            found="true"
            break
        fi
    done < "$RT_CACHE"
    echo "$found"
}

# Get route table name by ID
get_route_table_name() {
    local rt_id="$1"
    
    [[ ! -f "$RT_CACHE" ]] && { echo "N/A"; return; }
    [[ -z "$rt_id" || "$rt_id" == "N/A" ]] && { echo "N/A"; return; }
    
    local name
    name=$(grep "^${rt_id}|" "$RT_CACHE" 2>/dev/null | head -1 | cut -d'|' -f3)
    echo "${name:-N/A}"
}

# Get route table rule count by ID
get_route_table_rule_count() {
    local rt_id="$1"
    
    [[ ! -f "$RT_CACHE" ]] && { echo "0"; return; }
    [[ -z "$rt_id" || "$rt_id" == "N/A" ]] && { echo "0"; return; }
    
    local count
    count=$(grep "^${rt_id}|" "$RT_CACHE" 2>/dev/null | head -1 | cut -d'|' -f5)
    echo "${count:-0}"
}

# Get security list name by ID (SL_CACHE format: SL_ID|VCN_ID|DISPLAY_NAME|STATE|INGRESS_COUNT|EGRESS_COUNT)
get_security_list_name() {
    local sl_id="$1"
    
    [[ ! -f "$SL_CACHE" ]] && { echo ""; return; }
    [[ -z "$sl_id" || "$sl_id" == "N/A" ]] && { echo ""; return; }
    
    local name
    name=$(grep "^${sl_id}|" "$SL_CACHE" 2>/dev/null | head -1 | cut -d'|' -f3)
    echo "${name:-}"
}

# Get NSG ingress/egress counts
get_nsg_rule_counts() {
    local nsg_id="$1"
    
    [[ -z "$nsg_id" ]] && { echo "0|0"; return; }
    [[ ! -f "$NSG_RULES_CACHE" ]] && { echo "0|0"; return; }
    
    local line
    line=$(grep "^${nsg_id}|" "$NSG_RULES_CACHE" 2>/dev/null | head -1)
    
    if [[ -n "$line" ]]; then
        local ingress egress
        ingress=$(echo "$line" | cut -d'|' -f2)
        egress=$(echo "$line" | cut -d'|' -f3)
        echo "${ingress:-0}|${egress:-0}"
    else
        echo "0|0"
    fi
}

# Find matching shortname for a resource name
get_shortname_match() {
    local name="$1"
    local name_lower
    name_lower=$(echo "$name" | tr '[:upper:]' '[:lower:]')
    
    local shortname
    for shortname in "${NETWORK_SHORTNAMES[@]}"; do
        if [[ "$name_lower" == *"$shortname"* ]]; then
            echo "$shortname"
            return 0
        fi
    done
    echo ""
}

# Display network resources grouped by shortname
display_network_resources() {
    local compartment_id="$1"
    local vcn_ocid="$2"
    local vcn_name="${3:-N/A}"
    
    [[ "$vcn_ocid" == "N/A" || -z "$vcn_ocid" ]] && return 1
    
    # Fetch/refresh caches
    fetch_network_resources "$compartment_id" "$vcn_ocid"
    fetch_all_network_gateways "$compartment_id" "$vcn_ocid"
    
    # Fetch OS Private Endpoints (pass compartment + network compartment if set)
    fetch_os_private_endpoints "$compartment_id" "${NETWORK_COMPARTMENT_ID:-}"
    
    # Build subnet OCID → PE name lookup from OS PE cache
    declare -A PE_SUBNET_MAP
    if [[ -f "$OS_PE_CACHE" ]]; then
        while IFS='|' read -r _pe_name _pe_ns _pe_state _pe_prefix _pe_subnet _pe_ip _pe_ocid _pe_nsgs _pe_comp _pe_ts; do
            [[ "$_pe_name" =~ ^#.*$ ]] && continue
            [[ -z "$_pe_name" || -z "$_pe_subnet" || "$_pe_subnet" == "N/A" ]] && continue
            PE_SUBNET_MAP["$_pe_subnet"]="$_pe_name"
        done < "$OS_PE_CACHE"
    fi
    
    [[ ! -f "$NETWORK_RESOURCES_CACHE" ]] && return 1
    
    echo -e "${BOLD}${WHITE}Network Resources:${NC}"
    _display_cache_info \
        "${NETWORK_RESOURCES_CACHE}|Subnets|SUBNET" \
        "${NETWORK_RESOURCES_CACHE}|NSGs|NSG" \
        "${RT_CACHE}|Routes" \
        "${IGW_CACHE}|IGW" \
        "${NAT_CACHE}|NAT" \
        "${SGW_CACHE}|SGW" \
        "${DRG_CACHE}|DRG" \
        "${OS_PE_CACHE}|OS PEs"
    
    # Build gateway indicators for VCN
    local has_igw has_sgw has_nat has_drg has_lpg has_rpc has_rt
    has_igw=$(has_internet_gateway "$vcn_ocid" 2>/dev/null) || has_igw="false"
    has_sgw=$(has_service_gateway "$vcn_ocid" 2>/dev/null) || has_sgw="false"
    has_nat=$(has_nat_gateway "$vcn_ocid" 2>/dev/null) || has_nat="false"
    has_drg=$(has_drg_attachment "$vcn_ocid" 2>/dev/null) || has_drg="false"
    has_lpg=$(has_local_peering_gateway "$vcn_ocid" 2>/dev/null) || has_lpg="false"
    has_rpc=$(has_remote_peering_connection "$vcn_ocid" 2>/dev/null) || has_rpc="false"
    has_rt=$(has_route_table "$vcn_ocid" 2>/dev/null) || has_rt="false"
    
    local igw_box sgw_box nat_box drg_box lpg_box rpc_box rt_box
    [[ "$has_igw" == "true" ]] && igw_box="${GREEN}[X]${NC}" || igw_box="${WHITE}[ ]${NC}"
    [[ "$has_sgw" == "true" ]] && sgw_box="${GREEN}[X]${NC}" || sgw_box="${WHITE}[ ]${NC}"
    [[ "$has_nat" == "true" ]] && nat_box="${GREEN}[X]${NC}" || nat_box="${WHITE}[ ]${NC}"
    [[ "$has_drg" == "true" ]] && drg_box="${GREEN}[X]${NC}" || drg_box="${WHITE}[ ]${NC}"
    [[ "$has_lpg" == "true" ]] && lpg_box="${GREEN}[X]${NC}" || lpg_box="${WHITE}[ ]${NC}"
    [[ "$has_rpc" == "true" ]] && rpc_box="${GREEN}[X]${NC}" || rpc_box="${WHITE}[ ]${NC}"
    [[ "$has_rt" == "true" ]] && rt_box="${GREEN}[X]${NC}" || rt_box="${WHITE}[ ]${NC}"
    
    local gateway_indicators="IGW:${igw_box} SGW:${sgw_box} NAT:${nat_box} DRG:${drg_box} LPG:${lpg_box} RPC:${rpc_box} RT:${rt_box}"
    
    # Display VCN line with gateway indicators
    echo -e "${BOLD}${MAGENTA}VCN:${NC} ${GREEN}${vcn_name}${NC} ${WHITE}[${NC}${gateway_indicators}${WHITE}]${NC} ${WHITE}(${YELLOW}${vcn_ocid}${WHITE})${NC}"
    echo ""
    
    # Build arrays of subnets and NSGs
    declare -A subnets_by_shortname
    declare -A nsgs_by_shortname
    declare -a unmatched_subnets
    declare -a unmatched_nsgs
    declare -a subnet_shortnames
    
    # Read subnets (now with route-table-id, security-list-ids, and dns-label)
    while IFS='|' read -r type name cidr access state ocid rt_ocid sl_ids dns_label; do
        [[ "$type" != "SUBNET" ]] && continue
        local shortname
        shortname=$(get_shortname_match "$name")
        if [[ -n "$shortname" ]]; then
            subnets_by_shortname[$shortname]="${name}|${cidr}|${access}|${ocid}|${rt_ocid}|${sl_ids}|${dns_label}"
            subnet_shortnames+=("$shortname")
        else
            unmatched_subnets+=("${name}|${cidr}|${access}|${ocid}|${rt_ocid}|${sl_ids}|${dns_label}")
        fi
    done < <(grep "^SUBNET|" "$NETWORK_RESOURCES_CACHE" 2>/dev/null)
    
    # Read NSGs
    while IFS='|' read -r type name _ state ocid; do
        [[ "$type" != "NSG" ]] && continue
        local shortname
        shortname=$(get_shortname_match "$name")
        if [[ -n "$shortname" ]]; then
            if [[ -n "${nsgs_by_shortname[$shortname]:-}" ]]; then
                nsgs_by_shortname[$shortname]="${nsgs_by_shortname[$shortname]}#${name}|${ocid}"
            else
                nsgs_by_shortname[$shortname]="${name}|${ocid}"
            fi
        else
            unmatched_nsgs+=("${name}|${ocid}")
        fi
    done < <(grep "^NSG|" "$NETWORK_RESOURCES_CACHE" 2>/dev/null)
    
    # Display subnets with their matching NSGs
    local shortname
    for shortname in "${subnet_shortnames[@]}"; do
        local subnet_info="${subnets_by_shortname[$shortname]}"
        [[ -z "$subnet_info" ]] && continue
        
        local name cidr access ocid rt_ocid sl_ids dns_label
        IFS='|' read -r name cidr access ocid rt_ocid sl_ids dns_label <<< "$subnet_info"
        
        local access_color
        [[ "$access" == "Private" ]] && access_color="$RED" || access_color="$LIGHT_GREEN"
        
        # Get route table info
        local rt_name rt_rules rt_display
        rt_name=$(get_route_table_name "$rt_ocid")
        rt_rules=$(get_route_table_rule_count "$rt_ocid")
        rt_display="${rt_name} (${rt_rules})"
        
        # DNS label display with fixed width (one space after colon)
        local dns_display
        if [[ -n "$dns_label" ]]; then
            dns_display=$(printf "DNS: %-12s" "$dns_label")
        else
            dns_display=$(printf "%-17s" "")
        fi
        
        # Get security list names
        local sl_display=""
        if [[ -n "$sl_ids" ]]; then
            local sl_names=""
            IFS=',' read -ra sl_array <<< "$sl_ids"
            for sl_id in "${sl_array[@]}"; do
                [[ -z "$sl_id" ]] && continue
                local sl_name
                sl_name=$(get_security_list_name "$sl_id")
                if [[ -n "$sl_name" ]]; then
                    [[ -n "$sl_names" ]] && sl_names+=", "
                    sl_names+="$sl_name"
                fi
            done
            [[ -n "$sl_names" ]] && sl_display="${sl_names}"
        fi
        
        # Subnet line with route table and DNS label
        # OS PE indicator - check if this subnet has a private endpoint
        local pe_indicator=""
        if [[ -n "${PE_SUBNET_MAP[$ocid]:-}" ]]; then
            pe_indicator="OS PE ${GREEN}[X]${NC} "
        fi
        
        printf "  ${BOLD}${WHITE}Subnet:${NC} ${GREEN}%-30s${NC} ${WHITE}[${CYAN}%-15s${WHITE}]${NC} ${WHITE}[${access_color}%-7s${WHITE}]${NC} ${MAGENTA}%-17s${NC} %b${WHITE}RT:${NC} ${CYAN}%-25s${NC} ${WHITE}(${YELLOW}%s${WHITE})${NC}\n" \
            "$name" "$cidr" "$access" "$dns_display" "$pe_indicator" "$rt_display" "$ocid"
        
        # Count total items for tree display (SL + NSGs)
        local nsg_list="${nsgs_by_shortname[$shortname]:-}"
        local has_sl=false
        local has_nsg=false
        [[ -n "$sl_display" ]] && has_sl=true
        [[ -n "$nsg_list" ]] && has_nsg=true
        
        # Display security lists if any
        if [[ "$has_sl" == "true" ]]; then
            local sl_prefix="└─"
            [[ "$has_nsg" == "true" ]] && sl_prefix="├─"
            printf "          ${MAGENTA}${sl_prefix} SL:${NC}  ${WHITE}%s${NC}\n" "$sl_display"
        fi
        
        # Display matching NSGs
        if [[ "$has_nsg" == "true" ]]; then
            local nsg_entries
            IFS='#' read -ra nsg_entries <<< "$nsg_list"
            local nsg_count=${#nsg_entries[@]}
            local i=0
            for nsg_entry in "${nsg_entries[@]}"; do
                ((i++))
                local nsg_name nsg_ocid
                IFS='|' read -r nsg_name nsg_ocid <<< "$nsg_entry"
                
                # Get NSG rule counts
                local rule_counts ingress egress rules_display
                rule_counts=$(get_nsg_rule_counts "$nsg_ocid")
                ingress=$(echo "$rule_counts" | cut -d'|' -f1)
                egress=$(echo "$rule_counts" | cut -d'|' -f2)
                rules_display="In:${ingress} Out:${egress}"
                
                local prefix="├─"
                [[ $i -eq $nsg_count ]] && prefix="└─"
                
                # NSG line with rule counts - aligned with subnet OCID
                printf "          ${BLUE}${prefix} NSG:${NC} ${WHITE}%-30s${NC} ${CYAN}%-15s${NC} %-51s ${WHITE}(${YELLOW}%s${WHITE})${NC}\n" \
                    "$nsg_name" "$rules_display" "" "$nsg_ocid"
            done
        fi
        echo ""
    done
    
    # Display unmatched subnets
    if [[ ${#unmatched_subnets[@]} -gt 0 ]]; then
        for subnet_entry in "${unmatched_subnets[@]}"; do
            local name cidr access ocid rt_ocid sl_ids dns_label
            IFS='|' read -r name cidr access ocid rt_ocid sl_ids dns_label <<< "$subnet_entry"
            
            local access_color
            [[ "$access" == "Private" ]] && access_color="$RED" || access_color="$LIGHT_GREEN"
            
            # Get route table info
            local rt_name rt_rules rt_display
            rt_name=$(get_route_table_name "$rt_ocid")
            rt_rules=$(get_route_table_rule_count "$rt_ocid")
            rt_display="${rt_name} (${rt_rules})"
            
            # DNS label display with fixed width (one space after colon)
            local dns_display
            if [[ -n "$dns_label" ]]; then
                dns_display=$(printf "DNS: %-12s" "$dns_label")
            else
                dns_display=$(printf "%-17s" "")
            fi
            
            # Get security list names
            local sl_display=""
            if [[ -n "$sl_ids" ]]; then
                local sl_names=""
                IFS=',' read -ra sl_array <<< "$sl_ids"
                for sl_id in "${sl_array[@]}"; do
                    [[ -z "$sl_id" ]] && continue
                    local sl_name
                    sl_name=$(get_security_list_name "$sl_id")
                    if [[ -n "$sl_name" ]]; then
                        [[ -n "$sl_names" ]] && sl_names+=", "
                        sl_names+="$sl_name"
                    fi
                done
                [[ -n "$sl_names" ]] && sl_display="${sl_names}"
            fi
            
            # OS PE indicator - check if this subnet has a private endpoint
            local pe_indicator=""
            if [[ -n "${PE_SUBNET_MAP[$ocid]:-}" ]]; then
                pe_indicator="OS PE ${GREEN}[X]${NC} "
            fi
            
            printf "  ${BOLD}${WHITE}Subnet:${NC} ${GREEN}%-30s${NC} ${WHITE}[${CYAN}%-15s${WHITE}]${NC} ${WHITE}[${access_color}%-7s${WHITE}]${NC} ${MAGENTA}%-17s${NC} %b${WHITE}RT:${NC} ${CYAN}%-25s${NC} ${WHITE}(${YELLOW}%s${WHITE})${NC}\n" \
                "$name" "$cidr" "$access" "$dns_display" "$pe_indicator" "$rt_display" "$ocid"
            
            # Display security lists if any
            if [[ -n "$sl_display" ]]; then
                printf "          ${MAGENTA}└─ SL:${NC}  ${WHITE}%s${NC}\n" "$sl_display"
            fi
            echo ""
        done
    fi
    
    # Display unmatched NSGs if any
    if [[ ${#unmatched_nsgs[@]} -gt 0 ]]; then
        echo -e "  ${BOLD}${WHITE}Unmatched NSGs:${NC}"
        local i=0
        local total=${#unmatched_nsgs[@]}
        for nsg_entry in "${unmatched_nsgs[@]}"; do
            ((i++))
            local nsg_name nsg_ocid
            IFS='|' read -r nsg_name nsg_ocid <<< "$nsg_entry"
            
            # Get NSG rule counts
            local rule_counts ingress egress rules_display
            rule_counts=$(get_nsg_rule_counts "$nsg_ocid")
            ingress=$(echo "$rule_counts" | cut -d'|' -f1)
            egress=$(echo "$rule_counts" | cut -d'|' -f2)
            rules_display="In:${ingress} Out:${egress}"
            
            local prefix="├─"
            [[ $i -eq $total ]] && prefix="└─"
            
            # NSG line with rule counts - aligned with subnet OCID
            printf "          ${BLUE}${prefix} NSG:${NC} ${WHITE}%-30s${NC} ${CYAN}%-15s${NC} %-51s ${WHITE}(${YELLOW}%s${WHITE})${NC}\n" \
                "$nsg_name" "$rules_display" "" "$nsg_ocid"
        done
        echo ""
    fi
}

# Build announcement lookup tables from cached data
build_announcement_lookup() {
    local compartment_id="$1"
    
    # Reset arrays
    INSTANCE_ANNOUNCEMENTS=()
    GPU_MEM_CLUSTER_ANNOUNCEMENTS=()
    
    # Refresh cache if needed
    if ! is_cache_fresh "$ANNOUNCEMENTS_LIST_CACHE"; then
        log_info "Fetching announcements from OCI..."
        
        if ! oci announce announcements list \
                --compartment-id "$compartment_id" \
                --all > "$ANNOUNCEMENTS_LIST_CACHE" 2>/dev/null; then
            log_warn "Failed to fetch announcements"
            return 1
        fi
        
        # Fetch details for each announcement in parallel
        local announcement_ids
        announcement_ids=$(jq -r '.data.items[].id' "$ANNOUNCEMENTS_LIST_CACHE" 2>/dev/null)
        
        local ann_id
        for ann_id in $announcement_ids; do
            local detail_file="${CACHE_DIR}/${ann_id##*.}.json"
            if [[ ! -f "$detail_file" || ! -s "$detail_file" ]]; then
                oci announce announcements get --announcement-id "$ann_id" > "$detail_file" 2>/dev/null &
            fi
        done
        wait
    fi
    
    # Process cached announcement details
    local detail_file
    for detail_file in "$CACHE_DIR"/*.json; do
        [[ ! -f "$detail_file" ]] && continue
        [[ "$detail_file" == "$ANNOUNCEMENTS_LIST_CACHE" ]] && continue
        [[ "$detail_file" == *"/ack_status_cache.json" ]] && continue
        
        # Validate JSON has announcement data
        if ! jq -e '.data.id' "$detail_file" > /dev/null 2>&1; then
            continue
        fi
        
        # Only process ACTIVE announcements
        local lifecycle_state
        lifecycle_state=$(jq -r '.data."lifecycle-state" // "N/A"' "$detail_file")
        [[ "$lifecycle_state" != "ACTIVE" ]] && continue
        
        local reference_ticket
        reference_ticket=$(jq -r '.data."reference-ticket-number" // "N/A"' "$detail_file")
        local short_ticket="${reference_ticket:0:8}"
        
        # Extract affected resources count
        local resource_count
        resource_count=$(jq '.data."affected-resources" | length' "$detail_file" 2>/dev/null) || resource_count=0
        
        local i
        for ((i=0; i<resource_count; i++)); do
            # Get instance/resource ID
            local resource_id
            resource_id=$(jq -r ".data.\"affected-resources\"[$i] | 
                if .properties then
                    (.properties[] | select(.name == \"resourceId\" or .name == \"instanceId\") | .value) // null
                else
                    (.\"resource-id\" // .\"instance-id\" // null)
                end" "$detail_file" 2>/dev/null)
            
            # Get GPU memory cluster
            local gpu_mem_cluster
            gpu_mem_cluster=$(jq -r ".data.\"affected-resources\"[$i] |
                if .properties then
                    (.properties[] | select(.name == \"gpuMemoryCluster\") | .value) // null
                else
                    null
                end" "$detail_file" 2>/dev/null)
            
            # Add to instance lookup (avoid duplicates)
            if [[ -n "$resource_id" && "$resource_id" != "null" ]]; then
                if [[ -z "${INSTANCE_ANNOUNCEMENTS[$resource_id]:-}" ]]; then
                    INSTANCE_ANNOUNCEMENTS[$resource_id]="$short_ticket"
                elif [[ ! "${INSTANCE_ANNOUNCEMENTS[$resource_id]}" =~ $short_ticket ]]; then
                    INSTANCE_ANNOUNCEMENTS[$resource_id]="${INSTANCE_ANNOUNCEMENTS[$resource_id]},$short_ticket"
                fi
            fi
            
            # Add to GPU memory cluster lookup (avoid duplicates)
            if [[ -n "$gpu_mem_cluster" && "$gpu_mem_cluster" != "null" ]]; then
                if [[ -z "${GPU_MEM_CLUSTER_ANNOUNCEMENTS[$gpu_mem_cluster]:-}" ]]; then
                    GPU_MEM_CLUSTER_ANNOUNCEMENTS[$gpu_mem_cluster]="$short_ticket"
                elif [[ ! "${GPU_MEM_CLUSTER_ANNOUNCEMENTS[$gpu_mem_cluster]}" =~ $short_ticket ]]; then
                    GPU_MEM_CLUSTER_ANNOUNCEMENTS[$gpu_mem_cluster]="${GPU_MEM_CLUSTER_ANNOUNCEMENTS[$gpu_mem_cluster]},$short_ticket"
                fi
            fi
        done
    done
}

#===============================================================================
# LOOKUP FUNCTIONS
#===============================================================================

# Get cluster state from cache
# Args: $1 = cluster OCID
get_cluster_state() {
    lookup_cache "$CLUSTER_CACHE" "$1" 3
}

# Get instance configuration ID from cluster OCID
# Args: $1 = cluster OCID
get_instance_config_from_cluster() {
    lookup_cache "$CLUSTER_CACHE" "$1" 5
}

# Get compute cluster ID from GPU memory cluster OCID
# Args: $1 = GPU memory cluster OCID
get_compute_cluster_from_gpu_cluster() {
    lookup_cache "$CLUSTER_CACHE" "$1" 6
}

# Get GPU memory cluster size from cluster OCID
# Args: $1 = cluster OCID
get_cluster_size() {
    lookup_cache "$CLUSTER_CACHE" "$1" 7
}

# Get node state from cache
# Args: $1 = instance OCID (provider ID)
get_node_state_cached() {
    lookup_cache "$NODE_STATE_CACHE" "$1" 2
}

# Get capacity topology state for an instance
# Args: $1 = instance OCID
get_capacity_topology_state() {
    lookup_cache "$CAPACITY_TOPOLOGY_CACHE" "$1" 3
}

# Get fabric details from cluster OCID
# Args: $1 = cluster OCID
# Returns: DisplayName|Last5Chars|FabricOCID|State|AvailableHosts|TotalHosts
get_fabric_from_cluster() {
    local cluster_ocid="$1"
    local default="N/A|N/A|N/A|N/A|0|0"
    
    [[ ! -f "$FABRIC_CACHE" || ! -f "$CLUSTER_CACHE" ]] && { echo "$default"; return 1; }
    
    local fabric_suffix
    fabric_suffix=$(grep "^${cluster_ocid}|" "$CLUSTER_CACHE" 2>/dev/null | cut -d'|' -f4)
    [[ -z "$fabric_suffix" ]] && { echo "$default"; return 1; }
    
    local fabric_line
    fabric_line=$(grep -v '^#' "$FABRIC_CACHE" | grep "|${fabric_suffix}|" | head -n1)
    echo "${fabric_line:-$default}"
}

# Get announcements for a resource (instance and/or GPU memory cluster)
# Args: $1 = instance OCID, $2 = GPU memory cluster OCID
# Returns: comma-separated ticket numbers or "-" if none
get_resource_announcements() {
    local instance_ocid="$1"
    local gpu_mem_cluster="$2"
    local result=""
    
    # Check instance-level announcements
    if [[ -n "$instance_ocid" && -n "${INSTANCE_ANNOUNCEMENTS[$instance_ocid]:-}" ]]; then
        result="${INSTANCE_ANNOUNCEMENTS[$instance_ocid]}"
    fi
    
    # Check GPU memory cluster level announcements
    if [[ -n "$gpu_mem_cluster" && "$gpu_mem_cluster" != "N/A" && -n "${GPU_MEM_CLUSTER_ANNOUNCEMENTS[$gpu_mem_cluster]:-}" ]]; then
        if [[ -z "$result" ]]; then
            result="${GPU_MEM_CLUSTER_ANNOUNCEMENTS[$gpu_mem_cluster]}"
        else
            # Append unique tickets only
            local ticket
            for ticket in ${GPU_MEM_CLUSTER_ANNOUNCEMENTS[$gpu_mem_cluster]//,/ }; do
                [[ ! "$result" =~ $ticket ]] && result="${result},${ticket}"
            done
        fi
    fi
    
    echo "${result:--}"
}

#===============================================================================
# COLOR HELPER FUNCTIONS
#===============================================================================

# Get color for Kubernetes node state
color_node_state() {
    case "$1" in
        Ready)    echo "$GREEN" ;;
        NotReady) echo "$RED" ;;
        -)        echo "$GRAY" ;;
        *)        echo "$YELLOW" ;;
    esac
}

# Get color for OCI instance state
color_oci_state() {
    case "$1" in
        RUNNING)    echo "$GREEN" ;;
        STOPPED)    echo "$RED" ;;
        TERMINATED) echo "$RED" ;;
        *)          echo "$YELLOW" ;;
    esac
}

# Get color for capacity topology state
color_cap_topo_state() {
    case "$1" in
        AVAILABLE) echo "$GREEN" ;;
        N/A)       echo "$YELLOW" ;;
        *)         echo "$RED" ;;
    esac
}

# Get color for cluster state
color_cluster_state() {
    case "$1" in
        ACTIVE) echo "$GREEN" ;;
        CREATING) echo "$CYAN" ;;
        UPDATING|SCALING) echo "$YELLOW" ;;
        INACTIVE|FAILED|DELETED|DELETING) echo "$RED" ;;
        *)      echo "$WHITE" ;;
    esac
}

# Get color for fabric state
color_fabric_state() {
    case "$1" in
        AVAILABLE) echo "$GREEN" ;;
        *)         echo "$RED" ;;
    esac
}

# Get color for announcement status
color_announcement() {
    [[ "$1" == "-" ]] && echo "$GREEN" || echo "$RED"
}

# Get color for firmware update state
color_firmware_state() {
    case "$1" in
        UP_TO_DATE|COMPLETED) echo "$GREEN" ;;
        IN_PROGRESS|UPDATING) echo "$YELLOW" ;;
        FAILED|ERROR) echo "$RED" ;;
        *) echo "$WHITE" ;;
    esac
}

#===============================================================================
# TABLE FORMATTING HELPERS
#===============================================================================

# Print a horizontal separator line
print_separator() {
    local width="${1:-80}"
    echo -e "${BLUE}$(printf '━%.0s' $(seq 1 "$width"))${NC}"
}

# Truncate string to max length with ellipsis
truncate_string() {
    local str="$1"
    local max_len="$2"
    
    if [[ ${#str} -gt $max_len ]]; then
        echo "${str:0:$((max_len-3))}..."
    else
        echo "$str"
    fi
}

#===============================================================================
# OKE ENVIRONMENT HEADER
#===============================================================================

# Display OKE environment header
display_oke_environment_header() {
    local compartment_id="$1"
    local region="$2"
    
    # Fetch/refresh cache
    fetch_oke_environment "$compartment_id" "$region"
    
    # Read values from cache
    local tenancy_ocid compartment_name ads
    local cluster_name cluster_ocid cluster_state cluster_version cluster_addons pod_network vcn_name vcn_ocid
    local compute_cluster_name compute_cluster_ocid
    
    tenancy_ocid=$(get_oke_env_value "TENANCY_OCID")
    compartment_name=$(get_oke_env_value "COMPARTMENT_NAME")
    ads=$(get_oke_env_value "ADS")
    cluster_name=$(get_oke_env_value "CLUSTER_NAME")
    cluster_ocid=$(get_oke_env_value "OKE_CLUSTER_ID")
    cluster_state=$(get_oke_env_value "CLUSTER_STATE")
    cluster_version=$(get_oke_env_value "CLUSTER_VERSION")
    cluster_addons=$(get_oke_env_value "CLUSTER_ADDONS")
    pod_network=$(get_oke_env_value "POD_NETWORK")
    vcn_name=$(get_oke_env_value "VCN_NAME")
    vcn_ocid=$(get_oke_env_value "VCN_OCID")
    compute_cluster_name=$(get_oke_env_value "COMPUTE_CLUSTER_NAME")
    compute_cluster_ocid=$(get_oke_env_value "COMPUTE_CLUSTER_OCID")
    
    # If cluster version is empty/N/A, fetch directly from OCI (same as manage_oke_cluster)
    if [[ -z "$cluster_version" || "$cluster_version" == "N/A" ]] && [[ -n "$cluster_ocid" && "$cluster_ocid" != "N/A" ]]; then
        local cluster_json
        cluster_json=$(oci ce cluster get --cluster-id "$cluster_ocid" --output json 2>/dev/null)
        if [[ -n "$cluster_json" ]]; then
            cluster_version=$(echo "$cluster_json" | jq -r '.data["kubernetes-version"] // "N/A"')
            # Update cache with the version
            if [[ -f "$OKE_ENV_CACHE" && -n "$cluster_version" && "$cluster_version" != "N/A" ]]; then
                if grep -q "^CLUSTER_VERSION|" "$OKE_ENV_CACHE" 2>/dev/null; then
                    sed -i "s/^CLUSTER_VERSION|.*/CLUSTER_VERSION|${cluster_version}/" "$OKE_ENV_CACHE"
                else
                    echo "CLUSTER_VERSION|${cluster_version}" >> "$OKE_ENV_CACHE"
                fi
            fi
        fi
    fi
    
    # Box width for content (excluding border chars)
    local width=148
    local h_line
    h_line=$(printf '═%.0s' $(seq 1 $width))
    
    # Helper function to print a simple labeled row (no OCID)
    _print_row() {
        local label="$1"
        local value="$2"
        local label_width=18
        local value_width=$((width - 2 - label_width))
        printf "${BOLD}${BLUE}║${NC}  ${CYAN}%-${label_width}s${NC}${WHITE}%-${value_width}s${NC}${BOLD}${BLUE}║${NC}\n" "$label" "$value"
    }
    
    # Helper function to print a row with name and OCID (OCID in yellow)
    _print_row_with_ocid() {
        local label="$1"
        local name="$2"
        local ocid="$3"
        local label_width=18
        local combined="${name} (${ocid})"
        local combined_len=${#combined}
        local value_width=$((width - 2 - label_width))
        local padding=$((value_width - combined_len))
        [[ $padding -lt 0 ]] && padding=0
        printf "${BOLD}${BLUE}║${NC}  ${CYAN}%-${label_width}s${NC}${WHITE}%s${NC} ${YELLOW}(%s)${NC}%${padding}s${BOLD}${BLUE}║${NC}\n" "$label" "$name" "$ocid" ""
    }
    
    # Helper for OCID-only rows (like tenancy)
    _print_ocid_row() {
        local label="$1"
        local ocid="$2"
        local label_width=18
        local value_width=$((width - 2 - label_width))
        printf "${BOLD}${BLUE}║${NC}  ${CYAN}%-${label_width}s${NC}${YELLOW}%-${value_width}s${NC}${BOLD}${BLUE}║${NC}\n" "$label" "$ocid"
    }
    
    echo ""
    
    # Top border
    echo -e "${BOLD}${BLUE}╔${h_line}╗${NC}"
    
    # Title row - centered
    local title="OKE CLUSTER ENVIRONMENT"
    local title_len=${#title}
    local left_pad=$(( (width - title_len) / 2 ))
    local right_pad=$(( width - title_len - left_pad ))
    printf "${BOLD}${BLUE}║${NC}%${left_pad}s${BOLD}${WHITE}%s${NC}%${right_pad}s${BOLD}${BLUE}║${NC}\n" "" "$title" ""
    
    # Section separator
    echo -e "${BOLD}${BLUE}╠${h_line}╣${NC}"
    
    # Tenancy & Region section
    _print_ocid_row "Tenancy:" "$tenancy_ocid"
    _print_row "Region:" "$region"
    _print_row_with_ocid "Compartment:" "$compartment_name" "$compartment_id"
    _print_row "ADs:" "$ads"
    
    # Section separator
    echo -e "${BOLD}${BLUE}╠${h_line}╣${NC}"
    
    # OKE Cluster section - special handling for cluster with state
    local label_width=18
    local cluster_combined="${cluster_name} [${cluster_state}] (${cluster_ocid})"
    local cluster_combined_len=${#cluster_combined}
    local value_width=$((width - 2 - label_width))
    local cluster_padding=$((value_width - cluster_combined_len))
    [[ $cluster_padding -lt 0 ]] && cluster_padding=0
    printf "${BOLD}${BLUE}║${NC}  ${CYAN}%-${label_width}s${NC}${WHITE}%s${NC} ${GREEN}[%s]${NC} ${YELLOW}(%s)${NC}%${cluster_padding}s${BOLD}${BLUE}║${NC}\n" "OKE Cluster:" "$cluster_name" "$cluster_state" "$cluster_ocid" ""
    
    _print_row "OKE Version:" "$cluster_version"
    _print_row "Pod Network:" "$pod_network"
    _print_row "Cluster Addons:" "$cluster_addons"
    _print_row_with_ocid "VCN:" "$vcn_name" "$vcn_ocid"
    
    # Section separator
    echo -e "${BOLD}${BLUE}╠${h_line}╣${NC}"
    
    # Compute Cluster section
    _print_row_with_ocid "Compute Cluster:" "$compute_cluster_name" "$compute_cluster_ocid"
    
    # Section separator - Helm Deployments
    echo -e "${BOLD}${BLUE}╠${h_line}╣${NC}"
    
    # Helm Deployments section - check for GPU-related helm releases
    local helm_available=false
    if command -v helm &>/dev/null && command -v kubectl &>/dev/null; then
        helm_available=true
    fi
    
    if [[ "$helm_available" == "true" ]]; then
        # Check gpu-operator namespace
        local gpu_operator_info gpu_op_json
        gpu_op_json=$(helm list -n gpu-operator -o json 2>/dev/null)
        if [[ -n "$gpu_op_json" && "$gpu_op_json" != "[]" ]]; then
            gpu_operator_info=$(echo "$gpu_op_json" | jq -r '.[0] | select(.name == "gpu-operator") | "\(.chart) [\(.status)] rev:\(.revision) updated:\(.updated | split(".")[0])"' 2>/dev/null)
        fi
        if [[ -n "$gpu_operator_info" && "$gpu_operator_info" != "null" ]]; then
            _print_row "GPU Operator:" "$gpu_operator_info"
        else
            _print_row "GPU Operator:" "Not installed"
        fi
        
        # Check nvidia-dra-driver-gpu namespace
        local dra_driver_info dra_json
        dra_json=$(helm list -n nvidia-dra-driver-gpu -o json 2>/dev/null)
        if [[ -n "$dra_json" && "$dra_json" != "[]" ]]; then
            dra_driver_info=$(echo "$dra_json" | jq -r '.[0] | select(.name == "nvidia-dra-driver-gpu") | "\(.chart) [\(.status)] rev:\(.revision) updated:\(.updated | split(".")[0])"' 2>/dev/null)
        fi
        if [[ -n "$dra_driver_info" && "$dra_driver_info" != "null" ]]; then
            _print_row "DRA Driver:" "$dra_driver_info"
        else
            _print_row "DRA Driver:" "Not installed"
        fi
    else
        _print_row "Helm Deploys:" "(helm/kubectl not available)"
    fi
    
    # Bottom border
    echo -e "${BOLD}${BLUE}╚${h_line}╝${NC}"
    _display_cache_info \
        "${OKE_ENV_CACHE}|OKE Env" \
        "${FABRIC_CACHE}|Fabrics" \
        "${CLUSTER_CACHE}|GPU Clusters" \
        "${INSTANCE_CLUSTER_MAP_CACHE}|Instance Map" \
        "${COMPUTE_CLUSTER_CACHE}|Compute Clusters"
    echo ""
    
    # Display network resources (subnets and NSGs grouped by shortname)
    display_network_resources "$compartment_id" "$vcn_ocid" "$vcn_name"
}

#===============================================================================
# DISPLAY FUNCTIONS
#===============================================================================

# List fabrics without active clusters
list_fabrics_without_clusters() {
    echo -e "${BOLD}${MAGENTA}=== GPU Memory Fabrics Without Clusters ===${NC}"
    echo ""
    
    if [[ ! -f "$FABRIC_CACHE" || ! -f "$CLUSTER_CACHE" ]]; then
        echo -e "${YELLOW}Cache files not available${NC}"
        return 1
    fi
    
    local all_fabric_suffixes
    all_fabric_suffixes=$(grep -v '^#' "$FABRIC_CACHE" | cut -d'|' -f2)
    
    local used_fabric_suffixes
    # Include ACTIVE, UPDATING, SCALING, and CREATING states when determining fabrics with clusters
    used_fabric_suffixes=$(grep -v '^#' "$CLUSTER_CACHE" | grep -E "\|ACTIVE\||\|UPDATING\||\|SCALING\||\|CREATING\|" | cut -d'|' -f4 | sort -u)
    
    local found_unused=false
    local temp_output
    temp_output=$(create_temp_file) || return 1
    
    local fabric_suffix
    while read -r fabric_suffix; do
        [[ -z "$fabric_suffix" ]] && continue
        
        if ! echo "$used_fabric_suffixes" | grep -q "^${fabric_suffix}$"; then
            found_unused=true
            local fabric_line
            fabric_line=$(grep -v '^#' "$FABRIC_CACHE" | grep "|${fabric_suffix}|" | head -n1)
            
            if [[ -n "$fabric_line" ]]; then
                # Format: DisplayName|Last5Chars|FabricOCID|State|HealthyHosts|AvailableHosts|TotalHosts|CurrentFirmware|TargetFirmware|FirmwareUpdateState
                local fabric_name fabric_ocid fabric_state healthy_hosts avail_hosts total_hosts current_firmware target_firmware firmware_update_state
                IFS='|' read -r fabric_name _ fabric_ocid fabric_state healthy_hosts avail_hosts total_hosts current_firmware target_firmware firmware_update_state <<< "$fabric_line"
                echo "${fabric_name}|${fabric_ocid}|${fabric_state}|${healthy_hosts}|${avail_hosts}|${total_hosts}|${current_firmware}|${target_firmware}|${firmware_update_state}" >> "$temp_output"
            fi
        fi
    done <<< "$all_fabric_suffixes"
    
    if [[ "$found_unused" == "true" ]]; then
        # Print header - aligned with clique summary
        printf "${BOLD}%-48s ┌─ GPU Memory Fabric ─┐${NC}\n" ""
        printf "${BOLD}%-48s %8s %6s %6s    %-12s${NC}\n" \
            "Fabric Display Name" "Healthy" "Avail" "Total" "State"
        print_separator 106
        
        # Print data rows
        local fabric_name fabric_ocid fabric_state healthy_hosts avail_hosts total_hosts current_firmware target_firmware firmware_update_state
        while IFS='|' read -r fabric_name fabric_ocid fabric_state healthy_hosts avail_hosts total_hosts current_firmware target_firmware firmware_update_state; do
            local state_color
            state_color=$(color_fabric_state "$fabric_state")
            
            # Color available hosts - light green if not 0
            local avail_color="$WHITE"
            [[ "$avail_hosts" != "0" && "$avail_hosts" != "N/A" ]] && avail_color="$LIGHT_GREEN"
            
            printf "${CYAN}%-48s${NC} ${WHITE}%8s${NC} ${avail_color}%6s${NC} ${WHITE}%6s${NC}    ${state_color}%-12s${NC}\n" \
                "$fabric_name" "$healthy_hosts" "$avail_hosts" "$total_hosts" "$fabric_state"
            printf "          ${WHITE}├─${NC} ${BOLD}${ORANGE}%-18s${NC} ${WHITE}%-44s${NC} ${WHITE}(${YELLOW}%s${WHITE})${NC}\n" \
                "Fabric:" "$fabric_name" "$fabric_ocid"
            
            # Display firmware bundle IDs if available
            if [[ "$current_firmware" != "N/A" && -n "$current_firmware" ]]; then
                local current_short="${current_firmware: -5}"
                local target_short="${target_firmware: -5}"
                local firmware_color="$WHITE"
                
                # Highlight in red if current != target
                if [[ "$current_firmware" != "$target_firmware" && "$target_firmware" != "N/A" && -n "$target_firmware" ]]; then
                    firmware_color="$RED"
                fi
                
                # Color firmware update state
                local update_state_color
                update_state_color=$(color_firmware_state "$firmware_update_state")
                
                printf "          ${WHITE}└─${NC} ${BOLD}${ORANGE}Firmware:${NC} ${update_state_color}%-12s${NC} ${firmware_color}current: %-10s target: %-10s${NC}\n" \
                    "$firmware_update_state" "$current_short" "$target_short"
            fi
            echo ""
        done < "$temp_output"
    else
        echo -e "${GREEN}All fabrics have active clusters${NC}"
    fi
    
    rm -f "$temp_output"
}

#===============================================================================
# UNIFIED CONSOLE HISTORY FUNCTION
# Single function for capturing and displaying console history
# Used by both CLI (--console-history) and interactive modes
#===============================================================================

# Capture and display console history for an instance
# Args: 
#   $1 = instance OCID (required)
#   $2 = region (optional, defaults to EFFECTIVE_REGION or REGION)
#   $3 = instance display name (optional, for display purposes)
#   $4 = auto_cleanup - "true" to delete history after display (default: "true")
#   $5 = interactive - "true" for interactive prompts (default: "false")
#
# Returns: 0 on success, 1 on failure
# Output: Console history content to stdout
#
fetch_and_display_console_history() {
    local instance_ocid="$1"
    local region="${2:-${EFFECTIVE_REGION:-$REGION}}"
    local instance_name="${3:-$instance_ocid}"
    local auto_cleanup="${4:-true}"
    local interactive="${5:-false}"
    
    # Validate required args
    if [[ -z "$instance_ocid" ]]; then
        echo -e "${RED}Error: Instance OCID required${NC}" >&2
        return 1
    fi
    
    if [[ -z "$region" ]]; then
        echo -e "${RED}Error: Region not set${NC}" >&2
        return 1
    fi
    
    local console_history_id=""
    local capture_cmd=""
    local status_cmd=""
    local content_cmd=""
    
    # ========== STEP 1: Capture Console History ==========
    echo ""
    echo -e "${YELLOW}Capturing console history...${NC}"
    echo ""
    
    capture_cmd="oci --region \"$region\" compute console-history capture --instance-id \"$instance_ocid\" --output json"
    echo -e "${GRAY}Command: ${capture_cmd}${NC}"
    echo ""
    
    local capture_result
    capture_result=$(oci --region "$region" compute console-history capture \
        --instance-id "$instance_ocid" \
        --output json 2>&1)
    local capture_exit=$?
    
    if [[ $capture_exit -ne 0 ]]; then
        echo -e "${RED}✗ Failed to capture console history${NC}"
        echo -e "${GRAY}Exit code: $capture_exit${NC}"
        echo -e "${GRAY}Output: $capture_result${NC}"
        return 1
    fi
    
    console_history_id=$(echo "$capture_result" | jq -r '.data.id // empty' 2>/dev/null)
    
    if [[ -z "$console_history_id" ]]; then
        echo -e "${RED}✗ Failed to get console history ID from response${NC}"
        echo -e "${GRAY}Response: $capture_result${NC}"
        return 1
    fi
    
    echo -e "${GREEN}✓ Console history capture initiated${NC}"
    echo -e "  ${CYAN}History ID:${NC} ${YELLOW}$console_history_id${NC}"
    echo ""
    
    # ========== STEP 2: Wait for Capture to Complete ==========
    echo -e "${YELLOW}Waiting for capture to complete...${NC}"
    
    status_cmd="oci --region \"$region\" compute console-history get --instance-console-history-id \"$console_history_id\" --output json"
    echo -e "${GRAY}Polling command: ${status_cmd}${NC}"
    echo ""
    
    local max_wait=60
    local wait_count=0
    local capture_state="REQUESTED"
    local status_json=""
    
    while [[ "$capture_state" != "SUCCEEDED" && "$capture_state" != "FAILED" && $wait_count -lt $max_wait ]]; do
        sleep 2
        ((wait_count+=2))
        
        status_json=$(oci --region "$region" compute console-history get \
            --instance-console-history-id "$console_history_id" \
            --output json 2>/dev/null)
        
        capture_state=$(echo "$status_json" | jq -r '.data["lifecycle-state"] // "UNKNOWN"' 2>/dev/null)
        echo -ne "\r  ${YELLOW}Status:${NC} ${WHITE}${capture_state}${NC} (${wait_count}s)    "
    done
    echo ""
    
    if [[ "$capture_state" != "SUCCEEDED" ]]; then
        echo ""
        echo -e "${RED}✗ Console history capture failed or timed out${NC}"
        echo -e "  ${CYAN}Final State:${NC} ${YELLOW}$capture_state${NC}"
        
        # Cleanup on failure if we have an ID
        if [[ -n "$console_history_id" && "$auto_cleanup" == "true" ]]; then
            oci --region "$region" compute console-history delete \
                --instance-console-history-id "$console_history_id" \
                --force 2>/dev/null
        fi
        return 1
    fi
    
    # Show final status details
    echo ""
    echo -e "${GREEN}✓ Console history capture completed${NC}"
    echo -e "  ${CYAN}Lifecycle State:${NC} ${GREEN}$capture_state${NC}"
    
    # Extract additional details from status_json
    local time_created availability_domain
    time_created=$(echo "$status_json" | jq -r '.data["time-created"] // "N/A"' 2>/dev/null)
    availability_domain=$(echo "$status_json" | jq -r '.data["availability-domain"] // "N/A"' 2>/dev/null)
    echo -e "  ${CYAN}Time Created:${NC}    ${WHITE}${time_created}${NC}"
    echo -e "  ${CYAN}AD:${NC}              ${WHITE}${availability_domain}${NC}"
    echo ""
    
    # ========== STEP 3: Fetch Console History Content ==========
    echo -e "${BOLD}${MAGENTA}─── Console Output ───────────────────────────────────────────────────────────────${NC}"
    echo ""
    
    content_cmd="oci --region \"$region\" compute console-history get-content --instance-console-history-id \"$console_history_id\" --length 10000000 --file -"
    echo -e "${GRAY}Command: ${content_cmd}${NC}"
    echo ""
    
    # Use temp file for reliability
    local temp_output temp_error
    temp_output=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    temp_error=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    
    # Capture the raw command output for display if empty
    local raw_output
    raw_output=$(oci --region "$region" compute console-history get-content \
        --instance-console-history-id "$console_history_id" \
        --length 10000000 \
        --file "$temp_output" 2>&1)
    local fetch_exit=$?
    
    echo -e "${BOLD}${MAGENTA}─── Output ───────────────────────────────────────────────────────────────────────${NC}"
    
    if [[ $fetch_exit -eq 0 ]]; then
        if [[ -s "$temp_output" ]]; then
            cat "$temp_output"
        else
            echo -e "${YELLOW}(Console history is empty - no serial console output captured)${NC}"
            echo ""
            echo -e "${WHITE}OCI CLI raw output:${NC}"
            if [[ -n "$raw_output" ]]; then
                echo -e "${GRAY}${raw_output}${NC}"
            else
                echo -e "${GRAY}(no output returned)${NC}"
            fi
            echo ""
            echo -e "${WHITE}Note: This can happen if:${NC}"
            echo -e "${GRAY}  - The instance has not produced any serial console output${NC}"
            echo -e "${GRAY}  - Serial console logging is not enabled on the instance${NC}"
            echo -e "${GRAY}  - The instance was recently created/rebooted${NC}"
        fi
    else
        echo -e "${RED}Failed to fetch console history content${NC}"
        echo -e "${GRAY}Exit code: $fetch_exit${NC}"
        echo -e "${WHITE}OCI CLI output:${NC}"
        echo -e "${GRAY}${raw_output}${NC}"
        if [[ -s "$temp_error" ]]; then
            echo -e "${WHITE}Stderr:${NC}"
            cat "$temp_error"
        fi
    fi
    
    echo ""
    echo -e "${BOLD}${MAGENTA}─── End of Console Output ────────────────────────────────────────────────────────${NC}"
    echo ""
    
    # ========== STEP 4: Save Option (Interactive Only) ==========
    if [[ "$interactive" == "true" && -s "$temp_output" ]]; then
        echo -n -e "${CYAN}Save to file? [y/N]: ${NC}"
        local save_choice
        read -r save_choice
        
        if [[ "$save_choice" =~ ^[Yy] ]]; then
            local safe_name
            safe_name=$(echo "$instance_name" | tr ' ' '_' | tr -cd '[:alnum:]_-')
            local filename="${safe_name}_console_$(date +%Y%m%d_%H%M%S).log"
            
            echo -n -e "${CYAN}Filename [${filename}]: ${NC}"
            local custom_filename
            read -r custom_filename
            [[ -n "$custom_filename" ]] && filename="$custom_filename"
            
            if cp "$temp_output" "$filename" 2>/dev/null; then
                echo -e "${GREEN}✓ Console output saved to: ${WHITE}$(pwd)/${filename}${NC}"
            else
                echo -e "${RED}Failed to save console output${NC}"
            fi
        fi
        echo ""
    fi
    
    # Cleanup temp files
    rm -f "$temp_output" "$temp_error"
    
    # ========== STEP 5: Cleanup Console History ==========
    if [[ "$auto_cleanup" == "true" ]]; then
        echo -e "${GRAY}Cleaning up console history...${NC}"
        local delete_cmd="oci --region \"$region\" compute console-history delete --instance-console-history-id \"$console_history_id\" --force"
        echo -e "${GRAY}Command: ${delete_cmd}${NC}"
        
        if oci --region "$region" compute console-history delete \
            --instance-console-history-id "$console_history_id" \
            --force 2>/dev/null; then
            echo -e "${GREEN}✓ Console history deleted${NC}"
        else
            echo -e "${YELLOW}⚠ Failed to delete console history (may need manual cleanup)${NC}"
            echo -e "${GRAY}History ID: ${console_history_id}${NC}"
        fi
    else
        echo -e "${WHITE}Console history retained:${NC} ${YELLOW}$console_history_id${NC}"
    fi
    
    echo ""
    return 0
}

# CLI wrapper for console history (--console-history flag)
# Args: $1 = instance OCID
get_console_history() {
    local instance_ocid="$1"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    echo ""
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${CYAN}                              CONSOLE HISTORY                                       ${NC}"
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${WHITE}Instance OCID:${NC} ${YELLOW}$instance_ocid${NC}"
    echo -e "${WHITE}Region:${NC}        ${WHITE}$region${NC}"
    
    # Call unified function with auto_cleanup=true, interactive=false
    fetch_and_display_console_history "$instance_ocid" "$region" "$instance_ocid" "true" "false"
}

# List instances not in Kubernetes with interactive console history option
list_instances_not_in_k8s() {
    local oci_temp="$1"
    local k8s_temp="$2"
    local interactive="${3:-true}"  # Default to interactive mode
    
    # Dynamic header based on instance filter
    local instance_filter="${INSTANCE_FILTER:-all}"
    local header_text all_running_text
    case "$instance_filter" in
        gpu)
            header_text="GPU Instances Not in Kubernetes"
            all_running_text="All running GPU instances are in Kubernetes"
            ;;
        non-gpu)
            header_text="Non-GPU Instances Not in Kubernetes"
            all_running_text="All running non-GPU instances are in Kubernetes"
            ;;
        all)
            header_text="Instances Not in Kubernetes"
            all_running_text="All running instances are in Kubernetes"
            ;;
        *)
            header_text="GPU Instances Not in Kubernetes"
            all_running_text="All running GPU instances are in Kubernetes"
            ;;
    esac
    
    echo -e "${BOLD}${MAGENTA}=== $header_text ===${NC}"
    echo ""
    
    # Collect instances not in k8s into a temp file for sorting
    local orphan_temp
    orphan_temp=$(create_temp_file) || return 1
    
    # oci_temp format: display_name|status|instance_ocid|gpu_mem_tag|shape|time_created
    local display_name status instance_ocid gpu_mem_tag shape time_created
    while IFS='|' read -r display_name status instance_ocid gpu_mem_tag shape time_created; do
        [[ -z "$instance_ocid" ]] && continue
        
        # Skip bastion and operator instances - they're not supposed to be in K8s
        local display_name_lower="${display_name,,}"  # Convert to lowercase
        if [[ "$display_name_lower" == *bastion* || "$display_name_lower" == *operator* ]]; then
            continue
        fi
        
        # Look up GPU memory cluster from API-based cache (preferred) or fall back to tag
        local gpu_mem
        gpu_mem=$(get_instance_gpu_cluster "$instance_ocid")
        [[ "$gpu_mem" == "N/A" && "$gpu_mem_tag" != "N/A" ]] && gpu_mem="$gpu_mem_tag"
        
        # Use grep without ^ anchor because providerID has oci:// prefix
        if ! grep -q "$instance_ocid" "$k8s_temp" 2>/dev/null; then
            if [[ "$status" == "RUNNING" ]]; then
                # Store with time_created for sorting
                echo "${time_created}|${display_name}|${instance_ocid}|${status}|${gpu_mem}" >> "$orphan_temp"
            fi
        fi
    done < "$oci_temp"
    
    local orphan_count
    orphan_count=$(wc -l < "$orphan_temp" 2>/dev/null) || orphan_count=0
    
    if [[ $orphan_count -eq 0 ]]; then
        echo -e "${GREEN}$all_running_text${NC}"
        rm -f "$orphan_temp"
        return 0
    fi
    
    # Sort by time_created (ascending - oldest first, newest last)
    local sorted_temp
    sorted_temp=$(create_temp_file) || { rm -f "$orphan_temp"; return 1; }
    sort -t'|' -k1,1 "$orphan_temp" > "$sorted_temp"
    
    # Read sorted data into arrays
    local -a orphan_names=()
    local -a orphan_ocids=()
    local -a orphan_states=()
    local -a orphan_gpu_mems=()
    local -a orphan_times=()
    
    while IFS='|' read -r time_created display_name instance_ocid status gpu_mem; do
        orphan_times+=("$time_created")
        orphan_names+=("$display_name")
        orphan_ocids+=("$instance_ocid")
        orphan_states+=("$status")
        orphan_gpu_mems+=("$gpu_mem")
    done < "$sorted_temp"
    
    rm -f "$orphan_temp" "$sorted_temp"
    
    # Display numbered list of instances not in kubernetes
    printf "${BOLD}%-4s %-35s %-10s %-15s %-22s %s${NC}\n" \
        "#" "Display Name" "OCI State" "GPU Mem Cluster" "Created" "Instance OCID"
    print_separator 180
    
    local i
    for ((i=0; i<orphan_count; i++)); do
        local gpu_mem_display="${orphan_gpu_mems[$i]}"
        [[ "$gpu_mem_display" != "N/A" && ${#gpu_mem_display} -gt 12 ]] && gpu_mem_display="...${gpu_mem_display: -9}"
        
        # Format time_created - show date and time portion
        local time_display="${orphan_times[$i]}"
        if [[ "$time_display" != "N/A" && -n "$time_display" ]]; then
            # Format: 2026-01-27T03:29:11.123Z -> 2026-01-27 03:29:11
            time_display="${time_display:0:19}"
            time_display="${time_display/T/ }"
        fi
        
        printf "${YELLOW}%-4s${NC} ${CYAN}%-35s${NC} ${GREEN}%-10s${NC} ${MAGENTA}%-15s${NC} ${GRAY}%-22s${NC} ${WHITE}%s${NC}\n" \
            "$((i+1))" \
            "$(truncate_string "${orphan_names[$i]}" 35)" \
            "${orphan_states[$i]}" \
            "$gpu_mem_display" \
            "$time_display" \
            "${orphan_ocids[$i]}"
    done
    
    echo ""
    echo -e "${YELLOW}Total instances not in kubernetes: ${orphan_count}${NC}"
    
    # Interactive mode - prompt for console history
    if [[ "$interactive" == "true" && -t 0 ]]; then
        echo ""
        echo -e "${BOLD}${CYAN}Would you like to view console history for any of these instances?${NC}"
        echo -e "Enter instance number (1-${orphan_count}), or press Enter to skip: "
        
        local selection
        read -r selection
        
        if [[ -n "$selection" ]]; then
            # Validate input is a number
            if [[ "$selection" =~ ^[0-9]+$ ]]; then
                if [[ $selection -ge 1 && $selection -le $orphan_count ]]; then
                    local selected_idx=$((selection - 1))
                    echo ""
                    echo -e "${GREEN}Selected: ${orphan_names[$selected_idx]}${NC}"
                    get_console_history "${orphan_ocids[$selected_idx]}"
                else
                    log_error "Invalid selection. Please enter a number between 1 and ${orphan_count}"
                fi
            else
                log_error "Invalid input. Please enter a number."
            fi
        else
            echo -e "${CYAN}Skipping console history view.${NC}"
        fi
    fi
}

# Non-interactive version for scripting - just list instances not in kubernetes
list_instances_not_in_k8s_non_interactive() {
    local oci_temp="$1"
    local k8s_temp="$2"
    list_instances_not_in_k8s "$oci_temp" "$k8s_temp" "false"
}

#===============================================================================
# MAIN LIST FUNCTIONS
#===============================================================================

# List all GPU instances in compartment
list_all_instances() {
    local compartment_id="$1"
    local region="$2"
    
    # Validate required parameters
    if [[ -z "$compartment_id" ]]; then
        log_error "COMPARTMENT_ID not set. Use --compartment-id or set in variables.sh"
        return 1
    fi
    if [[ -z "$region" ]]; then
        log_error "REGION not set. Use --region or set in variables.sh"
        return 1
    fi
    
    # Get instance filter (default to "gpu" for backward compatibility)
    local instance_filter="${INSTANCE_FILTER:-all}"
    
    # Display OKE environment header
    display_oke_environment_header "$compartment_id" "$region"
    
    # Fetch all cached data
    fetch_gpu_fabrics
    fetch_gpu_clusters
    fetch_instance_configurations
    
    # Set header based on filter
    local header_text
    case "$instance_filter" in
        gpu)
            header_text="All GPU Instances in Compartment"
            ;;
        non-gpu)
            header_text="All Non-GPU Instances in Compartment"
            ;;
        all)
            header_text="All Instances in Compartment"
            ;;
        *)
            header_text="All Instances in Compartment"
            instance_filter="all"
            ;;
    esac
    
    echo -e "${BOLD}${MAGENTA}=== $header_text ===${NC}"
    echo -e "${GRAY}(Filter: $instance_filter - change INSTANCE_FILTER in variables.sh)${NC}"
    echo ""
    
    # Create temp files
    local oci_temp k8s_temp output_temp
    oci_temp=$(create_temp_file) || return 1
    k8s_temp=$(create_temp_file) || { rm -f "$oci_temp"; return 1; }
    output_temp=$(create_temp_file) || { rm -f "$oci_temp" "$k8s_temp"; return 1; }
    
    # Build jq filter based on INSTANCE_FILTER
    local jq_filter
    case "$instance_filter" in
        gpu)
            jq_filter='select(.shape | test("GPU"; "i"))'
            ;;
        non-gpu)
            jq_filter='select(.shape | test("GPU"; "i") | not)'
            ;;
        all)
            jq_filter='.'
            ;;
    esac
    
    # Fetch OCI instances with appropriate filter
    log_info "Fetching instances from OCI (filter: $instance_filter)..."
    oci compute instance list \
        --compartment-id "$compartment_id" \
        --region "$region" \
        --all \
        --output json 2>/dev/null | jq -r "
            .data[] | 
            $jq_filter | 
            select(.[\"lifecycle-state\"] != \"TERMINATED\") |
            \"\(.[\"display-name\"])|\(.[\"lifecycle-state\"])|\(.id)|\(.[\"freeform-tags\"][\"oci:compute:gpumemorycluster\"] // \"N/A\")|\(.shape)|\(.[\"time-created\"] // \"N/A\")\"
        " > "$oci_temp"
    
    # Fetch K8s nodes - fetch ALL nodes to avoid missing nodes without GPU labels
    # The label nvidia.com/gpu.present may not be set immediately on new nodes
    log_info "Fetching nodes from Kubernetes..."
    kubectl get nodes -o json 2>/dev/null | jq -r '
        .items[] | 
        "\(.spec.providerID)|\(.metadata.name)|\(.metadata.labels["nvidia.com/gpu.clique"] // "N/A")|\(.metadata.labels["nvidia.com/gpu.present"] // "false")"
    ' > "$k8s_temp"
    
    # Fetch additional data
    log_info "Fetching node states..."
    fetch_node_states
    
    log_info "Fetching announcements..."
    build_announcement_lookup "$compartment_id"
    
    log_info "Fetching capacity topology..."
    fetch_capacity_topology
    
    log_info "Fetching compute clusters..."
    fetch_compute_clusters
    
    echo "Processing data..."
    echo ""
    
    # Print table header with spanning headers
    # Column positions: DisplayName(28) Node(15) State(7) CliqueID(43) State(11) OCID(95) Name(12) State(10) State(10) Announce(18)
    printf "${BOLD}%-28s%-73s%-107s%-23s%-11s%-11s${NC}\n" \
    "" \
    "┌──────────────────────────── K8s ─────────────────────────────────┐" \
    "┌──────────────────────────────────── OCI Instance ─────────────────────────────────────────────────────┐" \
    "┌─── GPU Mem Cluster ───┐" \
    "  CapTopo" \
    "  Maintenance"
    printf "${BOLD}%-28s %-15s %-7s %-43s %-11s %-95s %-12s %-10s %-10s %-18s${NC}\n" \
        "Display Name" "Node" "State" "Clique ID" "State" "Instance OCID" "Name" "State" "State" "Announce"
    print_separator 280
    
    # Process and collect data for sorting
    local display_name status instance_ocid gpu_mem_tag shape time_created
    while IFS='|' read -r display_name status instance_ocid gpu_mem_tag shape time_created; do
        [[ -z "$instance_ocid" ]] && continue
        
        # Look up GPU memory cluster from API-based cache (preferred) or fall back to tag
        local gpu_mem
        gpu_mem=$(get_instance_gpu_cluster "$instance_ocid")
        [[ "$gpu_mem" == "N/A" && "$gpu_mem_tag" != "N/A" ]] && gpu_mem="$gpu_mem_tag"
        
        local k8s_info node_name clique_id node_state
        # k8s_temp format: providerID|nodeName|clique|gpuPresent
        k8s_info=$(grep "$instance_ocid" "$k8s_temp" 2>/dev/null)
        
        if [[ -n "$k8s_info" ]]; then
            # Instance is in Kubernetes
            IFS='|' read -r _ node_name clique_id _ <<< "$k8s_info"
            node_state=$(get_node_state_cached "$instance_ocid")
        else
            # Instance is NOT in Kubernetes
            node_name="-"
            clique_id="-"
            node_state="-"
        fi
        
        # Get various states
        local cluster_state cap_topo_state announcements
        cluster_state="N/A"
        [[ "$gpu_mem" != "N/A" ]] && cluster_state=$(get_cluster_state "$gpu_mem")
        cap_topo_state=$(get_capacity_topology_state "$instance_ocid")
        announcements=$(get_resource_announcements "$instance_ocid" "$gpu_mem")
        
        # Truncate for display - ensure consistent widths
        local gpu_mem_display="$gpu_mem"
        [[ "$gpu_mem" != "N/A" && ${#gpu_mem} -gt 12 ]] && gpu_mem_display="...${gpu_mem: -9}"
        [[ "$gpu_mem" == "N/A" ]] && gpu_mem_display="-"
        
        local cluster_state_display
        cluster_state_display=$(truncate_string "$cluster_state" 10)
        [[ "$cluster_state" == "N/A" ]] && cluster_state_display="-"
        
        # Truncate display name to 28 characters
        local display_name_truncated
        display_name_truncated=$(truncate_string "$display_name" 28)
        
        # Store for sorting (by GPU mem cluster, then display name)
        echo "${gpu_mem}|${display_name_truncated}|${node_name}|${node_state}|${status}|${instance_ocid}|${gpu_mem_display}|${cluster_state_display}|${clique_id}|${cap_topo_state}|${announcements}" >> "$output_temp"
    done < "$oci_temp"
    
    # Sort and display
    sort -t'|' -k1,1 -k2,2 "$output_temp" | while IFS='|' read -r _ dn nn ns st io gm cs ci ct ann; do
        local ns_color st_color ct_color ann_color cs_color
        ns_color=$(color_node_state "$ns")
        st_color=$(color_oci_state "$st")
        ct_color=$(color_cap_topo_state "$ct")
        ann_color=$(color_announcement "$ann")
        cs_color=$(color_cluster_state "$cs")
        
        printf "%-28s %-15s ${ns_color}%-7s${NC} %-43s ${st_color}%-11s${NC} %-95s %-12s ${cs_color}%-10s${NC} ${ct_color}%-10s${NC} ${ann_color}%-18s${NC}\n" \
            "$dn" "$nn" "$ns" "$ci" "$st" "$io" "$gm" "$cs" "$ct" "$ann"
    done
    
    echo ""
    
    # Show GPU-specific summary and additional info (skip for non-gpu filter or if no GPU memory infrastructure)
    if [[ "$instance_filter" != "non-gpu" ]]; then
        # Check if any GPU memory fabrics or clusters exist in cache
        local has_gpu_memory_infra=false
        if [[ -f "$FABRIC_CACHE" ]] && grep -qv '^#' "$FABRIC_CACHE" 2>/dev/null; then
            has_gpu_memory_infra=true
        fi
        if [[ -f "$CLUSTER_CACHE" ]] && grep -qv '^#' "$CLUSTER_CACHE" 2>/dev/null; then
            has_gpu_memory_infra=true
        fi
        
        # Also check if any instances actually have GPU memory cluster tags (field 4 != N/A)
        local has_gpu_mem_instances=false
        if awk -F'|' '$4 != "N/A" && $4 != "" {found=1; exit} END {exit !found}' "$oci_temp" 2>/dev/null; then
            has_gpu_mem_instances=true
        fi
        
        # Also check if any K8s nodes have clique labels (field 3 != N/A)
        # k8s_temp format: providerID|nodeName|clique|gpuPresent
        local has_k8s_cliques=false
        if awk -F'|' '$3 != "N/A" && $3 != "" {found=1; exit} END {exit !found}' "$k8s_temp" 2>/dev/null; then
            has_k8s_cliques=true
        fi
        
        # Also check if the instance-cluster map has entries (from GPU Memory Cluster API)
        local has_instance_cluster_map=false
        if [[ -f "$INSTANCE_CLUSTER_MAP_CACHE" ]] && grep -qv '^#' "$INSTANCE_CLUSTER_MAP_CACHE" 2>/dev/null; then
            has_instance_cluster_map=true
        fi
        
        if [[ "$has_gpu_memory_infra" == "true" || "$has_gpu_mem_instances" == "true" || "$has_k8s_cliques" == "true" || "$has_instance_cluster_map" == "true" ]]; then
            display_clique_summary "$oci_temp" "$k8s_temp"
        fi
    fi
    
    echo ""
    list_instances_not_in_k8s "$oci_temp" "$k8s_temp"
    
    # Cleanup
    rm -f "$oci_temp" "$k8s_temp" "$output_temp"
}

#--------------------------------------------------------------------------------
# List instances requiring maintenance attention
# Shows instances with DEGRADED capacity topology state or active announcements
#--------------------------------------------------------------------------------
list_maintenance_instances() {
    # Redirects to the merged maintenance view
    list_maintenance_events "${1:-$EFFECTIVE_COMPARTMENT_ID}" "${2:-$EFFECTIVE_REGION}"
}

#--------------------------------------------------------------------------------
# Fetch and cache instance maintenance events (1-hour TTL)
# Args: $1 = compartment_id, $2 = region, $3 = force_refresh (optional)
# Returns: path to cache file
#--------------------------------------------------------------------------------
fetch_maintenance_events() {
    local compartment_id="${1:-$EFFECTIVE_COMPARTMENT_ID}"
    local region="${2:-$EFFECTIVE_REGION}"
    local force_refresh="${3:-false}"
    
    # Check cache validity
    if [[ "$force_refresh" != "true" && -f "$MAINT_EVENTS_CACHE" && -s "$MAINT_EVENTS_CACHE" ]]; then
        local cache_age=999999
        if [[ "$(uname)" == "Darwin" ]]; then
            cache_age=$(( $(date +%s) - $(stat -f %m "$MAINT_EVENTS_CACHE" 2>/dev/null || echo 0) ))
        else
            cache_age=$(( $(date +%s) - $(stat -c %Y "$MAINT_EVENTS_CACHE" 2>/dev/null || echo 0) ))
        fi
        if [[ $cache_age -lt $MAINT_EVENTS_CACHE_TTL ]]; then
            echo "$MAINT_EVENTS_CACHE"
            return 0
        fi
    fi
    
    echo -e "${GRAY}Fetching instance maintenance events from OCI...${NC}" >&2
    
    if ! oci compute instance-maintenance-event list \
            --compartment-id "$compartment_id" \
            --region "$region" \
            --all \
            --output json > "$MAINT_EVENTS_CACHE" 2>/dev/null; then
        echo -e "${RED}Failed to fetch maintenance events${NC}" >&2
        rm -f "$MAINT_EVENTS_CACHE" "$FAULT_DETAILS_CACHE"
        return 1
    fi
    
    # Validate JSON
    if ! jq -e '.data' "$MAINT_EVENTS_CACHE" &>/dev/null; then
        echo -e "${RED}Invalid JSON response for maintenance events${NC}" >&2
        rm -f "$MAINT_EVENTS_CACHE" "$FAULT_DETAILS_CACHE"
        return 1
    fi
    
    local event_count
    event_count=$(jq '.data | length' "$MAINT_EVENTS_CACHE" 2>/dev/null)
    echo -e "${GREEN}✓ Cached ${event_count} maintenance event(s)${NC}" >&2
    
    echo "$MAINT_EVENTS_CACHE"
    return 0
}

#--------------------------------------------------------------------------------
# Reschedule a maintenance event
# Args: $1 = event_id, $2 = event_display_name, $3 = current_window_start
#       $4 = compartment_id, $5 = region
#--------------------------------------------------------------------------------
reschedule_maintenance_event() {
    local event_id="$1"
    local event_display_name="$2"
    local current_window_start="$3"
    local compartment_id="${4:-$EFFECTIVE_COMPARTMENT_ID}"
    local region="${5:-$EFFECTIVE_REGION}"
    local log_file="${LOGS_DIR}/maintenance_events_actions.log"
    
    echo ""
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${CYAN}                                      RESCHEDULE MAINTENANCE EVENT                                               ${NC}"
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "  ${WHITE}Event:${NC}             ${YELLOW}$event_display_name${NC}"
    echo -e "  ${WHITE}Event OCID:${NC}        ${GRAY}$event_id${NC}"
    echo -e "  ${WHITE}Current Schedule:${NC}   ${WHITE}$current_window_start${NC}"
    echo ""
    
    # Calculate preset times using date -u -d for accurate UTC calculation
    local t5m_utc t10m_utc t1h_utc t24h_utc
    t5m_utc=$(date -u -d '+5 minutes' +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
    t10m_utc=$(date -u -d '+10 minutes' +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
    t1h_utc=$(date -u -d '+1 hour' +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
    t24h_utc=$(date -u -d '+24 hours' +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
    
    # Fallback for macOS/BSD date
    if [[ -z "$t5m_utc" ]]; then
        t5m_utc=$(date -u -v+5M +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
        t10m_utc=$(date -u -v+10M +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
        t1h_utc=$(date -u -v+1H +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
        t24h_utc=$(date -u -v+24H +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
    fi
    
    echo -e "${BOLD}${WHITE}─── Reschedule Options ───${NC}"
    echo ""
    echo -e "  ${YELLOW}1${NC}) 5 minutes from now   →  ${WHITE}${t5m_utc}${NC}"
    echo -e "  ${YELLOW}2${NC}) 10 minutes from now  →  ${WHITE}${t10m_utc}${NC}"
    echo -e "  ${YELLOW}3${NC}) 1 hour from now      →  ${WHITE}${t1h_utc}${NC}"
    echo -e "  ${YELLOW}4${NC}) 24 hours from now    →  ${WHITE}${t24h_utc}${NC}"
    echo -e "  ${YELLOW}5${NC}) Custom date/time (UTC)"
    echo -e "  ${YELLOW}b${NC}) Cancel / Back"
    echo ""
    echo -n -e "${CYAN}Select [1-5/b]: ${NC}"
    read -r resched_choice
    
    local new_time_window=""
    
    case "$resched_choice" in
        1) new_time_window="$t5m_utc" ;;
        2) new_time_window="$t10m_utc" ;;
        3) new_time_window="$t1h_utc" ;;
        4) new_time_window="$t24h_utc" ;;
        5)
            echo ""
            echo -e "${GRAY}Enter UTC datetime in format: YYYY-MM-DDTHH:MM:SS.000Z${NC}"
            echo -e "${GRAY}Example: 2026-02-04T15:30:00.000Z${NC}"
            echo ""
            echo -n -e "${CYAN}New time-window-start: ${NC}"
            read -r custom_time
            if [[ -z "$custom_time" ]]; then
                echo -e "${YELLOW}No time provided - cancelled${NC}"
                return
            fi
            # Basic format validation
            if [[ ! "$custom_time" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2} ]]; then
                echo -e "${RED}Invalid datetime format. Expected: YYYY-MM-DDTHH:MM:SS.000Z${NC}"
                return
            fi
            # Ensure it ends with Z if no timezone
            [[ ! "$custom_time" =~ [Zz]$ && ! "$custom_time" =~ [+-][0-9] ]] && custom_time="${custom_time}Z"
            new_time_window="$custom_time"
            ;;
        b|B|"")
            echo -e "${YELLOW}Cancelled${NC}"
            return
            ;;
        *)
            echo -e "${RED}Invalid selection${NC}"
            return
            ;;
    esac
    
    echo ""
    echo -e "${BOLD}${WHITE}─── Confirm Reschedule ───${NC}"
    echo ""
    echo -e "  ${WHITE}Event:${NC}     ${YELLOW}$event_display_name${NC}"
    echo -e "  ${WHITE}Current:${NC}   ${WHITE}$current_window_start${NC}"
    echo -e "  ${WHITE}New:${NC}       ${GREEN}$new_time_window${NC}"
    echo ""
    
    local resched_cmd="oci compute instance-maintenance-event update --instance-maintenance-event-id $event_id --time-window-start $new_time_window"
    
    echo -e "${BOLD}${WHITE}Command to execute:${NC}"
    echo -e "${GRAY}$resched_cmd${NC}"
    echo ""
    echo -n -e "${CYAN}Confirm reschedule? (yes/no): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "yes" ]]; then
        echo -e "${YELLOW}Reschedule cancelled${NC}"
        return
    fi
    
    echo ""
    echo -e "${YELLOW}Executing reschedule...${NC}"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: $resched_cmd" >> "$log_file"
    echo -e "${WHITE}$ ${resched_cmd}${NC}"
    echo ""
    
    local resched_output
    resched_output=$(oci compute instance-maintenance-event update \
        --instance-maintenance-event-id "$event_id" \
        --time-window-start "$new_time_window" \
        --output json 2>&1)
    local resched_rc=$?
    
    if [[ $resched_rc -eq 0 ]]; then
        echo -e "${GREEN}✓ Maintenance event rescheduled successfully${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Rescheduled $event_display_name ($event_id) to $new_time_window" >> "$log_file"
        
        # Show updated event details
        local new_window_start
        new_window_start=$(echo "$resched_output" | jq -r '.data["time-window-start"] // "N/A"' 2>/dev/null)
        echo -e "  ${WHITE}New window start:${NC} ${GREEN}$new_window_start${NC}"
        
        # Invalidate cache since data changed
        rm -f "$MAINT_EVENTS_CACHE" "$FAULT_DETAILS_CACHE"
        echo -e "${GRAY}Cache invalidated - will refresh on next view${NC}"
    else
        echo -e "${RED}✗ Failed to reschedule maintenance event${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Reschedule $event_display_name ($event_id) to $new_time_window" >> "$log_file"
        echo -e "${GRAY}Error output:${NC}"
        echo "$resched_output" | head -20
    fi
    
    echo ""
    echo -e "${GRAY}Log: $log_file${NC}"
    echo -n -e "${CYAN}Press Enter to continue...${NC}"
    read -r
}

#--------------------------------------------------------------------------------
# List and manage instance maintenance events
# Fetches from OCI with 1-hour cache, shows instance/K8s details, allows reschedule
#--------------------------------------------------------------------------------
list_maintenance_events() {
    local compartment_id="${1:-$EFFECTIVE_COMPARTMENT_ID}"
    local region="${2:-$EFFECTIVE_REGION}"
    local force_refresh="${3:-false}"
    local filter_type="${4:-named}"
    local me_view_mode="${5:-compact}"
    
    echo ""
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${CYAN}                                                         INSTANCE MAINTENANCE EVENTS                                                                                    ${NC}"
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    _display_cache_info \
        "${MAINT_EVENTS_CACHE}|Maint Events" \
        "${FAULT_DETAILS_CACHE}|Fault Details" \
        "${ANNOUNCEMENTS_LIST_CACHE}|Announcements"
    echo ""
    echo -e "${GRAY}Region: ${WHITE}$region${NC}  ${GRAY}Compartment: ${WHITE}$(resolve_compartment_name "$compartment_id")${NC} ${GRAY}($compartment_id)${NC}"
    echo -e "${GRAY}Source: oci compute instance-maintenance-event list${NC}  ${GRAY}View: ${WHITE}${me_view_mode}${NC} ${GRAY}(type 'view' to toggle)${NC}"
    case "$filter_type" in
        named)       echo -e "${YELLOW}Filter: Named instances only + hiding CapTopo=AVAILABLE + hiding SUCCEEDED >2 days old${NC}" ;;
        PROCESSING)  echo -e "${YELLOW}Filter: Showing only PROCESSING events${NC}" ;;
        SUCCEEDED)   echo -e "${YELLOW}Filter: Showing only SUCCEEDED events${NC}" ;;
        CANCELED)    echo -e "${YELLOW}Filter: Showing only CANCELED events${NC}" ;;
        SCHEDULED)   echo -e "${YELLOW}Filter: Showing only SCHEDULED events${NC}" ;;
        none)        ;;
    esac
    echo ""
    
    #==========================================================================
    # Fetch maintenance events (cached)
    #==========================================================================
    local cache_file
    cache_file=$(fetch_maintenance_events "$compartment_id" "$region" "$force_refresh")
    
    if [[ $? -ne 0 || -z "$cache_file" || ! -f "$cache_file" ]]; then
        echo -e "${RED}Failed to fetch maintenance events${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local event_count
    event_count=$(jq '.data | length' "$cache_file" 2>/dev/null)
    
    if [[ "$event_count" -eq 0 || -z "$event_count" ]]; then
        echo -e "${GREEN}✓ No instance maintenance events found${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    #==========================================================================
    # Fetch K8s nodes and OCI instances for cross-reference
    #==========================================================================
    echo -e "${GRAY}Fetching instance and K8s data for cross-reference...${NC}"
    
    # K8s lookup: providerID → node_name|ready_status|unschedulable|taint_count|taint_names|serial_number
    local me_k8s_lookup=""
    me_k8s_lookup=$(kubectl get nodes -o json 2>/dev/null | jq -r '
        .items[] |
        "\(.spec.providerID // "")|\(.metadata.name)|\(.status.conditions[] | select(.type=="Ready") | .status)|\(.spec.unschedulable // false)|\(.spec.taints // [] | length)|\(.spec.taints // [] | [.[].key] | join(","))|\(.metadata.labels["oci.oraclecloud.com/host.serial_number"] // "N/A")"
    ' 2>/dev/null)
    
    # Pod counts per node
    log_info "Fetching pod counts per node..."
    local me_pods_per_node
    me_pods_per_node=$(kubectl get pods --all-namespaces --field-selector=status.phase=Running -o json 2>/dev/null | \
        jq -r '.items[] | .spec.nodeName' 2>/dev/null | sort | uniq -c | awk '{print $2"|"$1}')
    
    # Instance lookup: instance_ocid → display_name|shape|state|ad|gpu_mem_cluster
    local me_inst_temp
    me_inst_temp=$(create_temp_file) || return 1
    oci compute instance list \
        --compartment-id "$compartment_id" \
        --region "$region" \
        --all \
        --output json 2>/dev/null | jq -r '
        .data[] |
        select(.["lifecycle-state"] != "TERMINATED") |
        "\(.id)|\(.["display-name"] // "N/A")|\(.shape // "N/A")|\(.["lifecycle-state"] // "N/A")|\(.["availability-domain"] // "N/A")|\(.["freeform-tags"]["oci:compute:gpumemorycluster"] // "N/A")"
    ' > "$me_inst_temp" 2>/dev/null
    
    # Build announcement lookup
    log_info "Fetching announcements..."
    build_announcement_lookup "$compartment_id"
    
    # Additional fetches for instances-requiring-maintenance section
    log_info "Fetching capacity topology data..."
    fetch_capacity_topology
    log_info "Fetching GPU memory clusters..."
    fetch_gpu_clusters
    log_info "Fetching GPU fabrics..."
    fetch_gpu_fabrics
    
    #==========================================================================
    # SECTION 1: Instances Requiring Maintenance Attention
    #==========================================================================
    echo ""
    echo -e "${BOLD}${RED}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${RED}                                              INSTANCES REQUIRING MAINTENANCE ATTENTION                                                                                ${NC}"
    echo -e "${BOLD}${RED}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${GRAY}Showing instances with: DEGRADED capacity topology state OR active maintenance announcements${NC}"
    echo ""
    
    printf "${BOLD}%-4s %-26s %-10s %-20s %-8s %-6s %-5s %-10s %-14s %-16s %-20s %s${NC}\n" \
        "ID" "Display Name" "OCI State" "K8s Node" "Ready" "Cordon" "Pods" "CapTopo" "Serial Number" "Announcement" "Shape" "Instance OCID"
    print_separator 240
    
    local maint_inst_count=0
    local maint_output_temp
    maint_output_temp=$(create_temp_file) || true
    
    # Iterate instances to find those requiring attention
    while IFS='|' read -r mi_ocid mi_name mi_shape mi_state mi_ad mi_gpu_mem; do
        [[ -z "$mi_ocid" ]] && continue
        
        # Apply named filter to instances section too
        if [[ "$filter_type" == "named" && ("$mi_name" == "N/A" || -z "$mi_name") ]]; then
            continue
        fi
        
        local mi_cap_topo
        mi_cap_topo=$(get_capacity_topology_state "$mi_ocid")
        [[ -z "$mi_cap_topo" ]] && mi_cap_topo="N/A"
        
        local mi_ann
        mi_ann=$(get_resource_announcements "$mi_ocid" "$mi_gpu_mem")
        [[ -z "$mi_ann" ]] && mi_ann="-"
        
        local mi_needs="false"
        [[ "$mi_cap_topo" == "DEGRADED" ]] && mi_needs="true"
        [[ "$mi_ann" != "-" && -n "$mi_ann" ]] && mi_needs="true"
        [[ "$mi_needs" != "true" ]] && continue
        
        # K8s info from shared lookup
        local mi_k8s_node="N/A" mi_k8s_ready="N/A" mi_k8s_cordon="-" mi_k8s_pods="-" mi_k8s_serial="N/A"
        local mi_k8s_info
        mi_k8s_info=$(echo "$me_k8s_lookup" | grep "$mi_ocid" 2>/dev/null)
        if [[ -n "$mi_k8s_info" ]]; then
            mi_k8s_node=$(echo "$mi_k8s_info" | cut -d'|' -f2)
            mi_k8s_ready=$(echo "$mi_k8s_info" | cut -d'|' -f3)
            local mi_unsched
            mi_unsched=$(echo "$mi_k8s_info" | cut -d'|' -f4)
            mi_k8s_serial=$(echo "$mi_k8s_info" | cut -d'|' -f7)
            [[ "$mi_unsched" == "true" ]] && mi_k8s_cordon="Yes"
            local mi_node_pods
            mi_node_pods=$(echo "$me_pods_per_node" | grep "^${mi_k8s_node}|" | cut -d'|' -f2)
            mi_k8s_pods="${mi_node_pods:-0}"
        fi
        
        local mi_sort_ann="$mi_ann"
        [[ "$mi_ann" == "-" || -z "$mi_ann" ]] && mi_sort_ann="zzz"
        
        # When named filter: skip instances where ALL their events are SUCCEEDED with window start > 2 days old
        if [[ "$filter_type" == "named" ]]; then
            local mi_has_active_event=false
            local mi_evt_line
            while IFS='|' read -r _eid mi_evt_iid _er _ec mi_evt_lc mi_evt_ws _rest; do
                [[ "$mi_evt_iid" != "$mi_ocid" ]] && continue
                if [[ "${mi_evt_lc^^}" != "SUCCEEDED" ]]; then
                    mi_has_active_event=true
                    break
                fi
                # SUCCEEDED - check if window start is within 2 days
                if [[ "$mi_evt_ws" != "null" && -n "$mi_evt_ws" ]]; then
                    local mi_chk_epoch
                    mi_chk_epoch=$(date -u -d "${mi_evt_ws:0:19}" +%s 2>/dev/null) || mi_chk_epoch=""
                    if [[ -n "$mi_chk_epoch" ]]; then
                        local mi_2d_ago=$(( $(date -u +%s) - 172800 ))
                        if [[ $mi_chk_epoch -ge $mi_2d_ago ]]; then
                            mi_has_active_event=true
                            break
                        fi
                    fi
                fi
            done < <(jq -r '.data[] | "\(.id)|\(.["instance-id"] // "")|\(.["maintenance-reason"] // "N/A")|\(.["maintenance-category"] // "N/A")|\(.["lifecycle-state"] // "N/A")|\(.["time-window-start"] // "null")|\(.["time-hard-due-date"] // "null")"' "$cache_file" 2>/dev/null)
            
            # Also keep if DEGRADED cap topo (regardless of event state)
            [[ "$mi_cap_topo" == "DEGRADED" ]] && mi_has_active_event=true
            
            if [[ "$mi_has_active_event" != "true" ]]; then
                continue
            fi
        fi
        
        echo "${mi_sort_ann}|${mi_cap_topo}|${mi_ann}|${mi_name}|${mi_state}|${mi_k8s_node}|${mi_k8s_ready}|${mi_k8s_cordon}|${mi_k8s_pods}|${mi_k8s_serial}|${mi_shape}|${mi_ocid}" >> "$maint_output_temp"
    done < "$me_inst_temp"
    
    # Build instance map and display sorted table
    declare -A MAINT_INSTANCE_MAP=()
    rm -f "${TEMP_DIR}/maint_map_$$"
    local maint_inst_idx=0
    
    sort -t'|' -k1,1 -k2,2r "$maint_output_temp" 2>/dev/null | while IFS='|' read -r sort_key mi_cap mi_ann mi_dn mi_oci_st mi_k8s_nd mi_k8s_rdy mi_k8s_crd mi_k8s_pds mi_k8s_ser mi_shp mi_ocid; do
        [[ -z "$mi_ocid" ]] && continue
        ((maint_inst_idx++))
        ((maint_inst_count++))
        
        echo "m${maint_inst_idx}|${mi_ocid}|${mi_k8s_nd}|${mi_dn}|${mi_k8s_crd}" >> "${TEMP_DIR}/maint_map_$$"
        
        local mi_oci_color="$GREEN"
        case "$mi_oci_st" in RUNNING) mi_oci_color="$GREEN" ;; STOPPED) mi_oci_color="$RED" ;; *) mi_oci_color="$YELLOW" ;; esac
        local mi_rdy_color="$GREEN"
        [[ "$mi_k8s_rdy" != "True" ]] && mi_rdy_color="$RED"
        [[ "$mi_k8s_rdy" == "N/A" ]] && mi_rdy_color="$GRAY"
        local mi_crd_color="$GRAY"
        [[ "$mi_k8s_crd" == "Yes" ]] && mi_crd_color="$YELLOW"
        local mi_pds_color="$CYAN"
        [[ "$mi_k8s_pds" == "-" || "$mi_k8s_pds" == "0" ]] && mi_pds_color="$GRAY"
        local mi_cap_color="$GREEN"
        [[ "$mi_cap" == "DEGRADED" ]] && mi_cap_color="$RED"
        [[ "$mi_cap" == "N/A" ]] && mi_cap_color="$GRAY"
        local mi_ann_color="$GRAY"
        [[ "$mi_ann" != "-" && -n "$mi_ann" ]] && mi_ann_color="$YELLOW"
        local mi_ser_color="$GRAY"
        [[ "$mi_k8s_ser" != "N/A" && -n "$mi_k8s_ser" ]] && mi_ser_color="$CYAN"
        
        printf "${YELLOW}%-4s${NC} %-26s ${mi_oci_color}%-10s${NC} %-20s ${mi_rdy_color}%-8s${NC} ${mi_crd_color}%-6s${NC} ${mi_pds_color}%-5s${NC} ${mi_cap_color}%-10s${NC} ${mi_ser_color}%-14s${NC} ${mi_ann_color}%-16s${NC} %-20s ${GRAY}%s${NC}\n" \
            "m${maint_inst_idx}" "${mi_dn:0:26}" "$mi_oci_st" "${mi_k8s_nd:0:20}" "$mi_k8s_rdy" "$mi_k8s_crd" "$mi_k8s_pds" "$mi_cap" "${mi_k8s_ser:0:14}" "${mi_ann:0:16}" "${mi_shp:0:20}" "$mi_ocid"
    done
    
    # Read instance map from temp file (subshell workaround)
    if [[ -f "${TEMP_DIR}/maint_map_$$" ]]; then
        while IFS='|' read -r midx mocid mk8s_node mdn mcordon; do
            MAINT_INSTANCE_MAP[$midx]="${mocid}|${mk8s_node}|${mdn}|${mcordon}"
        done < "${TEMP_DIR}/maint_map_$$"
        maint_inst_count=$(wc -l < "${TEMP_DIR}/maint_map_$$")
        rm -f "${TEMP_DIR}/maint_map_$$"
    fi
    
    echo ""
    if [[ $maint_inst_count -eq 0 ]]; then
        echo -e "${GREEN}✓ No instances require maintenance attention${NC}"
    else
        echo -e "${YELLOW}Found ${WHITE}${maint_inst_count}${YELLOW} instance(s) requiring attention${NC}"
    fi
    
    # Announcement details section
    echo ""
    echo -e "${BOLD}${CYAN}─── Announcement Details ─────────────────────────────────────────────────────────────────────────────────────────${NC}"
    echo ""
    printf "${BOLD}%-4s %-10s %-15s %-20s %-20s %-115s${NC}\n" \
        "ID" "Ticket" "Type" "Start" "End" "Description"
    print_separator 190
    
    local me_ann_idx=0
    declare -A ANN_TICKET_MAP=()
    local me_shown_announcements=""
    local me_sorted_tickets
    me_sorted_tickets=$(awk -F'|' '{print $3}' "$maint_output_temp" 2>/dev/null | tr ',' '\n' | grep -v '^-$' | grep -v '^$' | sort -u)
    
    local me_ticket
    while read -r me_ticket; do
        [[ -z "$me_ticket" ]] && continue
        [[ "$me_shown_announcements" == *"|${me_ticket}|"* ]] && continue
        me_shown_announcements="${me_shown_announcements}|${me_ticket}|"
        ((me_ann_idx++))
        
        local me_ann_detail_file=""
        local me_cache_scan
        for me_cache_scan in "$CACHE_DIR"/*.json; do
            [[ ! -f "$me_cache_scan" ]] && continue
            [[ "$me_cache_scan" == "$ANNOUNCEMENTS_LIST_CACHE" ]] && continue
            local me_ref_ticket
            me_ref_ticket=$(jq -r '.data."reference-ticket-number" // ""' "$me_cache_scan" 2>/dev/null)
            if [[ "${me_ref_ticket:0:8}" == "$me_ticket" ]]; then
                me_ann_detail_file="$me_cache_scan"
                break
            fi
        done
        
        if [[ -n "$me_ann_detail_file" && -f "$me_ann_detail_file" ]]; then
            local me_ann_type me_ann_start me_ann_end me_ann_desc
            me_ann_type=$(jq -r '.data["announcement-type"] // "N/A"' "$me_ann_detail_file" 2>/dev/null)
            me_ann_start=$(jq -r '.data["time-one-value"] // "N/A"' "$me_ann_detail_file" 2>/dev/null)
            me_ann_end=$(jq -r '.data["time-two-value"] // "N/A"' "$me_ann_detail_file" 2>/dev/null)
            me_ann_desc=$(jq -r '.data.description // "N/A"' "$me_ann_detail_file" 2>/dev/null)
            local me_start_disp="${me_ann_start:0:16}" me_end_disp="${me_ann_end:0:16}"
            [[ "$me_ann_start" == "N/A" || "$me_ann_start" == "null" ]] && me_start_disp="-"
            [[ "$me_ann_end" == "N/A" || "$me_ann_end" == "null" ]] && me_end_disp="-"
            local me_desc_trunc="${me_ann_desc:0:115}"
            [[ ${#me_ann_desc} -gt 115 ]] && me_desc_trunc="${me_desc_trunc}..."
            ANN_TICKET_MAP["a${me_ann_idx}"]="${me_ticket}|${me_ann_detail_file}"
            local me_type_color="$WHITE"
            case "$me_ann_type" in
                ACTION_REQUIRED) me_type_color="$RED" ;;
                EMERGENCY_MAINTENANCE) me_type_color="$RED" ;;
                SCHEDULED_MAINTENANCE) me_type_color="$YELLOW" ;;
                *) me_type_color="$CYAN" ;;
            esac
            printf "${YELLOW}%-4s${NC} %-10s ${me_type_color}%-15s${NC} %-20s %-20s ${GRAY}%-115s${NC}\n" \
                "a${me_ann_idx}" "$me_ticket" "${me_ann_type:0:15}" "$me_start_disp" "$me_end_disp" "$me_desc_trunc"
        else
            ANN_TICKET_MAP["a${me_ann_idx}"]="${me_ticket}|"
            printf "${YELLOW}%-4s${NC} %-10s %-15s %-20s %-20s ${GRAY}%-115s${NC}\n" \
                "a${me_ann_idx}" "$me_ticket" "(not cached)" "-" "-" "Run --refresh to fetch details"
        fi
    done <<< "$me_sorted_tickets"
    
    if [[ $me_ann_idx -eq 0 ]]; then
        echo -e "  ${GRAY}No active announcements${NC}"
    fi
    
    echo ""
    rm -f "$maint_output_temp"
    
    #==========================================================================
    # Display events table
    #==========================================================================
    echo ""
    
    # Pre-build fault detail lookup: event_id → faultId~component~severity~description~impact~recommended
    # Uses persistent cache file to avoid re-fetching on every display
    declare -A ME_FAULT_MAP=()
    
    # Load from persistent cache first
    if [[ -f "$FAULT_DETAILS_CACHE" && -s "$FAULT_DETAILS_CACHE" ]]; then
        while IFS='=' read -r fc_evt_id fc_data; do
            [[ -z "$fc_evt_id" || "$fc_evt_id" == "#"* ]] && continue
            [[ -n "$fc_data" && "$fc_data" != "-~-~-~-~-~-" ]] && ME_FAULT_MAP[$fc_evt_id]="$fc_data"
        done < "$FAULT_DETAILS_CACHE"
    fi
    
    # Extract from list response additional-details (flat keys or nested faultDetails)
    while IFS='~' read -r flt_evt_id flt_fault_id flt_component flt_severity flt_desc flt_impact flt_recommended; do
        [[ -z "$flt_evt_id" ]] && continue
        [[ "$flt_fault_id" == "-" && "$flt_component" == "-" && "$flt_severity" == "-" ]] && continue
        [[ -n "${ME_FAULT_MAP[$flt_evt_id]:-}" ]] && continue  # already in cache
        ME_FAULT_MAP[$flt_evt_id]="${flt_fault_id}~${flt_component}~${flt_severity}~${flt_desc}~${flt_impact}~${flt_recommended}"
    done < <(jq -r '
        .data[] |
        .id as $eid |
        (.["additional-details"] // {}) as $ad |
        (($ad["faultDetails"] // $ad["fault-details"] // $ad["fault_details"] // null) |
         if . != null then (if type == "string" then (try fromjson catch null) else . end) else null end |
         if type == "array" and length > 0 then .[0] elif type == "object" then . else null end
        ) as $nested |
        if $nested != null then
            "\($eid)~\($nested.faultId // $nested["fault-id"] // "-")~\($nested.faultComponent // $nested["fault-component"] // "-")~\($nested.severity // "-")~\($nested.customerDescription // $nested["customer-description"] // $nested.description // "-")~\($nested.impactDescription // $nested["impact-description"] // "-")~\($nested.recommendedAction // $nested["recommended-action"] // "-")"
        elif ($ad.faultId // $ad["fault-id"] // $ad["faultid"] // null) != null then
            "\($eid)~\($ad.faultId // $ad["fault-id"] // $ad["faultid"] // "-")~\($ad.faultComponent // $ad["fault-component"] // $ad.component // "-")~\($ad.severity // $ad.faultSeverity // "-")~\($ad.customerDescription // $ad["customer-description"] // $ad.description // $ad.faultDescription // "-")~\($ad.impactDescription // $ad["impact-description"] // "-")~\($ad.recommendedAction // $ad["recommended-action"] // "-")"
        else
            empty
        end
    ' "$cache_file" 2>/dev/null)
    
    # Parallel fetch for events not yet in cache
    local fault_temp_dir="${TEMP_DIR}/fault_detail_$$"
    mkdir -p "$fault_temp_dir" 2>/dev/null
    local fault_fetch_count=0
    local fault_fetch_pids=()
    local fault_total_to_fetch=0
    
    # Count how many need fetching
    while IFS= read -r flt_evt_id; do
        [[ -z "$flt_evt_id" ]] && continue
        [[ -n "${ME_FAULT_MAP[$flt_evt_id]:-}" ]] && continue
        ((fault_total_to_fetch++))
    done < <(jq -r '.data[].id' "$cache_file" 2>/dev/null)
    
    if [[ $fault_total_to_fetch -gt 0 ]]; then
        echo -ne "${GRAY}Fetching fault details for ${fault_total_to_fetch} events...${NC}" >&2
    fi
    
    while IFS= read -r flt_evt_id; do
        [[ -z "$flt_evt_id" ]] && continue
        [[ -n "${ME_FAULT_MAP[$flt_evt_id]:-}" ]] && continue
        
        # Fetch individual event in background
        (
            local evt_detail
            evt_detail=$(oci compute instance-maintenance-event get \
                --instance-maintenance-event-id "$flt_evt_id" \
                --output json 2>/dev/null)
            if [[ -n "$evt_detail" ]]; then
                local fault_line
                fault_line=$(echo "$evt_detail" | jq -r '
                    (.data["additional-details"] // {}) as $ad |
                    (($ad["faultDetails"] // $ad["fault-details"] // $ad["fault_details"] // null) |
                     if . != null then (if type == "string" then (try fromjson catch null) else . end) else null end |
                     if type == "array" and length > 0 then .[0] elif type == "object" then . else null end
                    ) as $nested |
                    if $nested != null then
                        "\($nested.faultId // $nested["fault-id"] // "-")~\($nested.faultComponent // $nested["fault-component"] // "-")~\($nested.severity // "-")~\($nested.customerDescription // $nested["customer-description"] // $nested.description // "-")~\($nested.impactDescription // $nested["impact-description"] // "-")~\($nested.recommendedAction // $nested["recommended-action"] // "-")"
                    elif ($ad.faultId // $ad["fault-id"] // $ad["faultid"] // null) != null then
                        "\($ad.faultId // $ad["fault-id"] // $ad["faultid"] // "-")~\($ad.faultComponent // $ad["fault-component"] // $ad.component // "-")~\($ad.severity // $ad.faultSeverity // "-")~\($ad.customerDescription // $ad["customer-description"] // $ad.description // $ad.faultDescription // "-")~\($ad.impactDescription // $ad["impact-description"] // "-")~\($ad.recommendedAction // $ad["recommended-action"] // "-")"
                    else
                        "-~-~-~-~-~-"
                    end
                ' 2>/dev/null)
                if [[ -n "$fault_line" && "$fault_line" != "-~-~-~-~-~-" ]]; then
                    echo "$fault_line" > "$fault_temp_dir/$flt_evt_id"
                fi
            fi
        ) &
        fault_fetch_pids+=($!)
        ((fault_fetch_count++))
        
        # Throttle: wait after every 10 parallel fetches
        if [[ $fault_fetch_count -ge 10 ]]; then
            wait "${fault_fetch_pids[@]}" 2>/dev/null
            fault_fetch_pids=()
            fault_fetch_count=0
        fi
    done < <(jq -r '.data[].id' "$cache_file" 2>/dev/null)
    
    # Wait for remaining background jobs
    if [[ ${#fault_fetch_pids[@]} -gt 0 ]]; then
        wait "${fault_fetch_pids[@]}" 2>/dev/null
    fi
    
    # Read fetched fault details into ME_FAULT_MAP
    local fault_found_count=0
    local cache_updated=false
    for fault_file in "$fault_temp_dir"/*; do
        [[ ! -f "$fault_file" ]] && continue
        local f_evt_id
        f_evt_id=$(basename "$fault_file")
        local f_data
        f_data=$(cat "$fault_file" 2>/dev/null)
        if [[ -n "$f_data" && "$f_data" != "-~-~-~-~-~-" ]]; then
            ME_FAULT_MAP[$f_evt_id]="$f_data"
            ((fault_found_count++))
            cache_updated=true
        fi
    done
    rm -rf "$fault_temp_dir" 2>/dev/null
    
    if [[ $fault_total_to_fetch -gt 0 ]]; then
        echo -e " ${GREEN}✓${NC} ${GRAY}(${fault_found_count} with fault data)${NC}" >&2
    fi
    
    # Persist fault cache to disk (write full map)
    if [[ "$cache_updated" == "true" || ! -f "$FAULT_DETAILS_CACHE" ]]; then
        {
            echo "# Fault details cache - event_id=faultId~component~severity~description~impact~recommended"
            for fc_key in "${!ME_FAULT_MAP[@]}"; do
                echo "${fc_key}=${ME_FAULT_MAP[$fc_key]}"
            done
        } > "$FAULT_DETAILS_CACHE" 2>/dev/null
    fi
    
    # Compute epoch thresholds for 5-minute imminent window highlighting
    local me_now_epoch
    me_now_epoch=$(date -u +%s)
    local me_5min_epoch=$(( me_now_epoch + 300 ))
    
    # Show current UTC time with datetime aligned to Window Start column
    printf "  %-4s %-30s %-20s %-14s %-10s %-8s %-6s %-8s %-5s %-22s %-12s %-11s ${GRAY}%28s ${WHITE}%-26s${NC}\n" \
        "" "" "" "" "" "" "" "" "" "" "" "" "Current UTC:" "$(date -u +'%Y-%m-%dT%H:%M:%S.000Z')"
    
    if [[ "$me_view_mode" == "detail" ]]; then
        printf "  ${BOLD}%-4s %-30s %-20s %-14s %-10s %-8s %-6s %-8s %-5s %-22s %-12s %-11s %-28s %-26s %-22s %-6s %-10s %-10s${NC}\n" \
            "#" "Instance Name" "K8s Node" "Serial" "State" "K8s" "Crdn" "Taints" "Pods" "Maint Reason" "Category" "Lifecycle" "Event Name" "Window Start" "Hard Due Date" "Rescd" "Announce" "CapTopo"
        print_separator 275
    else
        # Compact view: same columns + Fault Code + CapTopo at end, no sub-lines
        printf "  ${BOLD}%-4s %-30s %-20s %-14s %-10s %-8s %-6s %-8s %-5s %-22s %-12s %-11s %-28s %-26s %-22s %-6s %-10s %-22s %-10s${NC}\n" \
            "#" "Instance Name" "K8s Node" "Serial" "State" "K8s" "Crdn" "Taints" "Pods" "Maint Reason" "Category" "Lifecycle" "Event Name" "Window Start" "Hard Due Date" "Rescd" "Announce" "Fault Code" "CapTopo"
        print_separator 297
    fi
    
    declare -A ME_EVENT_MAP=()
    declare -A ME_INSTANCE_MAP=()
    local me_idx=0
    
    while IFS='|' read -r evt_id evt_instance_id evt_reason evt_category evt_lifecycle evt_window_start evt_hard_due evt_can_resched evt_display_name evt_instance_action evt_additional; do
        [[ -z "$evt_id" ]] && continue
        
        # Look up instance details
        local inst_name="N/A" inst_shape="N/A" inst_state="N/A" inst_ad="N/A" inst_gpu_mem="N/A"
        local inst_info
        inst_info=$(grep "$evt_instance_id" "$me_inst_temp" 2>/dev/null | head -1)
        if [[ -n "$inst_info" ]]; then
            inst_name=$(echo "$inst_info" | cut -d'|' -f2)
            inst_shape=$(echo "$inst_info" | cut -d'|' -f3)
            inst_state=$(echo "$inst_info" | cut -d'|' -f4)
            inst_ad=$(echo "$inst_info" | cut -d'|' -f5)
            inst_gpu_mem=$(echo "$inst_info" | cut -d'|' -f6)
        fi
        
        # Apply filters
        # Named filter: skip events without a matching instance name
        if [[ "$filter_type" == "named" && ("$inst_name" == "N/A" || -z "$inst_name") ]]; then
            continue
        fi
        # Lifecycle state filters: skip events not matching the filter
        if [[ "$filter_type" == "PROCESSING" || "$filter_type" == "SUCCEEDED" || "$filter_type" == "CANCELED" || "$filter_type" == "SCHEDULED" ]]; then
            if [[ "${evt_lifecycle^^}" != "${filter_type}" ]]; then
                continue
            fi
        fi
        
        # Look up CapTopo state for this instance
        local evt_cap_topo="N/A"
        evt_cap_topo=$(get_capacity_topology_state "$evt_instance_id" 2>/dev/null)
        [[ -z "$evt_cap_topo" ]] && evt_cap_topo="N/A"
        
        # When named filter is active: hide events where CapTopo is AVAILABLE
        if [[ "$filter_type" == "named" && "$evt_cap_topo" == "AVAILABLE" ]]; then
            continue
        fi
        
        # When named filter is active: hide SUCCEEDED events with window start > 2 days old
        if [[ "$filter_type" == "named" && "${evt_lifecycle^^}" == "SUCCEEDED" ]]; then
            if [[ "$evt_window_start" != "null" && -n "$evt_window_start" ]]; then
                local chk_ws_epoch
                chk_ws_epoch=$(date -u -d "${evt_window_start:0:19}" +%s 2>/dev/null) || chk_ws_epoch=""
                if [[ -n "$chk_ws_epoch" ]]; then
                    local two_days_ago=$(( me_now_epoch - 172800 ))
                    if [[ $chk_ws_epoch -lt $two_days_ago ]]; then
                        continue
                    fi
                fi
            fi
        fi
        
        ((me_idx++))
        
        # Look up K8s node (expanded: name|ready|unschedulable|taint_count|taint_names|serial)
        local k8s_node="N/A" k8s_ready="N/A" k8s_unsched="false" k8s_taint_count="0" k8s_taint_names="" k8s_serial="N/A"
        local k8s_match
        k8s_match=$(echo "$me_k8s_lookup" | grep "$evt_instance_id" 2>/dev/null)
        if [[ -n "$k8s_match" ]]; then
            k8s_node=$(echo "$k8s_match" | cut -d'|' -f2)
            k8s_ready=$(echo "$k8s_match" | cut -d'|' -f3)
            k8s_unsched=$(echo "$k8s_match" | cut -d'|' -f4)
            k8s_taint_count=$(echo "$k8s_match" | cut -d'|' -f5)
            k8s_taint_names=$(echo "$k8s_match" | cut -d'|' -f6)
            k8s_serial=$(echo "$k8s_match" | cut -d'|' -f7)
        fi
        
        # Get pod count for this node
        local k8s_pods="-"
        if [[ "$k8s_node" != "N/A" && -n "$k8s_node" ]]; then
            local node_pod_count
            node_pod_count=$(echo "$me_pods_per_node" | grep "^${k8s_node}|" | cut -d'|' -f2)
            k8s_pods="${node_pod_count:-0}"
        fi
        
        # Get announcements for this instance
        local inst_announcement="-"
        inst_announcement=$(get_resource_announcements "$evt_instance_id" "$inst_gpu_mem" 2>/dev/null)
        [[ -z "$inst_announcement" ]] && inst_announcement="-"
        
        # Store mappings (include instance-action)
        ME_EVENT_MAP[$me_idx]="${evt_id}|${evt_instance_id}|${evt_reason}|${evt_category}|${evt_lifecycle}|${evt_window_start}|${evt_hard_due}|${evt_can_resched}|${evt_display_name}|${inst_name}|${k8s_node}|${inst_shape}|${inst_state}|${evt_instance_action}|${evt_additional}"
        ME_INSTANCE_MAP[$me_idx]="${evt_instance_id}"
        
        # Color coding
        local state_color="$GREEN"
        case "$inst_state" in
            RUNNING) state_color="$GREEN" ;;
            STOPPED) state_color="$RED" ;;
            *) state_color="$YELLOW" ;;
        esac
        
        local k8s_display="$k8s_ready"
        local k8s_color="$GRAY"
        if [[ "$k8s_ready" == "True" ]]; then
            k8s_display="Ready"
            k8s_color="$GREEN"
        elif [[ "$k8s_ready" != "N/A" ]]; then
            k8s_display="NotRdy"
            k8s_color="$RED"
        fi
        [[ "$k8s_node" == "N/A" ]] && k8s_display="-" && k8s_color="$GRAY"
        
        # Cordon display
        local cordon_display="-" cordon_color="$GRAY"
        if [[ "$k8s_node" != "N/A" ]]; then
            if [[ "$k8s_unsched" == "true" ]]; then
                cordon_display="Yes"
                cordon_color="$YELLOW"
            else
                cordon_display="-"
                cordon_color="$GRAY"
            fi
        fi
        
        # Taint display
        local taint_display="-" taint_color="$GRAY"
        if [[ "$k8s_node" != "N/A" ]]; then
            if [[ "$k8s_taint_count" -gt 0 ]]; then
                taint_display="${k8s_taint_count}"
                taint_color="$YELLOW"
            else
                taint_display="0"
                taint_color="$GRAY"
            fi
        fi
        
        # Pods color
        local pods_color="$CYAN"
        [[ "$k8s_pods" == "-" || "$k8s_pods" == "0" ]] && pods_color="$GRAY"
        
        local lifecycle_color="$WHITE"
        case "$evt_lifecycle" in
            SCHEDULED) lifecycle_color="$YELLOW" ;;
            STARTED) lifecycle_color="$GREEN" ;;
            COMPLETED|SUCCEEDED) lifecycle_color="$GREEN" ;;
            CANCELED|CANCELLED) lifecycle_color="$GRAY" ;;
            *) lifecycle_color="$WHITE" ;;
        esac
        
        local resched_display="No"
        local resched_color="$RED"
        if [[ "$evt_can_resched" == "true" ]]; then
            resched_display="Yes"
            resched_color="$GREEN"
        fi
        
        local reason_color="$YELLOW"
        [[ "$evt_reason" == "HARDWARE_REPLACEMENT" ]] && reason_color="$RED"
        
        # Instance action color
        local action_color="$WHITE"
        [[ "$evt_instance_action" == "STOP" ]] && action_color="$RED"
        [[ "$evt_instance_action" == "REBOOT" ]] && action_color="$YELLOW"
        
        # Announcement color
        local ann_color="$GRAY"
        [[ "$inst_announcement" != "-" && -n "$inst_announcement" ]] && ann_color="$YELLOW"
        
        # Format times - show date + time
        local window_display="${evt_window_start:0:19}"
        local hard_due_display="${evt_hard_due:0:19}"
        [[ "$evt_window_start" == "null" || -z "$evt_window_start" ]] && window_display="-"
        [[ "$evt_hard_due" == "null" || -z "$evt_hard_due" ]] && hard_due_display="-"
        
        # Window Start color coding based on lifecycle and time
        local window_color="$WHITE"
        local hard_due_color="$WHITE"
        local ws_field_width=26
        
        # Parse window start epoch for time comparisons
        local ws_epoch=""
        if [[ "$window_display" != "-" && "$evt_window_start" != "null" && -n "$evt_window_start" ]]; then
            ws_epoch=$(date -u -d "${evt_window_start:0:19}" +%s 2>/dev/null) || ws_epoch=""
        fi
        
        # Parse hard due date epoch
        local hd_epoch=""
        if [[ "$hard_due_display" != "-" && "$evt_hard_due" != "null" && -n "$evt_hard_due" ]]; then
            hd_epoch=$(date -u -d "${evt_hard_due:0:19}" +%s 2>/dev/null) || hd_epoch=""
        fi
        
        # Determine if window start is in the past
        local ws_in_past=false
        if [[ -n "$ws_epoch" && $ws_epoch -le $me_now_epoch ]]; then
            ws_in_past=true
        fi
        
        # Determine if hard due date is in the past
        local hd_in_past=false
        if [[ -n "$hd_epoch" && $hd_epoch -le $me_now_epoch ]]; then
            hd_in_past=true
        fi
        
        # Apply color rules for Window Start
        case "$evt_lifecycle" in
            PROCESSING)
                # Actively processing - always bold yellow
                window_color="${BOLD}${YELLOW}"
                ;;
            STARTED)
                # Started - always bold yellow
                window_color="${BOLD}${YELLOW}"
                ;;
            SUCCEEDED|COMPLETED)
                # Completed - gray (past) or green (future)
                if [[ "$ws_in_past" == "true" ]]; then
                    window_color="$GRAY"
                else
                    window_color="$GREEN"
                fi
                ;;
            CANCELED|CANCELLED)
                # Canceled - always gray
                window_color="$GRAY"
                ;;
            SCHEDULED)
                if [[ "$ws_in_past" == "true" ]]; then
                    # Past due - gray with warning indicator
                    window_color="$GRAY"
                    window_display="⚠ ${window_display}"
                    ws_field_width=28
                elif [[ -n "$ws_epoch" && $ws_epoch -le $me_5min_epoch ]]; then
                    # Within 5 minutes - IMMINENT - bold yellow
                    window_color="${BOLD}${YELLOW}"
                    window_display="⚠ ${window_display}"
                    ws_field_width=28
                fi
                # else: future → stays WHITE (default)
                ;;
            *)
                # Unknown lifecycle - gray if past, white if future
                if [[ "$ws_in_past" == "true" ]]; then
                    window_color="$GRAY"
                fi
                ;;
        esac
        
        # Apply color rules for Hard Due Date
        if [[ "$hd_in_past" == "true" ]]; then
            hard_due_color="$GRAY"
        fi
        
        # Serial number color (yellow for N/A, cyan for populated)
        local serial_color="$YELLOW"
        [[ "$k8s_serial" != "N/A" && -n "$k8s_serial" ]] && serial_color="$CYAN"
        
        # K8s node name color (yellow for N/A, cyan for populated)
        local k8s_node_color="$YELLOW"
        [[ "$k8s_node" != "N/A" && -n "$k8s_node" ]] && k8s_node_color="$CYAN"
        
        # Extract fault code for compact view or detail sub-line
        local row_fault="${ME_FAULT_MAP[$evt_id]:-}"
        local compact_fault_code="-"
        if [[ -n "$row_fault" && "$row_fault" != "-~-~-~-~-~-" ]]; then
            local rf_fault_id rf_component rf_severity rf_desc rf_impact rf_recommended
            IFS='~' read -r rf_fault_id rf_component rf_severity rf_desc rf_impact rf_recommended <<< "$row_fault"
            [[ "$rf_fault_id" != "-" && -n "$rf_fault_id" ]] && compact_fault_code="$rf_fault_id"
        fi
        
        if [[ "$me_view_mode" == "detail" ]]; then
            # CapTopo color
            local cap_topo_color="$GREEN"
            case "$evt_cap_topo" in AVAILABLE) cap_topo_color="$GREEN" ;; DEGRADED) cap_topo_color="$RED" ;; N/A) cap_topo_color="$GRAY" ;; *) cap_topo_color="$YELLOW" ;; esac
            
            # ── Detail view: full row + fault sub-line + blank line ──
            printf "  ${YELLOW}%-4s${NC} %-30s ${k8s_node_color}%-20s${NC} ${serial_color}%-14s${NC} ${state_color}%-10s${NC} ${k8s_color}%-8s${NC} ${cordon_color}%-6s${NC} ${taint_color}%-8s${NC} ${pods_color}%-5s${NC} ${reason_color}%-22s${NC} %-12s ${lifecycle_color}%-11s${NC} %-28s ${window_color}%-${ws_field_width}s${NC} ${hard_due_color}%-22s${NC} ${resched_color}%-6s${NC} ${ann_color}%-10s${NC} ${cap_topo_color}%-10s${NC}\n" \
                "$me_idx" "${inst_name:0:30}" "${k8s_node:0:20}" "${k8s_serial:0:14}" "$inst_state" "$k8s_display" "$cordon_display" "${taint_display:0:8}" "$k8s_pods" "${evt_reason:0:22}" "${evt_category:0:12}" "$evt_lifecycle" "${evt_display_name:0:28}" "${window_display:0:${ws_field_width}}" "${hard_due_display:0:22}" "$resched_display" "${inst_announcement:0:10}" "$evt_cap_topo"
            
            # Display fault/additional details as dim sub-line aligned to main row columns
            # ↳ indented 3 spaces, then:  Fault ID→Instance Name  Component→K8s Node  Sev→Serial
            #   Description→State..Lifecycle  Recommended→Event Name  Impact→Window Start
            local fault_shown=false
            if [[ -n "$row_fault" && "$row_fault" != "-~-~-~-~-~-" ]]; then
                if [[ "$rf_fault_id" != "-" || "$rf_component" != "-" || "$rf_severity" != "-" ]]; then
                    # Severity color
                    local rf_sev_color="$GRAY"
                    case "$rf_severity" in
                        CRITICAL) rf_sev_color="${BOLD}${RED}" ;;
                        HIGH)     rf_sev_color="$YELLOW" ;;
                        MEDIUM)   rf_sev_color="$CYAN" ;;
                        LOW)      rf_sev_color="$GREEN" ;;
                    esac
                    
                    # Prepare field values (empty string for missing fields)
                    local f_id="" f_comp="" f_sev="" f_desc="" f_action="" f_impact=""
                    [[ "$rf_fault_id" != "-" && -n "$rf_fault_id" ]] && f_id="$rf_fault_id"
                    [[ "$rf_component" != "-" && -n "$rf_component" ]] && f_comp="$rf_component"
                    [[ "$rf_severity" != "-" && -n "$rf_severity" ]] && f_sev="$rf_severity"
                    [[ "$rf_desc" != "-" && -n "$rf_desc" ]] && f_desc="${rf_desc:0:89}"
                    [[ "$rf_recommended" != "-" && -n "$rf_recommended" ]] && f_action="$rf_recommended"
                    [[ "$rf_impact" != "-" && -n "$rf_impact" ]] && f_impact="${rf_impact:0:65}"
                    
                    # Column-aligned printf:  3sp + ↳ + 3sp = 7 chars prefix (aligns with Instance Name pos 7)
                    # %-30s=FaultID  %-20s=Component  %-14s=Sev  %-89s=Desc(cyan)  %-28s=Recommended  %-65s=Impact(cyan)
                    printf "   ${CYAN}↳${GRAY}   %-30s %-20s ${rf_sev_color}%-14s${CYAN} %-89s ${YELLOW}%-28s${CYAN} %-65s${NC}\n" \
                        "$f_id" "$f_comp" "Sev:$f_sev" "$f_desc" "$f_action" "$f_impact"
                    fault_shown=true
                fi
            fi
            
            # Fallback: show raw additional-details as dim sub-line aligned to Instance Name column
            if [[ "$fault_shown" == "false" && -n "$evt_additional" ]]; then
                local ad_clean="$evt_additional"
                [[ "$ad_clean" == \"*\" ]] && ad_clean="${ad_clean:1:${#ad_clean}-2}"
                
                if [[ "$ad_clean" != "{}" && "$ad_clean" != "null" && -n "$ad_clean" ]]; then
                    local ad_oneline=""
                    ad_oneline=$(echo "$ad_clean" | jq -r '
                        if type == "string" then (try fromjson catch {}) else . end |
                        if type == "object" and length > 0 then
                            [to_entries[] | select(.value != null and .value != "" and .value != "null" and .value != "{}") |
                             "\(.key): \(.value | tostring | .[0:50])"] | join("  ")
                        else empty end
                    ' 2>/dev/null)
                    
                    if [[ -n "$ad_oneline" ]]; then
                        printf "   ${CYAN}↳${GRAY}   %s${NC}\n" "$ad_oneline"
                    fi
                fi
            fi
            
            # Blank line after each event group for readability
            echo ""
        else
            # ── Compact view: single row + fault code + CapTopo column, no sub-line ──
            local fault_code_color="$GRAY"
            [[ "$compact_fault_code" != "-" ]] && fault_code_color="$CYAN"
            local cap_topo_color="$GREEN"
            case "$evt_cap_topo" in AVAILABLE) cap_topo_color="$GREEN" ;; DEGRADED) cap_topo_color="$RED" ;; N/A) cap_topo_color="$GRAY" ;; *) cap_topo_color="$YELLOW" ;; esac
            
            printf "  ${YELLOW}%-4s${NC} %-30s ${k8s_node_color}%-20s${NC} ${serial_color}%-14s${NC} ${state_color}%-10s${NC} ${k8s_color}%-8s${NC} ${cordon_color}%-6s${NC} ${taint_color}%-8s${NC} ${pods_color}%-5s${NC} ${reason_color}%-22s${NC} %-12s ${lifecycle_color}%-11s${NC} %-28s ${window_color}%-${ws_field_width}s${NC} ${hard_due_color}%-22s${NC} ${resched_color}%-6s${NC} ${ann_color}%-10s${NC} ${fault_code_color}%-22s${NC} ${cap_topo_color}%-10s${NC}\n" \
                "$me_idx" "${inst_name:0:30}" "${k8s_node:0:20}" "${k8s_serial:0:14}" "$inst_state" "$k8s_display" "$cordon_display" "${taint_display:0:8}" "$k8s_pods" "${evt_reason:0:22}" "${evt_category:0:12}" "$evt_lifecycle" "${evt_display_name:0:28}" "${window_display:0:${ws_field_width}}" "${hard_due_display:0:22}" "$resched_display" "${inst_announcement:0:10}" "${compact_fault_code:0:22}" "$evt_cap_topo"
        fi
            
    done < <(jq -r '.data[] | "\(.id)|\(.["instance-id"] // "")|\(.["maintenance-reason"] // "N/A")|\(.["maintenance-category"] // "N/A")|\(.["lifecycle-state"] // "N/A")|\(.["time-window-start"] // "null")|\(.["time-hard-due-date"] // "null")|\(.["can-reschedule"] // false)|\(.["display-name"] // "N/A")|\(.["instance-action"] // "N/A")|\(.["additional-details"] // "{}" | @json)"' "$cache_file" 2>/dev/null | sort -t'|' -k6,6)
    
    echo ""
    echo -e "${GRAY}Total: ${WHITE}${me_idx}${GRAY} maintenance event(s)${NC}"
    
    # Show taint legend if any taints found
    local any_taints=false
    for ((ti=1; ti<=me_idx; ti++)); do
        local ti_info="${ME_EVENT_MAP[$ti]:-}"
        [[ -z "$ti_info" ]] && continue
        local ti_k8s_node
        ti_k8s_node=$(echo "$ti_info" | cut -d'|' -f11)
        if [[ "$ti_k8s_node" != "N/A" && -n "$ti_k8s_node" ]]; then
            local ti_k8s_match
            ti_k8s_match=$(echo "$me_k8s_lookup" | grep "$ti_k8s_node" 2>/dev/null | head -1)
            local ti_taint_names
            ti_taint_names=$(echo "$ti_k8s_match" | rev | cut -d'|' -f1 | rev)
            if [[ -n "$ti_taint_names" && "$ti_taint_names" != "0" ]]; then
                any_taints=true
                break
            fi
        fi
    done
    
    if [[ "$any_taints" == "true" ]]; then
        echo ""
        echo -e "${BOLD}${WHITE}─── Taint Details ───${NC}"
        for ((ti=1; ti<=me_idx; ti++)); do
            local ti_info="${ME_EVENT_MAP[$ti]:-}"
            [[ -z "$ti_info" ]] && continue
            local ti_inst_name ti_k8s_node
            ti_inst_name=$(echo "$ti_info" | cut -d'|' -f10)
            ti_k8s_node=$(echo "$ti_info" | cut -d'|' -f11)
            if [[ "$ti_k8s_node" != "N/A" && -n "$ti_k8s_node" ]]; then
                local ti_k8s_match
                ti_k8s_match=$(echo "$me_k8s_lookup" | grep "$ti_k8s_node" 2>/dev/null | head -1)
                local ti_taint_count ti_taint_names
                ti_taint_count=$(echo "$ti_k8s_match" | awk -F'|' '{print $(NF-1)}')
                ti_taint_names=$(echo "$ti_k8s_match" | rev | cut -d'|' -f1 | rev)
                if [[ -n "$ti_taint_names" && "$ti_taint_count" -gt 0 ]] 2>/dev/null; then
                    echo -e "  ${YELLOW}#$ti${NC} ${WHITE}${ti_inst_name:0:30}${NC}: ${GRAY}${ti_taint_names}${NC}"
                fi
            fi
        done
    fi
    echo ""
    
    #==========================================================================
    # Interactive menu (merged: events + instances + announcements)
    #==========================================================================
    while true; do
        echo -e "${BOLD}${WHITE}─── Actions ───${NC}"
        echo -e "  ${BOLD}Maintenance Events:${NC}"
        echo -e "    ${YELLOW}#${NC}                      - View event details (e.g., '1', '3')"
        echo -e "    ${YELLOW}resched #${NC}              - Reschedule event (e.g., 'resched 1' or 'resched 1,3,5' or 'resched 1-5' or 'resched all')"
        echo -e "    ${ORANGE}c #${NC}                    - Cordon K8s node for event (e.g., 'c 1' or 'c 1,3,5' or 'c all')"
        echo -e "    ${ORANGE}d #${NC}                    - Drain K8s node for event (e.g., 'd 1' or 'd 1,3,5' or 'd all')"
        echo -e "    ${ORANGE}cd #${NC}                   - Cordon then drain K8s node (e.g., 'cd 1' or 'cd all')"
        echo -e "    ${CYAN}p #${NC}                    - View pods on event node (e.g., 'p 1' or 'p 1,3,5' or 'p all')"
        echo -e "  ${BOLD}Maintenance Instances:${NC}"
        echo -e "    ${YELLOW}m#${NC}                     - Manage instance (e.g., 'm1' for c/d/uncordon/terminate/details)"
        echo -e "    ${YELLOW}a#${NC}                     - View announcement details (e.g., 'a1')"
        echo -e "    ${CYAN}pods m1,m2${NC}             - View pods on nodes (or 'pods all')"
        echo -e "    ${ORANGE}c m1,m2${NC}                - Cordon multiple nodes (or 'd m1,m2' / 'cd m1,m2' / 'uncordon m1,m2' / 'terminate m1,m2')"
        echo -e "  ${BOLD}General:${NC}"
        if [[ "$me_view_mode" == "compact" ]]; then
            echo -e "    ${CYAN}view${NC}                   - Switch to detail view (fault sub-lines)"
        else
            echo -e "    ${CYAN}view${NC}                   - Switch to compact view (single-line)"
        fi
        echo -e "    ${CYAN}filter${NC}                 - Filter events (${GREEN}n${NC}=named ${GREEN}p${NC}=processing ${GREEN}su${NC}=succeeded ${GREEN}c${NC}=canceled ${GREEN}sc${NC}=scheduled ${GREEN}all${NC}=clear)"
        echo -e "    ${CYAN}list${NC}                   - Show announcement details again"
        echo -e "    ${MAGENTA}r${NC}                      - Force refresh from OCI (invalidate cache)"
        echo -e "    ${CYAN}q${NC}                      - Back"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Maintenance] Selection: ${NC}"
        read -r me_selection
        
        [[ -z "$me_selection" || "$me_selection" == "q" || "$me_selection" == "Q" || "$me_selection" == "back" ]] && break
        
        # Normalize shortcuts: c → cordon, d → drain, cd → cordon-drain, p → pods
        # Must check cd before c to avoid cd being matched as c + d...
        if [[ "$me_selection" =~ ^cd[[:space:]]+(.+)$ ]]; then
            me_selection="cordon-drain ${BASH_REMATCH[1]}"
        elif [[ "$me_selection" =~ ^c[[:space:]]+(.+)$ ]]; then
            me_selection="cordon ${BASH_REMATCH[1]}"
        elif [[ "$me_selection" =~ ^d[[:space:]]+(.+)$ ]]; then
            me_selection="drain ${BASH_REMATCH[1]}"
        elif [[ "$me_selection" =~ ^p[[:space:]]+(.+)$ && ! "$me_selection" =~ ^pods ]]; then
            me_selection="pods ${BASH_REMATCH[1]}"
        fi
        
        # View toggle
        if [[ "$me_selection" == "view" || "$me_selection" == "VIEW" || "$me_selection" == "v" || "$me_selection" == "V" ]]; then
            local new_view="compact"
            [[ "$me_view_mode" == "compact" ]] && new_view="detail"
            rm -f "$me_inst_temp"
            list_maintenance_events "$compartment_id" "$region" "false" "$filter_type" "$new_view"
            return
        fi
        
        # Refresh
        if [[ "$me_selection" == "r" || "$me_selection" == "R" || "$me_selection" == "refresh" || "$me_selection" == "REFRESH" ]]; then
            rm -f "$MAINT_EVENTS_CACHE" "$FAULT_DETAILS_CACHE"
            echo -e "${YELLOW}Cache invalidated - refreshing...${NC}"
            rm -f "$me_inst_temp"
            list_maintenance_events "$compartment_id" "$region" "true" "$filter_type" "$me_view_mode"
            return
        fi
        
        # Filter command - supports 'filter' (submenu) or 'filter <shortcut>' (direct)
        if [[ "${me_selection,,}" =~ ^(filter|f)(\ +.*)?$ ]]; then
            local filter_arg="${me_selection#* }"
            # If just 'filter' or 'f' with no arg, show submenu
            if [[ "$filter_arg" == "${me_selection}" || -z "${filter_arg// /}" ]]; then
                echo ""
                echo -e "${BOLD}${WHITE}─── Filter Options ───${NC}"
                echo -e "  ${GREEN}n${NC}   - Named instances only (has a display name)"
                echo -e "  ${GREEN}p${NC}   - PROCESSING events"
                echo -e "  ${GREEN}su${NC}  - SUCCEEDED events"
                echo -e "  ${GREEN}c${NC}   - CANCELED events"
                echo -e "  ${GREEN}sc${NC}  - SCHEDULED events"
                echo -e "  ${GREEN}all${NC} - Clear filter (show all)"
                echo ""
                echo -n -e "${BOLD}${CYAN}[Filter] Select: ${NC}"
                read -r filter_arg
            fi
            
            local new_filter="none"
            case "${filter_arg,,}" in
                n)   new_filter="named" ;;
                p)   new_filter="PROCESSING" ;;
                su)  new_filter="SUCCEEDED" ;;
                c)   new_filter="CANCELED" ;;
                sc)  new_filter="SCHEDULED" ;;
                all) new_filter="none" ;;
                *)   echo -e "${RED}Invalid filter: ${filter_arg}${NC}"; continue ;;
            esac
            
            rm -f "$me_inst_temp"
            list_maintenance_events "$compartment_id" "$region" "false" "$new_filter" "$me_view_mode"
            return
        fi
        
        # Legacy: 'all' clears filter
        if [[ "${me_selection,,}" == "all" ]]; then
            rm -f "$me_inst_temp"
            list_maintenance_events "$compartment_id" "$region" "false" "none" "$me_view_mode"
            return
        fi
        
        # Show announcements list again
        if [[ "$me_selection" == "list" ]]; then
            echo ""
            echo -e "${BOLD}${CYAN}─── Announcement Details ─────────────────────────────────────────────────────────────────────────────────────────${NC}"
            echo ""
            printf "${BOLD}%-4s %-10s %-15s %-20s %-20s %-115s${NC}\n" \
                "ID" "Ticket" "Type" "Start" "End" "Description"
            print_separator 190
            for la_key in $(echo "${!ANN_TICKET_MAP[@]}" | tr ' ' '\n' | sort); do
                local la_info="${ANN_TICKET_MAP[$la_key]:-}"
                [[ -z "$la_info" ]] && continue
                local la_ticket la_file
                IFS='|' read -r la_ticket la_file <<< "$la_info"
                if [[ -n "$la_file" && -f "$la_file" ]]; then
                    local la_type la_start la_end la_desc
                    la_type=$(jq -r '.data["announcement-type"] // "N/A"' "$la_file" 2>/dev/null)
                    la_start=$(jq -r '.data["time-one-value"] // "N/A"' "$la_file" 2>/dev/null)
                    la_end=$(jq -r '.data["time-two-value"] // "N/A"' "$la_file" 2>/dev/null)
                    la_desc=$(jq -r '.data.description // "N/A"' "$la_file" 2>/dev/null)
                    local la_s="${la_start:0:16}" la_e="${la_end:0:16}"
                    [[ "$la_start" == "N/A" || "$la_start" == "null" ]] && la_s="-"
                    [[ "$la_end" == "N/A" || "$la_end" == "null" ]] && la_e="-"
                    local la_dt="${la_desc:0:115}"
                    [[ ${#la_desc} -gt 115 ]] && la_dt="${la_dt}..."
                    local la_tc="$WHITE"
                    case "$la_type" in ACTION_REQUIRED|EMERGENCY_MAINTENANCE) la_tc="$RED" ;; SCHEDULED_MAINTENANCE) la_tc="$YELLOW" ;; *) la_tc="$CYAN" ;; esac
                    printf "${YELLOW}%-4s${NC} %-10s ${la_tc}%-15s${NC} %-20s %-20s ${GRAY}%-115s${NC}\n" "$la_key" "$la_ticket" "${la_type:0:15}" "$la_s" "$la_e" "$la_dt"
                else
                    printf "${YELLOW}%-4s${NC} %-10s %-15s %-20s %-20s ${GRAY}%-115s${NC}\n" "$la_key" "$la_ticket" "(not cached)" "-" "-" "Run --refresh to fetch details"
                fi
            done
            echo ""
            continue
        fi
        
        #----------------------------------------------------------------------
        # Cordon command - route by target type (numeric=events, m#=instances)
        #----------------------------------------------------------------------
        if [[ "$me_selection" =~ ^cordon[[:space:]]+(.+)$ ]]; then
            local cordon_targets="${BASH_REMATCH[1]}"
            
            # Detect m-prefix targets → route to instances bulk handler
            if [[ "$cordon_targets" =~ ^m ]]; then
                # Route to instances bulk handler below
                me_selection="cordon ${cordon_targets}"
            else
                # Events-based cordon (numeric indices)
                local cordon_log_file="${LOGS_DIR}/maintenance_events_actions.log"
                declare -a cordon_indices=()
                
                if [[ "$cordon_targets" == "all" || "$cordon_targets" == "ALL" ]]; then
                    for ((ci=1; ci<=me_idx; ci++)); do
                        cordon_indices+=("$ci")
                    done
                else
                    IFS=',' read -ra cordon_parts <<< "$cordon_targets"
                    for cpart in "${cordon_parts[@]}"; do
                        cpart=$(echo "$cpart" | tr -d ' ')
                        if [[ "$cpart" =~ ^([0-9]+)-([0-9]+)$ ]]; then
                            local cr_start="${BASH_REMATCH[1]}" cr_end="${BASH_REMATCH[2]}"
                            for ((ci=cr_start; ci<=cr_end; ci++)); do
                                [[ $ci -ge 1 && $ci -le $me_idx ]] && cordon_indices+=("$ci")
                            done
                        elif [[ "$cpart" =~ ^[0-9]+$ ]]; then
                            [[ $cpart -ge 1 && $cpart -le $me_idx ]] && cordon_indices+=("$cpart")
                        fi
                    done
                fi
                
                if [[ ${#cordon_indices[@]} -eq 0 ]]; then
                    echo -e "${RED}No valid events selected${NC}"
                    continue
                fi
                
                declare -a cordon_valid_nodes=()
                declare -a cordon_skipped=()
                
                for ci_idx in "${cordon_indices[@]}"; do
                    local ci_info="${ME_EVENT_MAP[$ci_idx]:-}"
                    [[ -z "$ci_info" ]] && continue
                    local ci_evt_id ci_inst_id ci_reason ci_category ci_lifecycle ci_window_start ci_hard_due ci_can_resched ci_evt_name ci_inst_name ci_k8s_node ci_shape ci_state ci_instance_action ci_additional
                    IFS='|' read -r ci_evt_id ci_inst_id ci_reason ci_category ci_lifecycle ci_window_start ci_hard_due ci_can_resched ci_evt_name ci_inst_name ci_k8s_node ci_shape ci_state ci_instance_action ci_additional <<< "$ci_info"
                    
                    if [[ "$ci_k8s_node" == "N/A" || -z "$ci_k8s_node" ]]; then
                        cordon_skipped+=("$ci_idx|$ci_inst_name|not a K8s node")
                        continue
                    fi
                    local ci_k8s_match ci_unsched="false"
                    ci_k8s_match=$(echo "$me_k8s_lookup" | grep "$ci_inst_id" 2>/dev/null)
                    [[ -n "$ci_k8s_match" ]] && ci_unsched=$(echo "$ci_k8s_match" | cut -d'|' -f4)
                    if [[ "$ci_unsched" == "true" ]]; then
                        cordon_skipped+=("$ci_idx|$ci_inst_name|already cordoned (${ci_k8s_node})")
                        continue
                    fi
                    cordon_valid_nodes+=("$ci_idx|$ci_inst_name|$ci_k8s_node")
                done
                
                [[ ${#cordon_skipped[@]} -gt 0 ]] && {
                    echo ""
                    echo -e "${YELLOW}Skipping ${#cordon_skipped[@]} event(s):${NC}"
                    for skip_entry in "${cordon_skipped[@]}"; do
                        local skip_idx skip_name skip_reason
                        IFS='|' read -r skip_idx skip_name skip_reason <<< "$skip_entry"
                        echo -e "  ${GRAY}#$skip_idx ${skip_name} - ${skip_reason}${NC}"
                    done
                }
                
                if [[ ${#cordon_valid_nodes[@]} -eq 0 ]]; then
                    echo -e "${RED}No valid K8s nodes to cordon${NC}"
                    continue
                fi
                
                echo ""
                echo -e "${BOLD}${CYAN}═══ CORDON K8S NODES ═══${NC}"
                echo ""
                printf "  ${BOLD}%-4s %-30s %-40s %-50s${NC}\n" "#" "Instance Name" "K8s Node" "Command"
                print_separator 130
                for cvn in "${cordon_valid_nodes[@]}"; do
                    local cv_idx cv_inst_name cv_k8s_node
                    IFS='|' read -r cv_idx cv_inst_name cv_k8s_node <<< "$cvn"
                    printf "  ${YELLOW}%-4s${NC} %-30s ${WHITE}%-40s${NC} ${GRAY}kubectl cordon %s${NC}\n" "$cv_idx" "${cv_inst_name:0:30}" "${cv_k8s_node:0:40}" "$cv_k8s_node"
                done
                echo ""
                echo -n -e "${CYAN}Type 'yes' to cordon ${#cordon_valid_nodes[@]} node(s): ${NC}"
                read -r cordon_confirm
                if [[ "$cordon_confirm" != "yes" ]]; then
                    echo -e "${YELLOW}Cancelled${NC}"
                    continue
                fi
                echo ""
                local cordon_success=0 cordon_fail=0
                for cvn in "${cordon_valid_nodes[@]}"; do
                    local cv_idx cv_inst_name cv_k8s_node
                    IFS='|' read -r cv_idx cv_inst_name cv_k8s_node <<< "$cvn"
                    echo -e "${WHITE}[#$cv_idx] ${cv_inst_name} → ${cv_k8s_node}${NC}"
                    echo -e "${GRAY}$ kubectl cordon ${cv_k8s_node}${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: kubectl cordon ${cv_k8s_node}" >> "$cordon_log_file"
                    if kubectl cordon "$cv_k8s_node" 2>&1; then
                        echo -e "  ${GREEN}✓ Node cordoned${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Cordoned ${cv_k8s_node}" >> "$cordon_log_file"
                        ((cordon_success++))
                    else
                        echo -e "  ${RED}✗ Failed to cordon${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Cordon ${cv_k8s_node}" >> "$cordon_log_file"
                        ((cordon_fail++))
                    fi
                    echo ""
                done
                echo -e "${BOLD}${WHITE}═══ Cordon Complete ═══${NC}"
                echo -e "  ${GREEN}Success: $cordon_success${NC}  ${RED}Failed: $cordon_fail${NC}  ${WHITE}Total: ${#cordon_valid_nodes[@]}${NC}"
                echo -e "${GRAY}Log: $cordon_log_file${NC}"
                echo ""
                echo -n -e "${CYAN}Press Enter to continue...${NC}"
                read -r
                continue
            fi
        fi
        
        #----------------------------------------------------------------------
        # Drain command (events-based): drain 1 / drain 1,3,5 / drain all
        #----------------------------------------------------------------------
        if [[ "$me_selection" =~ ^drain[[:space:]]+(.+)$ ]]; then
            local drain_targets="${BASH_REMATCH[1]}"
            
            # Detect m-prefix targets → route to instances bulk handler
            if [[ "$drain_targets" =~ ^m ]]; then
                me_selection="drain ${drain_targets}"
            else
                # Events-based drain (numeric indices)
                local drain_log_file="${LOGS_DIR}/maintenance_events_actions.log"
                declare -a drain_indices=()
                
                if [[ "$drain_targets" == "all" || "$drain_targets" == "ALL" ]]; then
                    for ((di=1; di<=me_idx; di++)); do
                        drain_indices+=("$di")
                    done
                else
                    IFS=',' read -ra drain_parts <<< "$drain_targets"
                    for dpart in "${drain_parts[@]}"; do
                        dpart=$(echo "$dpart" | tr -d ' ')
                        if [[ "$dpart" =~ ^([0-9]+)-([0-9]+)$ ]]; then
                            local dr_start="${BASH_REMATCH[1]}" dr_end="${BASH_REMATCH[2]}"
                            for ((di=dr_start; di<=dr_end; di++)); do
                                [[ $di -ge 1 && $di -le $me_idx ]] && drain_indices+=("$di")
                            done
                        elif [[ "$dpart" =~ ^[0-9]+$ ]]; then
                            [[ $dpart -ge 1 && $dpart -le $me_idx ]] && drain_indices+=("$dpart")
                        fi
                    done
                fi
                
                if [[ ${#drain_indices[@]} -eq 0 ]]; then
                    echo -e "${RED}No valid events selected${NC}"
                    continue
                fi
                
                declare -a drain_valid_nodes=()
                declare -a drain_skipped=()
                
                for di_idx in "${drain_indices[@]}"; do
                    local di_info="${ME_EVENT_MAP[$di_idx]:-}"
                    [[ -z "$di_info" ]] && continue
                    local di_evt_id di_inst_id di_reason di_category di_lifecycle di_window_start di_hard_due di_can_resched di_evt_name di_inst_name di_k8s_node di_shape di_state di_instance_action di_additional
                    IFS='|' read -r di_evt_id di_inst_id di_reason di_category di_lifecycle di_window_start di_hard_due di_can_resched di_evt_name di_inst_name di_k8s_node di_shape di_state di_instance_action di_additional <<< "$di_info"
                    
                    if [[ "$di_k8s_node" == "N/A" || -z "$di_k8s_node" ]]; then
                        drain_skipped+=("$di_idx|$di_inst_name|not a K8s node")
                        continue
                    fi
                    drain_valid_nodes+=("$di_idx|$di_inst_name|$di_k8s_node")
                done
                
                [[ ${#drain_skipped[@]} -gt 0 ]] && {
                    echo ""
                    echo -e "${YELLOW}Skipping ${#drain_skipped[@]} event(s):${NC}"
                    for skip_entry in "${drain_skipped[@]}"; do
                        local skip_idx skip_name skip_reason
                        IFS='|' read -r skip_idx skip_name skip_reason <<< "$skip_entry"
                        echo -e "  ${GRAY}#$skip_idx ${skip_name} - ${skip_reason}${NC}"
                    done
                }
                
                if [[ ${#drain_valid_nodes[@]} -eq 0 ]]; then
                    echo -e "${RED}No valid K8s nodes to drain${NC}"
                    continue
                fi
                
                echo ""
                echo -e "${BOLD}${CYAN}═══ DRAIN K8S NODES ═══${NC}"
                echo -e "${RED}⚠️  WARNING: This will evict all pods from ${#drain_valid_nodes[@]} node(s)!${NC}"
                echo ""
                printf "  ${BOLD}%-4s %-30s %-40s %-60s${NC}\n" "#" "Instance Name" "K8s Node" "Command"
                print_separator 140
                for dvn in "${drain_valid_nodes[@]}"; do
                    local dv_idx dv_inst_name dv_k8s_node
                    IFS='|' read -r dv_idx dv_inst_name dv_k8s_node <<< "$dvn"
                    printf "  ${YELLOW}%-4s${NC} %-30s ${WHITE}%-40s${NC} ${GRAY}kubectl drain %s --ignore-daemonsets --delete-emptydir-data --force${NC}\n" "$dv_idx" "${dv_inst_name:0:30}" "${dv_k8s_node:0:40}" "$dv_k8s_node"
                done
                echo ""
                echo -n -e "${RED}Type 'yes' to drain ${#drain_valid_nodes[@]} node(s): ${NC}"
                local drain_confirm
                read -r drain_confirm
                if [[ "$drain_confirm" != "yes" ]]; then
                    echo -e "${YELLOW}Cancelled${NC}"
                    continue
                fi
                echo ""
                local drain_success=0 drain_fail=0
                for dvn in "${drain_valid_nodes[@]}"; do
                    local dv_idx dv_inst_name dv_k8s_node
                    IFS='|' read -r dv_idx dv_inst_name dv_k8s_node <<< "$dvn"
                    echo -e "${WHITE}[#$dv_idx] ${dv_inst_name} → ${dv_k8s_node}${NC}"
                    echo -e "${GRAY}$ kubectl drain ${dv_k8s_node} --ignore-daemonsets --delete-emptydir-data --force${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: kubectl drain ${dv_k8s_node} --ignore-daemonsets --delete-emptydir-data --force" >> "$drain_log_file"
                    if kubectl drain "$dv_k8s_node" --ignore-daemonsets --delete-emptydir-data --force 2>&1; then
                        echo -e "  ${GREEN}✓ Node drained${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Drained ${dv_k8s_node}" >> "$drain_log_file"
                        ((drain_success++))
                    else
                        echo -e "  ${RED}✗ Failed to drain${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Drain ${dv_k8s_node}" >> "$drain_log_file"
                        ((drain_fail++))
                    fi
                    echo ""
                done
                echo -e "${BOLD}${WHITE}═══ Drain Complete ═══${NC}"
                echo -e "  ${GREEN}Success: $drain_success${NC}  ${RED}Failed: $drain_fail${NC}  ${WHITE}Total: ${#drain_valid_nodes[@]}${NC}"
                echo -e "${GRAY}Log: $drain_log_file${NC}"
                echo ""
                echo -n -e "${CYAN}Press Enter to continue...${NC}"
                read -r
                continue
            fi
        fi
        
        #----------------------------------------------------------------------
        # Cordon-Drain command (events-based): cordon-drain 1 / cordon-drain all
        #----------------------------------------------------------------------
        if [[ "$me_selection" =~ ^cordon-drain[[:space:]]+(.+)$ ]]; then
            local cd_targets="${BASH_REMATCH[1]}"
            
            # Detect m-prefix targets → route to instances bulk handler
            if [[ "$cd_targets" =~ ^m ]]; then
                me_selection="cordon-drain ${cd_targets}"
            else
                # Events-based cordon-drain (numeric indices)
                local cd_log_file="${LOGS_DIR}/maintenance_events_actions.log"
                declare -a cd_indices=()
                
                if [[ "$cd_targets" == "all" || "$cd_targets" == "ALL" ]]; then
                    for ((cdi=1; cdi<=me_idx; cdi++)); do
                        cd_indices+=("$cdi")
                    done
                else
                    IFS=',' read -ra cd_parts <<< "$cd_targets"
                    for cdpart in "${cd_parts[@]}"; do
                        cdpart=$(echo "$cdpart" | tr -d ' ')
                        if [[ "$cdpart" =~ ^([0-9]+)-([0-9]+)$ ]]; then
                            local cdr_start="${BASH_REMATCH[1]}" cdr_end="${BASH_REMATCH[2]}"
                            for ((cdi=cdr_start; cdi<=cdr_end; cdi++)); do
                                [[ $cdi -ge 1 && $cdi -le $me_idx ]] && cd_indices+=("$cdi")
                            done
                        elif [[ "$cdpart" =~ ^[0-9]+$ ]]; then
                            [[ $cdpart -ge 1 && $cdpart -le $me_idx ]] && cd_indices+=("$cdpart")
                        fi
                    done
                fi
                
                if [[ ${#cd_indices[@]} -eq 0 ]]; then
                    echo -e "${RED}No valid events selected${NC}"
                    continue
                fi
                
                declare -a cd_valid_nodes=()
                declare -a cd_skipped=()
                
                for cdi_idx in "${cd_indices[@]}"; do
                    local cdi_info="${ME_EVENT_MAP[$cdi_idx]:-}"
                    [[ -z "$cdi_info" ]] && continue
                    local cdi_evt_id cdi_inst_id cdi_reason cdi_category cdi_lifecycle cdi_window_start cdi_hard_due cdi_can_resched cdi_evt_name cdi_inst_name cdi_k8s_node cdi_shape cdi_state cdi_instance_action cdi_additional
                    IFS='|' read -r cdi_evt_id cdi_inst_id cdi_reason cdi_category cdi_lifecycle cdi_window_start cdi_hard_due cdi_can_resched cdi_evt_name cdi_inst_name cdi_k8s_node cdi_shape cdi_state cdi_instance_action cdi_additional <<< "$cdi_info"
                    
                    if [[ "$cdi_k8s_node" == "N/A" || -z "$cdi_k8s_node" ]]; then
                        cd_skipped+=("$cdi_idx|$cdi_inst_name|not a K8s node")
                        continue
                    fi
                    cd_valid_nodes+=("$cdi_idx|$cdi_inst_name|$cdi_k8s_node")
                done
                
                [[ ${#cd_skipped[@]} -gt 0 ]] && {
                    echo ""
                    echo -e "${YELLOW}Skipping ${#cd_skipped[@]} event(s):${NC}"
                    for skip_entry in "${cd_skipped[@]}"; do
                        local skip_idx skip_name skip_reason
                        IFS='|' read -r skip_idx skip_name skip_reason <<< "$skip_entry"
                        echo -e "  ${GRAY}#$skip_idx ${skip_name} - ${skip_reason}${NC}"
                    done
                }
                
                if [[ ${#cd_valid_nodes[@]} -eq 0 ]]; then
                    echo -e "${RED}No valid K8s nodes to cordon & drain${NC}"
                    continue
                fi
                
                echo ""
                echo -e "${BOLD}${CYAN}═══ CORDON & DRAIN K8S NODES ═══${NC}"
                echo -e "${RED}⚠️  This will cordon then drain ${#cd_valid_nodes[@]} node(s)!${NC}"
                echo ""
                printf "  ${BOLD}%-4s %-30s %-40s${NC}\n" "#" "Instance Name" "K8s Node"
                print_separator 80
                for cdn in "${cd_valid_nodes[@]}"; do
                    local cd_idx cd_inst_name cd_k8s_node
                    IFS='|' read -r cd_idx cd_inst_name cd_k8s_node <<< "$cdn"
                    printf "  ${YELLOW}%-4s${NC} %-30s ${WHITE}%-40s${NC}\n" "$cd_idx" "${cd_inst_name:0:30}" "${cd_k8s_node:0:40}"
                done
                echo ""
                echo -n -e "${RED}Type 'yes' to cordon & drain ${#cd_valid_nodes[@]} node(s): ${NC}"
                local cd_confirm
                read -r cd_confirm
                if [[ "$cd_confirm" != "yes" ]]; then
                    echo -e "${YELLOW}Cancelled${NC}"
                    continue
                fi
                echo ""
                local cd_success=0 cd_fail=0
                for cdn in "${cd_valid_nodes[@]}"; do
                    local cd_idx cd_inst_name cd_k8s_node
                    IFS='|' read -r cd_idx cd_inst_name cd_k8s_node <<< "$cdn"
                    echo -e "${WHITE}[#$cd_idx] ${cd_inst_name} → ${cd_k8s_node}${NC}"
                    
                    # Step 1: Cordon
                    echo -e "${GRAY}$ kubectl cordon ${cd_k8s_node}${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: kubectl cordon ${cd_k8s_node}" >> "$cd_log_file"
                    if kubectl cordon "$cd_k8s_node" 2>&1; then
                        echo -e "  ${GREEN}✓ Node cordoned${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Cordoned ${cd_k8s_node}" >> "$cd_log_file"
                    else
                        echo -e "  ${RED}✗ Failed to cordon - skipping drain${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Cordon ${cd_k8s_node} - skipping drain" >> "$cd_log_file"
                        ((cd_fail++))
                        echo ""
                        continue
                    fi
                    
                    # Step 2: Drain
                    echo -e "${GRAY}$ kubectl drain ${cd_k8s_node} --ignore-daemonsets --delete-emptydir-data --force${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: kubectl drain ${cd_k8s_node} --ignore-daemonsets --delete-emptydir-data --force" >> "$cd_log_file"
                    if kubectl drain "$cd_k8s_node" --ignore-daemonsets --delete-emptydir-data --force 2>&1; then
                        echo -e "  ${GREEN}✓ Node drained${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Drained ${cd_k8s_node}" >> "$cd_log_file"
                        ((cd_success++))
                    else
                        echo -e "  ${RED}✗ Failed to drain (node remains cordoned)${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Drain ${cd_k8s_node} (remains cordoned)" >> "$cd_log_file"
                        ((cd_fail++))
                    fi
                    echo ""
                done
                echo -e "${BOLD}${WHITE}═══ Cordon & Drain Complete ═══${NC}"
                echo -e "  ${GREEN}Success: $cd_success${NC}  ${RED}Failed: $cd_fail${NC}  ${WHITE}Total: ${#cd_valid_nodes[@]}${NC}"
                echo -e "${GRAY}Log: $cd_log_file${NC}"
                echo ""
                echo -n -e "${CYAN}Press Enter to continue...${NC}"
                read -r
                continue
            fi
        fi
        
        #----------------------------------------------------------------------
        # Instances bulk operations: cordon/drain/cordon-drain/uncordon/terminate m#
        #----------------------------------------------------------------------
        if [[ "$me_selection" =~ ^(cordon-drain|cordon|drain|uncordon|terminate)[[:space:]]+(m.*) ]]; then
            local bulk_action="${BASH_REMATCH[1]}"
            local bulk_targets="${BASH_REMATCH[2]}"
            
            if [[ "$bulk_targets" == "mall" || "$bulk_targets" == "MALL" ]]; then
                bulk_targets=$(echo "${!MAINT_INSTANCE_MAP[@]}" | tr ' ' ',')
            fi
            
            local target_list=() valid_instances=() invalid_instances=() non_k8s_instances=()
            IFS=',' read -ra target_list <<< "$bulk_targets"
            
            for target in "${target_list[@]}"; do
                target=$(echo "$target" | tr -d ' ')
                local inst_info="${MAINT_INSTANCE_MAP[$target]:-}"
                if [[ -z "$inst_info" ]]; then
                    invalid_instances+=("$target")
                    continue
                fi
                local inst_ocid inst_k8s_node inst_name inst_cordon
                IFS='|' read -r inst_ocid inst_k8s_node inst_name inst_cordon <<< "$inst_info"
                if [[ "$bulk_action" != "terminate" && ("$inst_k8s_node" == "N/A" || -z "$inst_k8s_node") ]]; then
                    non_k8s_instances+=("$target:$inst_name")
                    continue
                fi
                valid_instances+=("$target|$inst_ocid|$inst_k8s_node|$inst_name|$inst_cordon")
            done
            
            [[ ${#invalid_instances[@]} -gt 0 ]] && echo -e "${RED}Invalid: ${invalid_instances[*]}${NC}"
            [[ ${#non_k8s_instances[@]} -gt 0 ]] && echo -e "${YELLOW}Skipping (not K8s): ${non_k8s_instances[*]}${NC}"
            
            if [[ ${#valid_instances[@]} -eq 0 ]]; then
                echo -e "${RED}No valid instances selected${NC}"
                continue
            fi
            
            echo ""
            echo -e "${BOLD}${WHITE}═══ BULK ${bulk_action^^} - ${#valid_instances[@]} instance(s) ═══${NC}"
            echo ""
            printf "${BOLD}%-6s %-28s %-20s %-60s${NC}\n" "ID" "Instance Name" "K8s Node" "Command"
            print_separator 120
            for inst_entry in "${valid_instances[@]}"; do
                local idx inst_ocid inst_k8s_node inst_name inst_cordon
                IFS='|' read -r idx inst_ocid inst_k8s_node inst_name inst_cordon <<< "$inst_entry"
                local cmd=""
                case "$bulk_action" in
                    cordon) cmd="kubectl cordon ${inst_k8s_node}" ;;
                    drain) cmd="kubectl drain ${inst_k8s_node} --ignore-daemonsets --delete-emptydir-data --force" ;;
                    cordon-drain) cmd="kubectl cordon + drain ${inst_k8s_node}" ;;
                    uncordon) cmd="kubectl uncordon ${inst_k8s_node}" ;;
                    terminate) cmd="oci compute instance terminate --instance-id ${inst_ocid} --preserve-boot-volume false --force" ;;
                esac
                printf "${YELLOW}%-6s${NC} %-28s %-20s ${WHITE}%s${NC}\n" "$idx" "${inst_name:0:27}" "${inst_k8s_node:0:19}" "$cmd"
            done
            echo ""
            [[ "$bulk_action" == "drain" || "$bulk_action" == "cordon-drain" ]] && echo -e "${RED}⚠️  WARNING: This will evict all pods from ${#valid_instances[@]} node(s)!${NC}"
            [[ "$bulk_action" == "terminate" ]] && echo -e "${RED}⚠️  WARNING: This will PERMANENTLY TERMINATE ${#valid_instances[@]} instance(s)!${NC}"
            echo ""
            local confirm_text="yes"
            [[ "$bulk_action" == "terminate" ]] && confirm_text="TERMINATE"
            echo -n -e "${RED}Type '${confirm_text}' to execute: ${NC}"
            read -r confirm
            if [[ "$confirm" == "$confirm_text" ]]; then
                echo ""
                local success_count=0 fail_count=0
                for inst_entry in "${valid_instances[@]}"; do
                    local idx inst_ocid inst_k8s_node inst_name inst_cordon
                    IFS='|' read -r idx inst_ocid inst_k8s_node inst_name inst_cordon <<< "$inst_entry"
                    
                    if [[ "$bulk_action" == "cordon-drain" ]]; then
                        # Two-step: cordon then drain
                        echo -e "${YELLOW}[$idx] Step 1 - Cordon:${NC} kubectl cordon ${inst_k8s_node}"
                        if eval "kubectl cordon ${inst_k8s_node}" 2>&1; then
                            echo -e "${GREEN}  ✓ Cordoned${NC}"
                            echo "[$(date '+%Y-%m-%d %H:%M:%S')] CORDON: kubectl cordon ${inst_k8s_node}" >> "$MAINTENANCE_LOG_FILE"
                        else
                            echo -e "${RED}  ✗ Cordon failed - skipping drain${NC}"
                            echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED CORDON: kubectl cordon ${inst_k8s_node}" >> "$MAINTENANCE_LOG_FILE"
                            ((fail_count++))
                            echo ""
                            continue
                        fi
                        echo -e "${YELLOW}[$idx] Step 2 - Drain:${NC} kubectl drain ${inst_k8s_node} --ignore-daemonsets --delete-emptydir-data --force"
                        if eval "kubectl drain ${inst_k8s_node} --ignore-daemonsets --delete-emptydir-data --force" 2>&1; then
                            echo -e "${GREEN}  ✓ Drained${NC}"
                            echo "[$(date '+%Y-%m-%d %H:%M:%S')] DRAIN: kubectl drain ${inst_k8s_node} --ignore-daemonsets --delete-emptydir-data --force" >> "$MAINTENANCE_LOG_FILE"
                            ((success_count++))
                        else
                            echo -e "${RED}  ✗ Drain failed (node remains cordoned)${NC}"
                            echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED DRAIN: kubectl drain ${inst_k8s_node} (remains cordoned)" >> "$MAINTENANCE_LOG_FILE"
                            ((fail_count++))
                        fi
                    else
                        local cmd="" log_cmd=""
                        case "$bulk_action" in
                            cordon) cmd="kubectl cordon ${inst_k8s_node}"; log_cmd="CORDON: $cmd" ;;
                            drain) cmd="kubectl drain ${inst_k8s_node} --ignore-daemonsets --delete-emptydir-data --force"; log_cmd="DRAIN: $cmd" ;;
                            uncordon) cmd="kubectl uncordon ${inst_k8s_node}"; log_cmd="UNCORDON: $cmd" ;;
                            terminate) cmd="oci compute instance terminate --instance-id ${inst_ocid} --preserve-boot-volume false --force"; log_cmd="TERMINATE: $cmd" ;;
                        esac
                        echo -e "${YELLOW}[$idx] Executing:${NC} $cmd"
                        if eval "$cmd" 2>&1; then
                            echo -e "${GREEN}  ✓ Success: ${inst_name}${NC}"
                            ((success_count++))
                            echo "[$(date '+%Y-%m-%d %H:%M:%S')] $log_cmd" >> "$MAINTENANCE_LOG_FILE"
                        else
                            echo -e "${RED}  ✗ Failed: ${inst_name}${NC}"
                            ((fail_count++))
                            echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED $log_cmd" >> "$MAINTENANCE_LOG_FILE"
                        fi
                    fi
                    echo ""
                done
                echo -e "${BOLD}${WHITE}═══ Bulk Operation Complete ═══${NC}"
                echo -e "  ${GREEN}Success:${NC} $success_count  ${RED}Failed:${NC} $fail_count"
                echo -e "  ${GRAY}Log:${NC} $MAINTENANCE_LOG_FILE"
            else
                echo -e "${YELLOW}Cancelled${NC}"
            fi
            echo ""
            continue
        fi
        
        #----------------------------------------------------------------------
        # Pods on nodes: pods m1,m2 or pods 1,2 (p #) or pods all
        #----------------------------------------------------------------------
        if [[ "$me_selection" =~ ^pods[[:space:]]+(.*) ]]; then
            local pods_targets="${BASH_REMATCH[1]}"
            
            local pods_valid=() pods_invalid=() pods_non_k8s=()
            
            # Detect target type: numeric (events) or m# (instances)
            if [[ "$pods_targets" =~ ^[0-9] || "$pods_targets" == "all" ]]; then
                # Event-based pods: resolve event indices to k8s nodes
                local pods_evt_indices=()
                if [[ "$pods_targets" == "all" || "$pods_targets" == "ALL" ]]; then
                    for ((pei=1; pei<=me_idx; pei++)); do pods_evt_indices+=("$pei"); done
                else
                    IFS=',' read -ra pods_evt_indices <<< "$pods_targets"
                fi
                
                for pei in "${pods_evt_indices[@]}"; do
                    pei=$(echo "$pei" | tr -d ' ')
                    local pe_info="${ME_EVENT_MAP[$pei]:-}"
                    if [[ -z "$pe_info" ]]; then pods_invalid+=("$pei"); continue; fi
                    local pe_k8s_node pe_inst_name
                    pe_k8s_node=$(echo "$pe_info" | cut -d'|' -f11)
                    pe_inst_name=$(echo "$pe_info" | cut -d'|' -f10)
                    if [[ "$pe_k8s_node" == "N/A" || -z "$pe_k8s_node" ]]; then
                        pods_non_k8s+=("${pei}:${pe_inst_name}")
                        continue
                    fi
                    pods_valid+=("${pei}|${pe_k8s_node}|${pe_inst_name}")
                done
            else
                # m# instance-based pods
                [[ "$pods_targets" == "mall" || "$pods_targets" == "MALL" ]] && pods_targets=$(echo "${!MAINT_INSTANCE_MAP[@]}" | tr ' ' ',')
                IFS=',' read -ra pods_list <<< "$pods_targets"
                for pt in "${pods_list[@]}"; do
                    pt=$(echo "$pt" | tr -d ' ')
                    local pi="${MAINT_INSTANCE_MAP[$pt]:-}"
                    if [[ -z "$pi" ]]; then pods_invalid+=("$pt"); continue; fi
                    local po pk pn pc
                    IFS='|' read -r po pk pn pc <<< "$pi"
                    if [[ "$pk" == "N/A" || -z "$pk" ]]; then pods_non_k8s+=("$pt:$pn"); continue; fi
                    pods_valid+=("$pt|$pk|$pn")
                done
            fi
            [[ ${#pods_invalid[@]} -gt 0 ]] && echo -e "${RED}Invalid: ${pods_invalid[*]}${NC}"
            [[ ${#pods_non_k8s[@]} -gt 0 ]] && echo -e "${YELLOW}Skipping (not K8s): ${pods_non_k8s[*]}${NC}"
            if [[ ${#pods_valid[@]} -eq 0 ]]; then echo -e "${RED}No valid nodes${NC}"; continue; fi
            
            echo ""
            echo -e "${BOLD}${CYAN}═══ PODS ON ${#pods_valid[@]} NODE(S) ═══${NC}"
            for pv in "${pods_valid[@]}"; do
                local pv_idx pv_node pv_name
                IFS='|' read -r pv_idx pv_node pv_name <<< "$pv"
                echo ""
                echo -e "${BOLD}${WHITE}─── [$pv_idx] ${CYAN}$pv_name${NC} ${GRAY}(node: $pv_node)${NC} ${BOLD}${WHITE}───${NC}"
                echo ""
                local node_pods
                node_pods=$(kubectl get pods --all-namespaces --field-selector "spec.nodeName=$pv_node" -o wide 2>/dev/null)
                if [[ -n "$node_pods" ]]; then
                    local pod_count
                    pod_count=$(echo "$node_pods" | tail -n +2 | wc -l)
                    echo -e "${WHITE}Total Pods: ${CYAN}$pod_count${NC}"
                    echo ""
                    echo "$node_pods" | head -1 | while IFS= read -r line; do echo -e "${BOLD}${WHITE}$line${NC}"; done
                    echo "$node_pods" | tail -n +2 | while IFS= read -r line; do
                        if echo "$line" | grep -q "Running"; then echo -e "${GREEN}$line${NC}"
                        elif echo "$line" | grep -q "Completed"; then echo -e "${GRAY}$line${NC}"
                        elif echo "$line" | grep -qE "Error|Failed|CrashLoopBackOff|ImagePullBackOff"; then echo -e "${RED}$line${NC}"
                        elif echo "$line" | grep -qE "Pending|ContainerCreating|Init"; then echo -e "${YELLOW}$line${NC}"
                        else echo "$line"; fi
                    done
                else
                    echo -e "${GRAY}No pods found on this node${NC}"
                fi
            done
            echo ""
            continue
        fi
        
        #----------------------------------------------------------------------
        # Instance management: m# single instance
        #----------------------------------------------------------------------
        if [[ "$me_selection" =~ ^m[0-9]+$ ]]; then
            local mi_info="${MAINT_INSTANCE_MAP[$me_selection]:-}"
            if [[ -z "$mi_info" ]]; then
                echo -e "${RED}Invalid selection: $me_selection${NC}"
                continue
            fi
            local mi_ocid mi_k8s_node mi_name mi_cordon
            IFS='|' read -r mi_ocid mi_k8s_node mi_name mi_cordon <<< "$mi_info"
            
            echo ""
            echo -e "${BOLD}${WHITE}═══ Instance: ${CYAN}${mi_name}${NC} ${BOLD}${WHITE}═══${NC}"
            echo -e "  ${WHITE}OCID:${NC}     $mi_ocid"
            echo -e "  ${WHITE}K8s Node:${NC} $mi_k8s_node"
            echo -e "  ${WHITE}Cordoned:${NC} $mi_cordon"
            echo ""
            echo -e "${BOLD}${WHITE}Actions:${NC}"
            echo -e "  ${YELLOW}1${NC}) Cordon node"
            echo -e "  ${YELLOW}2${NC}) Drain node"
            echo -e "  ${YELLOW}3${NC}) Uncordon node"
            echo -e "  ${RED}4${NC}) Terminate instance"
            echo -e "  ${CYAN}5${NC}) View instance details"
            echo -e "  ${YELLOW}6${NC}) Cordon & Drain node"
            echo -e "  ${CYAN}b${NC}) Back"
            echo ""
            echo -n -e "${CYAN}Action: ${NC}"
            read -r mi_action
            case "$mi_action" in
                1)
                    if [[ "$mi_k8s_node" == "N/A" || -z "$mi_k8s_node" ]]; then echo -e "${RED}Not a K8s node${NC}"; continue; fi
                    echo -e "${GRAY}$ kubectl cordon ${mi_k8s_node}${NC}"
                    echo -n -e "${CYAN}Confirm? (yes/no): ${NC}"
                    read -r c; if [[ "$c" == "yes" ]]; then
                        kubectl cordon "$mi_k8s_node" 2>&1 && echo -e "${GREEN}✓ Cordoned${NC}" || echo -e "${RED}✗ Failed${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] CORDON: kubectl cordon ${mi_k8s_node}" >> "$MAINTENANCE_LOG_FILE"
                    else echo -e "${YELLOW}Cancelled${NC}"; fi ;;
                2)
                    if [[ "$mi_k8s_node" == "N/A" || -z "$mi_k8s_node" ]]; then echo -e "${RED}Not a K8s node${NC}"; continue; fi
                    echo -e "${GRAY}$ kubectl drain ${mi_k8s_node} --ignore-daemonsets --delete-emptydir-data --force${NC}"
                    echo -e "${RED}⚠️  This will evict all pods!${NC}"
                    echo -n -e "${CYAN}Confirm? (yes/no): ${NC}"
                    read -r c; if [[ "$c" == "yes" ]]; then
                        kubectl drain "$mi_k8s_node" --ignore-daemonsets --delete-emptydir-data --force 2>&1 && echo -e "${GREEN}✓ Drained${NC}" || echo -e "${RED}✗ Failed${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] DRAIN: kubectl drain ${mi_k8s_node} --ignore-daemonsets --delete-emptydir-data --force" >> "$MAINTENANCE_LOG_FILE"
                    else echo -e "${YELLOW}Cancelled${NC}"; fi ;;
                3)
                    if [[ "$mi_k8s_node" == "N/A" || -z "$mi_k8s_node" ]]; then echo -e "${RED}Not a K8s node${NC}"; continue; fi
                    echo -e "${GRAY}$ kubectl uncordon ${mi_k8s_node}${NC}"
                    echo -n -e "${CYAN}Confirm? (yes/no): ${NC}"
                    read -r c; if [[ "$c" == "yes" ]]; then
                        kubectl uncordon "$mi_k8s_node" 2>&1 && echo -e "${GREEN}✓ Uncordoned${NC}" || echo -e "${RED}✗ Failed${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] UNCORDON: kubectl uncordon ${mi_k8s_node}" >> "$MAINTENANCE_LOG_FILE"
                    else echo -e "${YELLOW}Cancelled${NC}"; fi ;;
                6)
                    if [[ "$mi_k8s_node" == "N/A" || -z "$mi_k8s_node" ]]; then echo -e "${RED}Not a K8s node${NC}"; continue; fi
                    echo -e "${GRAY}Step 1: kubectl cordon ${mi_k8s_node}${NC}"
                    echo -e "${GRAY}Step 2: kubectl drain ${mi_k8s_node} --ignore-daemonsets --delete-emptydir-data --force${NC}"
                    echo -e "${RED}⚠️  This will cordon then drain (evict all pods)!${NC}"
                    echo -n -e "${CYAN}Confirm? (yes/no): ${NC}"
                    read -r c; if [[ "$c" == "yes" ]]; then
                        echo -e "${YELLOW}Cordoning...${NC}"
                        if kubectl cordon "$mi_k8s_node" 2>&1; then
                            echo -e "${GREEN}✓ Cordoned${NC}"
                            echo "[$(date '+%Y-%m-%d %H:%M:%S')] CORDON: kubectl cordon ${mi_k8s_node}" >> "$MAINTENANCE_LOG_FILE"
                            echo -e "${YELLOW}Draining...${NC}"
                            if kubectl drain "$mi_k8s_node" --ignore-daemonsets --delete-emptydir-data --force 2>&1; then
                                echo -e "${GREEN}✓ Drained${NC}"
                                echo "[$(date '+%Y-%m-%d %H:%M:%S')] DRAIN: kubectl drain ${mi_k8s_node} --ignore-daemonsets --delete-emptydir-data --force" >> "$MAINTENANCE_LOG_FILE"
                            else
                                echo -e "${RED}✗ Drain failed (node remains cordoned)${NC}"
                                echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED DRAIN: kubectl drain ${mi_k8s_node} (remains cordoned)" >> "$MAINTENANCE_LOG_FILE"
                            fi
                        else
                            echo -e "${RED}✗ Cordon failed - skipping drain${NC}"
                            echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED CORDON: kubectl cordon ${mi_k8s_node}" >> "$MAINTENANCE_LOG_FILE"
                        fi
                    else echo -e "${YELLOW}Cancelled${NC}"; fi ;;
                4)
                    echo -e "${GRAY}$ oci compute instance terminate --instance-id ${mi_ocid} --preserve-boot-volume false --force${NC}"
                    echo -e "${RED}⚠️  PERMANENT TERMINATION!${NC}"
                    echo -n -e "${RED}Type 'TERMINATE' to confirm: ${NC}"
                    read -r c; if [[ "$c" == "TERMINATE" ]]; then
                        oci compute instance terminate --instance-id "$mi_ocid" --preserve-boot-volume false --force 2>&1 && echo -e "${GREEN}✓ Terminated${NC}" || echo -e "${RED}✗ Failed${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] TERMINATE: oci compute instance terminate --instance-id ${mi_ocid} --preserve-boot-volume false --force" >> "$MAINTENANCE_LOG_FILE"
                    else echo -e "${YELLOW}Cancelled${NC}"; fi ;;
                5) display_instance_details "$mi_ocid" ;;
                b|B) ;;
                *) echo -e "${RED}Invalid action${NC}" ;;
            esac
            echo ""
            continue
        fi
        
        #----------------------------------------------------------------------
        # Announcement details: a#
        #----------------------------------------------------------------------
        if [[ "$me_selection" =~ ^a[0-9]+$ ]]; then
            local ann_info="${ANN_TICKET_MAP[$me_selection]:-}"
            if [[ -z "$ann_info" ]]; then
                echo -e "${RED}Invalid selection: $me_selection${NC}"
                continue
            fi
            local ann_ticket ann_file
            IFS='|' read -r ann_ticket ann_file <<< "$ann_info"
            echo ""
            echo -e "${BOLD}${YELLOW}═══ Announcement: ${ann_ticket} ═══${NC}"
            if [[ -n "$ann_file" && -f "$ann_file" ]]; then
                local full_ticket ann_type ann_summary ann_description ann_services
                local ann_time_start ann_time_end ann_time_created platform_type lifecycle_state
                full_ticket=$(jq -r '.data."reference-ticket-number" // "N/A"' "$ann_file")
                ann_type=$(jq -r '.data["announcement-type"] // "N/A"' "$ann_file")
                ann_summary=$(jq -r '.data.summary // "N/A"' "$ann_file")
                ann_description=$(jq -r '.data.description // "N/A"' "$ann_file")
                ann_services=$(jq -r '.data["affected-services"] // [] | join(", ")' "$ann_file")
                ann_time_start=$(jq -r '.data["time-one-value"] // "N/A"' "$ann_file")
                ann_time_end=$(jq -r '.data["time-two-value"] // "N/A"' "$ann_file")
                ann_time_created=$(jq -r '.data["time-created"] // "N/A"' "$ann_file")
                platform_type=$(jq -r '.data["platform-type"] // "N/A"' "$ann_file")
                lifecycle_state=$(jq -r '.data["lifecycle-state"] // "N/A"' "$ann_file")
                echo ""
                echo -e "  ${WHITE}Full Ticket:${NC}  $full_ticket"
                echo -e "  ${WHITE}Type:${NC}         $ann_type"
                echo -e "  ${WHITE}State:${NC}        $lifecycle_state"
                echo -e "  ${WHITE}Platform:${NC}     $platform_type"
                echo -e "  ${WHITE}Services:${NC}     $ann_services"
                echo -e "  ${WHITE}Created:${NC}      ${ann_time_created:0:19}"
                [[ "$ann_time_start" != "N/A" && "$ann_time_start" != "null" ]] && echo -e "  ${WHITE}Start Time:${NC}   ${ann_time_start:0:19}"
                [[ "$ann_time_end" != "N/A" && "$ann_time_end" != "null" ]] && echo -e "  ${WHITE}End Time:${NC}     ${ann_time_end:0:19}"
                echo ""
                echo -e "  ${WHITE}Summary:${NC}"
                echo -e "    ${CYAN}$ann_summary${NC}"
                echo ""
                if [[ "$ann_description" != "N/A" && "$ann_description" != "null" && -n "$ann_description" ]]; then
                    echo -e "  ${WHITE}Description:${NC}"
                    echo "$ann_description" | fold -s -w 90 | while IFS= read -r line; do echo -e "    ${GRAY}${line}${NC}"; done
                fi
                local resource_count
                resource_count=$(jq '.data."affected-resources" | length' "$ann_file" 2>/dev/null) || resource_count=0
                echo ""
                echo -e "  ${WHITE}Affected Resources:${NC} $resource_count"
            else
                echo -e "${RED}  Not cached. Run --refresh to fetch.${NC}"
            fi
            echo ""
            continue
        fi
        
        #----------------------------------------------------------------------
        # Reschedule: resched <selection>
        #----------------------------------------------------------------------
        if [[ "$me_selection" =~ ^resched[[:space:]]+(.+)$ ]]; then
            local resched_targets="${BASH_REMATCH[1]}"
            local log_file="${LOGS_DIR}/maintenance_events_actions.log"
            
            # Parse selection into indices (supports: 1,3,5 / 1-5 / all)
            declare -a resched_indices=()
            
            if [[ "$resched_targets" == "all" || "$resched_targets" == "ALL" ]]; then
                for ((ri=1; ri<=me_idx; ri++)); do
                    resched_indices+=("$ri")
                done
            else
                IFS=',' read -ra resched_parts <<< "$resched_targets"
                for rpart in "${resched_parts[@]}"; do
                    rpart=$(echo "$rpart" | tr -d ' ')
                    if [[ "$rpart" =~ ^([0-9]+)-([0-9]+)$ ]]; then
                        local rr_start="${BASH_REMATCH[1]}"
                        local rr_end="${BASH_REMATCH[2]}"
                        for ((ri=rr_start; ri<=rr_end; ri++)); do
                            [[ $ri -ge 1 && $ri -le $me_idx ]] && resched_indices+=("$ri")
                        done
                    elif [[ "$rpart" =~ ^[0-9]+$ ]]; then
                        [[ $rpart -ge 1 && $rpart -le $me_idx ]] && resched_indices+=("$rpart")
                    fi
                done
            fi
            
            if [[ ${#resched_indices[@]} -eq 0 ]]; then
                echo -e "${RED}No valid events selected${NC}"
                continue
            fi
            
            # If single event, use the single-event reschedule flow
            if [[ ${#resched_indices[@]} -eq 1 ]]; then
                local si_idx="${resched_indices[0]}"
                local si_info="${ME_EVENT_MAP[$si_idx]:-}"
                if [[ -z "$si_info" ]]; then
                    echo -e "${RED}Invalid event number: $si_idx${NC}"
                    continue
                fi
                local si_evt_id si_inst_id si_reason si_category si_lifecycle si_window_start si_hard_due si_can_resched si_evt_name si_inst_name si_k8s_node si_shape si_state si_instance_action si_additional
                IFS='|' read -r si_evt_id si_inst_id si_reason si_category si_lifecycle si_window_start si_hard_due si_can_resched si_evt_name si_inst_name si_k8s_node si_shape si_state si_instance_action si_additional <<< "$si_info"
                if [[ "$si_can_resched" != "true" ]]; then
                    echo -e "${RED}Event #$si_idx cannot be rescheduled (can-reschedule: ${si_can_resched})${NC}"
                    continue
                fi
                reschedule_maintenance_event "$si_evt_id" "$si_evt_name" "$si_window_start" "$compartment_id" "$region"
                continue
            fi
            
            # Bulk reschedule flow
            echo ""
            echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
            echo -e "${BOLD}${CYAN}                                              BULK RESCHEDULE MAINTENANCE EVENTS                                                             ${NC}"
            echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
            echo ""
            
            # Validate and collect reschedulable events
            declare -a bulk_valid_events=()
            declare -a bulk_skipped_events=()
            
            for bi in "${resched_indices[@]}"; do
                local bi_info="${ME_EVENT_MAP[$bi]:-}"
                if [[ -z "$bi_info" ]]; then
                    echo -e "${RED}  Skipping invalid event #$bi${NC}"
                    continue
                fi
                local bi_evt_id bi_inst_id bi_reason bi_category bi_lifecycle bi_window_start bi_hard_due bi_can_resched bi_evt_name bi_inst_name bi_k8s_node bi_shape bi_state bi_instance_action bi_additional
                IFS='|' read -r bi_evt_id bi_inst_id bi_reason bi_category bi_lifecycle bi_window_start bi_hard_due bi_can_resched bi_evt_name bi_inst_name bi_k8s_node bi_shape bi_state bi_instance_action bi_additional <<< "$bi_info"
                
                if [[ "$bi_can_resched" != "true" ]]; then
                    bulk_skipped_events+=("$bi|$bi_inst_name|$bi_evt_name|cannot reschedule")
                    continue
                fi
                
                bulk_valid_events+=("$bi|$bi_evt_id|$bi_inst_name|$bi_evt_name|$bi_window_start")
            done
            
            # Show skipped events
            if [[ ${#bulk_skipped_events[@]} -gt 0 ]]; then
                echo -e "${YELLOW}Skipping ${#bulk_skipped_events[@]} event(s) that cannot be rescheduled:${NC}"
                for skip_entry in "${bulk_skipped_events[@]}"; do
                    local skip_idx skip_inst skip_evt skip_reason
                    IFS='|' read -r skip_idx skip_inst skip_evt skip_reason <<< "$skip_entry"
                    echo -e "  ${GRAY}#$skip_idx ${skip_inst} - ${skip_reason}${NC}"
                done
                echo ""
            fi
            
            if [[ ${#bulk_valid_events[@]} -eq 0 ]]; then
                echo -e "${RED}No reschedulable events in selection${NC}"
                continue
            fi
            
            # Show events to be rescheduled
            echo -e "${BOLD}${WHITE}Events to reschedule (${#bulk_valid_events[@]}):${NC}"
            echo ""
            printf "  ${BOLD}%-4s %-42s %-35s %-25s${NC}\n" "#" "Instance Name" "Event" "Current Window Start"
            print_separator 115
            
            for bve in "${bulk_valid_events[@]}"; do
                local bv_idx bv_evt_id bv_inst_name bv_evt_name bv_window_start
                IFS='|' read -r bv_idx bv_evt_id bv_inst_name bv_evt_name bv_window_start <<< "$bve"
                printf "  ${YELLOW}%-4s${NC} %-42s %-35s ${WHITE}%-25s${NC}\n" \
                    "$bv_idx" "${bv_inst_name:0:42}" "${bv_evt_name:0:35}" "${bv_window_start:0:25}"
            done
            echo ""
            
            # Select new time (same preset menu)
            local bulk_t5m bulk_t10m bulk_t1h bulk_t24h
            bulk_t5m=$(date -u -d '+5 minutes' +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
            bulk_t10m=$(date -u -d '+10 minutes' +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
            bulk_t1h=$(date -u -d '+1 hour' +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
            bulk_t24h=$(date -u -d '+24 hours' +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
            
            # Fallback for macOS/BSD date
            if [[ -z "$bulk_t5m" ]]; then
                bulk_t5m=$(date -u -v+5M +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
                bulk_t10m=$(date -u -v+10M +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
                bulk_t1h=$(date -u -v+1H +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
                bulk_t24h=$(date -u -v+24H +'%Y-%m-%dT%H:%M:%S.000Z' 2>/dev/null)
            fi
            
            echo -e "${BOLD}${WHITE}─── New Schedule ───${NC}"
            echo ""
            echo -e "  ${YELLOW}1${NC}) 5 minutes from now   →  ${WHITE}${bulk_t5m}${NC}"
            echo -e "  ${YELLOW}2${NC}) 10 minutes from now  →  ${WHITE}${bulk_t10m}${NC}"
            echo -e "  ${YELLOW}3${NC}) 1 hour from now      →  ${WHITE}${bulk_t1h}${NC}"
            echo -e "  ${YELLOW}4${NC}) 24 hours from now    →  ${WHITE}${bulk_t24h}${NC}"
            echo -e "  ${YELLOW}5${NC}) Custom date/time (UTC)"
            echo -e "  ${YELLOW}b${NC}) Cancel"
            echo ""
            echo -n -e "${CYAN}Select [1-5/b]: ${NC}"
            read -r bulk_time_choice
            
            local bulk_new_time=""
            case "$bulk_time_choice" in
                1) bulk_new_time="$bulk_t5m" ;;
                2) bulk_new_time="$bulk_t10m" ;;
                3) bulk_new_time="$bulk_t1h" ;;
                4) bulk_new_time="$bulk_t24h" ;;
                5)
                    echo ""
                    echo -e "${GRAY}Enter UTC datetime in format: YYYY-MM-DDTHH:MM:SS.000Z${NC}"
                    echo -e "${GRAY}Example: 2026-02-04T15:30:00.000Z${NC}"
                    echo ""
                    echo -n -e "${CYAN}New time-window-start: ${NC}"
                    read -r bulk_custom_time
                    if [[ -z "$bulk_custom_time" ]]; then
                        echo -e "${YELLOW}Cancelled${NC}"
                        continue
                    fi
                    if [[ ! "$bulk_custom_time" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2} ]]; then
                        echo -e "${RED}Invalid datetime format${NC}"
                        continue
                    fi
                    [[ ! "$bulk_custom_time" =~ [Zz]$ && ! "$bulk_custom_time" =~ [+-][0-9] ]] && bulk_custom_time="${bulk_custom_time}Z"
                    bulk_new_time="$bulk_custom_time"
                    ;;
                b|B|"")
                    echo -e "${YELLOW}Cancelled${NC}"
                    continue
                    ;;
                *)
                    echo -e "${RED}Invalid selection${NC}"
                    continue
                    ;;
            esac
            
            # Show confirmation with all commands
            echo ""
            echo -e "${BOLD}${WHITE}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
            echo -e "${BOLD}${WHITE}  CONFIRM BULK RESCHEDULE - ${#bulk_valid_events[@]} event(s) → ${GREEN}${bulk_new_time}${NC}"
            echo -e "${BOLD}${WHITE}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
            echo ""
            
            printf "  ${BOLD}%-4s %-42s %-100s${NC}\n" "#" "Instance Name" "Command"
            print_separator 155
            
            for bve in "${bulk_valid_events[@]}"; do
                local bv_idx bv_evt_id bv_inst_name bv_evt_name bv_window_start
                IFS='|' read -r bv_idx bv_evt_id bv_inst_name bv_evt_name bv_window_start <<< "$bve"
                local bv_cmd="oci compute instance-maintenance-event update --instance-maintenance-event-id $bv_evt_id --time-window-start $bulk_new_time"
                printf "  ${YELLOW}%-4s${NC} %-42s ${WHITE}%s${NC}\n" \
                    "$bv_idx" "${bv_inst_name:0:42}" "$bv_cmd"
            done
            
            echo ""
            echo -e "${YELLOW}⚠ This will reschedule ${#bulk_valid_events[@]} maintenance event(s) to ${WHITE}${bulk_new_time}${NC}"
            echo ""
            echo -n -e "${RED}Type 'yes' to execute all ${#bulk_valid_events[@]} reschedule commands: ${NC}"
            read -r bulk_confirm
            
            if [[ "$bulk_confirm" != "yes" ]]; then
                echo -e "${YELLOW}Bulk reschedule cancelled${NC}"
                continue
            fi
            
            echo ""
            echo -e "${BOLD}${YELLOW}Executing bulk reschedule...${NC}"
            echo ""
            
            local bulk_success=0
            local bulk_fail=0
            
            for bve in "${bulk_valid_events[@]}"; do
                local bv_idx bv_evt_id bv_inst_name bv_evt_name bv_window_start
                IFS='|' read -r bv_idx bv_evt_id bv_inst_name bv_evt_name bv_window_start <<< "$bve"
                
                local bv_cmd="oci compute instance-maintenance-event update --instance-maintenance-event-id $bv_evt_id --time-window-start $bulk_new_time"
                
                echo -e "${WHITE}[#$bv_idx] ${bv_inst_name}${NC}"
                echo -e "${GRAY}$ $bv_cmd${NC}"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: $bv_cmd" >> "$log_file"
                
                local bv_output
                bv_output=$(oci compute instance-maintenance-event update \
                    --instance-maintenance-event-id "$bv_evt_id" \
                    --time-window-start "$bulk_new_time" \
                    --output json 2>&1)
                local bv_rc=$?
                
                if [[ $bv_rc -eq 0 ]]; then
                    local bv_new_window
                    bv_new_window=$(echo "$bv_output" | jq -r '.data["time-window-start"] // "N/A"' 2>/dev/null)
                    echo -e "  ${GREEN}✓ Rescheduled → ${bv_new_window}${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Rescheduled $bv_inst_name ($bv_evt_id) to $bulk_new_time" >> "$log_file"
                    ((bulk_success++))
                else
                    echo -e "  ${RED}✗ Failed to reschedule${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Reschedule $bv_inst_name ($bv_evt_id) to $bulk_new_time" >> "$log_file"
                    local bv_err
                    bv_err=$(echo "$bv_output" | jq -r '.message // empty' 2>/dev/null)
                    [[ -n "$bv_err" ]] && echo -e "  ${GRAY}$bv_err${NC}"
                    ((bulk_fail++))
                fi
                echo ""
            done
            
            # Summary
            echo -e "${BOLD}${WHITE}═══ Bulk Reschedule Complete ═══${NC}"
            echo -e "  ${GREEN}Success: $bulk_success${NC}  ${RED}Failed: $bulk_fail${NC}  ${WHITE}Total: ${#bulk_valid_events[@]}${NC}"
            
            # Invalidate cache
            rm -f "$MAINT_EVENTS_CACHE" "$FAULT_DETAILS_CACHE"
            echo -e "${GRAY}Cache invalidated - will refresh on next view${NC}"
            echo -e "${GRAY}Log: $log_file${NC}"
            echo ""
            echo -n -e "${CYAN}Press Enter to continue...${NC}"
            read -r
            continue
        fi
        
        # View event details: just a number
        if [[ "$me_selection" =~ ^[0-9]+$ ]]; then
            local detail_info="${ME_EVENT_MAP[$me_selection]:-}"
            
            if [[ -z "$detail_info" ]]; then
                echo -e "${RED}Invalid event number: $me_selection${NC}"
                continue
            fi
            
            local d_evt_id d_inst_id d_reason d_category d_lifecycle d_window_start d_hard_due d_can_resched d_evt_name d_inst_name d_k8s_node d_shape d_state d_instance_action d_additional
            IFS='|' read -r d_evt_id d_inst_id d_reason d_category d_lifecycle d_window_start d_hard_due d_can_resched d_evt_name d_inst_name d_k8s_node d_shape d_state d_instance_action d_additional <<< "$detail_info"
            
            echo ""
            echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
            echo -e "${BOLD}${CYAN}                                    MAINTENANCE EVENT DETAILS                                                    ${NC}"
            echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
            echo ""
            
            # Fetch full event details live for the freshest data
            echo -e "${GRAY}Fetching full event details...${NC}"
            local full_evt_json
            full_evt_json=$(oci compute instance-maintenance-event get \
                --instance-maintenance-event-id "$d_evt_id" \
                --region "$region" \
                --output json 2>/dev/null)
            
            if [[ -n "$full_evt_json" ]] && echo "$full_evt_json" | jq -e '.data' &>/dev/null; then
                # Extract all fields from the full response
                local f_display_name f_description f_instance_action f_reason f_category f_lifecycle
                local f_window_start f_hard_due f_can_resched f_can_delete f_correlation f_created_by
                local f_time_created f_time_started f_time_finished f_estimated_duration f_instance_id
                
                f_display_name=$(echo "$full_evt_json" | jq -r '.data["display-name"] // "N/A"')
                f_description=$(echo "$full_evt_json" | jq -r '.data.description // "N/A"')
                f_instance_action=$(echo "$full_evt_json" | jq -r '.data["instance-action"] // "N/A"')
                f_reason=$(echo "$full_evt_json" | jq -r '.data["maintenance-reason"] // "N/A"')
                f_category=$(echo "$full_evt_json" | jq -r '.data["maintenance-category"] // "N/A"')
                f_lifecycle=$(echo "$full_evt_json" | jq -r '.data["lifecycle-state"] // "N/A"')
                f_window_start=$(echo "$full_evt_json" | jq -r '.data["time-window-start"] // "N/A"')
                f_hard_due=$(echo "$full_evt_json" | jq -r '.data["time-hard-due-date"] // "N/A"')
                f_can_resched=$(echo "$full_evt_json" | jq -r '.data["can-reschedule"] // "N/A"')
                f_can_delete=$(echo "$full_evt_json" | jq -r '.data["can-delete-local-storage"] // "N/A"')
                f_correlation=$(echo "$full_evt_json" | jq -r '.data["correlation-token"] // "N/A"')
                f_created_by=$(echo "$full_evt_json" | jq -r '.data["created-by"] // "N/A"')
                f_time_created=$(echo "$full_evt_json" | jq -r '.data["time-created"] // "N/A"')
                f_time_started=$(echo "$full_evt_json" | jq -r '.data["time-started"] // "null"')
                f_time_finished=$(echo "$full_evt_json" | jq -r '.data["time-finished"] // "null"')
                f_estimated_duration=$(echo "$full_evt_json" | jq -r '.data["estimated-duration"] // "null"')
                f_instance_id=$(echo "$full_evt_json" | jq -r '.data["instance-id"] // "N/A"')
                
                # Event details section
                echo -e "${BOLD}${WHITE}─── Event Information ───${NC}"
                echo ""
                echo -e "  ${WHITE}Display Name:${NC}        ${YELLOW}$f_display_name${NC}"
                echo -e "  ${WHITE}Event OCID:${NC}          ${GRAY}$d_evt_id${NC}"
                echo -e "  ${WHITE}Description:${NC}         ${CYAN}$f_description${NC}"
                echo -e "  ${WHITE}Correlation Token:${NC}   $f_correlation"
                echo -e "  ${WHITE}Created By:${NC}          $f_created_by"
                echo ""
                
                # Maintenance schedule section
                echo -e "${BOLD}${WHITE}─── Schedule ───${NC}"
                echo ""
                
                local lc_color="$WHITE"
                case "$f_lifecycle" in
                    SCHEDULED) lc_color="$YELLOW" ;;
                    STARTED) lc_color="$RED" ;;
                    COMPLETED|SUCCEEDED) lc_color="$GREEN" ;;
                    *) lc_color="$WHITE" ;;
                esac
                
                local resched_display="$RED"
                [[ "$f_can_resched" == "true" ]] && resched_display="$GREEN"
                
                echo -e "  ${WHITE}Lifecycle State:${NC}     ${lc_color}$f_lifecycle${NC}"
                echo -e "  ${WHITE}Maintenance Reason:${NC}  ${YELLOW}$f_reason${NC}"
                echo -e "  ${WHITE}Category:${NC}            $f_category"
                echo -e "  ${WHITE}Instance Action:${NC}     ${RED}$f_instance_action${NC}"
                echo -e "  ${WHITE}Can Reschedule:${NC}      ${resched_display}$f_can_resched${NC}"
                echo -e "  ${WHITE}Can Delete Storage:${NC}  $f_can_delete"
                echo ""
                echo -e "  ${WHITE}Time Created:${NC}        ${f_time_created:0:19}"
                echo -e "  ${WHITE}Window Start:${NC}        ${YELLOW}$f_window_start${NC}"
                echo -e "  ${WHITE}Hard Due Date:${NC}       ${RED}$f_hard_due${NC}"
                [[ "$f_time_started" != "null" && -n "$f_time_started" ]] && echo -e "  ${WHITE}Time Started:${NC}        $f_time_started"
                [[ "$f_time_finished" != "null" && -n "$f_time_finished" ]] && echo -e "  ${WHITE}Time Finished:${NC}       $f_time_finished"
                [[ "$f_estimated_duration" != "null" && -n "$f_estimated_duration" ]] && echo -e "  ${WHITE}Est. Duration:${NC}       $f_estimated_duration"
                echo ""
                
                # Instance details section
                echo -e "${BOLD}${WHITE}─── Instance Information ───${NC}"
                echo ""
                echo -e "  ${WHITE}Instance OCID:${NC}       ${YELLOW}$f_instance_id${NC}"
                echo -e "  ${WHITE}Instance Name:${NC}       ${WHITE}$d_inst_name${NC}"
                echo -e "  ${WHITE}Instance State:${NC}      $d_state"
                echo -e "  ${WHITE}Shape:${NC}               $d_shape"
                if [[ "$d_k8s_node" != "N/A" && -n "$d_k8s_node" ]]; then
                    echo -e "  ${WHITE}K8s Node:${NC}            ${CYAN}$d_k8s_node${NC}"
                    local k8s_detail_ready
                    k8s_detail_ready=$(echo "$me_k8s_lookup" | grep "$f_instance_id" | cut -d'|' -f3)
                    echo -e "  ${WHITE}K8s Ready:${NC}           $k8s_detail_ready"
                else
                    echo -e "  ${WHITE}K8s Node:${NC}            ${GRAY}Not a K8s node${NC}"
                fi
                echo ""
                
                # Fault details section
                local fault_details_raw
                fault_details_raw=$(echo "$full_evt_json" | jq -r '.data["additional-details"]["faultDetails"] // "null"' 2>/dev/null)
                
                if [[ "$fault_details_raw" != "null" && -n "$fault_details_raw" && "$fault_details_raw" != "[]" ]]; then
                    echo -e "${BOLD}${RED}─── Fault Details ───${NC}"
                    echo ""
                    
                    # faultDetails is a JSON string inside a string, parse it
                    echo "$fault_details_raw" | jq -r '.[] | "  Fault ID:        \(.faultId // "N/A")\n  Component:       \(.faultComponent // "N/A")\n  Severity:        \(.severity // "N/A")\n  Description:     \(.customerDescription // "N/A")\n  Impact:          \(.impactDescription // "N/A")\n  Impact Type:     \(.impactType // "N/A")\n  Recommended:     \(.recommendedAction // "N/A")\n"' 2>/dev/null | while IFS= read -r line; do
                        if [[ "$line" =~ ^[[:space:]]*Fault\ ID: ]]; then
                            echo -e "  ${WHITE}${line}${NC}"
                        elif [[ "$line" =~ ^[[:space:]]*Severity: ]]; then
                            echo -e "  ${RED}${line}${NC}"
                        elif [[ "$line" =~ ^[[:space:]]*Recommended: ]]; then
                            echo -e "  ${YELLOW}${line}${NC}"
                        elif [[ "$line" =~ ^[[:space:]]*Impact ]]; then
                            echo -e "  ${CYAN}${line}${NC}"
                        else
                            echo -e "  ${GRAY}${line}${NC}"
                        fi
                    done
                fi
                
                # Repair details section
                local repair_details_raw
                repair_details_raw=$(echo "$full_evt_json" | jq -r '.data["additional-details"]["repairDetails"] // "null"' 2>/dev/null)
                
                if [[ "$repair_details_raw" != "null" && -n "$repair_details_raw" && "$repair_details_raw" != "[]" ]]; then
                    echo -e "${BOLD}${YELLOW}─── Repair Details ───${NC}"
                    echo ""
                    
                    echo "$repair_details_raw" | jq -r '.[] | "  Component Type:  \(.componentType // "N/A")\n  Repair Type:     \(.repairType // "N/A")\n  Component ID:    \(.componentIdentifier // "N/A")\n  ID Type:         \(.componentIdentifierType // "N/A")\n"' 2>/dev/null | while IFS= read -r line; do
                        echo -e "  ${GRAY}${line}${NC}"
                    done
                fi
                
                # Alternative resolution actions
                local alt_actions
                alt_actions=$(echo "$full_evt_json" | jq -r '.data["alternative-resolution-actions"] // []' 2>/dev/null)
                if [[ "$alt_actions" != "[]" && "$alt_actions" != "null" && -n "$alt_actions" ]]; then
                    echo -e "${BOLD}${WHITE}─── Alternative Resolution Actions ───${NC}"
                    echo ""
                    echo "$alt_actions" | jq -r '.[]' 2>/dev/null | while IFS= read -r action; do
                        echo -e "  ${CYAN}• $action${NC}"
                    done
                    echo ""
                fi
                
            else
                echo -e "${RED}Failed to fetch full event details${NC}"
                echo ""
                echo -e "  ${WHITE}Event OCID:${NC}    ${GRAY}$d_evt_id${NC}"
                echo -e "  ${WHITE}Instance:${NC}      $d_inst_name ($d_inst_id)"
                echo -e "  ${WHITE}Reason:${NC}        $d_reason"
                echo -e "  ${WHITE}Category:${NC}      $d_category"
                echo -e "  ${WHITE}Lifecycle:${NC}     $d_lifecycle"
                echo -e "  ${WHITE}Window Start:${NC}  $d_window_start"
            fi
            
            echo ""
            echo -e "${BOLD}${WHITE}─────────────────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
            
            # Quick action from detail view
            if [[ "$d_can_resched" == "true" ]]; then
                echo ""
                echo -e "  ${YELLOW}resched${NC}) Reschedule this event     ${CYAN}b${NC}) Back"
                echo ""
                echo -n -e "${CYAN}Action [resched/b]: ${NC}"
                read -r detail_action
                
                if [[ "$detail_action" == "resched" || "$detail_action" == "RESCHED" ]]; then
                    reschedule_maintenance_event "$d_evt_id" "$d_evt_name" "$d_window_start" "$compartment_id" "$region"
                fi
            else
                echo -n -e "${CYAN}Press Enter to continue...${NC}"
                read -r
            fi
            
            continue
        fi
        
        echo -e "${RED}Invalid selection. Use a number to view details or 'resched #' to reschedule.${NC}"
    done
    
    # Cleanup
    rm -f "$me_inst_temp"
}

#--------------------------------------------------------------------------------
# List all announcements with affected resource details
# Shows all announcements and validates if affected instances still exist
#--------------------------------------------------------------------------------
list_all_announcements() {
    local compartment_id="${1:-$EFFECTIVE_COMPARTMENT_ID}"
    local region="${2:-$EFFECTIVE_REGION}"
    
    # Validate required parameters
    if [[ -z "$compartment_id" ]]; then
        log_error "COMPARTMENT_ID not set"
        return 1
    fi
    
    # Display simple header (no OKE cluster or network details)
    echo ""
    echo -e "${BOLD}${WHITE}Environment:${NC}"
    echo -e "  ${CYAN}Region:${NC}      ${WHITE}${region}${NC}"
    echo -e "  ${CYAN}Compartment:${NC} ${WHITE}$(resolve_compartment_name "${compartment_id}")${NC} ${GRAY}(${compartment_id})${NC}"
    echo ""
    
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${CYAN}                                         ALL ANNOUNCEMENTS                                                       ${NC}"
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    _display_cache_info \
        "${ANNOUNCEMENTS_LIST_CACHE}|Announcements"
    echo ""
    
    # Fetch announcements
    log_info "Fetching announcements from OCI..."
    
    # Force refresh of announcements cache
    rm -f "$ANNOUNCEMENTS_LIST_CACHE"
    
    if ! oci announce announcements list \
            --compartment-id "$compartment_id" \
            --all > "$ANNOUNCEMENTS_LIST_CACHE" 2>/dev/null; then
        log_error "Failed to fetch announcements"
        return 1
    fi
    
    # Get announcement count
    local ann_count
    ann_count=$(jq '.data.items | length' "$ANNOUNCEMENTS_LIST_CACHE" 2>/dev/null) || ann_count=0
    
    if [[ "$ann_count" -eq 0 ]]; then
        echo -e "${GREEN}✓ No announcements found${NC}"
        echo ""
        return 0
    fi
    
    echo -e "${GRAY}Found ${WHITE}${ann_count}${GRAY} announcement(s)${NC}"
    echo ""
    
    # Fetch all instances in compartment for validation
    log_info "Fetching instances for validation..."
    local instances_json
    instances_json=$(oci compute instance list \
        --compartment-id "$compartment_id" \
        --region "$region" \
        --all \
        --output json 2>/dev/null)
    
    # Build instance lookup (OCID -> display_name|state)
    declare -A INSTANCE_LOOKUP
    if [[ -n "$instances_json" ]]; then
        while IFS='|' read -r ocid name state; do
            [[ -n "$ocid" ]] && INSTANCE_LOOKUP[$ocid]="${name}|${state}"
        done < <(echo "$instances_json" | jq -r '.data[] | "\(.id)|\(.["display-name"])|\(.["lifecycle-state"])"' 2>/dev/null)
    fi
    
    # Fetch details for each announcement
    log_info "Fetching announcement details..."
    local announcement_ids
    announcement_ids=$(jq -r '.data.items[].id' "$ANNOUNCEMENTS_LIST_CACHE" 2>/dev/null)
    
    # Fetch details in parallel
    local ann_id
    for ann_id in $announcement_ids; do
        local detail_file="${CACHE_DIR}/${ann_id##*.}.json"
        oci announce announcements get --announcement-id "$ann_id" > "$detail_file" 2>/dev/null &
    done
    wait
    
    # ── Display function (called for default filtered + show-all) ──
    _display_announcements_table() {
        local show_deleted="${1:-false}"
        
        echo ""
        
        if [[ "$show_deleted" == "true" ]]; then
            echo -e "${BOLD}${WHITE}Showing: ${YELLOW}ALL${WHITE} announcements (including instances with OCI state DELETED)${NC}"
        else
            echo -e "${BOLD}${WHITE}Showing: ${GREEN}Active${WHITE} announcements (hiding where all instances are DELETED/gone)${NC}"
        fi
        echo ""
        
        # Print announcements table header - Type limited to 20
        printf "${BOLD}%-4s %-10s %-10s %-20s %-16s %-16s %-30s %-14s %-42s %-80s${NC}\n" \
            "ID" "Ticket" "State" "Type" "Start" "End" "Display Name" "OCI State" "Instance OCID" "Description"
        print_separator 256
        
        # Build announcement index map for interactive selection
        # Clear previous map
        for key in "${!ANN_INDEX_MAP[@]}"; do
            unset ANN_INDEX_MAP["$key"]
        done
        ann_idx=0
        local shown_count=0
        local skipped_count=0
        
        # Process each announcement
        for ann_id in $announcement_ids; do
            local detail_file="${CACHE_DIR}/${ann_id##*.}.json"
            
            if [[ ! -f "$detail_file" ]]; then
                continue
            fi
            
            # Extract announcement fields
            local lifecycle_state ref_ticket ann_type description
            local time_one time_two resource_count
            
            lifecycle_state=$(jq -r '.data."lifecycle-state" // "N/A"' "$detail_file")
            ref_ticket=$(jq -r '.data."reference-ticket-number" // "N/A"' "$detail_file")
            ann_type=$(jq -r '.data."announcement-type" // "N/A"' "$detail_file")
            description=$(jq -r '.data.description // ""' "$detail_file")
            time_one=$(jq -r '.data."time-one-value" // "N/A"' "$detail_file")
            time_two=$(jq -r '.data."time-two-value" // "N/A"' "$detail_file")
            resource_count=$(jq '.data."affected-resources" | length' "$detail_file" 2>/dev/null) || resource_count=0
            
            # ── Filter by OCI instance state (not announcement lifecycle-state) ──
            # Skip announcements where ALL affected resources are DELETED/gone
            if [[ "$show_deleted" != "true" && $resource_count -gt 0 ]]; then
                local all_deleted=true
                local ri
                for ((ri=0; ri<resource_count; ri++)); do
                    local chk_resource_id
                    chk_resource_id=$(jq -r ".data.\"affected-resources\"[$ri] | 
                        if .properties then
                            (.properties[] | select(.name == \"resourceId\" or .name == \"instanceId\") | .value) // \"N/A\"
                        else
                            (.\"resource-id\" // .\"instance-id\" // \"N/A\")
                        end" "$detail_file" 2>/dev/null)
                    
                    if [[ "$chk_resource_id" != "N/A" && -n "$chk_resource_id" ]]; then
                        if [[ -n "${INSTANCE_LOOKUP[$chk_resource_id]:-}" ]]; then
                            local chk_state
                            chk_state=$(echo "${INSTANCE_LOOKUP[$chk_resource_id]}" | cut -d'|' -f2)
                            if [[ "$chk_state" != "TERMINATED" ]]; then
                                all_deleted=false
                                break
                            fi
                        fi
                        # Instance not in lookup = deleted/gone, continue checking
                    else
                        # No resource ID = not an instance resource, don't filter
                        all_deleted=false
                        break
                    fi
                done
                
                if [[ "$all_deleted" == "true" ]]; then
                    ((skipped_count++))
                    continue
                fi
            fi
            
            ((ann_idx++))
            ((shown_count++))
            
            # Store mapping
            ANN_INDEX_MAP["a${ann_idx}"]="${detail_file}"
            
            # Format times
            local start_display="${time_one:0:16}"
            local end_display="${time_two:0:16}"
            [[ "$time_one" == "N/A" || "$time_one" == "null" ]] && start_display="-"
            [[ "$time_two" == "N/A" || "$time_two" == "null" ]] && end_display="-"
            
            # Truncate description to 80 chars and type to 20
            local desc_trunc="${description:0:80}"
            [[ ${#description} -gt 80 ]] && desc_trunc="${desc_trunc}..."
            local type_trunc="${ann_type:0:20}"
        
        # Color based on lifecycle state
        local state_color="$GREEN"
        case "$lifecycle_state" in
            ACTIVE) state_color="$YELLOW" ;;
            INACTIVE) state_color="$GRAY" ;;
            *) state_color="$WHITE" ;;
        esac
        
        # Color based on announcement type
        local type_color="$WHITE"
        case "$ann_type" in
            ACTION_REQUIRED) type_color="$RED" ;;
            SCHEDULED_MAINTENANCE) type_color="$YELLOW" ;;
            EMERGENCY_MAINTENANCE) type_color="$RED" ;;
            PRODUCTION_EVENT_NOTIFICATION) type_color="$CYAN" ;;
            *) type_color="$WHITE" ;;
        esac
        
        # Truncate ticket for display
        local ticket_display="${ref_ticket:0:10}"
        
        # If no affected resources, show one row with N/A for instance info
        if [[ $resource_count -eq 0 ]]; then
            printf "${YELLOW}%-4s${NC} %-10s ${state_color}%-10s${NC} ${type_color}%-20s${NC} %-16s %-16s ${GRAY}%-30s${NC} ${GRAY}%-14s${NC} ${GRAY}%-42s${NC} ${GRAY}%-80s${NC}\n" \
                "a${ann_idx}" "$ticket_display" "$lifecycle_state" "$type_trunc" "$start_display" "$end_display" "-" "-" "-" "$desc_trunc"
        else
            # Loop through affected resources
            local i
            local first_row=true
            for ((i=0; i<resource_count; i++)); do
                # Get resource details
                local resource_id resource_name
                
                resource_id=$(jq -r ".data.\"affected-resources\"[$i] | 
                    if .properties then
                        (.properties[] | select(.name == \"resourceId\" or .name == \"instanceId\") | .value) // \"N/A\"
                    else
                        (.\"resource-id\" // .\"instance-id\" // \"N/A\")
                    end" "$detail_file" 2>/dev/null)
                
                resource_name=$(jq -r ".data.\"affected-resources\"[$i] |
                    if .properties then
                        (.properties[] | select(.name == \"resourceName\" or .name == \"instanceName\") | .value) // \"N/A\"
                    else
                        (.\"resource-name\" // .\"instance-name\" // \"N/A\")
                    end" "$detail_file" 2>/dev/null)
                
                # Check if instance still exists and get current state
                local instance_state="UNKNOWN"
                local instance_display_name="$resource_name"
                local inst_state_color="$GRAY"
                
                if [[ "$resource_id" != "N/A" && -n "$resource_id" ]]; then
                    if [[ -n "${INSTANCE_LOOKUP[$resource_id]:-}" ]]; then
                        local lookup_info="${INSTANCE_LOOKUP[$resource_id]}"
                        instance_display_name=$(echo "$lookup_info" | cut -d'|' -f1)
                        instance_state=$(echo "$lookup_info" | cut -d'|' -f2)
                        
                        case "$instance_state" in
                            RUNNING) inst_state_color="$GREEN" ;;
                            STOPPED) inst_state_color="$RED" ;;
                            TERMINATED) inst_state_color="$RED" ;;
                            *) inst_state_color="$YELLOW" ;;
                        esac
                    else
                        instance_state="DELETED"
                        inst_state_color="$RED"
                        [[ "$instance_display_name" == "N/A" ]] && instance_display_name="(deleted)"
                    fi
                fi
                
                # Truncate display name and OCID
                local name_trunc="${instance_display_name:0:30}"
                local ocid_trunc="N/A"
                if [[ "$resource_id" != "N/A" && -n "$resource_id" ]]; then
                    ocid_trunc="...${resource_id: -39}"
                fi
                
                # Print row - only show announcement details on first row
                if [[ "$first_row" == "true" ]]; then
                    printf "${YELLOW}%-4s${NC} %-10s ${state_color}%-10s${NC} ${type_color}%-20s${NC} %-16s %-16s %-30s ${inst_state_color}%-14s${NC} %-42s ${GRAY}%-80s${NC}\n" \
                        "a${ann_idx}" "$ticket_display" "$lifecycle_state" "$type_trunc" "$start_display" "$end_display" "$name_trunc" "$instance_state" "$ocid_trunc" "$desc_trunc"
                    first_row=false
                else
                    # Continuation row - empty announcement columns
                    printf "%-4s %-10s %-10s %-20s %-16s %-16s %-30s ${inst_state_color}%-14s${NC} %-42s %-80s\n" \
                        "" "" "" "" "" "" "$name_trunc" "$instance_state" "$ocid_trunc" ""
                fi
            done
        fi
    done
    
    echo ""
    print_separator 256
    echo ""
    echo -e "${WHITE}Displayed ${CYAN}${shown_count}${WHITE} announcement(s)${NC}"
    [[ "$show_deleted" != "true" && $skipped_count -gt 0 ]] && \
        echo -e "${GRAY}  (${skipped_count} announcement(s) hidden where all instances DELETED - use ${WHITE}all${GRAY} to show)${NC}"
    echo ""
    
    # Show legend
    echo -e "${BOLD}${WHITE}Legend:${NC}"
    echo -e "  ${WHITE}States:${NC} ${YELLOW}ACTIVE${NC} (current) | ${GRAY}INACTIVE${NC} (past) | ${RED}DELETED${NC}"
    echo -e "  ${WHITE}Types:${NC}  ${RED}ACTION_REQUIRED${NC} / ${RED}EMERGENCY_MAINT..${NC} (urgent) | ${YELLOW}SCHEDULED_MAINT..${NC} (planned) | ${CYAN}PRODUCTION_EVENT..${NC} (info)"
    echo -e "  ${WHITE}Instance:${NC} ${GREEN}RUNNING${NC} | ${RED}STOPPED${NC} | ${RED}DELETED${NC} (no longer exists)"
    echo ""
    }
    # ── End of _display_announcements_table ──
    
    # Initialize index map and show default (filtered) view
    declare -A ANN_INDEX_MAP
    local ann_idx=0
    local current_show_all="false"
    
    _display_announcements_table "$current_show_all"
    
    # Interactive menu
    while true; do
        echo -e "${BOLD}${WHITE}─── Actions ───${NC}"
        echo -e "  Enter ${YELLOW}a#${NC} (e.g., a1) to view full announcement details"
        if [[ "$current_show_all" == "true" ]]; then
            echo -e "  Enter ${CYAN}active${NC} to hide announcements where all instances are DELETED"
        else
            echo -e "  Enter ${CYAN}all${NC} to include announcements where all instances are DELETED"
        fi
        echo -e "  Enter ${CYAN}q${NC} to quit"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Announcements] Selection: ${NC}"
        read -r selection
        
        [[ -z "$selection" || "$selection" == "q" || "$selection" == "Q" || "$selection" == "back" || "$selection" == "b" ]] && break
        
        if [[ "${selection,,}" == "all" ]]; then
            current_show_all="true"
            _display_announcements_table "$current_show_all"
            continue
        fi
        
        if [[ "${selection,,}" == "active" ]]; then
            current_show_all="false"
            _display_announcements_table "$current_show_all"
            continue
        fi
        
        if [[ "$selection" =~ ^a[0-9]+$ ]]; then
            local detail_file="${ANN_INDEX_MAP[$selection]:-}"
            if [[ -z "$detail_file" || ! -f "$detail_file" ]]; then
                echo -e "${RED}Invalid selection: $selection${NC}"
                continue
            fi
            
            # Extract full announcement details
            local ref_ticket lifecycle_state ann_type summary description
            local time_created time_updated time_one time_two
            local affected_services platform_type resource_count
            
            ref_ticket=$(jq -r '.data."reference-ticket-number" // "N/A"' "$detail_file")
            lifecycle_state=$(jq -r '.data."lifecycle-state" // "N/A"' "$detail_file")
            ann_type=$(jq -r '.data."announcement-type" // "N/A"' "$detail_file")
            summary=$(jq -r '.data.summary // "N/A"' "$detail_file")
            description=$(jq -r '.data.description // "N/A"' "$detail_file")
            time_created=$(jq -r '.data."time-created" // "N/A"' "$detail_file")
            time_updated=$(jq -r '.data."time-updated" // "N/A"' "$detail_file")
            time_one=$(jq -r '.data."time-one-value" // "N/A"' "$detail_file")
            time_two=$(jq -r '.data."time-two-value" // "N/A"' "$detail_file")
            affected_services=$(jq -r '.data."affected-services" // [] | join(", ")' "$detail_file")
            platform_type=$(jq -r '.data."platform-type" // "N/A"' "$detail_file")
            resource_count=$(jq '.data."affected-resources" | length' "$detail_file" 2>/dev/null) || resource_count=0
            
            echo ""
            echo -e "${BOLD}${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
            echo -e "${BOLD}${YELLOW}  Announcement: ${WHITE}${ref_ticket}${NC}"
            echo -e "${BOLD}${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
            echo ""
            echo -e "  ${WHITE}Type:${NC}         $ann_type"
            echo -e "  ${WHITE}State:${NC}        $lifecycle_state"
            echo -e "  ${WHITE}Platform:${NC}     $platform_type"
            echo -e "  ${WHITE}Services:${NC}     $affected_services"
            echo -e "  ${WHITE}Created:${NC}      ${time_created:0:19}"
            [[ "$time_updated" != "N/A" && "$time_updated" != "null" ]] && echo -e "  ${WHITE}Updated:${NC}      ${time_updated:0:19}"
            [[ "$time_one" != "N/A" && "$time_one" != "null" ]] && echo -e "  ${WHITE}Start Time:${NC}   ${time_one:0:19}"
            [[ "$time_two" != "N/A" && "$time_two" != "null" ]] && echo -e "  ${WHITE}End Time:${NC}     ${time_two:0:19}"
            echo ""
            echo -e "  ${WHITE}Summary:${NC}"
            echo -e "    ${CYAN}$summary${NC}"
            echo ""
            if [[ "$description" != "N/A" && "$description" != "null" && -n "$description" ]]; then
                echo -e "  ${WHITE}Description:${NC}"
                echo "$description" | fold -s -w 100 | while IFS= read -r line; do
                    echo -e "    ${GRAY}${line}${NC}"
                done
            fi
            
            # Show affected resources
            if [[ $resource_count -gt 0 ]]; then
                echo ""
                echo -e "  ${WHITE}Affected Resources (${resource_count}):${NC}"
                echo -e "  ${GRAY}─────────────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
                printf "  ${BOLD}%-40s %-30s %-16s %-22s${NC}\n" "Instance OCID" "Display Name" "OCI State" "GPU Memory Cluster"
                echo -e "  ${GRAY}─────────────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
                
                local i
                for ((i=0; i<resource_count; i++)); do
                    local resource_id resource_name gpu_mem_cluster
                    
                    resource_id=$(jq -r ".data.\"affected-resources\"[$i] | 
                        if .properties then
                            (.properties[] | select(.name == \"resourceId\" or .name == \"instanceId\") | .value) // \"N/A\"
                        else
                            (.\"resource-id\" // .\"instance-id\" // \"N/A\")
                        end" "$detail_file" 2>/dev/null)
                    
                    resource_name=$(jq -r ".data.\"affected-resources\"[$i] |
                        if .properties then
                            (.properties[] | select(.name == \"resourceName\" or .name == \"instanceName\") | .value) // \"N/A\"
                        else
                            (.\"resource-name\" // .\"instance-name\" // \"N/A\")
                        end" "$detail_file" 2>/dev/null)
                    
                    gpu_mem_cluster=$(jq -r ".data.\"affected-resources\"[$i] |
                        if .properties then
                            (.properties[] | select(.name == \"gpuMemoryCluster\") | .value) // \"N/A\"
                        else
                            \"N/A\"
                        end" "$detail_file" 2>/dev/null)
                    
                    # Check if instance still exists
                    local instance_state="UNKNOWN"
                    local instance_display_name="$resource_name"
                    local state_color="$GRAY"
                    
                    if [[ "$resource_id" != "N/A" && -n "$resource_id" ]]; then
                        if [[ -n "${INSTANCE_LOOKUP[$resource_id]:-}" ]]; then
                            local lookup_info="${INSTANCE_LOOKUP[$resource_id]}"
                            instance_display_name=$(echo "$lookup_info" | cut -d'|' -f1)
                            instance_state=$(echo "$lookup_info" | cut -d'|' -f2)
                            
                            case "$instance_state" in
                                RUNNING) state_color="$GREEN" ;;
                                STOPPED) state_color="$RED" ;;
                                TERMINATED) state_color="$RED" ;;
                                *) state_color="$YELLOW" ;;
                            esac
                        else
                            instance_state="NO LONGER EXISTS"
                            state_color="$RED"
                            [[ "$instance_display_name" == "N/A" ]] && instance_display_name="(deleted)"
                        fi
                    fi
                    
                    # Truncate OCID for display
                    local ocid_display="N/A"
                    if [[ "$resource_id" != "N/A" && -n "$resource_id" ]]; then
                        ocid_display="...${resource_id: -37}"
                    fi
                    
                    # Truncate GPU memory cluster
                    local gpu_display="N/A"
                    if [[ "$gpu_mem_cluster" != "N/A" && -n "$gpu_mem_cluster" ]]; then
                        gpu_display="...${gpu_mem_cluster: -19}"
                    fi
                    
                    printf "  %-40s %-30s ${state_color}%-16s${NC} %-22s\n" \
                        "$ocid_display" "${instance_display_name:0:30}" "$instance_state" "$gpu_display"
                done
            else
                echo ""
                echo -e "  ${GRAY}No specific resources listed for this announcement${NC}"
            fi
            echo ""
        else
            echo -e "${RED}Invalid selection. Use a# (e.g., a1) for announcement details.${NC}"
        fi
    done
}

# Display summary by clique
display_clique_summary() {
    local oci_temp="$1"
    local k8s_temp="$2"
    
    local joined_temp
    joined_temp=$(create_temp_file) || return 1
    
    # Debug: Check file contents
    if [[ "${DEBUG:-false}" == "true" ]]; then
        echo -e "${GRAY}[DEBUG] oci_temp has $(wc -l < "$oci_temp") lines${NC}" >&2
        echo -e "${GRAY}[DEBUG] k8s_temp has $(wc -l < "$k8s_temp") lines${NC}" >&2
        if [[ -f "$INSTANCE_CLUSTER_MAP_CACHE" ]]; then
            local map_count
            map_count=$(grep -v '^#' "$INSTANCE_CLUSTER_MAP_CACHE" 2>/dev/null | wc -l)
            echo -e "${GRAY}[DEBUG] Instance-to-cluster map has $map_count entries${NC}" >&2
        else
            echo -e "${GRAY}[DEBUG] Instance-to-cluster map cache NOT FOUND at $INSTANCE_CLUSTER_MAP_CACHE${NC}" >&2
        fi
    fi
    
    # APPROACH:
    # 1. Start from Instance-Cluster Map (instances in GPU memory clusters via API)
    # 2. For each instance, check if it's in K8s (k8s_temp)
    # 3. If in K8s, get the clique label
    # 4. Group by GPU Memory Cluster (not clique)
    
    local k8s_found=0 k8s_not_found=0
    local total_unhealthy=0
    
    # Process instances from the instance-cluster map cache
    # Format: InstanceOCID|ClusterOCID|ClusterDisplayName
    if [[ -f "$INSTANCE_CLUSTER_MAP_CACHE" ]]; then
        while IFS='|' read -r instance_ocid gpu_cluster_ocid cluster_name; do
            # Skip header lines
            [[ "$instance_ocid" == \#* ]] && continue
            [[ -z "$instance_ocid" ]] && continue
            
            # Get instance display name from oci_temp
            # oci_temp format: display_name|status|instance_ocid|gpu_mem_tag|shape|time_created
            local oci_line display_name status
            oci_line=$(grep "|${instance_ocid}|" "$oci_temp" 2>/dev/null | head -1)
            if [[ -n "$oci_line" ]]; then
                IFS='|' read -r display_name status _ _ _ _ <<< "$oci_line"
            else
                # Instance not in oci_temp (maybe filtered out or different compartment)
                display_name="(unknown)"
                status="UNKNOWN"
            fi
            
            # Check for unhealthy instances (DEGRADED cap_topo or has announcements)
            local cap_topo_state announcements
            cap_topo_state=$(get_capacity_topology_state "$instance_ocid" 2>/dev/null)
            announcements=$(get_resource_announcements "$instance_ocid" "$gpu_cluster_ocid" 2>/dev/null)
            if [[ "$cap_topo_state" == "DEGRADED" || ( -n "$announcements" && "$announcements" != "-" ) ]]; then
                ((total_unhealthy++))
            fi
            
            # Check if instance is in K8s
            # k8s_temp format: providerID|nodeName|clique|gpuPresent
            local k8s_info
            k8s_info=$(grep "$instance_ocid" "$k8s_temp" 2>/dev/null)
            
            if [[ -n "$k8s_info" ]]; then
                ((k8s_found++))
                local node_name clique_id
                IFS='|' read -r _ node_name clique_id _ <<< "$k8s_info"
                
                # Use K8s clique if available, otherwise mark as no clique
                if [[ -n "$clique_id" && "$clique_id" != "N/A" ]]; then
                    # joined format: display_name|node_name|status|instance_ocid|gpu_cluster_ocid|clique_id|in_k8s
                    echo "${display_name}|${node_name}|${status}|${instance_ocid}|${gpu_cluster_ocid}|${clique_id}|YES" >> "$joined_temp"
                else
                    # In K8s but no clique label
                    echo "${display_name}|${node_name}|${status}|${instance_ocid}|${gpu_cluster_ocid}|N/A|YES" >> "$joined_temp"
                fi
            else
                ((k8s_not_found++))
                # Instance is in GPU memory cluster but NOT in K8s
                echo "${display_name}|-|${status}|${instance_ocid}|${gpu_cluster_ocid}|N/A|NO" >> "$joined_temp"
            fi
        done < "$INSTANCE_CLUSTER_MAP_CACHE"
    else
        log_warn "Instance-cluster map cache not found. Run with --refresh to build cache."
    fi
    
    if [[ "${DEBUG:-false}" == "true" ]]; then
        echo -e "${GRAY}[DEBUG] Total from GPU clusters: K8s found=$k8s_found, NOT_IN_K8S=$k8s_not_found${NC}" >&2
        echo -e "${GRAY}[DEBUG] joined_temp has $(wc -l < "$joined_temp") lines${NC}" >&2
    fi
    
    echo -e "${BOLD}${BLUE}=== Summary by GPU Memory Cluster ===${NC}"
    _display_cache_info \
        "${CLUSTER_CACHE}|GPU Clusters" \
        "${INSTANCE_CLUSTER_MAP_CACHE}|Instance Map" \
        "${CAPACITY_TOPOLOGY_CACHE}|Capacity Hosts"
    echo ""
    summary_temp=$(create_temp_file) || { rm -f "$joined_temp"; return 1; }
    
    # Get unique GPU Memory Clusters (field 5)
    local unique_clusters
    unique_clusters=$(awk -F'|' '{print $5}' "$joined_temp" 2>/dev/null | sort -u)
    
    # Also add clusters from cache that have no instances yet
    if [[ -f "$CLUSTER_CACHE" ]]; then
        while IFS='|' read -r cluster_ocid cluster_name cluster_state _; do
            [[ "$cluster_ocid" =~ ^#.*$ ]] && continue
            [[ -z "$cluster_ocid" ]] && continue
            # Only include active-ish states
            [[ "$cluster_state" != "ACTIVE" && "$cluster_state" != "UPDATING" && "$cluster_state" != "SCALING" && "$cluster_state" != "CREATING" ]] && continue
            # Add if not already in list
            if ! echo "$unique_clusters" | grep -q "^${cluster_ocid}$"; then
                unique_clusters="${unique_clusters}"$'\n'"${cluster_ocid}"
            fi
        done < <(grep -v '^#' "$CLUSTER_CACHE" 2>/dev/null)
    fi
    
    # Process each GPU Memory Cluster
    local gpu_cluster_ocid
    while read -r gpu_cluster_ocid; do
        [[ -z "$gpu_cluster_ocid" ]] && continue
        
        # Get cluster info from cache
        local cluster_name cluster_state cluster_size instance_config_id compute_cluster_id
        local cluster_line
        cluster_line=$(grep "^${gpu_cluster_ocid}|" "$CLUSTER_CACHE" 2>/dev/null | head -1)
        
        if [[ -n "$cluster_line" ]]; then
            # CLUSTER_CACHE format: ClusterOCID|DisplayName|State|FabricSuffix|InstanceConfigID|ComputeClusterID|Size
            IFS='|' read -r _ cluster_name cluster_state _ instance_config_id compute_cluster_id cluster_size <<< "$cluster_line"
        else
            cluster_name="(unknown)"
            cluster_state="UNKNOWN"
            cluster_size="0"
            instance_config_id="N/A"
            compute_cluster_id="N/A"
        fi
        
        # Get fabric info
        local fabric_info fabric_name fabric_ocid healthy_hosts available_hosts total_hosts current_firmware target_firmware firmware_update_state
        fabric_info=$(get_fabric_from_cluster "$gpu_cluster_ocid")
        IFS='|' read -r fabric_name _ fabric_ocid _ healthy_hosts available_hosts total_hosts current_firmware target_firmware firmware_update_state <<< "$fabric_info"
        
        # Count instances in this cluster
        local cluster_entries total_instances in_k8s_count not_in_k8s_count
        cluster_entries=$(grep "|${gpu_cluster_ocid}|" "$joined_temp" 2>/dev/null)
        total_instances=$(echo "$cluster_entries" | grep -c . 2>/dev/null) || total_instances=0
        in_k8s_count=$(echo "$cluster_entries" | grep -c "|YES$" 2>/dev/null) || in_k8s_count=0
        not_in_k8s_count=$(echo "$cluster_entries" | grep -c "|NO$" 2>/dev/null) || not_in_k8s_count=0
        
        # Get unique cliques in this cluster
        local cliques_list
        cliques_list=$(echo "$cluster_entries" | awk -F'|' '$7=="YES" && $6!="N/A" {print $6}' | sort -u | tr '\n' ',' | sed 's/,$//')
        [[ -z "$cliques_list" ]] && cliques_list="-"
        
        # Format: cluster_name|gpu_cluster_ocid|cluster_state|cluster_size|in_k8s_count|not_in_k8s_count|cliques_list|fabric_name|fabric_ocid|instance_config_id|compute_cluster_id|healthy_hosts|available_hosts|total_hosts|current_firmware|target_firmware|firmware_update_state
        echo "${cluster_name}|${gpu_cluster_ocid}|${cluster_state}|${cluster_size}|${in_k8s_count}|${not_in_k8s_count}|${cliques_list}|${fabric_name}|${fabric_ocid}|${instance_config_id}|${compute_cluster_id}|${healthy_hosts}|${available_hosts}|${total_hosts}|${current_firmware}|${target_firmware}|${firmware_update_state}" >> "$summary_temp"
    done <<< "$unique_clusters"
    
    # Check if we have any data
    if [[ ! -s "$summary_temp" ]]; then
        echo -e "${YELLOW}No GPU Memory Clusters found.${NC}"
        rm -f "$joined_temp" "$summary_temp"
        return 0
    fi
    
    # Print summary table header - matching old format
    printf "${BOLD}%44s K8s  ┌─GPU Memory Fabric─┐ GPU Mem Cluster${NC}\n" ""
    printf "${BOLD}%-30s %-12s %5s  %7s %5s %5s       %4s       %-12s${NC}\n" \
        "GPU Memory Cluster" "State" "Nodes" "Healthy" "Avail" "Total" "Size" ""
    print_separator 110
    
    # Sort summary by cluster name
    local sorted_summary
    sorted_summary=$(sort -t'|' -k1,1 "$summary_temp")
    
    # Calculate totals
    local total_size=0 total_in_k8s=0 total_not_in_k8s=0
    local total_healthy=0 total_avail=0 total_hosts_sum=0
    local total_in_hops=0
    # Track unique fabrics to avoid double counting
    declare -A seen_fabrics
    
    # Get HoPS count from capacity topology (UNAVAILABLE state in lifecycle-details)
    if [[ -f "$CAPACITY_TOPOLOGY_CACHE" ]]; then
        total_in_hops=$(grep -v "^#" "$CAPACITY_TOPOLOGY_CACHE" | awk -F'|' '$3 == "UNAVAILABLE"' | wc -l)
    fi
    
    while IFS='|' read -r cluster_name gpu_cluster_ocid cluster_state cluster_size in_k8s_count not_in_k8s_count cliques_list fabric_name fabric_ocid instance_config_id compute_cluster_id healthy_hosts available_hosts total_hosts current_firmware target_firmware firmware_update_state; do
        [[ -z "$cluster_name" ]] && continue
        
        # Add to totals
        [[ "$cluster_size" =~ ^[0-9]+$ ]] && total_size=$((total_size + cluster_size))
        [[ "$in_k8s_count" =~ ^[0-9]+$ ]] && total_in_k8s=$((total_in_k8s + in_k8s_count))
        [[ "$not_in_k8s_count" =~ ^[0-9]+$ ]] && total_not_in_k8s=$((total_not_in_k8s + not_in_k8s_count))
        
        # Add fabric totals (only count each fabric once)
        if [[ -n "$fabric_ocid" && "$fabric_ocid" != "N/A" && -z "${seen_fabrics[$fabric_ocid]:-}" ]]; then
            seen_fabrics[$fabric_ocid]=1
            [[ "$healthy_hosts" =~ ^[0-9]+$ ]] && total_healthy=$((total_healthy + healthy_hosts))
            [[ "$available_hosts" =~ ^[0-9]+$ ]] && total_avail=$((total_avail + available_hosts))
            [[ "$total_hosts" =~ ^[0-9]+$ ]] && total_hosts_sum=$((total_hosts_sum + total_hosts))
        fi
        
        # Color state based on value
        local state_color
        state_color=$(color_cluster_state "$cluster_state")
        
        # Color available hosts - light green if not 0
        local avail_color="$WHITE"
        [[ "$available_hosts" != "0" && "$available_hosts" != "N/A" ]] && avail_color="$LIGHT_GREEN"
        
        # Color not_in_k8s - yellow if > 0 (nodes not in k8s)
        local in_k8s_color="$GREEN"
        [[ "$not_in_k8s_count" -gt 0 ]] && in_k8s_color="$YELLOW"
        
        # Truncate cluster name if needed
        local cluster_name_display="${cluster_name:0:28}"
        
        # Main summary line - K8s Nodes shows "in_k8s/total" format if there are nodes not in k8s
        local k8s_display="$in_k8s_count"
        if [[ "$not_in_k8s_count" -gt 0 ]]; then
            k8s_display="${in_k8s_count}/${cluster_size}"
        fi
        
        printf "${MAGENTA}%-30s${NC} ${state_color}%-12s${NC} ${in_k8s_color}%5s${NC}  ${WHITE}%7s${NC} ${avail_color}%5s${NC} ${WHITE}%5s${NC}       ${WHITE}%4s${NC}\n" \
            "$cluster_name_display" "$cluster_state" "$k8s_display" "$healthy_hosts" "$available_hosts" "$total_hosts" "$cluster_size"
        
        # Determine which is the last item for tree drawing
        local has_cliques=false has_fabric=false has_compute=false has_config=false has_firmware=false
        [[ "$cliques_list" != "-" && -n "$cliques_list" ]] && has_cliques=true
        [[ "$fabric_name" != "N/A" && -n "$fabric_name" ]] && has_fabric=true
        is_valid_ocid "$compute_cluster_id" && has_compute=true
        is_valid_ocid "$instance_config_id" && has_config=true
        [[ "$current_firmware" != "N/A" && -n "$current_firmware" ]] && has_firmware=true
        
        # Tree view - all items including OCID and Cliques
        # Cliques (first in tree)
        if [[ "$has_cliques" == true ]]; then
            local tree_char="├"
            [[ "$has_fabric" == false && "$has_compute" == false && "$has_config" == false && "$has_firmware" == false ]] && tree_char="└"
            printf "  ${WHITE}%s─${NC} ${BOLD}${CYAN}Cliques:${NC}      ${CYAN}%s${NC}\n" "$tree_char" "$cliques_list"
        fi
        
        # GPU Memory Cluster OCID (aligned with other OCIDs)
        local tree_char="├"
        [[ "$has_fabric" == false && "$has_compute" == false && "$has_config" == false && "$has_firmware" == false ]] && tree_char="└"
        printf "  ${WHITE}%s─${NC} ${BOLD}${MAGENTA}GPU Cluster:${NC}  %-45s ${YELLOW}%s${NC}\n" "$tree_char" "${cluster_name:0:45}" "$gpu_cluster_ocid"
        
        # Fabric
        if [[ "$has_fabric" == true ]]; then
            tree_char="├"
            [[ "$has_compute" == false && "$has_config" == false && "$has_firmware" == false ]] && tree_char="└"
            printf "  ${WHITE}%s─${NC} ${BOLD}${ORANGE}Fabric:${NC}       %-45s ${YELLOW}%s${NC}\n" \
                "$tree_char" "${fabric_name:0:45}" "$fabric_ocid"
        fi
        
        # Compute Cluster
        if [[ "$has_compute" == true ]]; then
            local compute_cluster_name
            compute_cluster_name=$(get_compute_cluster_name "$compute_cluster_id")
            tree_char="├"
            [[ "$has_config" == false && "$has_firmware" == false ]] && tree_char="└"
            printf "  ${WHITE}%s─${NC} ${BOLD}${BLUE}Compute:${NC}      %-45s ${YELLOW}%s${NC}\n" \
                "$tree_char" "${compute_cluster_name:0:45}" "$compute_cluster_id"
        fi
        
        # Instance Config
        if [[ "$has_config" == true ]]; then
            local instance_config_name
            instance_config_name=$(get_instance_config_name "$instance_config_id")
            tree_char="├"
            [[ "$has_firmware" == false ]] && tree_char="└"
            printf "  ${WHITE}%s─${NC} ${BOLD}${GREEN}Inst Config:${NC}  %-45s ${YELLOW}%s${NC}\n" \
                "$tree_char" "${instance_config_name:0:45}" "$instance_config_id"
        fi
        
        # Firmware (always last if present)
        if [[ "$has_firmware" == true ]]; then
            # Get last 5 chars of firmware versions
            local current_short="${current_firmware: -5}"
            local target_short="${target_firmware: -5}"
            
            # Color firmware update state
            local update_state_color
            update_state_color=$(color_firmware_state "$firmware_update_state")
            
            # Highlight target in red if current != target
            local target_color="$YELLOW"
            if [[ "$current_firmware" != "$target_firmware" && "$target_firmware" != "N/A" && -n "$target_firmware" ]]; then
                target_color="$RED"
            fi
            
            printf "  ${WHITE}└─${NC} ${BOLD}${ORANGE}Firmware:${NC}     ${update_state_color}%-14s${NC} current: ${YELLOW}%-8s${NC} target: ${target_color}%s${NC}\n" \
                "$firmware_update_state" "$current_short" "$target_short"
        fi
        
        echo ""
    done <<< "$sorted_summary"
    
    # Print totals
    print_separator 110
    printf "${BOLD}${WHITE}%-30s %-12s %5s  %7s %5s %5s       %4s${NC}\n" \
        "TOTALS" "" "$total_in_k8s" "$total_healthy" "$total_avail" "$total_hosts_sum" "$total_size"
    echo ""
    echo -e "${GRAY}  Total GPU Memory Cluster Size: ${WHITE}$total_size${NC}"
    echo -e "${GRAY}    ├─ Total Instances in K8s:        ${GREEN}$total_in_k8s${NC}"
    echo -e "${GRAY}    └─ Total Instances NOT in K8s:    ${RED}$total_not_in_k8s${NC}"
    echo -e "${GRAY}  Total Fabric Available Hosts:  ${LIGHT_GREEN}$total_avail${NC}"
    echo ""
    echo -e "${GRAY}  Total Fabric Hosts:            ${WHITE}$total_hosts_sum${NC}"
    echo -e "${GRAY}    ├─ Total Fabric Healthy Hosts:    ${WHITE}$total_healthy${NC}"
    echo -e "${GRAY}    ├─ Total Unhealthy Instances:     ${RED}$total_unhealthy${NC}  ${GRAY}(DEGRADED or has Announcement)${NC}"
    echo -e "${GRAY}    └─ Total Instances in HoPS:       ${YELLOW}$total_in_hops${NC}  ${GRAY}(UNAVAILABLE in Capacity Topology)${NC}"
    echo ""
    
    # Show fabrics without GPU Memory Clusters
    if [[ -f "$FABRIC_CACHE" ]]; then
        local unused_fabrics_temp
        unused_fabrics_temp=$(create_temp_file) || { rm -f "$joined_temp" "$summary_temp"; return 1; }
        local unused_healthy=0 unused_avail=0 unused_total=0
        
        # Find fabrics not referenced by any cluster
        # FABRIC_CACHE format: DisplayName|Last5Chars|FabricOCID|State|HealthyHosts|AvailableHosts|TotalHosts|CurrentFirmware|TargetFirmware|FirmwareUpdateState
        while IFS='|' read -r fabric_name last5 fabric_ocid fabric_state healthy avail total current_fw target_fw fw_state; do
            [[ "$fabric_name" =~ ^#.*$ ]] && continue
            [[ -z "$fabric_ocid" ]] && continue
            
            # Check if this fabric is used by any cluster (check if it's in seen_fabrics)
            if [[ -z "${seen_fabrics[$fabric_ocid]:-}" ]]; then
                echo "${fabric_name}|${fabric_ocid}|${fabric_state}|${healthy}|${avail}|${total}|${current_fw}|${target_fw}|${fw_state}" >> "$unused_fabrics_temp"
                [[ "$healthy" =~ ^[0-9]+$ ]] && unused_healthy=$((unused_healthy + healthy))
                [[ "$avail" =~ ^[0-9]+$ ]] && unused_avail=$((unused_avail + avail))
                [[ "$total" =~ ^[0-9]+$ ]] && unused_total=$((unused_total + total))
            fi
        done < <(grep -v '^#' "$FABRIC_CACHE" 2>/dev/null)
        
        if [[ -s "$unused_fabrics_temp" ]]; then
            echo ""
            echo -e "${BOLD}${MAGENTA}=== GPU Memory Fabrics Without Clusters ===${NC}"
            echo ""
            printf "${BOLD}%-48s ┌─ GPU Memory Fabric ─┐${NC}\n" ""
            printf "${BOLD}%-48s %8s %6s %6s    %-12s${NC}\n" \
                "Fabric Display Name" "Healthy" "Avail" "Total" "State"
            print_separator 106
            
            while IFS='|' read -r fabric_name fabric_ocid fabric_state healthy avail total current_fw target_fw fw_state; do
                [[ -z "$fabric_name" ]] && continue
                
                local state_color avail_color
                state_color=$(color_fabric_state "$fabric_state")
                avail_color="$WHITE"
                [[ "$avail" != "0" && "$avail" != "N/A" ]] && avail_color="$LIGHT_GREEN"
                
                printf "${CYAN}%-48s${NC} ${WHITE}%8s${NC} ${avail_color}%6s${NC} ${WHITE}%6s${NC}    ${state_color}%-12s${NC}\n" \
                    "$fabric_name" "$healthy" "$avail" "$total" "$fabric_state"
                printf "          ${WHITE}├─${NC} ${BOLD}${ORANGE}%-18s${NC} ${WHITE}%-44s${NC} ${WHITE}(${YELLOW}%s${WHITE})${NC}\n" \
                    "Fabric:" "$fabric_name" "$fabric_ocid"
                
                # Firmware
                if [[ "$current_fw" != "N/A" && -n "$current_fw" ]]; then
                    local current_short="${current_fw: -5}"
                    local target_short="${target_fw: -5}"
                    local firmware_color="$WHITE"
                    [[ "$current_fw" != "$target_fw" && "$target_fw" != "N/A" ]] && firmware_color="$RED"
                    
                    local update_state_color
                    update_state_color=$(color_firmware_state "$fw_state")
                    
                    printf "          ${WHITE}└─${NC} ${BOLD}${ORANGE}Firmware:${NC} ${update_state_color}%-12s${NC} ${firmware_color}current: %-10s target: %-10s${NC}\n" \
                        "$fw_state" "$current_short" "$target_short"
                fi
                echo ""
            done < "$unused_fabrics_temp"
            
            print_separator 106
            printf "${BOLD}${WHITE}%-48s %8s %6s %6s${NC}\n" \
                "TOTALS (Unused Fabrics)" "$unused_healthy" "$unused_avail" "$unused_total"
            echo ""
        fi
        
        rm -f "$unused_fabrics_temp"
    fi
    
    rm -f "$joined_temp" "$summary_temp"
}

# List all unique cliques with details
list_all_cliques() {
    echo -e "${BOLD}${MAGENTA}=== All GPU Cliques in Kubernetes Cluster ===${NC}"
    echo ""
    
    local cliques
    cliques=$(kubectl get nodes -o json 2>/dev/null | jq -r '.items[].metadata.labels["nvidia.com/gpu.clique"]' | grep -v null | sort -u)
    
    if [[ -z "$cliques" ]]; then
        echo -e "${YELLOW}No GPU cliques found in the cluster${NC}"
        return 0
    fi
    
    local total_cliques
    total_cliques=$(echo "$cliques" | wc -l)
    echo -e "${BOLD}${CYAN}Total Cliques Found:${NC} $total_cliques"
    echo ""
    
    # Fetch OCI data once
    local oci_data
    oci_data=$(create_temp_file) || return 1
    
    log_info "Fetching all instance details from OCI..."
    oci compute instance list \
        --compartment-id "${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}" \
        --region "${EFFECTIVE_REGION:-$REGION}" \
        --all \
        --output json 2>/dev/null | jq -r '.data[] | "\(.id)|\(.["display-name"])|\(.["lifecycle-state"])|\(.["freeform-tags"]["oci:compute:gpumemorycluster"] // "N/A")"' > "$oci_data"
    
    # Fetch GPU cluster data for instance config lookup
    fetch_gpu_clusters
    fetch_instance_configurations
    
    local clique_id
    while read -r clique_id; do
        [[ -z "$clique_id" ]] && continue
        
        print_separator 50
        echo -e "${BOLD}${YELLOW}Clique ID:${NC} $clique_id"
        
        local node_count
        node_count=$(kubectl get nodes -o json 2>/dev/null | jq --arg clique "$clique_id" '[.items[] | select(.metadata.labels["nvidia.com/gpu.clique"]==$clique)] | length')
        echo -e "${BOLD}${CYAN}Node Count:${NC} $node_count"
        echo ""
        
        # Get nodes grouped by GPU memory cluster
        declare -A cluster_nodes
        local clique_data
        clique_data=$(kubectl get nodes -o json 2>/dev/null | jq -r --arg clique "$clique_id" '
            .items[] | 
            select(.metadata.labels["nvidia.com/gpu.clique"]==$clique) | 
            "\(.metadata.name)|\(.spec.providerID)"
        ')
        
        local node ocid
        while IFS='|' read -r node ocid; do
            [[ -z "$node" ]] && continue
            
            local gpu_mem_cluster
            gpu_mem_cluster=$(grep "^${ocid}|" "$oci_data" 2>/dev/null | cut -d'|' -f4)
            gpu_mem_cluster="${gpu_mem_cluster:-N/A}"
            
            if [[ -z "${cluster_nodes[$gpu_mem_cluster]:-}" ]]; then
                cluster_nodes[$gpu_mem_cluster]="$node|$ocid"
            else
                cluster_nodes[$gpu_mem_cluster]="${cluster_nodes[$gpu_mem_cluster]}"$'\n'"$node|$ocid"
            fi
        done <<< "$clique_data"
        
        # Display grouped by GPU memory cluster
        local mem_cluster
        for mem_cluster in $(echo "${!cluster_nodes[@]}" | tr ' ' '\n' | sort); do
            local cluster_node_count
            cluster_node_count=$(echo "${cluster_nodes[$mem_cluster]}" | wc -l)
            echo -e "${BOLD}${GREEN}  GPU Mem Cluster: $mem_cluster${NC} ${CYAN}(Nodes: $cluster_node_count)${NC}"
            
            # Show instance configuration for this cluster
            if [[ "$mem_cluster" != "N/A" ]]; then
                local instance_config_id
                instance_config_id=$(get_instance_config_from_cluster "$mem_cluster")
                if is_valid_ocid "$instance_config_id"; then
                    local instance_config_name
                    instance_config_name=$(get_instance_config_name "$instance_config_id")
                    echo -e "    ${BOLD}${YELLOW}Instance Config:${NC} ${WHITE}$instance_config_name${NC}"
                    echo -e "                    ${CYAN}$instance_config_id${NC}"
                fi
            fi
            
            while IFS='|' read -r node ocid; do
                echo -e "    ${WHITE}$node${NC} - ${YELLOW}$ocid${NC}"
            done <<< "${cluster_nodes[$mem_cluster]}"
            echo ""
        done
        
        unset cluster_nodes
    done <<< "$cliques"
    
    rm -f "$oci_data"
    print_separator 50
}

# List cliques summary
list_cliques_summary() {
    echo -e "${BOLD}${MAGENTA}=== GPU Cliques Summary ===${NC}"
    echo ""
    
    local cliques
    cliques=$(kubectl get nodes -o json 2>/dev/null | jq -r '.items[].metadata.labels["nvidia.com/gpu.clique"]' | grep -v null | sort -u)
    
    if [[ -z "$cliques" ]]; then
        echo -e "${YELLOW}No GPU cliques found in the cluster${NC}"
        return 0
    fi
    
    local oci_data
    oci_data=$(create_temp_file) || return 1
    
    log_info "Fetching all instance details from OCI..."
    oci compute instance list \
        --compartment-id "${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}" \
        --region "${EFFECTIVE_REGION:-$REGION}" \
        --all \
        --output json 2>/dev/null | jq -r '.data[] | "\(.id)|\(.["display-name"])|\(.["lifecycle-state"])|\(.["freeform-tags"]["oci:compute:gpumemorycluster"] // "N/A")"' > "$oci_data"
    
    # Fetch GPU cluster data for instance config lookup
    fetch_gpu_clusters
    fetch_instance_configurations
    
    echo ""
    printf "${BOLD}%-40s %-15s %-20s${NC}\n" "Clique ID" "Total Nodes" "Memory Clusters"
    print_separator 75
    
    local clique_id
    while read -r clique_id; do
        [[ -z "$clique_id" ]] && continue
        
        local node_count
        node_count=$(kubectl get nodes -o json 2>/dev/null | jq --arg clique "$clique_id" '[.items[] | select(.metadata.labels["nvidia.com/gpu.clique"]==$clique)] | length')
        
        local clique_data
        clique_data=$(kubectl get nodes -o json 2>/dev/null | jq -r --arg clique "$clique_id" '
            .items[] | 
            select(.metadata.labels["nvidia.com/gpu.clique"]==$clique) | 
            .spec.providerID
        ')
        
        declare -A mem_clusters
        declare -A mem_cluster_instance_configs
        local ocid
        while read -r ocid; do
            [[ -z "$ocid" ]] && continue
            local gpu_mem_cluster
            gpu_mem_cluster=$(grep "^${ocid}|" "$oci_data" 2>/dev/null | cut -d'|' -f4)
            gpu_mem_cluster="${gpu_mem_cluster:-N/A}"
            mem_clusters[$gpu_mem_cluster]=1
            if [[ "$gpu_mem_cluster" != "N/A" && -z "${mem_cluster_instance_configs[$gpu_mem_cluster]:-}" ]]; then
                mem_cluster_instance_configs[$gpu_mem_cluster]=$(get_instance_config_from_cluster "$gpu_mem_cluster")
            fi
        done <<< "$clique_data"
        
        local cluster_list
        cluster_list=$(echo "${!mem_clusters[@]}" | tr ' ' '\n' | sort | tr '\n' ',' | sed 's/,$//')
        
        printf "${CYAN}%-40s${NC} ${GREEN}%-15s${NC} ${YELLOW}%-20s${NC}\n" "$clique_id" "$node_count" "$cluster_list"
        
        # Show instance configurations for each cluster
        local mc
        for mc in $(echo "${!mem_clusters[@]}" | tr ' ' '\n' | sort); do
            if [[ "$mc" != "N/A" && -n "${mem_cluster_instance_configs[$mc]:-}" ]]; then
                local ic="${mem_cluster_instance_configs[$mc]}"
                if is_valid_ocid "$ic"; then
                    local short_mc="...${mc: -12}"
                    local ic_name
                    ic_name=$(get_instance_config_name "$ic")
                    printf "  ${BOLD}${YELLOW}└─ ${short_mc} Instance Config:${NC} ${WHITE}%-40s${NC} ${CYAN}%s${NC}\n" "$ic_name" "$ic"
                fi
            fi
        done
        
        unset mem_clusters mem_cluster_instance_configs
    done <<< "$cliques"
    
    rm -f "$oci_data"
}

# Get detailed node info for a specific instance
get_node_info() {
    local instance_id="$1"
    local show_labels="$2"
    local show_clique="$3"
    local count_clique="$4"
    
    # Fetch all required cache data upfront
    fetch_gpu_fabrics
    fetch_gpu_clusters
    fetch_instance_configurations
    fetch_node_states
    fetch_capacity_topology
    build_announcement_lookup "${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    
    # Get OCI instance details FIRST
    log_info "Fetching OCI instance details..."
    local oci_instance_json
    oci_instance_json=$(oci compute instance get --instance-id "$instance_id" --output json 2>/dev/null)
    
    if [[ -z "$oci_instance_json" ]] || ! echo "$oci_instance_json" | jq -e '.data' > /dev/null 2>&1; then
        log_error "Could not find instance in OCI: $instance_id"
        return 1
    fi
    
    # Extract OCI instance fields
    local display_name oci_state shape ad fault_domain gpu_memory_cluster time_created
    display_name=$(echo "$oci_instance_json" | jq -r '.data["display-name"] // "N/A"')
    oci_state=$(echo "$oci_instance_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    shape=$(echo "$oci_instance_json" | jq -r '.data.shape // "N/A"')
    ad=$(echo "$oci_instance_json" | jq -r '.data["availability-domain"] // "N/A"')
    fault_domain=$(echo "$oci_instance_json" | jq -r '.data["fault-domain"] // "N/A"')
    gpu_memory_cluster=$(echo "$oci_instance_json" | jq -r '.data["freeform-tags"]["oci:compute:gpumemorycluster"] // "N/A"')
    time_created=$(echo "$oci_instance_json" | jq -r '.data["time-created"] // "N/A"')
    
    # Try to get Kubernetes node info (optional - may not exist)
    local node_json node_name node_data
    local in_kubernetes="false"
    node_json=$(kubectl get nodes -o json 2>/dev/null)
    
    if [[ -n "$node_json" ]]; then
        # Use contains() because providerID format is "oci://ocid1.instance..." not just the OCID
        node_name=$(echo "$node_json" | jq -r --arg id "$instance_id" '.items[] | select(.spec.providerID | contains($id)) | .metadata.name')
        if [[ -n "$node_name" ]]; then
            in_kubernetes="true"
            node_data=$(echo "$node_json" | jq --arg name "$node_name" '.items[] | select(.metadata.name==$name)')
        fi
    fi
    
    # Extract Kubernetes node fields (defaults if not in K8s)
    local node_state clique_id gpu_count gpu_product gpu_memory
    local kubelet_version os_image kernel_version container_runtime
    
    if [[ "$in_kubernetes" == "true" ]]; then
        node_state=$(get_node_state_cached "$instance_id")
        clique_id=$(echo "$node_data" | jq -r '.metadata.labels["nvidia.com/gpu.clique"] // "N/A"')
        gpu_count=$(echo "$node_data" | jq -r '.status.capacity["nvidia.com/gpu"] // "N/A"')
        gpu_product=$(echo "$node_data" | jq -r '.metadata.labels["nvidia.com/gpu.product"] // "N/A"')
        gpu_memory=$(echo "$node_data" | jq -r '.metadata.labels["nvidia.com/gpu.memory"] // "N/A"')
        kubelet_version=$(echo "$node_data" | jq -r '.status.nodeInfo.kubeletVersion // "N/A"')
        os_image=$(echo "$node_data" | jq -r '.status.nodeInfo.osImage // "N/A"')
        kernel_version=$(echo "$node_data" | jq -r '.status.nodeInfo.kernelVersion // "N/A"')
        container_runtime=$(echo "$node_data" | jq -r '.status.nodeInfo.containerRuntimeVersion // "N/A"')
    else
        node_name="NOT IN KUBERNETES"
        node_state="N/A"
        clique_id="N/A"
        gpu_count="N/A"
        gpu_product="N/A"
        gpu_memory="N/A"
        kubelet_version="N/A"
        os_image="N/A"
        kernel_version="N/A"
        container_runtime="N/A"
    fi
    
    # Get additional states
    local cap_topo_state announcements
    cap_topo_state=$(get_capacity_topology_state "$instance_id")
    announcements=$(get_resource_announcements "$instance_id" "$gpu_memory_cluster")
    
    # Get GPU memory cluster and fabric details
    local cluster_state="N/A"
    local instance_config_id="N/A"
    local fabric_name="N/A" fabric_ocid="N/A" fabric_state="N/A"
    local fabric_healthy_hosts="N/A" fabric_avail_hosts="N/A" fabric_total_hosts="N/A"
    
    if [[ "$gpu_memory_cluster" != "N/A" && "$gpu_memory_cluster" != "null" ]]; then
        cluster_state=$(get_cluster_state "$gpu_memory_cluster")
        instance_config_id=$(get_instance_config_from_cluster "$gpu_memory_cluster")
        local fabric_info
        fabric_info=$(get_fabric_from_cluster "$gpu_memory_cluster")
        # Format: DisplayName|Last5Chars|FabricOCID|State|HealthyHosts|AvailableHosts|TotalHosts
        IFS='|' read -r fabric_name _ fabric_ocid fabric_state fabric_healthy_hosts fabric_avail_hosts fabric_total_hosts <<< "$fabric_info"
    fi
    
    # Get clique size
    local clique_size="N/A"
    if [[ "$clique_id" != "N/A" && "$clique_id" != "null" ]]; then
        clique_size=$(echo "$node_json" | jq --arg clique "$clique_id" '[.items[] | select(.metadata.labels["nvidia.com/gpu.clique"]==$clique)] | length')
    fi
    
    echo ""
    
    # Display header
    echo -e "${BOLD}${MAGENTA}╔══════════════════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}${MAGENTA}║                           INSTANCE DETAILS                                   ║${NC}"
    echo -e "${BOLD}${MAGENTA}╚══════════════════════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    # OCI Instance section
    echo -e "${BOLD}${CYAN}=== OCI Instance ===${NC}"
    echo -e "  ${WHITE}Display Name:${NC}      $display_name"
    echo -e "  ${WHITE}Instance OCID:${NC}     ${YELLOW}$instance_id${NC}"
    echo -e "  ${WHITE}Shape:${NC}             $shape"
    echo -e "  ${WHITE}Availability Domain:${NC} $ad"
    echo -e "  ${WHITE}Fault Domain:${NC}      $fault_domain"
    echo -e "  ${WHITE}Created:${NC}           $time_created"
    
    local oci_state_color
    oci_state_color=$(color_oci_state "$oci_state")
    echo -e "  ${WHITE}OCI State:${NC}         ${oci_state_color}${oci_state}${NC}"
    echo ""
    
    # Kubernetes Node section
    echo -e "${BOLD}${CYAN}=== Kubernetes Node ===${NC}"
    if [[ "$in_kubernetes" == "true" ]]; then
        echo -e "  ${WHITE}Node Name:${NC}         ${GREEN}$node_name${NC}"
        
        local node_state_color
        node_state_color=$(color_node_state "$node_state")
        echo -e "  ${WHITE}Node State:${NC}        ${node_state_color}${node_state}${NC}"
        
        # Check cordon/drain status
        local node_json
        node_json=$(kubectl get node "$node_name" -o json 2>/dev/null)
        local is_unschedulable
        is_unschedulable=$(echo "$node_json" | jq -r '.spec.unschedulable // false' 2>/dev/null)
        
        # Get pod count on this node
        local pod_count
        pod_count=$(kubectl get pods --all-namespaces --field-selector=spec.nodeName="$node_name",status.phase=Running -o json 2>/dev/null | jq '.items | length' 2>/dev/null)
        [[ -z "$pod_count" ]] && pod_count="0"
        
        # Get daemonset pod count
        local ds_pod_count
        ds_pod_count=$(kubectl get pods --all-namespaces --field-selector=spec.nodeName="$node_name",status.phase=Running -o json 2>/dev/null | \
            jq '[.items[] | select(.metadata.ownerReferences[]?.kind == "DaemonSet")] | length' 2>/dev/null)
        [[ -z "$ds_pod_count" ]] && ds_pod_count="0"
        
        # Determine scheduling status
        local sched_status="Schedulable"
        local sched_color="$GREEN"
        if [[ "$is_unschedulable" == "true" ]]; then
            # Check if drained (cordoned + only daemonset pods)
            local non_ds_pods=$((pod_count - ds_pod_count))
            if [[ $non_ds_pods -le 0 ]]; then
                sched_status="Drained"
                sched_color="$RED"
            else
                sched_status="Cordoned"
                sched_color="$YELLOW"
            fi
        fi
        
        echo -e "  ${WHITE}Schedule Status:${NC}   ${sched_color}${sched_status}${NC}"
        echo -e "  ${WHITE}Running Pods:${NC}      ${CYAN}${pod_count}${NC} ${GRAY}(${ds_pod_count} DaemonSet)${NC}"
        
        echo -e "  ${WHITE}Kubelet Version:${NC}   $kubelet_version"
        echo -e "  ${WHITE}OS Image:${NC}          $os_image"
        echo -e "  ${WHITE}Kernel:${NC}            $kernel_version"
        echo -e "  ${WHITE}Container Runtime:${NC} $container_runtime"
    else
        echo -e "  ${YELLOW}Instance has not joined the Kubernetes cluster${NC}"
        echo -e "  ${GRAY}Use --console-history to check boot logs for issues${NC}"
    fi
    echo ""
    
    # GPU Information section
    echo -e "${BOLD}${CYAN}=== GPU Information ===${NC}"
    if [[ "$in_kubernetes" == "true" ]]; then
        echo -e "  ${WHITE}GPU Count:${NC}         $gpu_count"
        echo -e "  ${WHITE}GPU Product:${NC}       $gpu_product"
        echo -e "  ${WHITE}GPU Memory:${NC}        $gpu_memory MB"
        echo -e "  ${WHITE}GPU Clique ID:${NC}     ${YELLOW}$clique_id${NC}"
        echo -e "  ${WHITE}Clique Size:${NC}       $clique_size nodes"
    else
        echo -e "  ${YELLOW}GPU information not available (instance not in K8s)${NC}"
        echo -e "  ${WHITE}Shape:${NC}             $shape"
    fi
    echo ""
    
    # GPU Memory Cluster section
    echo -e "${BOLD}${CYAN}=== GPU Memory Cluster ===${NC}"
    if [[ "$gpu_memory_cluster" != "N/A" && "$gpu_memory_cluster" != "null" ]]; then
        echo -e "  ${WHITE}Cluster OCID:${NC}      ${YELLOW}$gpu_memory_cluster${NC}"
        
        local cluster_state_color
        cluster_state_color=$(color_cluster_state "$cluster_state")
        echo -e "  ${WHITE}Cluster State:${NC}     ${cluster_state_color}${cluster_state}${NC}"
        
        if is_valid_ocid "$instance_config_id"; then
            local instance_config_name
            instance_config_name=$(get_instance_config_name "$instance_config_id")
            echo -e "  ${WHITE}Instance Config:${NC}   ${WHITE}$instance_config_name${NC}"
            echo -e "                     ${CYAN}$instance_config_id${NC}"
        fi
    else
        echo -e "  ${YELLOW}No GPU Memory Cluster assigned${NC}"
    fi
    echo ""
    
    # GPU Memory Fabric section
    echo -e "${BOLD}${CYAN}=== GPU Memory Fabric ===${NC}"
    if [[ "$fabric_name" != "N/A" ]]; then
        echo -e "  ${WHITE}Fabric Name:${NC}       $fabric_name"
        echo -e "  ${WHITE}Fabric OCID:${NC}       ${YELLOW}$fabric_ocid${NC}"
        
        local fabric_state_color
        fabric_state_color=$(color_fabric_state "$fabric_state")
        echo -e "  ${WHITE}Fabric State:${NC}      ${fabric_state_color}${fabric_state}${NC}"
        
        echo -e "  ${WHITE}Healthy Hosts:${NC}     ${YELLOW}${fabric_healthy_hosts}${NC}"
        echo -e "  ${WHITE}Available Hosts:${NC}   ${fabric_avail_hosts}"
        echo -e "  ${WHITE}Total Hosts:${NC}       ${fabric_total_hosts}"
    else
        echo -e "  ${YELLOW}No GPU Memory Fabric information available${NC}"
    fi
    echo ""
    
    # Capacity Topology section
    echo -e "${BOLD}${CYAN}=== Capacity Topology ===${NC}"
    local cap_topo_color
    cap_topo_color=$(color_cap_topo_state "$cap_topo_state")
    echo -e "  ${WHITE}Host Status:${NC}       ${cap_topo_color}${cap_topo_state}${NC}"
    echo ""
    
    # Announcements section
    echo -e "${BOLD}${CYAN}=== Announcements ===${NC}"
    if [[ "$announcements" != "-" ]]; then
        echo -e "  ${WHITE}Active Tickets:${NC}    ${RED}${announcements}${NC}"
        
        # Show details for each announcement
        local ticket
        for ticket in ${announcements//,/ }; do
            local detail_file
            for detail_file in "$CACHE_DIR"/*.json; do
                [[ ! -f "$detail_file" ]] && continue
                [[ "$detail_file" == "$ANNOUNCEMENTS_LIST_CACHE" ]] && continue
                [[ "$detail_file" == *"/ack_status_cache.json" ]] && continue
                
                local ref_ticket
                ref_ticket=$(jq -r '.data."reference-ticket-number" // ""' "$detail_file" 2>/dev/null)
                if [[ "${ref_ticket:0:8}" == "$ticket" ]]; then
                    local ann_summary ann_type ann_time
                    ann_summary=$(jq -r '.data.summary // "N/A"' "$detail_file")
                    ann_type=$(jq -r '.data."announcement-type" // "N/A"' "$detail_file")
                    ann_time=$(jq -r '.data."time-one-value" // "N/A"' "$detail_file")
                    echo ""
                    echo -e "  ${YELLOW}Ticket: ${ticket}${NC}"
                    echo -e "    ${WHITE}Type:${NC}    $ann_type"
                    echo -e "    ${WHITE}Summary:${NC} $ann_summary"
                    echo -e "    ${WHITE}Time:${NC}    $ann_time"
                    break
                fi
            done
        done
    else
        echo -e "  ${GREEN}No active announcements${NC}"
    fi
    echo ""
    
    # Optional: Show Labels
    if [[ "$show_labels" == "true" ]]; then
        if [[ "$in_kubernetes" == "true" ]]; then
            echo -e "${BOLD}${CYAN}=== All Kubernetes Labels ===${NC}"
            echo "$node_data" | jq -r '.metadata.labels | to_entries | sort_by(.key) | .[] | "  \(.key): \(.value)"'
            echo ""
            
            echo -e "${BOLD}${CYAN}=== GPU Labels Only ===${NC}"
            echo "$node_data" | jq -r '.metadata.labels | to_entries | map(select(.key | contains("nvidia.com/gpu"))) | sort_by(.key) | .[] | "  \(.key): \(.value)"'
            echo ""
        else
            echo -e "${BOLD}${CYAN}=== Kubernetes Labels ===${NC}"
            echo -e "  ${YELLOW}Instance not in Kubernetes - no labels available${NC}"
            echo ""
        fi
    fi
    
    # Optional: Count Clique Members
    if [[ "$count_clique" == "true" && "$clique_id" != "N/A" && "$clique_id" != "null" && "$in_kubernetes" == "true" ]]; then
        echo -e "${BOLD}${CYAN}=== Nodes in Same Clique (${clique_id}) ===${NC}"
        echo ""
        
        local clique_nodes
        clique_nodes=$(echo "$node_json" | jq -r --arg clique "$clique_id" '
            .items[] | 
            select(.metadata.labels["nvidia.com/gpu.clique"]==$clique) | 
            "\(.metadata.name)|\(.spec.providerID)"
        ')
        
        local oci_data
        oci_data=$(create_temp_file) || return 0
        
        oci compute instance list \
            --compartment-id "${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}" \
            --region "${EFFECTIVE_REGION:-$REGION}" \
            --all \
            --output json 2>/dev/null | jq -r '.data[] | "\(.id)|\(.["display-name"])|\(.["lifecycle-state"])|\(.["freeform-tags"]["oci:compute:gpumemorycluster"] // "N/A")"' > "$oci_data"
        
        # Group by GPU memory cluster
        declare -A cluster_nodes
        local node ocid
        while IFS='|' read -r node ocid; do
            [[ -z "$node" ]] && continue
            
            local mem_cluster
            mem_cluster=$(grep "^${ocid}|" "$oci_data" 2>/dev/null | cut -d'|' -f4)
            mem_cluster="${mem_cluster:-N/A}"
            
            if [[ -z "${cluster_nodes[$mem_cluster]:-}" ]]; then
                cluster_nodes[$mem_cluster]="$node|$ocid"
            else
                cluster_nodes[$mem_cluster]="${cluster_nodes[$mem_cluster]}"$'\n'"$node|$ocid"
            fi
        done <<< "$clique_nodes"
        
        # Display grouped by GPU memory cluster
        local mem_cluster
        for mem_cluster in $(echo "${!cluster_nodes[@]}" | tr ' ' '\n' | sort); do
            local cluster_node_count
            cluster_node_count=$(echo "${cluster_nodes[$mem_cluster]}" | wc -l)
            local short_cluster="...${mem_cluster: -9}"
            [[ "$mem_cluster" == "N/A" ]] && short_cluster="N/A"
            
            echo -e "  ${BOLD}${BLUE}GPU Memory Cluster: ${short_cluster}${NC} (${cluster_node_count} nodes)"
            
            # Show instance configuration for this cluster
            if [[ "$mem_cluster" != "N/A" ]]; then
                local ic
                ic=$(get_instance_config_from_cluster "$mem_cluster")
                if is_valid_ocid "$ic"; then
                    local ic_name
                    ic_name=$(get_instance_config_name "$ic")
                    echo -e "    ${BOLD}${YELLOW}Instance Config:${NC} ${WHITE}$ic_name${NC}"
                    echo -e "                    ${CYAN}$ic${NC}"
                fi
            fi
            
            while IFS='|' read -r node ocid; do
                local is_current=""
                [[ "$ocid" == "$instance_id" ]] && is_current=" ${MAGENTA}← current${NC}"
                echo -e "    ${GREEN}$node${NC} - ${YELLOW}$ocid${NC}${is_current}"
            done <<< "${cluster_nodes[$mem_cluster]}"
            echo ""
        done
        
        unset cluster_nodes
        rm -f "$oci_data"
    elif [[ "$count_clique" == "true" && "$in_kubernetes" != "true" ]]; then
        echo -e "${BOLD}${CYAN}=== Clique Information ===${NC}"
        echo -e "  ${YELLOW}Instance not in Kubernetes - clique information not available${NC}"
        echo ""
    fi
    
    return 0
}

# List instances by GPU cluster
list_instances_by_gpu_cluster() {
    local gpu_cluster="$1"
    local compartment_id="$2"
    local region="$3"
    
    # Validate parameters
    [[ -z "$gpu_cluster" ]] && { log_error "GPU cluster ID required"; return 1; }
    [[ -z "$compartment_id" ]] && { log_error "COMPARTMENT_ID not set"; return 1; }
    [[ -z "$region" ]] && { log_error "REGION not set"; return 1; }
    
    fetch_gpu_fabrics
    fetch_gpu_clusters
    fetch_instance_configurations
    fetch_node_states
    fetch_capacity_topology
    build_announcement_lookup "$compartment_id"
    
    echo -e "${BOLD}${MAGENTA}=== Instances in GPU Memory Cluster ===${NC}"
    echo -e "${CYAN}GPU Memory Cluster:${NC} $gpu_cluster"
    echo -e "${CYAN}Compartment:${NC} ${WHITE}$(resolve_compartment_name "$compartment_id")${NC} ${GRAY}($compartment_id)${NC}"
    echo -e "${CYAN}Region:${NC} $region"
    echo ""
    
    local cluster_state
    cluster_state=$(get_cluster_state "$gpu_cluster")
    local cluster_state_color
    cluster_state_color=$(color_cluster_state "$cluster_state")
    echo -e "${CYAN}Cluster State:${NC} ${cluster_state_color}${cluster_state}${NC}"
    
    # Get and display instance configuration
    local instance_config_id
    instance_config_id=$(get_instance_config_from_cluster "$gpu_cluster")
    if is_valid_ocid "$instance_config_id"; then
        local instance_config_name
        instance_config_name=$(get_instance_config_name "$instance_config_id")
        echo -e "${CYAN}Instance Configuration:${NC} ${WHITE}$instance_config_name${NC}"
        echo -e "                        ${YELLOW}$instance_config_id${NC}"
    fi
    
    local fabric_info
    fabric_info=$(get_fabric_from_cluster "$gpu_cluster")
    # Format: DisplayName|Last5Chars|FabricOCID|State|HealthyHosts|AvailableHosts|TotalHosts
    local fabric_name fabric_suffix fabric_ocid fabric_state healthy_hosts avail_hosts total_hosts
    IFS='|' read -r fabric_name fabric_suffix fabric_ocid fabric_state healthy_hosts avail_hosts total_hosts <<< "$fabric_info"
    
    if [[ "$fabric_name" != "N/A" ]]; then
        echo ""
        echo -e "${BOLD}${GREEN}=== GPU Memory Fabric ===${NC}"
        echo -e "${CYAN}Fabric Name:${NC}     $fabric_name"
        echo -e "${CYAN}Fabric OCID:${NC}     $fabric_ocid"
        local fabric_state_color
        fabric_state_color=$(color_fabric_state "$fabric_state")
        echo -e "${CYAN}Fabric State:${NC}    ${fabric_state_color}${fabric_state}${NC}"
        echo -e "${CYAN}Healthy Hosts:${NC}   ${YELLOW}${healthy_hosts}${NC}"
        echo -e "${CYAN}Available Hosts:${NC} ${avail_hosts}"
        echo -e "${CYAN}Total Hosts:${NC}     ${total_hosts}"
    fi
    
    echo ""
    
    local oci_data k8s_data
    oci_data=$(create_temp_file) || return 1
    k8s_data=$(create_temp_file) || { rm -f "$oci_data"; return 1; }
    
    log_info "Fetching instance details from OCI..."
    # Get all instances for general info
    local all_instances_json
    all_instances_json=$(create_temp_file) || { rm -f "$oci_data" "$k8s_data"; return 1; }
    
    oci compute instance list \
        --compartment-id "$compartment_id" \
        --region "$region" \
        --all \
        --output json 2>/dev/null > "$all_instances_json"
    
    # Get instances belonging to this GPU cluster via API (not freeform tag)
    log_info "Fetching instances in GPU cluster via API..."
    local cluster_instances_json
    cluster_instances_json=$(create_temp_file) || { rm -f "$oci_data" "$k8s_data" "$all_instances_json"; return 1; }
    
    oci compute compute-gpu-memory-cluster-instance-summary list-compute-gpu-memory-cluster-instances \
        --compute-gpu-memory-cluster-id "$gpu_cluster" \
        --all \
        --output json 2>/dev/null > "$cluster_instances_json"
    
    # Extract instance IDs from the cluster
    local cluster_instance_ids
    cluster_instance_ids=$(jq -r '(.data.items // .data // [])[] | .["instance-id"] // .id' "$cluster_instances_json" 2>/dev/null)
    
    # Build oci_data with only instances in this cluster
    for inst_id in $cluster_instance_ids; do
        [[ -z "$inst_id" ]] && continue
        jq -r --arg id "$inst_id" '
            .data[] | select(.id == $id) | 
            "\(.id)|\(.["display-name"])|\(.["lifecycle-state"])|\(.["freeform-tags"]["oci:compute:gpumemorycluster"] // "N/A")"
        ' "$all_instances_json" >> "$oci_data" 2>/dev/null
    done
    
    rm -f "$all_instances_json" "$cluster_instances_json"
    
    log_info "Fetching Kubernetes node data..."
    # Fetch ALL nodes to avoid missing nodes without GPU labels yet
    kubectl get nodes -o json 2>/dev/null | jq -r '
        .items[] | 
        "\(.spec.providerID)|\(.metadata.name)|\(.metadata.labels["nvidia.com/gpu.clique"] // "N/A")"
    ' > "$k8s_data"
    
    echo ""
    
    # Print table header with spanning headers
    # Column positions: DisplayName(28) Node(15) State(7) CliqueID(43) State(11) OCID(95) Name(12) State(10) State(10) Announce(18)
    printf "${BOLD}%-28s%-66s%-107s%-23s%-11s%-11s${NC}\n" \
    "" \
    "┌──────────────────────────── K8s ────────────────────────────┐" \
    "┌──────────────────────────────────── OCI Instance ──────────────────────────────────────┐" \
    "┌─ GPU Mem Cluster ─┐" \
    "CapTopo" \
    "Maintenance"
    printf "${BOLD}%-28s %-15s %-7s %-43s %-11s %-95s %-12s %-10s %-10s %-18s${NC}\n" \
        "Display Name" "Node" "State" "Clique ID" "State" "Instance OCID" "Name" "State" "State" "Announce"
    print_separator 280
    
    # Process instances in this cluster (oci_data now contains only instances in the cluster)
    local instance_id display_name oci_state gpu_mem_tag
    local instances_shown=0
    local instances_in_k8s=0
    while IFS='|' read -r instance_id display_name oci_state gpu_mem_tag; do
        [[ -z "$instance_id" ]] && continue
        ((instances_shown++))
        
        local k8s_info
        # k8s_data format: providerID|nodeName|clique
        k8s_info=$(grep "$instance_id" "$k8s_data" 2>/dev/null)
        
        local node_name clique_id node_state
        if [[ -n "$k8s_info" ]]; then
            ((instances_in_k8s++))
            IFS='|' read -r _ node_name clique_id <<< "$k8s_info"
            node_state=$(get_node_state_cached "$instance_id")
        else
            node_name="-"
            clique_id="-"
            node_state="-"
        fi
        
        # Get GPU memory cluster name
        local gpu_mem_name
        gpu_mem_name=$(get_cluster_name_from_id "$gpu_cluster" 2>/dev/null)
        [[ -z "$gpu_mem_name" || "$gpu_mem_name" == "N/A" ]] && gpu_mem_name="-"
        
        # Get GPU memory cluster state
        local gpu_mem_state
        gpu_mem_state=$(get_cluster_state "$gpu_cluster" 2>/dev/null)
        [[ -z "$gpu_mem_state" || "$gpu_mem_state" == "N/A" ]] && gpu_mem_state="-"
        
        local cap_topo_state announcements
        cap_topo_state=$(get_capacity_topology_state "$instance_id")
        announcements=$(get_resource_announcements "$instance_id" "$gpu_cluster")
        
        # Get colors
        local ns_color st_color ct_color ann_color gmc_color
        ns_color=$(color_node_state "$node_state")
        st_color=$(color_oci_state "$oci_state")
        ct_color=$(color_cap_topo_state "$cap_topo_state")
        ann_color=$(color_announcement "$announcements")
        gmc_color=$(color_cluster_state "$gpu_mem_state")
        
        printf "%-28s %-15s ${ns_color}%-7s${NC} %-43s ${st_color}%-11s${NC} %-95s %-12s ${gmc_color}%-10s${NC} ${ct_color}%-10s${NC} ${ann_color}%-18s${NC}\n" \
            "${display_name:0:27}" "${node_name:0:14}" "$node_state" "${clique_id:0:42}" "$oci_state" "$instance_id" "${gpu_mem_name:0:11}" "$gpu_mem_state" "$cap_topo_state" "$announcements"
    done < "$oci_data"
    
    echo ""
    
    echo -e "${CYAN}Total Instances:${NC} $instances_shown (${instances_in_k8s} in Kubernetes)"
    
    rm -f "$oci_data" "$k8s_data"
}

#===============================================================================
# GPU MEMORY FABRIC & CLUSTER MANAGEMENT
#===============================================================================

# Display interactive management menu
display_gpu_management_menu() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    # Clear and re-initialize index maps as associative arrays
    unset FABRIC_INDEX_MAP CLUSTER_INDEX_MAP IC_INDEX_MAP CC_INDEX_MAP 2>/dev/null
    declare -gA FABRIC_INDEX_MAP=()
    declare -gA CLUSTER_INDEX_MAP=()
    declare -gA IC_INDEX_MAP=()
    declare -gA CC_INDEX_MAP=()
    
    # Fetch all required data
    fetch_gpu_fabrics
    fetch_gpu_clusters
    fetch_instance_configurations
    fetch_compute_clusters
    
    # Get compartment name
    local compartment_name="N/A"
    if [[ -n "$compartment_id" ]]; then
        compartment_name=$(oci iam compartment get --compartment-id "$compartment_id" --query 'data.name' --raw-output 2>/dev/null) || compartment_name="N/A"
    fi
    
    # Get availability domain from compute clusters (first one found)
    local availability_domain="N/A"
    if [[ -f "$COMPUTE_CLUSTER_CACHE" ]]; then
        availability_domain=$(grep -v '^#' "$COMPUTE_CLUSTER_CACHE" 2>/dev/null | head -1 | cut -d'|' -f3)
        [[ -z "$availability_domain" ]] && availability_domain="N/A"
    fi
    
    echo ""
    echo -e "${BOLD}${MAGENTA}╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}${MAGENTA}║                                              GPU MEMORY FABRIC & CLUSTER MANAGEMENT                                                                   ║${NC}"
    echo -e "${BOLD}${MAGENTA}╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    # ========== ENVIRONMENT INFO ==========
    echo -e "${BOLD}${WHITE}Environment:${NC}"
    echo -e "  ${CYAN}Region:${NC}              ${WHITE}${region}${NC}"
    echo -e "  ${CYAN}Availability Domain:${NC} ${WHITE}${availability_domain}${NC}"
    echo -e "  ${CYAN}Compartment:${NC}         ${WHITE}${compartment_name}${NC}"
    echo -e "                       ${YELLOW}${compartment_id}${NC}"
    _display_cache_info \
        "${FABRIC_CACHE}|Fabrics" \
        "${CLUSTER_CACHE}|GPU Clusters" \
        "${INSTANCE_CONFIG_CACHE}|Instance Configs" \
        "${COMPUTE_CLUSTER_CACHE}|Compute Clusters" \
        "${INSTANCE_CLUSTER_MAP_CACHE}|Instance Map"
    echo ""
    echo -e "${BOLD}${ORANGE}═══ GPU Memory Fabrics & Clusters ═══${NC}"
    echo ""
    
    # Header for fabrics - aligned columns (no firmware)
    printf "${BOLD}%-5s %-45s %-12s %8s %6s%6s  %s${NC}\n" \
        "ID" "Display Name" "State" "Healthy" "Avail" "Total" "OCID"
    print_separator 158
    
    local fabric_idx=0
    local cluster_idx=0
    
    if [[ -f "$FABRIC_CACHE" ]]; then
        # Sort fabrics by state: OCCUPIED first, then AVAILABLE, PROVISIONING, UNAVAILABLE
        local sorted_fabrics
        sorted_fabrics=$(grep -v '^#' "$FABRIC_CACHE" 2>/dev/null | awk -F'|' '
            {
                state = $4
                # Assign sort order based on state
                if (state == "OCCUPIED") order = 1
                else if (state == "AVAILABLE") order = 2
                else if (state == "PROVISIONING") order = 3
                else if (state == "UNAVAILABLE") order = 4
                else order = 5
                print order "|" $0
            }
        ' | sort -t'|' -k1,1n | cut -d'|' -f2-)
        
        while IFS='|' read -r fabric_name fabric_suffix fabric_ocid fabric_state healthy_hosts avail_hosts total_hosts current_fw target_fw fw_state; do
            [[ -z "$fabric_ocid" ]] && continue
            
            ((fabric_idx++))
            local fid="f${fabric_idx}"
            FABRIC_INDEX_MAP[$fid]="$fabric_ocid"
            
            # Color state
            local state_color
            case "$fabric_state" in
                OCCUPIED) state_color="$GREEN" ;;
                AVAILABLE) state_color="$GREEN" ;;
                PROVISIONING) state_color="$CYAN" ;;
                UNAVAILABLE) state_color="$RED" ;;
                *) state_color="$WHITE" ;;
            esac
            
            # Color available hosts
            local avail_color="$WHITE"
            [[ "$avail_hosts" != "0" && "$avail_hosts" != "N/A" ]] && avail_color="$LIGHT_GREEN"
            
            # Print fabric line: main info with OCID on same line
            printf "${YELLOW}%-5s${NC} ${CYAN}%-45s${NC} ${state_color}%-12s${NC} ${WHITE}%8s${NC} ${avail_color}%6s${NC}${WHITE}%6s${NC}  ${YELLOW}%s${NC}\n" \
                "$fid" "$fabric_name" "$fabric_state" "$healthy_hosts" "$avail_hosts" "$total_hosts" "$fabric_ocid"
            
            # Find and display clusters for this fabric
            local clusters_found=0
            if [[ -f "$CLUSTER_CACHE" ]]; then
                # Collect clusters for this fabric (include ACTIVE, UPDATING, SCALING, CREATING states)
                local cluster_lines=()
                while IFS='|' read -r cluster_ocid cluster_name cluster_state cluster_fabric_suffix instance_config_id compute_cluster_id cluster_size; do
                    [[ "$cluster_ocid" =~ ^#.*$ ]] && continue
                    [[ -z "$cluster_ocid" ]] && continue
                    # Include ACTIVE, UPDATING, SCALING, and CREATING states
                    [[ "$cluster_state" != "ACTIVE" && "$cluster_state" != "UPDATING" && "$cluster_state" != "SCALING" && "$cluster_state" != "CREATING" ]] && continue
                    [[ "$cluster_fabric_suffix" != "$fabric_suffix" ]] && continue
                    
                    cluster_lines+=("$cluster_ocid|$cluster_name|$cluster_state|$cluster_fabric_suffix|$instance_config_id|$compute_cluster_id|$cluster_size")
                done < <(grep -v '^#' "$CLUSTER_CACHE" 2>/dev/null)
                
                local num_clusters=${#cluster_lines[@]}
                local cluster_i=0
                
                for cluster_line in "${cluster_lines[@]}"; do
                    ((cluster_i++))
                    ((cluster_idx++))
                    ((clusters_found++))
                    
                    local cluster_ocid cluster_name cluster_state cluster_fabric_suffix instance_config_id compute_cluster_id cluster_size
                    IFS='|' read -r cluster_ocid cluster_name cluster_state cluster_fabric_suffix instance_config_id compute_cluster_id cluster_size <<< "$cluster_line"
                    
                    local gid="g${cluster_idx}"
                    CLUSTER_INDEX_MAP[$gid]="$cluster_ocid"
                    
                    # Get instance config name (full name, no truncation)
                    local ic_name="N/A"
                    [[ "$instance_config_id" != "N/A" && -n "$instance_config_id" ]] && ic_name=$(get_instance_config_name "$instance_config_id")
                    
                    # Get compute cluster name
                    local cc_name="N/A"
                    [[ "$compute_cluster_id" != "N/A" && -n "$compute_cluster_id" ]] && cc_name=$(get_compute_cluster_name "$compute_cluster_id")
                    
                    # Tree connector
                    local connector="├──"
                    local continuation="│"
                    [[ $cluster_i -eq $num_clusters ]] && { connector="└──"; continuation=" "; }
                    
                    # Determine state color
                    local state_color
                    state_color=$(color_cluster_state "$cluster_state")
                    
                    # Cluster line 1: ID, Name, State (aligned), Size (aligned with Total), OCID on same line
                    printf "     ${WHITE}${connector}${NC} ${YELLOW}%-4s${NC} ${MAGENTA}%-37s${NC} ${state_color}%-12s${NC} %8s %6s${WHITE}%6s${NC}  ${YELLOW}%s${NC}\n" \
                        "$gid" "$cluster_name" "$cluster_state" "" "" "$cluster_size" "$cluster_ocid"
                    
                    # Cluster line 2: Compute Cluster
                    printf "     ${WHITE}${continuation}${NC}            ${GRAY}Compute Cluster: ${BLUE}%s${NC}\n" "$cc_name"
                    
                    # Cluster line 3: Instance Configuration (full name)
                    printf "     ${WHITE}${continuation}${NC}            ${GRAY}Instance Config: ${GREEN}%s${NC}\n" "$ic_name"
                done
            fi
            
            # Show message if no clusters for this fabric
            if [[ $clusters_found -eq 0 ]]; then
                printf "     ${WHITE}└──${NC} ${GRAY}(no clusters)${NC}\n"
            fi
            
            echo ""
        done <<< "$sorted_fabrics"
    fi
    
    [[ $fabric_idx -eq 0 ]] && echo -e "  ${YELLOW}No GPU Memory Fabrics found${NC}"
    echo ""
    
    # ========== INSTANCE CONFIGURATIONS ==========
    echo -e "${BOLD}${GREEN}═══ Instance Configurations ═══${NC}"
    echo ""
    printf "${BOLD}%-5s %-60s %s${NC}\n" "ID" "Instance Configuration Name" "OCID"
    print_separator 140
    
    local ic_idx=0
    if [[ -f "$INSTANCE_CONFIG_CACHE" ]]; then
        while IFS='|' read -r ic_ocid ic_name _; do
            [[ "$ic_ocid" =~ ^#.*$ ]] && continue
            [[ -z "$ic_ocid" ]] && continue
            
            ((ic_idx++))
            local iid="i${ic_idx}"
            IC_INDEX_MAP[$iid]="$ic_ocid"
            
            printf "${YELLOW}%-5s${NC} ${WHITE}%-60s${NC} ${CYAN}%s${NC}\n" \
                "$iid" "$ic_name" "$ic_ocid"
        done < <(grep -v '^#' "$INSTANCE_CONFIG_CACHE" 2>/dev/null)
    fi
    
    [[ $ic_idx -eq 0 ]] && echo -e "  ${YELLOW}No Instance Configurations found${NC}"
    echo ""
    
    # ========== COMPUTE CLUSTERS ==========
    echo -e "${BOLD}${BLUE}═══ Compute Clusters ═══${NC}"
    echo ""
    printf "${BOLD}%-5s %-50s %-12s %s${NC}\n" "ID" "Compute Cluster Name" "Status" "OCID"
    print_separator 140
    
    local cc_idx=0
    if [[ -f "$COMPUTE_CLUSTER_CACHE" ]]; then
        while IFS='|' read -r cc_ocid cc_name cc_ad cc_state; do
            [[ "$cc_ocid" =~ ^#.*$ ]] && continue
            [[ -z "$cc_ocid" ]] && continue
            
            # Default state if not present (old cache format)
            [[ -z "$cc_state" ]] && cc_state="UNKNOWN"
            
            # Skip deleted clusters
            [[ "$cc_state" == "DELETED" ]] && continue
            
            ((cc_idx++))
            local cid="c${cc_idx}"
            CC_INDEX_MAP[$cid]="$cc_ocid"
            
            # Color-code the status
            local state_color="$GREEN"
            case "$cc_state" in
                ACTIVE) state_color="$GREEN" ;;
                CREATING|UPDATING) state_color="$YELLOW" ;;
                DELETING) state_color="$RED" ;;
                *) state_color="$GRAY" ;;
            esac
            
            printf "${YELLOW}%-5s${NC} ${WHITE}%-50s${NC} ${state_color}%-12s${NC} ${CYAN}%s${NC}\n" \
                "$cid" "$cc_name" "$cc_state" "$cc_ocid"
        done < <(grep -v '^#' "$COMPUTE_CLUSTER_CACHE" 2>/dev/null)
    fi
    
    [[ $cc_idx -eq 0 ]] && echo -e "  ${YELLOW}No Compute Clusters found${NC}"
    echo ""
}

# Interactive prompt for GPU management
#===============================================================================
# INTERACTIVE MANAGEMENT MAIN MENU
#===============================================================================

interactive_management_main_menu() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    while true; do
        echo ""
        echo -e "${BOLD}${BLUE}╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${BOLD}${BLUE}║                                                    OCI RESOURCE MANAGEMENT                                                                            ║${NC}"
        echo -e "${BOLD}${BLUE}╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}Environment:${NC}"
        echo -e "  ${CYAN}Region:${NC}      ${WHITE}${region}${NC}"
        echo -e "  ${CYAN}Compartment:${NC} ${WHITE}$(resolve_compartment_name "${compartment_id}")${NC} ${GRAY}(${compartment_id})${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}═══ Select a Resource to Manage ═══${NC}"
        echo ""
        echo -e "${BOLD}${BLUE}─── Overview ───${NC}"
        echo -e "  ${YELLOW}o${NC})  ${WHITE}Environment Overview${NC}           - Full environment view (same as running script without options)"
        echo ""
        echo -e "${BOLD}${BLUE}─── Kubernetes ───${NC}"
        echo -e "  ${YELLOW}1${NC})  ${WHITE}OKE Cluster Environment${NC}       - View OKE cluster details, VCN, and compute cluster"
        echo -e "  ${YELLOW}2${NC})  ${WHITE}NVIDIA GPU Stack Health${NC}       - Check GPU Operator & DRA components per node"
        echo -e "  ${YELLOW}3${NC})  ${WHITE}Kubernetes Management${NC}         - Node deregister, kubelet troubleshooting"
        echo ""
        echo -e "${BOLD}${BLUE}─── Networking ───${NC}"
        echo -e "  ${YELLOW}4${NC})  ${WHITE}Network Resources${NC}             - View subnets and NSGs grouped by function"
        echo ""
        echo -e "${BOLD}${BLUE}─── Compute & GPU ───${NC}"
        echo -e "  ${YELLOW}5${NC})  ${WHITE}GPU Memory Fabrics & Clusters${NC} - Manage GPU memory fabrics and clusters"
        echo -e "  ${YELLOW}6${NC})  ${WHITE}Compute Instances${NC}             - View instance details, IPs, and volumes"
        echo -e "  ${YELLOW}7${NC})  ${WHITE}Instance Configurations${NC}       - Create, view, compare, and delete instance configs"
        echo -e "  ${YELLOW}8${NC})  ${WHITE}Compute Clusters${NC}              - Create, view, and delete compute clusters"
        echo -e "  ${YELLOW}9${NC})  ${WHITE}GPU Instance Tagging${NC}          - Manage ComputeInstanceHostActions namespace and tags"
        echo -e "  ${YELLOW}10${NC}) ${WHITE}Capacity Topology${NC}             - View host lifecycle states and details summary"
        echo -e "  ${YELLOW}11${NC}) ${WHITE}Custom Images${NC}                 - List, import, create, and export custom images"
        echo ""
        echo -e "${BOLD}${BLUE}─── Storage ───${NC}"
        echo -e "  ${YELLOW}12${NC}) ${WHITE}File Storage (FSS)${NC}            - Manage file systems, mount targets, and exports"
        echo -e "  ${YELLOW}13${NC}) ${WHITE}Lustre File Systems${NC}           - Manage Lustre file systems and Object Storage links"
        echo -e "  ${YELLOW}14${NC}) ${WHITE}Object Storage${NC}                - Manage buckets, private endpoints, and settings"
        echo ""
        echo -e "${BOLD}${BLUE}─── Identity ───${NC}"
        echo -e "  ${YELLOW}15${NC}) ${WHITE}Compartments${NC}                  - List compartments and create sub-compartments"
        echo -e "  ${YELLOW}16${NC}) ${WHITE}Identity Domains${NC}              - View identity domains and domain details"
        echo -e "  ${YELLOW}17${NC}) ${WHITE}Policies${NC}                      - View all policies, search, and audit"
        echo ""
        echo -e "${BOLD}${BLUE}─── Infrastructure ───${NC}"
        echo -e "  ${YELLOW}18${NC}) ${WHITE}Resource Manager Stacks${NC}       - View stacks, jobs, logs, outputs, and state"
        echo -e "  ${YELLOW}19${NC}) ${WHITE}Work Requests${NC}                 - View work requests, status, errors, and logs"
        echo -e "  ${YELLOW}20${NC}) ${WHITE}Maintenance${NC}                   - Maintenance instances + maintenance events (view/reschedule)"
        echo -e "  ${YELLOW}21${NC}) ${WHITE}Announcements${NC}                 - Show all announcements with affected resource details"
        echo ""
        echo -e "${BOLD}${BLUE}─── Utilities ───${NC}"
        echo -e "  ${CYAN}c${NC})  ${WHITE}Cache Stats${NC}                   - View cache status, age, and refresh options"
        echo -e "  ${RED}q${NC})  ${WHITE}Quit${NC}"
        echo ""
        echo -n -e "${BOLD}${CYAN}Enter selection [o, 1-21, c, q]: ${NC}"
        
        local choice
        read -r choice
        
        # Empty input exits
        if [[ -z "$choice" ]]; then
            echo -e "${GREEN}Exiting management mode${NC}"
            break
        fi
        
        case "$choice" in
            o|O|overview)
                list_all_instances "$compartment_id" "$region"
                echo ""
                echo -e "Press Enter to return to menu..."
                read -r
                ;;
            1)
                manage_oke_cluster
                ;;
            2)
                manage_nvidia_gpu_stack_health
                ;;
            3)
                manage_kubernetes
                ;;
            4)
                manage_network_resources
                ;;
            5)
                interactive_gpu_management
                ;;
            6)
                manage_compute_instances
                ;;
            7)
                manage_instance_configurations
                ;;
            8)
                manage_compute_clusters
                ;;
            9)
                manage_gpu_instance_tagging
                ;;
            10)
                manage_capacity_topology
                ;;
            11)
                manage_custom_images
                ;;
            12)
                manage_file_storage
                ;;
            13)
                manage_lustre_file_systems
                ;;
            14)
                manage_object_storage
                ;;
            15)
                manage_compartments
                ;;
            16)
                manage_identity_domains
                ;;
            17)
                manage_policies
                ;;
            18)
                manage_resource_manager_stacks
                ;;
            19)
                manage_work_requests
                ;;
            20)
                list_maintenance_events "$compartment_id" "$region"
                ;;
            21)
                list_all_announcements "$compartment_id" "$region"
                ;;
            c|C|cache|CACHE)
                display_cache_stats
                ;;
            q|Q|quit|QUIT|exit|EXIT)
                echo ""
                echo -e "${GREEN}Exiting management mode${NC}"
                break
                ;;
            *)
                echo -e "${RED}Invalid selection. Please enter o, 1-21, c, or q.${NC}"
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# Centralized Compartment Selector - Reusable hierarchical compartment display
# Usage: display_compartment_selector <tenancy_id> <current_compartment> [show_full_ocid]
# Sets global arrays: COMP_MAP, COMP_CHILDREN, COMP_IDX, COMP_IDX_REV
# Returns: display_idx (number of compartments displayed)
#--------------------------------------------------------------------------------
display_compartment_selector() {
    local tenancy_id="$1"
    local current_compartment="$2"
    local show_full_ocid="${3:-false}"  # true to show full OCID, false for truncated
    
    # Get tenancy name
    local tenancy_name
    tenancy_name=$(oci iam tenancy get --tenancy-id "$tenancy_id" --query 'data.name' --raw-output 2>/dev/null || echo "Unknown")
    
    echo -e "${GRAY}Loading compartments...${NC}"
    
    # Fetch all compartments under tenancy
    local comp_json
    comp_json=$(oci iam compartment list --compartment-id "$tenancy_id" --compartment-id-in-subtree true --all --output json 2>/dev/null)
    
    if [[ -z "$comp_json" ]] || ! echo "$comp_json" | jq -e '.data' > /dev/null 2>&1; then
        echo -e "${RED}Failed to retrieve compartments. Check permissions.${NC}"
        return 1
    fi
    
    # Build compartment tree - clear arrays first
    declare -gA COMP_MAP      # id -> "name|state|parent_id|description"
    declare -gA COMP_CHILDREN # parent_id -> space-delimited list of child ids
    declare -gA COMP_IDX      # index -> id (for selection)
    declare -gA COMP_IDX_REV  # id -> index (reverse lookup)
    
    COMP_MAP=()
    COMP_CHILDREN=()
    COMP_IDX=()
    COMP_IDX_REV=()
    local comp_count=0
    
    # First pass: collect all compartments
    while IFS='|' read -r comp_id comp_name comp_state comp_parent comp_desc; do
        [[ -z "$comp_id" ]] && continue
        [[ "$comp_state" == "DELETED" ]] && continue
        ((comp_count++))
        COMP_MAP[$comp_id]="$comp_name|$comp_state|$comp_parent|$comp_desc"
        
        # Build parent-child relationships
        if [[ -n "$comp_parent" ]]; then
            if [[ -n "${COMP_CHILDREN[$comp_parent]}" ]]; then
                COMP_CHILDREN[$comp_parent]="${COMP_CHILDREN[$comp_parent]} $comp_id"
            else
                COMP_CHILDREN[$comp_parent]="$comp_id"
            fi
        fi
    done < <(echo "$comp_json" | jq -r '.data[] | "\(.id)|\(.name)|\(.["lifecycle-state"])|\(.["compartment-id"])|\(.description // "")"' 2>/dev/null)
    
    echo -ne "\r                                        \r"
    
    echo -e "${BOLD}${WHITE}═══ Compartment Hierarchy (${comp_count} compartments) ═══${NC}"
    echo ""
    
    # Column headers - Name and OCID in separate columns
    printf "  ${BOLD}%-6s %-10s %-5s %-55s %s${NC}\n" "#" "State" "Child" "Name" "OCID"
    print_separator 160
    
    # Print tenancy as root (not selectable, shown as reference)
    local tenancy_children_count=0
    for child in ${COMP_CHILDREN[$tenancy_id]}; do
        [[ -n "$child" ]] && ((tenancy_children_count++))
    done
    
    printf "  ${MAGENTA}[T]   ${NC}${GREEN}%-10s${NC} ${CYAN}[%-2s]${NC} ${MAGENTA}%-55s${NC} ${YELLOW}%s${NC}\n" \
        "ACTIVE" "$tenancy_children_count" "┌─ $tenancy_name (ROOT)" "$tenancy_id"
    
    # Recursive function to print compartment tree with proper indentation
    local display_idx=0
    
    _print_comp_tree() {
        local parent_id="$1"
        local depth="$2"
        local prefix="$3"
        local is_last="$4"
        
        local children=(${COMP_CHILDREN[$parent_id]})
        local child_count=${#children[@]}
        local child_idx=0
        
        for child_id in "${children[@]}"; do
            [[ -z "$child_id" ]] && continue
            ((child_idx++))
            
            local comp_data="${COMP_MAP[$child_id]}"
            [[ -z "$comp_data" ]] && continue
            
            local comp_name="${comp_data%%|*}"
            local rest="${comp_data#*|}"
            local comp_state="${rest%%|*}"
            rest="${rest#*|}"
            local comp_parent="${rest%%|*}"
            
            ((display_idx++))
            COMP_IDX[$display_idx]="$child_id"
            COMP_IDX_REV[$child_id]="$display_idx"
            
            local state_color="$GREEN"
            [[ "$comp_state" != "ACTIVE" ]] && state_color="$YELLOW"
            [[ "$comp_state" == "DELETING" || "$comp_state" == "DELETED" ]] && state_color="$RED"
            
            # Count this compartment's children
            local grandchildren_count=0
            for gc in ${COMP_CHILDREN[$child_id]}; do
                [[ -n "$gc" ]] && ((grandchildren_count++))
            done
            
            # Build tree branch characters
            local branch_char="├─"
            local next_prefix="$prefix│  "
            if [[ $child_idx -eq $child_count ]]; then
                branch_char="└─"
                next_prefix="$prefix   "
            fi
            
            # Current compartment marker - arrow printed separately before number
            local arrow_char="  "
            if [[ "$child_id" == "$current_compartment" ]]; then
                arrow_char="${BOLD}${CYAN}► ${NC}"
            fi
            
            # Children indicator
            local children_str="[-]"
            [[ $grandchildren_count -gt 0 ]] && children_str="[$grandchildren_count]"
            
            # Print row: # State Child TreeName     OCID (right-aligned)
            local tree_name="${prefix}${branch_char} ${comp_name}"
            printf "${arrow_char}${YELLOW}%-3s${NC}   ${state_color}%-10s${NC} ${CYAN}%-5s${NC} ${WHITE}%-55s${NC} ${YELLOW}%s${NC}\n" \
                "$display_idx" "$comp_state" "$children_str" "${tree_name:0:55}" "$child_id"
            
            # Recursively print children
            if [[ $grandchildren_count -gt 0 ]]; then
                _print_comp_tree "$child_id" "$((depth + 1))" "$next_prefix" "$([[ $child_idx -eq $child_count ]] && echo 1 || echo 0)"
            fi
        done
    }
    
    # Start printing from tenancy root
    _print_comp_tree "$tenancy_id" 0 "│  " 0
    
    echo ""
    
    # Return the display index count
    COMP_SELECTOR_COUNT=$display_idx
    return 0
}

#--------------------------------------------------------------------------------
# Resolve compartment/tenancy OCID to display name (robust multi-method lookup)
# Usage: resolve_compartment_name <ocid>
# Returns: display name or "Unknown" if all methods fail
#--------------------------------------------------------------------------------
# Cache for resolved compartment names to avoid repeated API calls
declare -gA RESOLVED_COMP_NAME_CACHE=()

resolve_compartment_name() {
    local ocid="$1"
    [[ -z "$ocid" ]] && echo "Unknown" && return
    
    # Check cache first
    if [[ -n "${RESOLVED_COMP_NAME_CACHE[$ocid]+_}" ]]; then
        echo "${RESOLVED_COMP_NAME_CACHE[$ocid]}"
        return
    fi
    
    local name=""
    
    # Method 1: Try oci iam compartment get (--raw-output for reliability)
    if [[ "$ocid" == ocid1.compartment.* ]]; then
        name=$(oci iam compartment get --compartment-id "$ocid" --query 'data.name' --raw-output 2>/dev/null)
        if [[ -n "$name" && "$name" != "null" && "$name" != "None" ]]; then
            RESOLVED_COMP_NAME_CACHE[$ocid]="$name"
            echo "$name"
            return
        fi
        # Fallback: try JSON+jq in case --query failed
        name=$(oci iam compartment get --compartment-id "$ocid" --output json 2>/dev/null | jq -r '.data.name // empty' 2>/dev/null)
        if [[ -n "$name" ]]; then
            RESOLVED_COMP_NAME_CACHE[$ocid]="$name"
            echo "$name"
            return
        fi
    fi
    
    # Method 2: Try as tenancy (root compartment)
    if [[ "$ocid" == ocid1.tenancy.* ]]; then
        name=$(oci iam tenancy get --tenancy-id "$ocid" --query 'data.name' --raw-output 2>/dev/null)
        if [[ -n "$name" && "$name" != "null" && "$name" != "None" ]]; then
            RESOLVED_COMP_NAME_CACHE[$ocid]="$name"
            echo "$name"
            return
        fi
        name=$(oci iam tenancy get --tenancy-id "$ocid" --output json 2>/dev/null | jq -r '.data.name // empty' 2>/dev/null)
        if [[ -n "$name" ]]; then
            RESOLVED_COMP_NAME_CACHE[$ocid]="$name"
            echo "$name"
            return
        fi
    fi
    
    # Method 3: If OCID prefix unknown or above failed, try both
    if [[ -z "$name" ]]; then
        name=$(oci iam compartment get --compartment-id "$ocid" --query 'data.name' --raw-output 2>/dev/null)
        if [[ -n "$name" && "$name" != "null" && "$name" != "None" ]]; then
            RESOLVED_COMP_NAME_CACHE[$ocid]="$name"
            echo "$name"
            return
        fi
    fi
    if [[ -z "$name" ]]; then
        name=$(oci iam tenancy get --tenancy-id "$ocid" --query 'data.name' --raw-output 2>/dev/null)
        if [[ -n "$name" && "$name" != "null" && "$name" != "None" ]]; then
            RESOLVED_COMP_NAME_CACHE[$ocid]="$name"
            echo "$name"
            return
        fi
    fi
    
    # Method 4: Search via compartment list from tenancy
    if [[ -z "$name" ]]; then
        # Get tenancy ID - try multiple sources
        local tenancy_id="${TENANCY_OCID:-}"
        if [[ -z "$tenancy_id" ]]; then
            tenancy_id="${TENANCY_ID:-}"
        fi
        if [[ -z "$tenancy_id" ]]; then
            local vf="${VARIABLES_FILE:-./variables.sh}"
            tenancy_id=$(grep "^TENANCY_OCID=" "$vf" 2>/dev/null | head -1 | cut -d'"' -f2)
            [[ -z "$tenancy_id" ]] && tenancy_id=$(grep "^TENANCY_ID=" "$vf" 2>/dev/null | head -1 | cut -d'"' -f2)
        fi
        # Try OCI CLI config file for tenancy
        if [[ -z "$tenancy_id" && -f "$HOME/.oci/config" ]]; then
            tenancy_id=$(grep "^tenancy=" "$HOME/.oci/config" 2>/dev/null | head -1 | cut -d'=' -f2 | tr -d ' ')
        fi
        # Try instance metadata as last resort for tenancy
        if [[ -z "$tenancy_id" ]]; then
            tenancy_id=$(curl -sH "Authorization: Bearer Oracle" -L http://169.254.169.254/opc/v2/instance/ 2>/dev/null | jq -r '.tenantId // empty' 2>/dev/null)
        fi
        
        if [[ -n "$tenancy_id" ]]; then
            # If the OCID IS the tenancy itself, resolve directly
            if [[ "$ocid" == "$tenancy_id" ]]; then
                name=$(oci iam tenancy get --tenancy-id "$tenancy_id" --query 'data.name' --raw-output 2>/dev/null)
                if [[ -n "$name" && "$name" != "null" && "$name" != "None" ]]; then
                    RESOLVED_COMP_NAME_CACHE[$ocid]="$name"
                    echo "$name"
                    return
                fi
            fi
            
            # Search in full compartment list
            name=$(oci iam compartment list --compartment-id "$tenancy_id" --compartment-id-in-subtree true --all --output json 2>/dev/null \
                | jq -r --arg id "$ocid" '.data[] | select(.id == $id) | .name // empty' 2>/dev/null)
            if [[ -n "$name" ]]; then
                RESOLVED_COMP_NAME_CACHE[$ocid]="$name"
                echo "$name"
                return
            fi
        fi
    fi
    
    # Method 5: Check if COMP_MAP (from compartment selector) has it
    if [[ -z "$name" && -n "${COMP_MAP[$ocid]+_}" ]]; then
        name="${COMP_MAP[$ocid]%%|*}"
        if [[ -n "$name" ]]; then
            RESOLVED_COMP_NAME_CACHE[$ocid]="$name"
            echo "$name"
            return
        fi
    fi
    
    RESOLVED_COMP_NAME_CACHE[$ocid]="Unknown"
    echo "Unknown"
}

#--------------------------------------------------------------------------------
# Get tenancy ID from a compartment ID (walks up the tree)
#--------------------------------------------------------------------------------
get_tenancy_id_from_compartment() {
    local compartment_id="$1"
    local tenancy_id
    
    tenancy_id=$(oci iam compartment get --compartment-id "$compartment_id" --query 'data."compartment-id"' --raw-output 2>/dev/null)
    while [[ "$tenancy_id" =~ ^ocid1\.compartment\. ]]; do
        local parent
        parent=$(oci iam compartment get --compartment-id "$tenancy_id" --query 'data."compartment-id"' --raw-output 2>/dev/null)
        [[ -z "$parent" || "$parent" == "$tenancy_id" ]] && break
        tenancy_id="$parent"
    done
    
    echo "$tenancy_id"
}

#--------------------------------------------------------------------------------
# Compartments Management - List and create sub-compartments
#--------------------------------------------------------------------------------
manage_compartments() {
    local tenancy_id="${TENANCY_OCID:-}"
    local current_compartment="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local tenancy_name=""
    
    # Get tenancy from compartment if not set
    if [[ -z "$tenancy_id" ]]; then
        tenancy_id=$(get_tenancy_id_from_compartment "$current_compartment")
    fi
    
    # Get tenancy name
    tenancy_name=$(oci iam tenancy get --tenancy-id "$tenancy_id" --query 'data.name' --raw-output 2>/dev/null || echo "Unknown")
    
    while true; do
        echo ""
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${CYAN}                                                         COMPARTMENT MANAGEMENT                                                                         ${NC}"
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo ""
        
        # Show Tenancy (Root) Information prominently
        echo -e "${BOLD}${MAGENTA}═══ Tenancy (Root) ═══${NC}"
        echo -e "  ${CYAN}Name:${NC}  ${BOLD}${WHITE}$tenancy_name${NC}"
        echo -e "  ${CYAN}OCID:${NC}  ${YELLOW}$tenancy_id${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}Current Compartment:${NC} ${YELLOW}...${current_compartment: -30}${NC}"
        echo ""
        
        # Use centralized compartment selector (show full OCID in management view)
        if ! display_compartment_selector "$tenancy_id" "$current_compartment" "true"; then
            echo ""
            echo -e "Press Enter to return..."
            read -r
            return
        fi
        
        local display_idx=$COMP_SELECTOR_COUNT
        
        echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
        echo ""
        echo -e "  ${YELLOW}#${NC})       Select compartment (view details, add sub-compartment)"
        echo -e "  ${GREEN}c${NC})       Create new compartment (will prompt for parent)"
        echo -e "  ${MAGENTA}r${NC})       Refresh"
        echo -e "  ${CYAN}b${NC})       Back to main menu"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Compartments] Enter selection: ${NC}"
        
        local selection
        read -r selection
        
        case "$selection" in
            [0-9]|[0-9][0-9]|[0-9][0-9][0-9])
                local selected_id="${COMP_IDX[$selection]}"
                if [[ -n "$selected_id" ]]; then
                    compartment_submenu "$selected_id" "$tenancy_id" COMP_MAP COMP_CHILDREN COMP_IDX
                else
                    echo -e "${RED}Invalid selection${NC}"
                    sleep 1
                fi
                ;;
            c|C)
                create_subcompartment_enhanced "$tenancy_id" COMP_MAP COMP_CHILDREN COMP_IDX $display_idx
                ;;
            r|R)
                continue
                ;;
            b|B|"")
                return
                ;;
            *)
                echo -e "${RED}Invalid selection${NC}"
                sleep 1
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# Compartment Submenu - View details and add sub-compartment
#--------------------------------------------------------------------------------
compartment_submenu() {
    local comp_id="$1"
    local tenancy_id="$2"
    local -n comp_map_ref=$3
    local -n comp_children_ref=$4
    local -n comp_idx_ref=$5
    
    while true; do
        echo ""
        echo -e "${BOLD}${CYAN}═══ Compartment Details ═══${NC}"
        echo ""
        
        # Get full details from API
        local comp_json
        comp_json=$(oci iam compartment get --compartment-id "$comp_id" --output json 2>/dev/null)
        
        if [[ -z "$comp_json" ]]; then
            echo -e "${RED}Failed to get compartment details${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
        
        local name state parent_id desc time_created
        name=$(echo "$comp_json" | jq -r '.data.name // "N/A"')
        state=$(echo "$comp_json" | jq -r '.data["lifecycle-state"] // "N/A"')
        parent_id=$(echo "$comp_json" | jq -r '.data["compartment-id"] // "N/A"')
        desc=$(echo "$comp_json" | jq -r '.data.description // "N/A"')
        time_created=$(echo "$comp_json" | jq -r '.data["time-created"] // "N/A"')
        
        local state_color="$GREEN"
        [[ "$state" != "ACTIVE" ]] && state_color="$YELLOW"
        [[ "$state" == "DELETING" || "$state" == "DELETED" ]] && state_color="$RED"
        
        echo -e "${BOLD}${WHITE}Basic Information:${NC}"
        echo -e "  ${CYAN}Name:${NC}         ${WHITE}$name${NC}"
        echo -e "  ${CYAN}State:${NC}        ${state_color}$state${NC}"
        echo -e "  ${CYAN}OCID:${NC}         ${YELLOW}$comp_id${NC}"
        echo -e "  ${CYAN}Created:${NC}      ${WHITE}${time_created/T/ }${NC}"
        echo -e "  ${CYAN}Description:${NC}  ${WHITE}${desc:-N/A}${NC}"
        echo ""
        
        # Show parent hierarchy
        echo -e "${BOLD}${WHITE}Parent Hierarchy:${NC}"
        if [[ "$parent_id" =~ ^ocid1\.tenancy\. ]]; then
            local tenancy_name
            tenancy_name=$(oci iam tenancy get --tenancy-id "$parent_id" --query 'data.name' --raw-output 2>/dev/null || echo "Unknown")
            echo -e "  ${MAGENTA}[ROOT] $tenancy_name${NC}"
            echo -e "    └─ ${WHITE}$name${NC} ${CYAN}◄ current${NC}"
        else
            # Build parent chain
            local parent_chain=()
            local current_parent="$parent_id"
            while [[ "$current_parent" =~ ^ocid1\.compartment\. ]]; do
                local parent_data="${comp_map_ref[$current_parent]}"
                if [[ -n "$parent_data" ]]; then
                    local parent_name="${parent_data%%|*}"
                    parent_chain+=("$parent_name|$current_parent")
                fi
                local next_parent
                next_parent=$(oci iam compartment get --compartment-id "$current_parent" --query 'data."compartment-id"' --raw-output 2>/dev/null)
                [[ -z "$next_parent" || "$next_parent" == "$current_parent" ]] && break
                current_parent="$next_parent"
            done
            
            # Print parent chain (reversed)
            local tenancy_name
            tenancy_name=$(oci iam tenancy get --tenancy-id "$tenancy_id" --query 'data.name' --raw-output 2>/dev/null || echo "Unknown")
            echo -e "  ${MAGENTA}[ROOT] $tenancy_name${NC}"
            
            local indent="    "
            for ((i=${#parent_chain[@]}-1; i>=0; i--)); do
                local entry="${parent_chain[$i]}"
                local p_name="${entry%%|*}"
                echo -e "  ${indent}└─ ${WHITE}$p_name${NC}"
                indent="${indent}   "
            done
            echo -e "  ${indent}└─ ${WHITE}$name${NC} ${CYAN}◄ current${NC}"
        fi
        echo ""
        
        # Show child compartments
        local children=(${comp_children_ref[$comp_id]})
        local child_count=${#children[@]}
        
        echo -e "${BOLD}${WHITE}Child Compartments (${child_count}):${NC}"
        if [[ $child_count -eq 0 ]]; then
            echo -e "  ${GRAY}No child compartments${NC}"
        else
            for child_id in "${children[@]}"; do
                [[ -z "$child_id" ]] && continue
                local child_data="${comp_map_ref[$child_id]}"
                local child_name="${child_data%%|*}"
                local rest="${child_data#*|}"
                local child_state="${rest%%|*}"
                local child_state_color="$GREEN"
                [[ "$child_state" != "ACTIVE" ]] && child_state_color="$YELLOW"
                echo -e "  └─ ${WHITE}$child_name${NC} ${child_state_color}[$child_state]${NC} ${GRAY}...${child_id: -12}${NC}"
            done
        fi
        echo ""
        
        # Show tags
        local defined_tags freeform_tags
        defined_tags=$(echo "$comp_json" | jq '.data["defined-tags"] // {}')
        freeform_tags=$(echo "$comp_json" | jq '.data["freeform-tags"] // {}')
        
        if [[ "$defined_tags" != "{}" ]]; then
            echo -e "${BOLD}${WHITE}Defined Tags:${NC}"
            echo "$defined_tags" | jq -r 'to_entries[] | "  \(.key):" as $ns | .value | to_entries[] | "    \($ns) \(.key) = \(.value)"'
            echo ""
        fi
        
        if [[ "$freeform_tags" != "{}" ]]; then
            echo -e "${BOLD}${WHITE}Freeform Tags:${NC}"
            echo "$freeform_tags" | jq -r 'to_entries[] | "  \(.key) = \(.value)"'
            echo ""
        fi
        
        # Actions
        echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
        echo ""
        echo -e "  ${GREEN}a${NC}) Add sub-compartment under '${WHITE}$name${NC}'"
        echo -e "  ${CYAN}s${NC}) Switch to this compartment"
        echo -e "  ${RED}d${NC}) Delete this compartment"
        echo -e "  ${CYAN}b${NC}) Back"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Compartments > ${name}] Enter selection: ${NC}"
        
        local action
        read -r action
        
        case "$action" in
            a|A)
                # Create sub-compartment directly under this compartment
                echo ""
                echo -e "${BOLD}${WHITE}═══ Create Sub-Compartment ═══${NC}"
                echo ""
                echo -e "  ${CYAN}Parent:${NC} ${WHITE}$name${NC}"
                echo -e "  ${GRAY}$comp_id${NC}"
                echo ""
                
                echo -n -e "${CYAN}New compartment name: ${NC}"
                local new_name
                read -r new_name
                
                if [[ -z "$new_name" ]]; then
                    echo -e "${RED}Name cannot be empty. Aborting.${NC}"
                    sleep 2
                    continue
                fi
                
                echo -n -e "${CYAN}Description (required): ${NC}"
                local new_desc
                read -r new_desc
                
                if [[ -z "$new_desc" ]]; then
                    echo -e "${RED}Description is required. Aborting.${NC}"
                    sleep 2
                    continue
                fi
                
                echo ""
                echo -e "${BOLD}${WHITE}Configuration:${NC}"
                echo -e "  ${CYAN}Parent:${NC}      ${WHITE}$name${NC}"
                echo -e "  ${CYAN}Name:${NC}        ${WHITE}$new_name${NC}"
                echo -e "  ${CYAN}Description:${NC} ${WHITE}$new_desc${NC}"
                echo ""
                
                # Build and show command
                local cmd="oci iam compartment create --compartment-id \"$comp_id\" --name \"$new_name\" --description \"$new_desc\""
                
                echo -e "${GRAY}Command:${NC}"
                echo "$cmd"
                echo ""
                
                echo -n -e "${YELLOW}Create this compartment? (Y/n): ${NC}"
                local confirm
                read -r confirm
                
                if [[ "$confirm" != "n" && "$confirm" != "N" ]]; then
                    # Log the action
                    local log_file="${LOGS_DIR}/compartment_actions_$(date +%Y%m%d).log"
                    mkdir -p "$(dirname "$log_file")" 2>/dev/null
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] CREATE COMPARTMENT: $cmd" >> "$log_file"
                    
                    local result
                    result=$(oci iam compartment create --compartment-id "$comp_id" --name "$new_name" --description "$new_desc" --output json 2>&1)
                    
                    if echo "$result" | jq -e '.data' > /dev/null 2>&1; then
                        local new_id
                        new_id=$(echo "$result" | jq -r '.data.id')
                        echo -e "${GREEN}✓ Compartment created successfully!${NC}"
                        echo -e "  ${CYAN}New OCID:${NC} ${YELLOW}$new_id${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created compartment $new_name ($new_id)" >> "$log_file"
                        echo ""
                        echo -e "${GRAY}Refreshing compartment list...${NC}"
                        sleep 1
                        return  # Return to main compartment list to refresh
                    else
                        echo -e "${RED}✗ Failed to create compartment${NC}"
                        echo "$result"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
                    fi
                    
                    echo ""
                    echo -e "Press Enter to continue..."
                    read -r
                fi
                ;;
            d|D)
                # Delete compartment
                echo ""
                echo -e "${BOLD}${RED}═══ Delete Compartment ═══${NC}"
                echo ""
                
                # Check for children
                if [[ $child_count -gt 0 ]]; then
                    echo -e "${RED}⚠ WARNING: This compartment has ${child_count} child compartment(s)!${NC}"
                    echo -e "${YELLOW}You must delete all child compartments first before deleting this one.${NC}"
                    echo ""
                    echo -e "Child compartments:"
                    for child_id in "${children[@]}"; do
                        [[ -z "$child_id" ]] && continue
                        local child_data="${comp_map_ref[$child_id]}"
                        local child_name="${child_data%%|*}"
                        echo -e "  • ${WHITE}$child_name${NC}"
                    done
                    echo ""
                    echo -e "Press Enter to continue..."
                    read -r
                    continue
                fi
                
                echo -e "${RED}⚠ WARNING: You are about to delete compartment:${NC}"
                echo ""
                echo -e "  ${CYAN}Name:${NC} ${WHITE}$name${NC}"
                echo -e "  ${CYAN}OCID:${NC} ${YELLOW}$comp_id${NC}"
                echo ""
                echo -e "${YELLOW}This action will:${NC}"
                echo -e "  • Move the compartment to DELETING state"
                echo -e "  • Eventually permanently delete the compartment"
                echo -e "  • Delete cannot be undone after completion"
                echo ""
                echo -e "${RED}All resources in this compartment must be deleted first!${NC}"
                echo ""
                
                # Build and show command
                local del_cmd="oci iam compartment delete --compartment-id \"$comp_id\""
                echo -e "${GRAY}Command:${NC}"
                echo "$del_cmd"
                echo ""
                
                echo -n -e "${RED}Type the compartment name to confirm deletion: ${NC}"
                local confirm_name
                read -r confirm_name
                
                if [[ "$confirm_name" != "$name" ]]; then
                    echo -e "${YELLOW}Name does not match. Deletion cancelled.${NC}"
                    sleep 2
                    continue
                fi
                
                echo -n -e "${RED}Are you ABSOLUTELY sure? (type 'DELETE' to confirm): ${NC}"
                local confirm_delete
                read -r confirm_delete
                
                if [[ "$confirm_delete" != "DELETE" ]]; then
                    echo -e "${YELLOW}Deletion cancelled.${NC}"
                    sleep 2
                    continue
                fi
                
                # Log the action
                local log_file="${LOGS_DIR}/compartment_actions_$(date +%Y%m%d).log"
                mkdir -p "$(dirname "$log_file")" 2>/dev/null
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] DELETE COMPARTMENT: $del_cmd" >> "$log_file"
                
                echo ""
                echo -e "${GRAY}Deleting compartment...${NC}"
                
                local result
                result=$(oci iam compartment delete --compartment-id "$comp_id" --force 2>&1)
                
                if [[ $? -eq 0 ]]; then
                    echo -e "${GREEN}✓ Compartment deletion initiated!${NC}"
                    echo -e "  ${GRAY}The compartment will move to DELETING state and be permanently removed.${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Initiated deletion of compartment $name ($comp_id)" >> "$log_file"
                    echo ""
                    echo -e "${GRAY}Refreshing compartment list...${NC}"
                    sleep 1
                else
                    echo -e "${RED}✗ Failed to delete compartment${NC}"
                    echo "$result"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
                    echo ""
                    echo -e "Press Enter to continue..."
                    read -r
                fi
                
                return  # Return to main compartment list to refresh
                ;;
            s|S)
                EFFECTIVE_COMPARTMENT_ID="$comp_id"
                echo -e "${GREEN}✓ Switched to compartment: ${WHITE}$name${NC}"
                echo -e "  ${GRAY}Note: This affects only this session${NC}"
                sleep 2
                return
                ;;
            b|B|"")
                return
                ;;
            *)
                echo -e "${RED}Invalid selection${NC}"
                sleep 1
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# Create sub-compartment - Enhanced with hierarchy selection
#--------------------------------------------------------------------------------
create_subcompartment_enhanced() {
    local tenancy_id="$1"
    local -n comp_map_ref=$2
    local -n comp_children_ref=$3
    local -n comp_idx_ref=$4
    local max_idx=$5
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Create Sub-Compartment ═══${NC}"
    echo ""
    
    # Step 1: Select parent compartment with hierarchy display
    echo -e "${WHITE}Step 1: Select parent compartment${NC}"
    echo ""
    
    # Get tenancy name
    local tenancy_name
    tenancy_name=$(oci iam tenancy get --tenancy-id "$tenancy_id" --query 'data.name' --raw-output 2>/dev/null || echo "Unknown")
    
    printf "  ${YELLOW}%-3s${NC}) ${MAGENTA}%-50s${NC} ${GRAY}%s${NC}\n" "0" "[ROOT] $tenancy_name" "$tenancy_id"
    
    # List compartments with hierarchy indication
    local idx=0
    for i in $(seq 1 $max_idx); do
        local comp_id="${comp_idx_ref[$i]}"
        [[ -z "$comp_id" ]] && continue
        
        local comp_data="${comp_map_ref[$comp_id]}"
        [[ -z "$comp_data" ]] && continue
        
        local comp_name="${comp_data%%|*}"
        local rest="${comp_data#*|}"
        local comp_state="${rest%%|*}"
        
        # Count children
        local child_count=0
        for child in ${comp_children_ref[$comp_id]}; do
            [[ -n "$child" ]] && ((child_count++))
        done
        
        local children_indicator=""
        [[ $child_count -gt 0 ]] && children_indicator=" ${CYAN}[$child_count children]${NC}"
        
        printf "  ${YELLOW}%-3s${NC}) ${WHITE}%-50s${NC}${children_indicator} ${GRAY}...%s${NC}\n" \
            "$i" "${comp_name:0:48}" "${comp_id: -12}"
    done
    
    echo ""
    echo -n -e "${CYAN}Select parent compartment [0 for root]: ${NC}"
    local parent_choice
    read -r parent_choice
    
    local parent_id="$tenancy_id"
    local parent_name="[ROOT] $tenancy_name"
    
    if [[ "$parent_choice" =~ ^[1-9][0-9]*$ ]] && [[ -n "${comp_idx_ref[$parent_choice]}" ]]; then
        parent_id="${comp_idx_ref[$parent_choice]}"
        local parent_data="${comp_map_ref[$parent_id]}"
        parent_name="${parent_data%%|*}"
    fi
    
    echo -e "  ${GREEN}Selected:${NC} ${WHITE}$parent_name${NC}"
    echo ""
    
    # Step 2: Enter compartment name
    echo -e "${WHITE}Step 2: Enter new compartment name${NC}"
    echo -n -e "${CYAN}Compartment name: ${NC}"
    local new_name
    read -r new_name
    
    if [[ -z "$new_name" ]]; then
        echo -e "${RED}Name cannot be empty. Aborting.${NC}"
        sleep 2
        return
    fi
    
    # Step 3: Enter description (required)
    echo ""
    echo -e "${WHITE}Step 3: Enter description (required)${NC}"
    echo -n -e "${CYAN}Description: ${NC}"
    local new_desc
    read -r new_desc
    
    if [[ -z "$new_desc" ]]; then
        echo -e "${RED}Description is required. Aborting.${NC}"
        sleep 2
        return
    fi
    
    # Summary
    echo ""
    echo -e "${BOLD}${WHITE}═══ Configuration Summary ═══${NC}"
    echo ""
    echo -e "  ${CYAN}Parent:${NC}      ${WHITE}$parent_name${NC}"
    echo -e "               ${GRAY}$parent_id${NC}"
    echo -e "  ${CYAN}Name:${NC}        ${WHITE}$new_name${NC}"
    echo -e "  ${CYAN}Description:${NC} ${WHITE}$new_desc${NC}"
    echo ""
    
    # Build and show command
    local cmd="oci iam compartment create --compartment-id \"$parent_id\" --name \"$new_name\" --description \"$new_desc\""
    
    echo -e "${GRAY}Command:${NC}"
    echo "$cmd"
    echo ""
    
    echo -n -e "${YELLOW}Create this compartment? (Y/n): ${NC}"
    local confirm
    read -r confirm
    
    if [[ "$confirm" == "n" || "$confirm" == "N" ]]; then
        echo -e "${YELLOW}Aborted.${NC}"
        sleep 1
        return
    fi
    
    # Log the action
    local log_file="${LOGS_DIR}/compartment_actions_$(date +%Y%m%d).log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] CREATE COMPARTMENT: $cmd" >> "$log_file"
    
    # Execute
    local result
    result=$(oci iam compartment create --compartment-id "$parent_id" --name "$new_name" --description "$new_desc" --output json 2>&1)
    
    if echo "$result" | jq -e '.data' > /dev/null 2>&1; then
        local new_id
        new_id=$(echo "$result" | jq -r '.data.id')
        echo -e "${GREEN}✓ Compartment created successfully!${NC}"
        echo -e "  ${CYAN}New OCID:${NC} ${YELLOW}$new_id${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created compartment $new_name ($new_id)" >> "$log_file"
        echo ""
        echo -e "${GRAY}Refreshing compartment list...${NC}"
        sleep 1
    else
        echo -e "${RED}✗ Failed to create compartment${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
    fi
}

#--------------------------------------------------------------------------------
# Switch compartment - Enhanced
#--------------------------------------------------------------------------------
switch_compartment_enhanced() {
    local tenancy_id="$1"
    local -n comp_map_ref=$2
    local -n comp_idx_ref=$3
    local max_idx=$4
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Switch Compartment ═══${NC}"
    echo ""
    echo -e "${WHITE}Select a compartment to switch to:${NC}"
    echo ""
    
    # Get tenancy name
    local tenancy_name
    tenancy_name=$(oci iam tenancy get --tenancy-id "$tenancy_id" --query 'data.name' --raw-output 2>/dev/null || echo "Unknown")
    
    printf "  ${YELLOW}%-3s${NC}) ${MAGENTA}%-50s${NC} ${GRAY}%s${NC}\n" "0" "[ROOT] $tenancy_name (Tenancy)" "$tenancy_id"
    
    # List compartments
    for i in $(seq 1 $max_idx); do
        local comp_id="${comp_idx_ref[$i]}"
        [[ -z "$comp_id" ]] && continue
        
        local comp_data="${comp_map_ref[$comp_id]}"
        [[ -z "$comp_data" ]] && continue
        
        local comp_name="${comp_data%%|*}"
        
        printf "  ${YELLOW}%-3s${NC}) ${WHITE}%-50s${NC} ${GRAY}...%s${NC}\n" \
            "$i" "${comp_name:0:48}" "${comp_id: -12}"
    done
    
    echo ""
    echo -n -e "${CYAN}Enter compartment number: ${NC}"
    local choice
    read -r choice
    
    if [[ "$choice" == "0" ]]; then
        EFFECTIVE_COMPARTMENT_ID="$tenancy_id"
        echo -e "${GREEN}✓ Switched to: ${WHITE}[ROOT] $tenancy_name${NC}"
        echo -e "  ${GRAY}Note: This affects only this session${NC}"
        sleep 2
    elif [[ "$choice" =~ ^[1-9][0-9]*$ ]] && [[ -n "${comp_idx_ref[$choice]}" ]]; then
        local selected_comp="${comp_idx_ref[$choice]}"
        EFFECTIVE_COMPARTMENT_ID="$selected_comp"
        local comp_data="${comp_map_ref[$selected_comp]}"
        local comp_name="${comp_data%%|*}"
        echo -e "${GREEN}✓ Switched to: ${WHITE}$comp_name${NC}"
        echo -e "  ${GRAY}Note: This affects only this session${NC}"
        sleep 2
    else
        echo -e "${RED}Invalid selection${NC}"
        sleep 1
    fi
}

#================================================================================
# IDENTITY DOMAINS MANAGEMENT
#================================================================================

manage_identity_domains() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local tenancy_id="${TENANCY_OCID:-}"
    
    if [[ -z "$tenancy_id" ]]; then
        tenancy_id=$(get_tenancy_id_from_compartment "$compartment_id")
    fi
    
    while true; do
        echo ""
        echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${GREEN}                                                     IDENTITY DOMAINS MANAGEMENT                                                                        ${NC}"
        echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo ""
        
        local cmd="oci iam domain list --compartment-id \"$tenancy_id\" --all"
        echo -e "  ${GRAY}Command: ${cmd}${NC}"
        echo -e "${GRAY}Fetching identity domains...${NC}"
        
        local domains_json
        domains_json=$(oci iam domain list --compartment-id "$tenancy_id" --all --output json 2>/dev/null)
        
        if [[ -z "$domains_json" ]] || ! echo "$domains_json" | jq -e '.data' > /dev/null 2>&1; then
            echo -e "${RED}Failed to fetch identity domains. Check permissions (iam domain list).${NC}"
            echo ""
            echo -e "Press Enter to return..."
            read -r
            return
        fi
        
        local domain_count
        domain_count=$(echo "$domains_json" | jq '(.data // []) | length')
        
        echo -e "Found ${GREEN}${domain_count}${NC} identity domain(s)"
        echo ""
        
        if [[ "$domain_count" -eq 0 ]]; then
            echo -e "${YELLOW}No identity domains found.${NC}"
            echo ""
            echo -e "Press Enter to return..."
            read -r
            return
        fi
        
        # Display domain list
        printf "${BOLD}%-3s  %-35s  %-12s  %-15s  %-10s  %s${NC}\n" \
            "#" "Domain Name" "Type" "License" "State" "URL"
        printf "${WHITE}%-3s  %-35s  %-12s  %-15s  %-10s  %s${NC}\n" \
            "---" "-----------------------------------" "------------" "---------------" "----------" "--------------------------------------------"
        
        local idx=0
        declare -A _DOM_IDS
        declare -A _DOM_NAMES
        declare -A _DOM_URLS
        
        while IFS=$'\t' read -r d_name d_type d_license d_state d_url d_id d_is_default d_compartment; do
            ((idx++))
            _DOM_IDS[$idx]="$d_id"
            _DOM_NAMES[$idx]="$d_name"
            _DOM_URLS[$idx]="$d_url"
            
            local state_color="$GREEN"
            [[ "$d_state" != "ACTIVE" ]] && state_color="$YELLOW"
            [[ "$d_state" == "FAILED" ]] && state_color="$RED"
            
            local default_tag=""
            [[ "$d_is_default" == "true" ]] && default_tag=" ${CYAN}(default)${NC}"
            
            printf "${YELLOW}%-3s${NC}  ${WHITE}%-35s${NC}  ${CYAN}%-12s${NC}  %-15s  ${state_color}%-10s${NC}  ${GRAY}%s${NC}%b\n" \
                "$idx" "${d_name:0:35}" "${d_type:0:12}" "${d_license:0:15}" "$d_state" "${d_url:0:44}" "$default_tag"
        done < <(echo "$domains_json" | jq -r '
            (.data // [])[] |
            [
                (.["display-name"] // "N/A"),
                (.type // "N/A"),
                (.["license-type"] // "N/A"),
                (.["lifecycle-state"] // "N/A"),
                (.url // "N/A"),
                (.id // "N/A"),
                ((.["is-default"] // false) | tostring),
                (.["compartment-id"] // "N/A")
            ] | @tsv
        ' 2>/dev/null)
        
        echo ""
        echo -n -e "${BOLD}${CYAN}[Identity Domains] Enter # to manage domain, ${MAGENTA}r${CYAN}=refresh, ${CYAN}back=return: ${NC}"
        read -r dom_choice
        
        case "$dom_choice" in
            ""|back|b|q)
                return
                ;;
            r|R|refresh)
                continue
                ;;
            *)
                if [[ "$dom_choice" =~ ^[0-9]+$ ]] && [[ -n "${_DOM_IDS[$dom_choice]:-}" ]]; then
                    _identity_domain_submenu "${_DOM_IDS[$dom_choice]}" "${_DOM_NAMES[$dom_choice]}" "$tenancy_id" "${_DOM_URLS[$dom_choice]}"
                else
                    echo -e "${RED}Invalid selection${NC}"
                    sleep 1
                fi
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# Identity Domain Submenu - Full management of a single domain
#--------------------------------------------------------------------------------
_identity_domain_submenu() {
    local domain_id="$1"
    local domain_name="$2"
    local tenancy_id="$3"
    local domain_url="$4"
    
    while true; do
        echo ""
        echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${GREEN}                                              DOMAIN: ${WHITE}${domain_name}                                                                                   ${NC}"
        echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo ""
        echo -e "  ${GRAY}Endpoint: ${domain_url}${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}═══ Domain Operations ═══${NC}"
        echo ""
        echo -e "${BOLD}${BLUE}─── View ───${NC}"
        echo -e "  ${YELLOW}1${NC})  ${WHITE}Domain Details${NC}                - View full domain configuration"
        echo -e "  ${YELLOW}2${NC})  ${WHITE}List Users${NC}                    - List users with group membership"
        echo -e "  ${YELLOW}3${NC})  ${WHITE}List Groups${NC}                   - List groups with member count"
        echo -e "  ${YELLOW}4${NC})  ${WHITE}List Dynamic Groups${NC}           - List dynamic groups with matching rules"
        echo -e "  ${YELLOW}5${NC})  ${WHITE}List Identity Providers${NC}       - List federation / identity providers"
        echo ""
        echo -e "${BOLD}${BLUE}─── Search ───${NC}"
        echo -e "  ${YELLOW}6${NC})  ${WHITE}Search Users${NC}                  - Search users by name/email keyword"
        echo -e "  ${YELLOW}7${NC})  ${WHITE}Search Groups${NC}                 - Search groups by name keyword"
        echo -e "  ${YELLOW}8${NC})  ${WHITE}Search Policies for User/Group${NC} - Find policies referencing a user or group"
        echo ""
        echo -e "${BOLD}${BLUE}─── Create ───${NC}"
        echo -e "  ${YELLOW}9${NC})  ${WHITE}Create User${NC}                   - Create a new user in this domain"
        echo -e "  ${YELLOW}10${NC}) ${WHITE}Create Group${NC}                  - Create a new group in this domain"
        echo -e "  ${YELLOW}11${NC}) ${WHITE}Create Dynamic Group${NC}          - Create a new dynamic group"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Domain: ${domain_name}] Enter selection [1-11, back]: ${NC}"
        read -r sub_choice
        
        case "$sub_choice" in
            ""|back|b|q)
                return
                ;;
            1)  _identity_domain_detail "$domain_id" ;;
            2)  _identity_list_users "$domain_url" "$tenancy_id" "$domain_name" ;;
            3)  _identity_list_groups "$domain_url" "$tenancy_id" "$domain_name" ;;
            4)  _identity_list_dynamic_groups "$domain_url" "$tenancy_id" ;;
            5)  _identity_list_identity_providers "$domain_url" ;;
            6)  _identity_search_users "$domain_url" "$tenancy_id" "$domain_name" ;;
            7)  _identity_search_groups "$domain_url" "$tenancy_id" "$domain_name" ;;
            8)  _identity_search_policies_for_principal "$tenancy_id" ;;
            9)  _identity_create_user "$domain_url" "$tenancy_id" "$domain_name" ;;
            10) _identity_create_group "$domain_url" "$tenancy_id" ;;
            11) _identity_create_dynamic_group "$domain_url" "$tenancy_id" ;;
            *)
                echo -e "${RED}Invalid selection${NC}"
                sleep 1
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# Domain Details (uses oci iam domain get - this is NOT an identity-domains op)
#--------------------------------------------------------------------------------
_identity_domain_detail() {
    local domain_id="$1"
    
    echo ""
    local cmd="oci iam domain get --domain-id \"$domain_id\""
    echo -e "  ${GRAY}Command: ${cmd}${NC}"
    echo -e "${GRAY}Fetching domain details...${NC}"
    
    local detail_json
    detail_json=$(oci iam domain get --domain-id "$domain_id" --output json 2>/dev/null)
    
    if [[ -z "$detail_json" ]]; then
        echo -e "${RED}Failed to fetch domain details${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Domain Configuration ═══${NC}"
    echo ""
    
    echo "$detail_json" | jq -r '
        .data |
        "  \u001b[0;36mDisplay Name:\u001b[0m      \u001b[1;37m\(.["display-name"] // "N/A")\u001b[0m",
        "  \u001b[0;36mDomain OCID:\u001b[0m       \u001b[1;33m\(.id // "N/A")\u001b[0m",
        "  \u001b[0;36mCompartment:\u001b[0m       \(.["compartment-id"] // "N/A")",
        "  \u001b[0;36mType:\u001b[0m              \(.type // "N/A")",
        "  \u001b[0;36mState:\u001b[0m             \(.["lifecycle-state"] // "N/A")",
        "  \u001b[0;36mHome Region:\u001b[0m       \(.["home-region"] // "N/A")",
        "  \u001b[0;36mURL:\u001b[0m               \(.url // "N/A")",
        "  \u001b[0;36mLicense Type:\u001b[0m      \(.["license-type"] // "N/A")",
        "  \u001b[0;36mIs Default:\u001b[0m        \(.["is-default"] // "N/A")",
        "  \u001b[0;36mIs Hidden:\u001b[0m         \(.["is-hidden-on-login"] // "N/A")",
        "  \u001b[0;36mCreated:\u001b[0m           \(.["time-created"] // "N/A")"
    ' 2>/dev/null
    
    echo ""
    echo -e "  ${CYAN}Replica Regions:${NC}"
    echo "$detail_json" | jq -r '
        (.data["replica-regions"] // [])[] |
        "    - \(.region // "N/A")  (State: \(.state // "N/A"))"
    ' 2>/dev/null || echo -e "    ${GRAY}(none)${NC}"
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# List Users (oci identity-domains user list)
# Groups are embedded in user SCIM response - no N+1 membership queries needed
#--------------------------------------------------------------------------------
_identity_list_users() {
    local domain_url="$1"
    local tenancy_id="$2"
    local domain_name="$3"
    
    echo ""
    local cmd="oci identity-domains user list --endpoint \"$domain_url\" --attribute-sets all --all"
    echo -e "  ${GRAY}Command: ${cmd}${NC}"
    echo -e "${GRAY}Fetching users from identity domain...${NC}"
    
    local users_json
    users_json=$(oci identity-domains user list --endpoint "$domain_url" --attribute-sets all --all --output json 2>/dev/null)
    
    if [[ -z "$users_json" ]] || ! echo "$users_json" | jq -e '.resources' > /dev/null 2>&1; then
        echo -e "${RED}Failed to fetch users. Check permissions (identity-domains user list).${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local user_count
    user_count=$(echo "$users_json" | jq '[(.resources // [])[] | select(.active == true)] | length')
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Users (${user_count} active) ═══${NC}"
    echo ""
    
    printf "${BOLD}%-3s  %-30s  %-35s  %-10s  %-10s  %s${NC}\n" \
        "#" "Username" "Email" "State" "Created" "Groups"
    printf "${WHITE}%-3s  %-30s  %-35s  %-10s  %-10s  %s${NC}\n" \
        "---" "------------------------------" "-----------------------------------" "----------" "----------" "──────────────────────────────────────────"
    
    local idx=0
    declare -A _USR_IDS
    declare -A _USR_NAMES
    
    while IFS=$'\t' read -r u_name u_email u_active u_id u_created u_groups; do
        [[ -z "$u_name" ]] && continue
        ((idx++))
        _USR_IDS[$idx]="$u_id"
        _USR_NAMES[$idx]="$u_name"
        
        local state_display="ACTIVE"
        local state_color="$GREEN"
        if [[ "$u_active" != "true" ]]; then
            state_display="INACTIVE"
            state_color="$RED"
        fi
        
        local created_short="${u_created:0:10}"
        
        printf "${YELLOW}%-3s${NC}  ${WHITE}%-30s${NC}  ${GRAY}%-35s${NC}  ${state_color}%-10s${NC}  ${GRAY}%-10s${NC}  ${MAGENTA}%s${NC}\n" \
            "$idx" "${u_name:0:30}" "${u_email:0:35}" "$state_display" "$created_short" "${u_groups}"
    done < <(echo "$users_json" | jq -r '
        (.resources // [])[] | select(.active == true) |
        [
            (.["user-name"] // "N/A"),
            ((.emails // []) | (map(select(.primary == true)) | .[0].value) // .[0].value // "N/A"),
            (if .active then "true" else "false" end),
            (.id // "N/A"),
            ((.meta // {}).created // "N/A"),
            ([(.groups // [])[] | .display] | join(", "))
        ] | @tsv
    ' 2>/dev/null)
    
    echo ""
    echo -n -e "${BOLD}${CYAN}[Users] Enter # for details, back=return: ${NC}"
    read -r uchoice
    
    if [[ "$uchoice" =~ ^[0-9]+$ ]] && [[ -n "${_USR_IDS[$uchoice]:-}" ]]; then
        _identity_user_detail "${_USR_IDS[$uchoice]}" "${_USR_NAMES[$uchoice]}" "$domain_url" "$tenancy_id"
    fi
}

#--------------------------------------------------------------------------------
# User Detail View (oci identity-domains user get)
# Groups are embedded - no separate membership query needed
#--------------------------------------------------------------------------------
_identity_user_detail() {
    local user_id="$1"
    local user_name="$2"
    local domain_url="$3"
    local tenancy_id="$4"
    
    echo ""
    local cmd="oci identity-domains user get --user-id \"$user_id\" --endpoint \"$domain_url\" --attribute-sets all"
    echo -e "  ${GRAY}Command: ${cmd}${NC}"
    echo -e "${GRAY}Fetching user details...${NC}"
    
    local user_json
    user_json=$(oci identity-domains user get --user-id "$user_id" --endpoint "$domain_url" --attribute-sets all --output json 2>/dev/null)
    
    if [[ -z "$user_json" ]]; then
        echo -e "${RED}Failed to fetch user details${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ User Details: ${GREEN}${user_name}${WHITE} ═══${NC}"
    echo ""
    
    # Display user attributes from SCIM response
    echo "$user_json" | jq -r '
        "  \u001b[0;36mUsername:\u001b[0m        \u001b[1;37m\(.["user-name"] // "N/A")\u001b[0m",
        "  \u001b[0;36mDisplay Name:\u001b[0m    \(.["display-name"] // "N/A")",
        "  \u001b[0;36mOCID:\u001b[0m            \u001b[1;33m\(.ocid // "N/A")\u001b[0m",
        "  \u001b[0;36mSCIM ID:\u001b[0m         \u001b[0;90m\(.id // "N/A")\u001b[0m",
        "  \u001b[0;36mEmail:\u001b[0m           \(((.emails // []) | (map(select(.primary == true)) | .[0].value) // .[0].value) // "N/A")",
        "  \u001b[0;36mActive:\u001b[0m          \(if .active then "\u001b[0;32mYes\u001b[0m" else "\u001b[1;31mNo\u001b[0m" end)",
        "  \u001b[0;36mName:\u001b[0m            \(((.name // {})["given-name"] // "") + " " + ((.name // {})["family-name"] // ""))",
        "  \u001b[0;36mCreated:\u001b[0m         \(((.meta // {}).created // "N/A") | split("T") | .[0])",
        "  \u001b[0;36mDescription:\u001b[0m     \(.description // "N/A")"
    ' 2>/dev/null
    
    # Groups are embedded in the SCIM user response
    echo ""
    echo -e "  ${CYAN}Group Memberships:${NC}"
    
    local user_group_names=()
    local group_count
    group_count=$(echo "$user_json" | jq '(.groups // []) | length' 2>/dev/null)
    
    if [[ "$group_count" -gt 0 && "$group_count" != "null" ]]; then
        while IFS=$'\t' read -r gname gval; do
            [[ -z "$gname" ]] && continue
            echo -e "    - ${MAGENTA}${gname}${NC}  ${GRAY}(${gval})${NC}"
            user_group_names+=("$gname")
        done < <(echo "$user_json" | jq -r '(.groups // [])[] | [.display // "N/A", .value // "N/A"] | @tsv' 2>/dev/null)
    else
        echo -e "    ${GRAY}(no group memberships)${NC}"
    fi
    
    # Additional SCIM attributes
    echo ""
    echo -e "  ${CYAN}Additional Attributes:${NC}"
    echo "$user_json" | jq -r '
        "  \u001b[0;36m  MFA Active:\u001b[0m     " +
            (if (.["urn:ietf:params:scim:schemas:oracle:idcs:extension:mfa:User"] // {})["mfa-status"] == "ENROLLED"
             then "\u001b[0;32mYes\u001b[0m" else "\u001b[1;33mNo\u001b[0m" end),
        "  \u001b[0;36m  User Type:\u001b[0m      \(.["user-type"] // "N/A")",
        "  \u001b[0;36m  DB Username:\u001b[0m    \(.["urn:ietf:params:scim:schemas:oracle:idcs:extension:db:User"]["db-user-name"] // "N/A")"
    ' 2>/dev/null 2>&1 || true
    
    # Search policies referencing this user (via user name, group names, any-user, any-group)
    echo ""
    echo -e "  ${CYAN}Policy References:${NC}"
    echo -e "  ${GRAY}Searching for: user '${user_name}', groups [${user_group_names[*]}], any-user, any-group${NC}"
    
    if [[ -f "$POLICIES_ALL_CACHE" ]]; then
        # Build JSON array of group names for Python
        local groups_json_arr="[]"
        if [[ ${#user_group_names[@]} -gt 0 ]]; then
            groups_json_arr=$(printf '%s\n' "${user_group_names[@]}" | jq -R . | jq -s .)
        fi
        
        # Use Python for full syntax-highlighted policy display (show ALL, no truncation)
        python3 - "$POLICIES_ALL_CACHE" "$user_name" "$groups_json_arr" "" << 'USER_POL_EOF'
import json, sys, re

pol_file = sys.argv[1]
user_name = sys.argv[2]
group_names = json.loads(sys.argv[3])
search_kw = sys.argv[4] if len(sys.argv) > 4 else ""

GREEN = '\033[0;32m'
YELLOW = '\033[1;33m'
CYAN = '\033[0;36m'
MAGENTA = '\033[0;35m'
BOLD = '\033[1m'
DIM = '\033[2m'
NC = '\033[0m'
RED = '\033[0;31m'
ORANGE = '\033[38;5;208m'
BG_YELLOW = '\033[43;30m'
BLUE = '\033[0;34m'

with open(pol_file) as f:
    policies = json.load(f)

def matches_principal(stmt):
    """Check if statement references this user via name, groups, any-user, any-group"""
    s = stmt.lower()
    # Direct user reference
    if user_name.lower() in s:
        return True
    # any-user / any-group
    if 'any-user' in s or 'any-group' in s:
        return True
    # Group membership references
    for gname in group_names:
        if re.search(r'group\s+' + re.escape(gname.lower()), s):
            return True
    return False

def highlight_stmt(stmt, search_kw=""):
    """Syntax highlight a policy statement - token-based to avoid ANSI-in-regex issues"""
    tokens = stmt.split()
    result = []
    i = 0
    while i < len(tokens):
        t = tokens[i]
        tl = t.lower()
        if tl == 'allow':
            result.append(f'{GREEN}{t}{NC}')
        elif tl == 'deny':
            result.append(f'{RED}{t}{NC}')
        elif tl == 'any-user':
            result.append(f'{ORANGE}{t}{NC}')
        elif tl == 'any-group':
            result.append(f'{ORANGE}{t}{NC}')
        elif tl == 'service' and i + 1 < len(tokens):
            result.append(f'{RED}{t}{NC}')
            i += 1
            result.append(f'{RED}{tokens[i]}{NC}')
        elif tl == 'dynamic-group' and i + 1 < len(tokens):
            result.append(f'{MAGENTA}{t}{NC}')
            i += 1
            result.append(f'{MAGENTA}{tokens[i]}{NC}')
        elif tl == 'group' and i + 1 < len(tokens):
            prev = tokens[i-1].lower() if i > 0 else ''
            if prev not in ('dynamic-group', 'any-group'):
                result.append(f'{MAGENTA}{t}{NC}')
                i += 1
                result.append(f'{MAGENTA}{tokens[i]}{NC}')
            else:
                result.append(t)
        elif tl in ('manage', 'use', 'read', 'inspect'):
            result.append(f'{YELLOW}{t}{NC}')
            if i + 1 < len(tokens):
                i += 1
                result.append(f'{CYAN}{tokens[i]}{NC}')
        elif tl == 'compartment' and i + 1 < len(tokens):
            result.append(t)
            i += 1
            result.append(f'{BOLD}{BLUE}{tokens[i]}{NC}')
        elif tl == 'where':
            result.append(f'{CYAN}{t}{NC}')
        else:
            result.append(t)
        i += 1
    h = ' '.join(result)
    if search_kw:
        try:
            h = re.sub(re.escape(search_kw), f'{BG_YELLOW}\\g<0>{NC}', h, flags=re.IGNORECASE)
        except re.error:
            pass
    return h

# Collect all matching statements
matches = []
for p in policies.get('data', []):
    pname = p.get('name', 'Unknown')
    comp_id = p.get('compartment-id', '')
    for stmt in p.get('statements', []):
        if matches_principal(stmt):
            if search_kw and search_kw.lower() not in stmt.lower():
                continue
            matches.append((pname, stmt, comp_id))

if not matches:
    if search_kw:
        print(f"    {YELLOW}No policy statements matching keyword '{search_kw}'{NC}")
    else:
        print(f"    {YELLOW}No policy references found for user '{user_name}'{NC}")
        print(f"    {DIM}Note: User may have access via policies not yet cached{NC}")
else:
    print(f"    Found {GREEN}{len(matches)}{NC} matching statement(s)")
    print()
    
    by_policy = {}
    for pname, stmt, comp_id in matches:
        by_policy.setdefault(pname, []).append(stmt)
    
    for pname, stmts in sorted(by_policy.items()):
        count_label = f"[{len(stmts)} statement{'s' if len(stmts) > 1 else ''}]"
        print(f"    {GREEN}📜 {pname}{NC} {DIM}{count_label}{NC}")
        for stmt in stmts:
            highlighted = highlight_stmt(stmt, search_kw)
            print(f"      └─ {highlighted}")
        print()

USER_POL_EOF
        
        # Offer keyword search within these policy references
        echo ""
        echo -n -e "  ${WHITE}Search these policies for keyword (Enter to skip): ${NC}"
        read -r pol_kw
        
        if [[ -n "$pol_kw" ]]; then
            echo ""
            echo -e "  ${CYAN}Filtered results for '${YELLOW}${pol_kw}${CYAN}':${NC}"
            python3 - "$POLICIES_ALL_CACHE" "$user_name" "$groups_json_arr" "$pol_kw" << 'USER_POL_SEARCH_EOF'
import json, sys, re

pol_file = sys.argv[1]
user_name = sys.argv[2]
group_names = json.loads(sys.argv[3])
search_kw = sys.argv[4]

GREEN = '\033[0;32m'
YELLOW = '\033[1;33m'
CYAN = '\033[0;36m'
MAGENTA = '\033[0;35m'
BOLD = '\033[1m'
DIM = '\033[2m'
NC = '\033[0m'
RED = '\033[0;31m'
ORANGE = '\033[38;5;208m'
BG_YELLOW = '\033[43;30m'
BLUE = '\033[0;34m'

with open(pol_file) as f:
    policies = json.load(f)

def matches_principal(stmt):
    s = stmt.lower()
    if user_name.lower() in s:
        return True
    if 'any-user' in s or 'any-group' in s:
        return True
    for gname in group_names:
        if re.search(r'group\s+' + re.escape(gname.lower()), s):
            return True
    return False

def highlight_stmt(stmt, kw=""):
    tokens = stmt.split()
    result = []
    i = 0
    while i < len(tokens):
        t = tokens[i]
        tl = t.lower()
        if tl == 'allow':
            result.append(f'{GREEN}{t}{NC}')
        elif tl == 'deny':
            result.append(f'{RED}{t}{NC}')
        elif tl == 'any-user':
            result.append(f'{ORANGE}{t}{NC}')
        elif tl == 'any-group':
            result.append(f'{ORANGE}{t}{NC}')
        elif tl == 'service' and i + 1 < len(tokens):
            result.append(f'{RED}{t}{NC}'); i += 1; result.append(f'{RED}{tokens[i]}{NC}')
        elif tl == 'dynamic-group' and i + 1 < len(tokens):
            result.append(f'{MAGENTA}{t}{NC}'); i += 1; result.append(f'{MAGENTA}{tokens[i]}{NC}')
        elif tl == 'group' and i + 1 < len(tokens):
            prev = tokens[i-1].lower() if i > 0 else ''
            if prev not in ('dynamic-group', 'any-group'):
                result.append(f'{MAGENTA}{t}{NC}'); i += 1; result.append(f'{MAGENTA}{tokens[i]}{NC}')
            else:
                result.append(t)
        elif tl in ('manage', 'use', 'read', 'inspect'):
            result.append(f'{YELLOW}{t}{NC}')
            if i + 1 < len(tokens): i += 1; result.append(f'{CYAN}{tokens[i]}{NC}')
        elif tl == 'compartment' and i + 1 < len(tokens):
            result.append(t); i += 1; result.append(f'{BOLD}{BLUE}{tokens[i]}{NC}')
        elif tl == 'where':
            result.append(f'{CYAN}{t}{NC}')
        else:
            result.append(t)
        i += 1
    h = ' '.join(result)
    if kw:
        try:
            h = re.sub(re.escape(kw), f'{BG_YELLOW}\\g<0>{NC}', h, flags=re.IGNORECASE)
        except re.error:
            pass
    return h

matches = []
for p in policies.get('data', []):
    pname = p.get('name', 'Unknown')
    for stmt in p.get('statements', []):
        if matches_principal(stmt) and search_kw.lower() in stmt.lower():
            matches.append((pname, stmt))

if not matches:
    print(f"    {YELLOW}No statements matching '{search_kw}' in user's policies{NC}")
else:
    print(f"    Found {GREEN}{len(matches)}{NC} statement(s) matching '{search_kw}'")
    print()
    by_policy = {}
    for pname, stmt in matches:
        by_policy.setdefault(pname, []).append(stmt)
    for pname, stmts in sorted(by_policy.items()):
        count_label = f"[{len(stmts)} statement{'s' if len(stmts) > 1 else ''}]"
        print(f"    {GREEN}📜 {pname}{NC} {DIM}{count_label}{NC}")
        for stmt in stmts:
            print(f"      └─ {highlight_stmt(stmt, search_kw)}")
        print()

USER_POL_SEARCH_EOF
        fi
    else
        echo -e "    ${GRAY}(policy cache not loaded - use Policies menu option 'r' to refresh)${NC}"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# List Groups with Member Count (oci identity-domains group list)
# Members are embedded in SCIM group response
#--------------------------------------------------------------------------------
_identity_list_groups() {
    local domain_url="$1"
    local tenancy_id="$2"
    local domain_name="$3"
    
    echo ""
    local cmd="oci identity-domains group list --endpoint \"$domain_url\" --attribute-sets all --all"
    echo -e "  ${GRAY}Command: ${cmd}${NC}"
    echo -e "${GRAY}Fetching groups from identity domain...${NC}"
    
    local groups_json
    groups_json=$(oci identity-domains group list --endpoint "$domain_url" --attribute-sets all --all --output json 2>/dev/null)
    
    if [[ -z "$groups_json" ]] || ! echo "$groups_json" | jq -e '.resources' > /dev/null 2>&1; then
        echo -e "${RED}Failed to fetch groups. Check permissions (identity-domains group list).${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local group_count
    group_count=$(echo "$groups_json" | jq '(.resources // []) | length')
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Groups (${group_count}) ═══${NC}"
    echo ""
    
    printf "${BOLD}%-3s  %-40s  %-10s  %-8s  %-15s  %s${NC}\n" \
        "#" "Group Name" "State" "Members" "Created" "Description"
    printf "${WHITE}%-3s  %-40s  %-10s  %-8s  %-15s  %s${NC}\n" \
        "---" "----------------------------------------" "----------" "--------" "---------------" "-------------------------------------------"
    
    local idx=0
    declare -A _GRP_IDS
    declare -A _GRP_NAMES
    
    while IFS=$'\t' read -r g_name g_active g_id g_created g_desc g_member_count; do
        [[ -z "$g_name" ]] && continue
        ((idx++))
        _GRP_IDS[$idx]="$g_id"
        _GRP_NAMES[$idx]="$g_name"
        
        local state_display="ACTIVE"
        local state_color="$GREEN"
        if [[ "$g_active" != "true" ]]; then
            state_display="INACTIVE"
            state_color="$YELLOW"
        fi
        
        local mem_color="$CYAN"
        [[ "$g_member_count" == "0" ]] && mem_color="$GRAY"
        
        printf "${YELLOW}%-3s${NC}  ${MAGENTA}%-40s${NC}  ${state_color}%-10s${NC}  ${mem_color}%-8s${NC}  ${GRAY}%-15s${NC}  ${GRAY}%s${NC}\n" \
            "$idx" "${g_name:0:40}" "$state_display" "$g_member_count" "${g_created:0:10}" "${g_desc:0:43}"
    done < <(echo "$groups_json" | jq -r '
        (.resources // [])[] |
        [
            (.["display-name"] // "N/A"),
            (if .active // true then "true" else "false" end),
            (.id // "N/A"),
            ((.meta // {}).created // "N/A"),
            (.description // "-"),
            ((.members // []) | length | tostring)
        ] | @tsv
    ' 2>/dev/null)
    
    echo ""
    echo -n -e "${BOLD}${CYAN}[Groups] Enter # for details, back=return: ${NC}"
    read -r gchoice
    
    if [[ "$gchoice" =~ ^[0-9]+$ ]] && [[ -n "${_GRP_IDS[$gchoice]:-}" ]]; then
        _identity_group_detail "${_GRP_IDS[$gchoice]}" "${_GRP_NAMES[$gchoice]}" "$domain_url" "$tenancy_id"
    fi
}

#--------------------------------------------------------------------------------
# Group Detail View (oci identity-domains group get)
# Members are embedded - no separate user-group-membership query needed
#--------------------------------------------------------------------------------
_identity_group_detail() {
    local group_id="$1"
    local group_name="$2"
    local domain_url="$3"
    local tenancy_id="$4"
    
    echo ""
    local cmd="oci identity-domains group get --group-id \"$group_id\" --endpoint \"$domain_url\" --attribute-sets all"
    echo -e "  ${GRAY}Command: ${cmd}${NC}"
    echo -e "${BOLD}${WHITE}═══ Group Details: ${MAGENTA}${group_name}${WHITE} ═══${NC}"
    echo ""
    
    local group_json
    group_json=$(oci identity-domains group get --group-id "$group_id" --endpoint "$domain_url" --attribute-sets all --output json 2>/dev/null)
    
    if [[ -n "$group_json" ]]; then
        echo "$group_json" | jq -r '
            "  \u001b[0;36mDisplay Name:\u001b[0m    \u001b[1;37m\(.["display-name"] // "N/A")\u001b[0m",
            "  \u001b[0;36mOCID:\u001b[0m            \u001b[1;33m\(.ocid // "N/A")\u001b[0m",
            "  \u001b[0;36mSCIM ID:\u001b[0m         \u001b[0;90m\(.id // "N/A")\u001b[0m",
            "  \u001b[0;36mActive:\u001b[0m          \(if .active // true then "\u001b[0;32mYes\u001b[0m" else "\u001b[1;31mNo\u001b[0m" end)",
            "  \u001b[0;36mDescription:\u001b[0m     \(.description // "N/A")",
            "  \u001b[0;36mCreated:\u001b[0m         \(((.meta // {}).created // "N/A") | split("T") | .[0])",
            "  \u001b[0;36mMembers:\u001b[0m         \((.members // []) | length)"
        ' 2>/dev/null
    fi
    
    # Members are embedded in the SCIM group response
    echo ""
    echo -e "  ${CYAN}Members:${NC}"
    
    local mem_count
    mem_count=$(echo "$group_json" | jq '(.members // []) | length' 2>/dev/null)
    
    if [[ "$mem_count" -gt 0 && "$mem_count" != "null" ]]; then
        while IFS=$'\t' read -r uname uval; do
            [[ -z "$uname" ]] && continue
            echo -e "    - ${WHITE}${uname}${NC}  ${GRAY}(${uval})${NC}"
        done < <(echo "$group_json" | jq -r '(.members // [])[] | [.name // .display // "N/A", .value // "N/A"] | @tsv' 2>/dev/null)
    else
        echo -e "    ${GRAY}(no members)${NC}"
    fi
    
    # Search policies referencing this group (group name, any-group)
    echo ""
    echo -e "  ${CYAN}Policy References:${NC}"
    if [[ -f "$POLICIES_ALL_CACHE" ]]; then
        local pol_matches
        pol_matches=$(jq -r --arg gname "$group_name" '
            [(.data // [])[] |
             . as $p |
             (.statements // [])[] |
             select(test("group\\s+" + $gname; "i") or test("any-group"; "i")) |
             {policy: $p.name, statement: .}
            ] | unique_by(.statement) | .[] |
            "    \u001b[0;32m📜 \(.policy)\u001b[0m: \(.statement)"
        ' "$POLICIES_ALL_CACHE" 2>/dev/null)
        
        if [[ -n "$pol_matches" ]]; then
            echo "$pol_matches" | head -20
            local match_total
            match_total=$(echo "$pol_matches" | wc -l)
            [[ $match_total -gt 20 ]] && echo -e "    ${GRAY}... and $((match_total - 20)) more${NC}"
        else
            echo -e "    ${GRAY}(no direct policy references found for group '${group_name}')${NC}"
        fi
    else
        echo -e "    ${GRAY}(policy cache not loaded - use Policies menu to refresh)${NC}"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# List Dynamic Groups (oci identity-domains dynamic-resource-group list)
#--------------------------------------------------------------------------------
_identity_list_dynamic_groups() {
    local domain_url="$1"
    local tenancy_id="$2"
    
    echo ""
    local cmd="oci identity-domains dynamic-resource-group list --endpoint \"$domain_url\" --all"
    echo -e "  ${GRAY}Command: ${cmd}${NC}"
    echo -e "${GRAY}Fetching dynamic groups from identity domain...${NC}"
    
    local dg_json
    dg_json=$(oci identity-domains dynamic-resource-group list --endpoint "$domain_url" --all --output json 2>/dev/null)
    
    if [[ -z "$dg_json" ]] || ! echo "$dg_json" | jq -e '.resources' > /dev/null 2>&1; then
        echo -e "${RED}Failed to fetch dynamic groups. Check permissions (identity-domains dynamic-resource-group list).${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local dg_count
    dg_count=$(echo "$dg_json" | jq '(.resources // []) | length')
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Dynamic Groups (${dg_count}) ═══${NC}"
    echo ""
    
    local idx=0
    declare -A _DG_IDS
    declare -A _DG_NAMES
    
    printf "${BOLD}%-3s  %-40s  %-10s  %s${NC}\n" \
        "#" "Dynamic Group Name" "Active" "Matching Rule"
    printf "${WHITE}%-3s  %-40s  %-10s  %s${NC}\n" \
        "---" "----------------------------------------" "----------" "────────────────────────────────────────────────────────────────"
    
    while IFS=$'\t' read -r dg_name dg_active dg_id dg_rule dg_desc; do
        [[ -z "$dg_name" ]] && continue
        ((idx++))
        _DG_IDS[$idx]="$dg_id"
        _DG_NAMES[$idx]="$dg_name"
        
        local state_display="Yes"
        local state_color="$GREEN"
        if [[ "$dg_active" != "true" ]]; then
            state_display="No"
            state_color="$YELLOW"
        fi
        
        printf "${YELLOW}%-3s${NC}  ${MAGENTA}%-40s${NC}  ${state_color}%-10s${NC}  ${GRAY}%s${NC}\n" \
            "$idx" "${dg_name:0:40}" "$state_display" "${dg_rule:0:65}"
        # Show full rule if truncated
        if [[ ${#dg_rule} -gt 65 ]]; then
            printf "     %-40s  %-10s  ${GRAY}%s${NC}\n" "" "" "${dg_rule:65}"
        fi
    done < <(echo "$dg_json" | jq -r '
        (.resources // [])[] |
        [
            (.["display-name"] // "N/A"),
            (if .active // true then "true" else "false" end),
            (.id // "N/A"),
            (.["matching-rule"] // "N/A"),
            (.description // "-")
        ] | @tsv
    ' 2>/dev/null)
    
    echo ""
    echo -n -e "${BOLD}${CYAN}[Dynamic Groups] Enter # for details, back=return: ${NC}"
    read -r dgchoice
    
    if [[ "$dgchoice" =~ ^[0-9]+$ ]] && [[ -n "${_DG_IDS[$dgchoice]:-}" ]]; then
        _identity_dynamic_group_detail "${_DG_IDS[$dgchoice]}" "${_DG_NAMES[$dgchoice]}" "$domain_url" "$tenancy_id"
    fi
}

#--------------------------------------------------------------------------------
# Dynamic Group Detail View (oci identity-domains dynamic-resource-group get)
#--------------------------------------------------------------------------------
_identity_dynamic_group_detail() {
    local dg_id="$1"
    local dg_name="$2"
    local domain_url="$3"
    local tenancy_id="$4"
    
    echo ""
    local cmd="oci identity-domains dynamic-resource-group get --dynamic-resource-group-id \"$dg_id\" --endpoint \"$domain_url\""
    echo -e "  ${GRAY}Command: ${cmd}${NC}"
    local dg_json
    dg_json=$(oci identity-domains dynamic-resource-group get --dynamic-resource-group-id "$dg_id" --endpoint "$domain_url" --output json 2>/dev/null)
    
    if [[ -z "$dg_json" ]]; then
        echo -e "${RED}Failed to fetch dynamic group details${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo -e "${BOLD}${WHITE}═══ Dynamic Group Details: ${MAGENTA}${dg_name}${WHITE} ═══${NC}"
    echo ""
    
    echo "$dg_json" | jq -r '
        "  \u001b[0;36mDisplay Name:\u001b[0m    \u001b[1;37m\(.["display-name"] // "N/A")\u001b[0m",
        "  \u001b[0;36mOCID:\u001b[0m            \u001b[1;33m\(.ocid // "N/A")\u001b[0m",
        "  \u001b[0;36mSCIM ID:\u001b[0m         \u001b[0;90m\(.id // "N/A")\u001b[0m",
        "  \u001b[0;36mActive:\u001b[0m          \(if .active // true then "\u001b[0;32mYes\u001b[0m" else "\u001b[1;31mNo\u001b[0m" end)",
        "  \u001b[0;36mDescription:\u001b[0m     \(.description // "N/A")",
        "  \u001b[0;36mCreated:\u001b[0m         \(((.meta // {}).created // "N/A") | split("T") | .[0])"
    ' 2>/dev/null
    
    echo ""
    echo -e "  ${CYAN}Matching Rule:${NC}"
    echo "$dg_json" | jq -r '.["matching-rule"] // "N/A"' 2>/dev/null | sed 's/^/    /'
    
    # Search policies referencing this dynamic group
    echo ""
    echo -e "  ${CYAN}Policy References:${NC}"
    if [[ -f "$POLICIES_ALL_CACHE" ]]; then
        local pol_matches
        pol_matches=$(jq -r --arg dgname "$dg_name" '
            [(.data // [])[] |
             . as $p |
             (.statements // [])[] |
             select(test("dynamic-group\\s+" + $dgname; "i")) |
             {policy: $p.name, statement: .}
            ] | unique_by(.statement) | .[] |
            "    \u001b[0;32m📜 \(.policy)\u001b[0m: \(.statement)"
        ' "$POLICIES_ALL_CACHE" 2>/dev/null)
        
        if [[ -n "$pol_matches" ]]; then
            echo "$pol_matches" | head -20
            local match_total
            match_total=$(echo "$pol_matches" | wc -l)
            [[ $match_total -gt 20 ]] && echo -e "    ${GRAY}... and $((match_total - 20)) more${NC}"
        else
            echo -e "    ${GRAY}(no policy references found for dynamic-group '${dg_name}')${NC}"
        fi
    else
        echo -e "    ${GRAY}(policy cache not loaded - use Policies menu to refresh)${NC}"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# List Identity Providers (oci identity-domains identity-provider list)
#--------------------------------------------------------------------------------
_identity_list_identity_providers() {
    local domain_url="$1"
    
    echo ""
    local cmd="oci identity-domains identity-provider list --endpoint \"$domain_url\" --all"
    echo -e "  ${GRAY}Command: ${cmd}${NC}"
    echo -e "${GRAY}Fetching identity providers from domain...${NC}"
    
    local idp_json
    idp_json=$(oci identity-domains identity-provider list --endpoint "$domain_url" --all --output json 2>/dev/null)
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Identity Providers / Federation ═══${NC}"
    echo ""
    
    if [[ -z "$idp_json" ]] || ! echo "$idp_json" | jq -e '.resources' > /dev/null 2>&1 || \
       [[ $(echo "$idp_json" | jq '(.resources // []) | length' 2>/dev/null) -eq 0 ]]; then
        echo -e "  ${GRAY}No identity providers found in this domain.${NC}"
        echo -e "  ${GRAY}Note: Check the domain URL in domain details for IdP settings.${NC}"
    else
        printf "${BOLD}%-3s  %-35s  %-12s  %-10s  %s${NC}\n" \
            "#" "Provider Name" "Type" "Enabled" "Description"
        printf "${WHITE}%-3s  %-35s  %-12s  %-10s  %s${NC}\n" \
            "---" "-----------------------------------" "------------" "----------" "---------------------------------------------"
        
        local idx=0
        while IFS=$'\t' read -r idp_name idp_type idp_enabled idp_id idp_desc; do
            [[ -z "$idp_name" ]] && continue
            ((idx++))
            local en_color="$GREEN"
            local en_display="Yes"
            if [[ "$idp_enabled" != "true" ]]; then
                en_color="$YELLOW"
                en_display="No"
            fi
            
            printf "${YELLOW}%-3s${NC}  ${WHITE}%-35s${NC}  ${CYAN}%-12s${NC}  ${en_color}%-10s${NC}  ${GRAY}%s${NC}\n" \
                "$idx" "${idp_name:0:35}" "${idp_type:0:12}" "$en_display" "${idp_desc:0:45}"
        done < <(echo "$idp_json" | jq -r '
            (.resources // [])[] |
            [
                (.["partner-name"] // .["display-name"] // "N/A"),
                (.type // "N/A"),
                (if .enabled // false then "true" else "false" end),
                (.id // "N/A"),
                (.description // "-")
            ] | @tsv
        ' 2>/dev/null)
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Search Users by keyword (oci identity-domains user list + client filter)
#--------------------------------------------------------------------------------
_identity_search_users() {
    local domain_url="$1"
    local tenancy_id="$2"
    local domain_name="$3"
    
    echo ""
    echo -n -e "  ${WHITE}Enter keyword to search users (name/email): ${NC}"
    read -r search_kw
    
    if [[ -z "$search_kw" ]]; then
        return
    fi
    
    echo -e "${GRAY}Searching users for '${search_kw}'...${NC}"
    
    local users_json
    users_json=$(oci identity-domains user list --endpoint "$domain_url" --attribute-sets all --all --output json 2>/dev/null)
    
    if [[ -z "$users_json" ]]; then
        echo -e "${RED}Failed to fetch users${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ User Search Results: '${YELLOW}${search_kw}${WHITE}' ═══${NC}"
    echo ""
    
    local idx=0
    declare -A _USR_SEARCH_IDS
    declare -A _USR_SEARCH_NAMES
    
    printf "${BOLD}%-3s  %-30s  %-35s  %-10s  %s${NC}\n" \
        "#" "Username" "Email" "State" "Created"
    printf "${WHITE}%-3s  %-30s  %-35s  %-10s  %s${NC}\n" \
        "---" "------------------------------" "-----------------------------------" "----------" "---------------"
    
    while IFS=$'\t' read -r u_name u_email u_active u_id u_created; do
        [[ -z "$u_name" ]] && continue
        # Case-insensitive match on name or email
        local search_lower="${search_kw,,}"
        local name_lower="${u_name,,}"
        local email_lower="${u_email,,}"
        
        if [[ "$name_lower" == *"$search_lower"* ]] || [[ "$email_lower" == *"$search_lower"* ]]; then
            ((idx++))
            _USR_SEARCH_IDS[$idx]="$u_id"
            _USR_SEARCH_NAMES[$idx]="$u_name"
            
            local state_display="ACTIVE"
            local state_color="$GREEN"
            if [[ "$u_active" != "true" ]]; then
                state_display="INACTIVE"
                state_color="$YELLOW"
            fi
            
            printf "${YELLOW}%-3s${NC}  ${WHITE}%-30s${NC}  ${GRAY}%-35s${NC}  ${state_color}%-10s${NC}  ${GRAY}%s${NC}\n" \
                "$idx" "${u_name:0:30}" "${u_email:0:35}" "$state_display" "${u_created:0:10}"
        fi
    done < <(echo "$users_json" | jq -r '
        (.resources // [])[] |
        [
            (.["user-name"] // "N/A"),
            ((.emails // []) | (map(select(.primary == true)) | .[0].value) // .[0].value // "N/A"),
            (if .active then "true" else "false" end),
            (.id // "N/A"),
            ((.meta // {}).created // "N/A")
        ] | @tsv
    ' 2>/dev/null)
    
    if [[ $idx -eq 0 ]]; then
        echo -e "  ${YELLOW}No users found matching '${search_kw}'${NC}"
    fi
    
    echo ""
    echo -n -e "${BOLD}${CYAN}[User Search] Enter # for details, back=return: ${NC}"
    read -r uchoice
    
    if [[ "$uchoice" =~ ^[0-9]+$ ]] && [[ -n "${_USR_SEARCH_IDS[$uchoice]:-}" ]]; then
        _identity_user_detail "${_USR_SEARCH_IDS[$uchoice]}" "${_USR_SEARCH_NAMES[$uchoice]}" "$domain_url" "$tenancy_id"
    fi
}

#--------------------------------------------------------------------------------
# Search Groups by keyword (oci identity-domains group list + client filter)
#--------------------------------------------------------------------------------
_identity_search_groups() {
    local domain_url="$1"
    local tenancy_id="$2"
    local domain_name="$3"
    
    echo ""
    echo -n -e "  ${WHITE}Enter keyword to search groups: ${NC}"
    read -r search_kw
    
    if [[ -z "$search_kw" ]]; then
        return
    fi
    
    echo -e "${GRAY}Searching groups for '${search_kw}'...${NC}"
    
    local groups_json
    groups_json=$(oci identity-domains group list --endpoint "$domain_url" --all --output json 2>/dev/null)
    
    if [[ -z "$groups_json" ]]; then
        echo -e "${RED}Failed to fetch groups${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Group Search Results: '${YELLOW}${search_kw}${WHITE}' ═══${NC}"
    echo ""
    
    local idx=0
    declare -A _GRP_SEARCH_IDS
    declare -A _GRP_SEARCH_NAMES
    
    printf "${BOLD}%-3s  %-40s  %-10s  %s${NC}\n" \
        "#" "Group Name" "Active" "Description"
    printf "${WHITE}%-3s  %-40s  %-10s  %s${NC}\n" \
        "---" "----------------------------------------" "----------" "---------------------------------------------"
    
    while IFS=$'\t' read -r g_name g_active g_id g_desc; do
        [[ -z "$g_name" ]] && continue
        local search_lower="${search_kw,,}"
        local name_lower="${g_name,,}"
        local desc_lower="${g_desc,,}"
        
        if [[ "$name_lower" == *"$search_lower"* ]] || [[ "$desc_lower" == *"$search_lower"* ]]; then
            ((idx++))
            _GRP_SEARCH_IDS[$idx]="$g_id"
            _GRP_SEARCH_NAMES[$idx]="$g_name"
            
            local state_display="Yes"
            local state_color="$GREEN"
            if [[ "$g_active" != "true" ]]; then
                state_display="No"
                state_color="$YELLOW"
            fi
            
            printf "${YELLOW}%-3s${NC}  ${MAGENTA}%-40s${NC}  ${state_color}%-10s${NC}  ${GRAY}%s${NC}\n" \
                "$idx" "${g_name:0:40}" "$state_display" "${g_desc:0:45}"
        fi
    done < <(echo "$groups_json" | jq -r '
        (.resources // [])[] |
        [
            (.["display-name"] // "N/A"),
            (if .active // true then "true" else "false" end),
            (.id // "N/A"),
            (.description // "-")
        ] | @tsv
    ' 2>/dev/null)
    
    if [[ $idx -eq 0 ]]; then
        echo -e "  ${YELLOW}No groups found matching '${search_kw}'${NC}"
    fi
    
    echo ""
    echo -n -e "${BOLD}${CYAN}[Group Search] Enter # for details, back=return: ${NC}"
    read -r gchoice
    
    if [[ "$gchoice" =~ ^[0-9]+$ ]] && [[ -n "${_GRP_SEARCH_IDS[$gchoice]:-}" ]]; then
        _identity_group_detail "${_GRP_SEARCH_IDS[$gchoice]}" "${_GRP_SEARCH_NAMES[$gchoice]}" "$domain_url" "$tenancy_id"
    fi
}

#--------------------------------------------------------------------------------
# Search Policies for a User or Group (by name or OCID)
# Searches: group <n>, dynamic-group <n>, any-user, any-group
# NOTE: This uses the policy cache - no identity-domains API calls needed
#--------------------------------------------------------------------------------
_identity_search_policies_for_principal() {
    local tenancy_id="$1"
    
    # Ensure policy cache is loaded
    if [[ ! -f "$POLICIES_ALL_CACHE" ]]; then
        echo ""
        echo -e "${GRAY}Policy cache not loaded. Fetching...${NC}"
        _policy_fetch_all "$tenancy_id"
        if [[ ! -f "$POLICIES_ALL_CACHE" ]]; then
            echo -e "${RED}Failed to load policies${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Search Policies for User/Group ═══${NC}"
    echo ""
    echo -e "  Enter a ${WHITE}user name${NC}, ${MAGENTA}group name${NC}, ${MAGENTA}dynamic-group name${NC},"
    echo -e "  ${YELLOW}OCID${NC}, or special: ${YELLOW}any-user${NC}, ${YELLOW}any-group${NC}"
    echo ""
    echo -n -e "  ${WHITE}Search term: ${NC}"
    read -r search_term
    
    if [[ -z "$search_term" ]]; then
        return
    fi
    
    echo ""
    echo -e "${GRAY}Searching policies for '${search_term}'...${NC}"
    echo ""
    
    # Use Python for rich search with syntax highlighting
    python3 - "$POLICIES_ALL_CACHE" "$search_term" << 'SEARCH_POL_EOF'
import json, sys, re

with open(sys.argv[1]) as f:
    policies = json.load(f)
search = sys.argv[2]
search_lower = search.lower()

GREEN = '\033[0;32m'
YELLOW = '\033[1;33m'
CYAN = '\033[0;36m'
MAGENTA = '\033[0;35m'
BOLD = '\033[1m'
DIM = '\033[2m'
NC = '\033[0m'
RED = '\033[0;31m'
ORANGE = '\033[38;5;208m'
BG_YELLOW = '\033[43;30m'

matches = []
for p in policies.get('data', []):
    pname = p.get('name', 'Unknown')
    for stmt in p.get('statements', []):
        stmt_lower = stmt.lower()
        hit = False
        
        # Direct text match (name, OCID, keyword)
        if search_lower in stmt_lower:
            hit = True
        # Also check for any-user/any-group if searching for those
        if search_lower in ('any-user', 'any-group', 'anyuser', 'anygroup'):
            if 'any-user' in stmt_lower or 'any-group' in stmt_lower:
                hit = True
        
        if hit:
            matches.append((pname, stmt))

if not matches:
    print(f"    {YELLOW}No policy statements matching '{search}'{NC}")
else:
    print(f"    Found {GREEN}{len(matches)}{NC} matching statement(s)")
    print()
    
    by_policy = {}
    for pname, stmt in matches:
        by_policy.setdefault(pname, []).append(stmt)
    
    for pname, stmts in sorted(by_policy.items()):
        count_label = f"[{len(stmts)} statement{'s' if len(stmts) > 1 else ''}]"
        print(f"    {GREEN}📜 {pname}{NC} {DIM}{count_label}{NC}")
        for stmt in stmts:
            # Token-based syntax highlighting
            tokens = stmt.split()
            result = []
            i = 0
            while i < len(tokens):
                t = tokens[i]
                tl = t.lower()
                if tl == 'allow':
                    result.append(f'{GREEN}{t}{NC}')
                elif tl == 'deny':
                    result.append(f'{RED}{t}{NC}')
                elif tl in ('any-user', 'any-group'):
                    result.append(f'{ORANGE}{t}{NC}')
                elif tl == 'service' and i + 1 < len(tokens):
                    result.append(f'{RED}{t}{NC}'); i += 1; result.append(f'{RED}{tokens[i]}{NC}')
                elif tl == 'dynamic-group' and i + 1 < len(tokens):
                    result.append(f'{MAGENTA}{t}{NC}'); i += 1; result.append(f'{MAGENTA}{tokens[i]}{NC}')
                elif tl == 'group' and i + 1 < len(tokens):
                    prev = tokens[i-1].lower() if i > 0 else ''
                    if prev not in ('dynamic-group', 'any-group'):
                        result.append(f'{MAGENTA}{t}{NC}'); i += 1; result.append(f'{MAGENTA}{tokens[i]}{NC}')
                    else:
                        result.append(t)
                elif tl in ('manage', 'use', 'read', 'inspect'):
                    result.append(f'{YELLOW}{t}{NC}')
                    if i + 1 < len(tokens): i += 1; result.append(f'{CYAN}{tokens[i]}{NC}')
                elif tl == 'where':
                    result.append(f'{CYAN}{t}{NC}')
                else:
                    result.append(t)
                i += 1
            highlighted = ' '.join(result)
            # Highlight search term
            try:
                highlighted = re.sub(re.escape(search), f'{BG_YELLOW}\\g<0>{NC}', highlighted, flags=re.IGNORECASE)
            except re.error:
                pass
            print(f"      └─ {highlighted}")
        print()

SEARCH_POL_EOF
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Create User (oci identity-domains user create)
#--------------------------------------------------------------------------------
_identity_create_user() {
    local domain_url="$1"
    local tenancy_id="$2"
    local domain_name="$3"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Create User (Identity Domain: ${CYAN}${domain_name}${WHITE}) ═══${NC}"
    echo ""
    
    echo -n -e "  ${WHITE}Username (login): ${NC}"
    read -r new_user_name
    [[ -z "$new_user_name" ]] && return
    
    echo -n -e "  ${WHITE}First name (given name): ${NC}"
    read -r new_first_name
    [[ -z "$new_first_name" ]] && new_first_name="$new_user_name"
    
    echo -n -e "  ${WHITE}Last name (family name): ${NC}"
    read -r new_last_name
    [[ -z "$new_last_name" ]] && new_last_name="User"
    
    echo -n -e "  ${WHITE}Email: ${NC}"
    read -r new_user_email
    
    echo -n -e "  ${WHITE}Description (optional): ${NC}"
    read -r new_user_desc
    
    echo ""
    echo -e "${BOLD}${WHITE}Command to execute:${NC}"
    
    # Build the command display
    local name_json="{\"givenName\":\"$new_first_name\",\"familyName\":\"$new_last_name\"}"
    local schemas_json='["urn:ietf:params:scim:schemas:core:2.0:User"]'
    
    local create_cmd="oci identity-domains user create --endpoint \"$domain_url\" --schemas '$schemas_json' --user-name \"$new_user_name\" --name '$name_json'"
    [[ -n "$new_user_email" ]] && create_cmd+=" --emails '[{\"value\":\"$new_user_email\",\"primary\":true,\"type\":\"work\"}]'"
    echo -e "  ${CYAN}${create_cmd}${NC}"
    echo ""
    echo -n -e "  ${YELLOW}Proceed? (y/N): ${NC}"
    read -r confirm
    
    if [[ "${confirm,,}" == "y" ]]; then
        local log_file="${LOG_DIR}/identity_actions.log"
        mkdir -p "$LOG_DIR"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: $create_cmd" >> "$log_file"
        echo -e "  ${GRAY}Logged to: ${log_file}${NC}"
        
        local result
        local email_arg=""
        [[ -n "$new_user_email" ]] && email_arg="--emails [$(printf '{"value":"%s","primary":true,"type":"work"}' "$new_user_email")]"
        
        if [[ -n "$new_user_email" ]]; then
            result=$(oci identity-domains user create \
                --endpoint "$domain_url" \
                --schemas "$schemas_json" \
                --user-name "$new_user_name" \
                --name "$name_json" \
                --emails "[{\"value\":\"$new_user_email\",\"primary\":true,\"type\":\"work\"}]" \
                --output json 2>&1)
        else
            result=$(oci identity-domains user create \
                --endpoint "$domain_url" \
                --schemas "$schemas_json" \
                --user-name "$new_user_name" \
                --name "$name_json" \
                --output json 2>&1)
        fi
        
        if echo "$result" | jq -e '.ocid // .id' > /dev/null 2>&1; then
            local new_ocid new_scim_id
            new_ocid=$(echo "$result" | jq -r '.ocid // "N/A"')
            new_scim_id=$(echo "$result" | jq -r '.id // "N/A"')
            echo -e "  ${GREEN}✓${NC} User created: ${WHITE}${new_user_name}${NC}"
            echo -e "  ${GRAY}OCID: ${new_ocid}${NC}"
            echo -e "  ${GRAY}SCIM ID: ${new_scim_id}${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created user $new_user_name ($new_ocid)" >> "$log_file"
        else
            echo -e "  ${RED}✗ Failed to create user${NC}"
            echo "$result" | head -5
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
        fi
    else
        echo -e "  ${GRAY}Cancelled${NC}"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Create Group (oci identity-domains group create)
#--------------------------------------------------------------------------------
_identity_create_group() {
    local domain_url="$1"
    local tenancy_id="$2"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Create Group ═══${NC}"
    echo ""
    
    echo -n -e "  ${WHITE}Group name: ${NC}"
    read -r new_group_name
    [[ -z "$new_group_name" ]] && return
    
    echo -n -e "  ${WHITE}Description (optional): ${NC}"
    read -r new_group_desc
    
    echo ""
    echo -e "${BOLD}${WHITE}Command to execute:${NC}"
    local schemas_json='["urn:ietf:params:scim:schemas:core:2.0:Group"]'
    local create_cmd="oci identity-domains group create --endpoint \"$domain_url\" --schemas '$schemas_json' --display-name \"$new_group_name\""
    echo -e "  ${CYAN}${create_cmd}${NC}"
    echo ""
    echo -n -e "  ${YELLOW}Proceed? (y/N): ${NC}"
    read -r confirm
    
    if [[ "${confirm,,}" == "y" ]]; then
        local log_file="${LOG_DIR}/identity_actions.log"
        mkdir -p "$LOG_DIR"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: $create_cmd" >> "$log_file"
        echo -e "  ${GRAY}Logged to: ${log_file}${NC}"
        
        local result
        result=$(oci identity-domains group create \
            --endpoint "$domain_url" \
            --schemas "$schemas_json" \
            --display-name "$new_group_name" \
            --output json 2>&1)
        
        if echo "$result" | jq -e '.ocid // .id' > /dev/null 2>&1; then
            local new_ocid new_scim_id
            new_ocid=$(echo "$result" | jq -r '.ocid // "N/A"')
            new_scim_id=$(echo "$result" | jq -r '.id // "N/A"')
            echo -e "  ${GREEN}✓${NC} Group created: ${MAGENTA}${new_group_name}${NC}"
            echo -e "  ${GRAY}OCID: ${new_ocid}${NC}"
            echo -e "  ${GRAY}SCIM ID: ${new_scim_id}${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created group $new_group_name ($new_ocid)" >> "$log_file"
        else
            echo -e "  ${RED}✗ Failed to create group${NC}"
            echo "$result" | head -5
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
        fi
    else
        echo -e "  ${GRAY}Cancelled${NC}"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Create Dynamic Group (oci identity-domains dynamic-resource-group create)
#--------------------------------------------------------------------------------
_identity_create_dynamic_group() {
    local domain_url="$1"
    local tenancy_id="$2"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Create Dynamic Group ═══${NC}"
    echo ""
    
    echo -n -e "  ${WHITE}Dynamic group name: ${NC}"
    read -r new_dg_name
    [[ -z "$new_dg_name" ]] && return
    
    echo -n -e "  ${WHITE}Description: ${NC}"
    read -r new_dg_desc
    [[ -z "$new_dg_desc" ]] && new_dg_desc="Created by policy audit tool"
    
    echo ""
    echo -e "  ${CYAN}Matching rule examples:${NC}"
    echo -e "    ${GRAY}All instances in a compartment:${NC}"
    echo -e "    ${WHITE}Any {instance.compartment.id = 'ocid1.compartment.oc1..xxx'}${NC}"
    echo -e "    ${GRAY}All instances with a tag:${NC}"
    echo -e "    ${WHITE}Any {tag.namespace.key.value = 'myvalue'}${NC}"
    echo -e "    ${GRAY}Specific resource type:${NC}"
    echo -e "    ${WHITE}Any {resource.type = 'fnfunc', resource.compartment.id = 'ocid1.compartment.oc1..xxx'}${NC}"
    echo ""
    echo -n -e "  ${WHITE}Matching rule: ${NC}"
    read -r new_dg_rule
    [[ -z "$new_dg_rule" ]] && return
    
    echo ""
    echo -e "${BOLD}${WHITE}Command to execute:${NC}"
    local schemas_json='["urn:ietf:params:scim:schemas:oracle:idcs:DynamicResourceGroup"]'
    local create_cmd="oci identity-domains dynamic-resource-group create --endpoint \"$domain_url\" --schemas '$schemas_json' --display-name \"$new_dg_name\" --description \"$new_dg_desc\" --matching-rule \"$new_dg_rule\""
    echo -e "  ${CYAN}${create_cmd}${NC}"
    echo ""
    echo -n -e "  ${YELLOW}Proceed? (y/N): ${NC}"
    read -r confirm
    
    if [[ "${confirm,,}" == "y" ]]; then
        local log_file="${LOG_DIR}/identity_actions.log"
        mkdir -p "$LOG_DIR"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: $create_cmd" >> "$log_file"
        echo -e "  ${GRAY}Logged to: ${log_file}${NC}"
        
        local result
        result=$(oci identity-domains dynamic-resource-group create \
            --endpoint "$domain_url" \
            --schemas "$schemas_json" \
            --display-name "$new_dg_name" \
            --description "$new_dg_desc" \
            --matching-rule "$new_dg_rule" \
            --output json 2>&1)
        
        if echo "$result" | jq -e '.ocid // .id' > /dev/null 2>&1; then
            local new_ocid new_scim_id
            new_ocid=$(echo "$result" | jq -r '.ocid // "N/A"')
            new_scim_id=$(echo "$result" | jq -r '.id // "N/A"')
            echo -e "  ${GREEN}✓${NC} Dynamic group created: ${MAGENTA}${new_dg_name}${NC}"
            echo -e "  ${GRAY}OCID: ${new_ocid}${NC}"
            echo -e "  ${GRAY}SCIM ID: ${new_scim_id}${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created dynamic-group $new_dg_name ($new_ocid)" >> "$log_file"
        else
            echo -e "  ${RED}✗ Failed to create dynamic group${NC}"
            echo "$result" | head -5
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
        fi
    else
        echo -e "  ${GRAY}Cancelled${NC}"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#================================================================================
# POLICY MANAGEMENT (Policy Audit)
#================================================================================

#--------------------------------------------------------------------------------
# Fetch all policies from all compartments with parallel execution and caching
# Stores results in POLICIES_ALL_CACHE and POLICIES_COMPS_CACHE
#--------------------------------------------------------------------------------
_policy_fetch_all() {
    local tenancy_id="$1"
    local force_refresh="${2:-false}"
    
    # Check cache freshness
    if [[ "$force_refresh" != "true" ]] && [[ -f "$POLICIES_ALL_CACHE" ]] && [[ -f "$POLICIES_COMPS_CACHE" ]]; then
        local file_age=$(($(date +%s) - $(stat -c %Y "$POLICIES_ALL_CACHE" 2>/dev/null || echo 0)))
        if [[ $file_age -lt $CACHE_MAX_AGE ]]; then
            local pol_count comp_count
            pol_count=$(jq '(.data // []) | length' "$POLICIES_ALL_CACHE" 2>/dev/null || echo 0)
            comp_count=$(jq '(.data // []) | length' "$POLICIES_COMPS_CACHE" 2>/dev/null || echo 0)
            echo -e "  ${GREEN}✓${NC} Policies cached: ${WHITE}${pol_count}${NC} policies across ${WHITE}${comp_count}${NC} compartments"
            return 0
        fi
    fi
    
    echo -e "  ${CYAN}Fetching compartment list...${NC}"
    
    # Fetch all compartments
    local comp_json
    comp_json=$(oci iam compartment list --compartment-id "$tenancy_id" --compartment-id-in-subtree true --all --output json 2>/dev/null)
    
    if [[ -z "$comp_json" ]] || ! echo "$comp_json" | jq -e '.data' > /dev/null 2>&1; then
        echo -e "${RED}Failed to fetch compartments${NC}"
        return 1
    fi
    
    echo "$comp_json" > "$POLICIES_COMPS_CACHE"
    
    # Build compartment ID list (active only + tenancy root)
    local comp_ids=()
    comp_ids+=("$tenancy_id")
    while read -r cid; do
        [[ -n "$cid" ]] && comp_ids+=("$cid")
    done < <(echo "$comp_json" | jq -r '(.data // [])[] | select(.["lifecycle-state"] == "ACTIVE") | .id' 2>/dev/null)
    
    local total_comps=${#comp_ids[@]}
    echo -e "  ${CYAN}Scanning ${WHITE}${total_comps}${CYAN} compartments for policies (parallel)...${NC}"
    
    # Parallel fetch into temp directory
    local parallel_temp="${TEMP_DIR}/policy_fetch_$$"
    mkdir -p "$parallel_temp"
    
    local max_parallel=15
    local running=0
    local comp_num=0
    
    for comp_id in "${comp_ids[@]}"; do
        ((comp_num++))
        
        (oci iam policy list --compartment-id "$comp_id" --all --output json 2>/dev/null > "${parallel_temp}/pol_${comp_num}.json") &
        ((running++))
        
        if [[ $running -ge $max_parallel ]]; then
            wait -n 2>/dev/null || wait
            ((running--))
        fi
        
        if [[ $((comp_num % 10)) -eq 0 ]]; then
            local done_count
            done_count=$(ls -1 "${parallel_temp}"/pol_*.json 2>/dev/null | wc -l)
            printf "\r  ${CYAN}Scanning: %d/%d compartments...${NC}   " "$done_count" "$total_comps"
        fi
    done
    
    wait
    echo ""
    
    # Merge all policy files
    echo -e "  ${GRAY}Merging results...${NC}"
    local merged
    merged=$(python3 -c "
import json, os, sys
all_policies = []
temp_dir = '${parallel_temp}'
for fname in sorted(os.listdir(temp_dir)):
    if fname.startswith('pol_') and fname.endswith('.json'):
        try:
            with open(os.path.join(temp_dir, fname)) as f:
                data = json.load(f)
                all_policies.extend(data.get('data', []))
        except:
            pass
# Deduplicate by policy ID
seen = set()
unique = []
for p in all_policies:
    pid = p.get('id', '')
    if pid and pid not in seen:
        seen.add(pid)
        unique.append(p)
json.dump({'data': unique}, sys.stdout)
" 2>/dev/null)
    
    if [[ -n "$merged" ]]; then
        echo "$merged" > "$POLICIES_ALL_CACHE"
        local pol_count
        pol_count=$(echo "$merged" | jq '(.data // []) | length' 2>/dev/null || echo 0)
        echo -e "  ${GREEN}✓${NC} Fetched ${WHITE}${pol_count}${NC} policies from ${WHITE}${total_comps}${NC} compartments"
    else
        echo -e "${RED}Failed to merge policy data${NC}"
        rm -rf "$parallel_temp"
        return 1
    fi
    
    rm -rf "$parallel_temp"
    return 0
}

#--------------------------------------------------------------------------------
# Display policy tree with filtering using Python
# Args: $1=policies_file $2=compartments_file $3=tenancy_id $4=filter $5=tenancy_name
#--------------------------------------------------------------------------------
_policy_display_tree() {
    local policies_file="$1"
    local compartments_file="$2"
    local tenancy_id="$3"
    local filter_raw="${4:-}"
    local tenancy_name="${5:-Root}"
    
    python3 - "$policies_file" "$compartments_file" "$tenancy_id" "$filter_raw" "$tenancy_name" << 'POLICY_TREE_EOF'
import json
import sys
import re
from collections import defaultdict

pol_file = sys.argv[1]
cmp_file = sys.argv[2]
tenancy_ocid = sys.argv[3]
filter_raw = sys.argv[4] if len(sys.argv) > 4 else ''
tenancy_name = sys.argv[5] if len(sys.argv) > 5 else 'Root'

# Parse filter type
filter_type = 'keyword'
filter_value = filter_raw.lower() if filter_raw else ''

if filter_raw.startswith('__COMPARTMENT__:'):
    filter_type = 'compartment'
    filter_value = filter_raw[16:].lower()
elif filter_raw.startswith('__POLICY__:'):
    filter_type = 'policy'
    filter_value = filter_raw[11:].lower()
elif filter_raw.startswith('__SERVICE__:'):
    filter_type = 'service'
    filter_value = filter_raw[12:].lower()

filter_patterns = [filter_value] if filter_value else []

def matches_filter(text, patterns):
    if not patterns:
        return True
    text_lower = text.lower()
    return any(p in text_lower for p in patterns)

def extract_resource_type(statement):
    pattern = r'\b(?:manage|use|read|inspect)\s+([a-zA-Z][a-zA-Z0-9_-]*(?:-[a-zA-Z0-9_]+)*)'
    match = re.search(pattern, statement, re.IGNORECASE)
    return match.group(1).lower() if match else ''

def matches_service_filter(statement, patterns):
    if not patterns:
        return True
    resource_type = extract_resource_type(statement)
    return any(p in resource_type for p in patterns) if resource_type else False

with open(pol_file) as f:
    policies = json.load(f)
with open(cmp_file) as f:
    compartments_raw = json.load(f)

# ANSI colors
GREEN = '\033[0;32m'
YELLOW = '\033[1;33m'
CYAN = '\033[0;36m'
MAGENTA = '\033[0;35m'
BOLD = '\033[1m'
DIM = '\033[2m'
NC = '\033[0m'
RED = '\033[0;31m'
BLUE = '\033[0;34m'
ORANGE = '\033[38;5;208m'
BOLD_BLUE = '\033[1;34m'
BG_YELLOW = '\033[43;30m'

# Build compartment data structures
comp_list = compartments_raw.get('data', compartments_raw) if isinstance(compartments_raw, dict) else compartments_raw
compartments = {tenancy_ocid: {'name': tenancy_name, 'id': tenancy_ocid, 'parent': None}}
for c in comp_list:
    cid = c.get('id', '')
    if c.get('lifecycle-state') == 'ACTIVE':
        compartments[cid] = {
            'name': c.get('name', 'Unknown'),
            'id': cid,
            'parent': c.get('compartment-id', tenancy_ocid)
        }

# Build children map
children = defaultdict(list)
for cid, comp in compartments.items():
    parent = comp.get('parent')
    if parent and parent != cid:
        children[parent].append(cid)

for parent_id in children:
    children[parent_id].sort(key=lambda x: compartments.get(x, {}).get('name', '').lower())

# Group policies by compartment
policies_by_comp = defaultdict(list)
for p in policies.get('data', []):
    comp_id = p.get('compartment-id', tenancy_ocid)
    policies_by_comp[comp_id].append(p)

# Count branch policies
def count_branch_policies(comp_id):
    count = len(policies_by_comp.get(comp_id, []))
    for child_id in children.get(comp_id, []):
        count += count_branch_policies(child_id)
    return count

branch_policy_counts = {cid: count_branch_policies(cid) for cid in compartments}

# Stats
total_policies = 0
total_statements = 0
matching_policies = 0
matching_statements = 0

def format_statement(s, highlight_keyword=None):
    """Syntax-highlight policy statement"""
    display = s
    
    # Deny in RED
    display = re.sub(r'\b(Deny)\b', f'{RED}\\1{NC}', display, flags=re.IGNORECASE)
    # Allow in GREEN
    display = re.sub(r'\b(Allow)\b', f'{GREEN}\\1{NC}', display, flags=re.IGNORECASE)
    # service <name> in RED
    display = re.sub(r'\b(service\s+)([a-zA-Z][a-zA-Z0-9._-]*)\b',
        lambda m: f'{m.group(1)}{RED}{m.group(2)}{NC}', display, flags=re.IGNORECASE)
    # any-user in ORANGE
    display = re.sub(r'\bany-user\b', f'{ORANGE}any-user{NC}', display, flags=re.IGNORECASE)
    # Verbs in YELLOW
    for kw in ['manage', 'use', 'read', 'inspect']:
        display = re.sub(rf'\b{kw}\b', f'{YELLOW}{kw}{NC}', display, flags=re.IGNORECASE)
    # Catch-all resource type after verb in CYAN
    yellow_esc = re.escape(YELLOW)
    nc_esc = re.escape(NC)
    verb_resource_pattern = rf'({yellow_esc}(?:manage|use|read|inspect){nc_esc}\s+)([a-zA-Z][a-zA-Z0-9-]*(?:-[a-zA-Z0-9]+)*)'
    def verb_resource_replacer(m):
        verb_part = m.group(1)
        resource = m.group(2)
        if '\033[' in resource:
            return m.group(0)
        return f'{verb_part}{CYAN}{resource}{NC}'
    display = re.sub(verb_resource_pattern, verb_resource_replacer, display)
    # dynamic-group in MAGENTA
    display = re.sub(r'\b(dynamic-group)\b', f'{MAGENTA}\\1{NC}', display, flags=re.IGNORECASE)
    # group (standalone) in MAGENTA
    display = re.sub(r'(?<!dynamic-)(?<!any-)(\bgroup\b)', f'{MAGENTA}\\1{NC}', display, flags=re.IGNORECASE)
    # any-group in ORANGE
    display = re.sub(r'\bany-group\b', f'{ORANGE}any-group{NC}', display, flags=re.IGNORECASE)
    # compartment references in BOLD_BLUE
    display = re.sub(r'(ocid1\.compartment\.[a-zA-Z0-9._-]+)', rf'{BOLD_BLUE}\1{NC}', display)
    comp_name_pattern = r'(in\s+compartment\s+)(?!id\b)([\'"]?)([a-zA-Z0-9_:/-]+)([\'"]?)'
    def comp_replacer(m):
        return f'{m.group(1)}{m.group(2)}{BOLD_BLUE}{m.group(3)}{NC}{m.group(4)}'
    display = re.sub(comp_name_pattern, comp_replacer, display, flags=re.IGNORECASE)
    display = re.sub(r'\b(in\s+)(tenancy)\b', rf'\1{BOLD_BLUE}\2{NC}', display, flags=re.IGNORECASE)
    # where in CYAN
    display = re.sub(r'\b(where)\b', f'{CYAN}\\1{NC}', display, flags=re.IGNORECASE)
    # Dim "to"
    display = re.sub(r'(\s)(to)(\s)', rf'\1{DIM}\2{NC}\3', display, flags=re.IGNORECASE)
    # Search keyword highlight (last, to stand out)
    if highlight_keyword:
        pattern = re.compile(re.escape(highlight_keyword), re.IGNORECASE)
        display = pattern.sub(f'{BG_YELLOW}\\g<0>{NC}', display)
    return display

def print_compartment(comp_id, prefix="", is_last=True, depth=0):
    global total_policies, total_statements, matching_policies, matching_statements
    comp = compartments.get(comp_id, {})
    comp_name = comp.get('name', 'Unknown')
    branch = "└── " if is_last else "├── "
    child_prefix = prefix + ("    " if is_last else "│   ")

    # Compartment filter check
    comp_matches_filter = True
    if filter_type == 'compartment' and filter_patterns:
        comp_matches_filter = matches_filter(comp_name, filter_patterns)
        if not comp_matches_filter:
            def has_matching_descendant(cid):
                c = compartments.get(cid, {})
                if matches_filter(c.get('name', ''), filter_patterns):
                    return True
                for child in children.get(cid, []):
                    if has_matching_descendant(child):
                        return True
                return False
            if not has_matching_descendant(comp_id):
                return

    # Filter policies
    comp_policies = policies_by_comp.get(comp_id, [])
    filtered_policies = []
    if not (filter_type == 'compartment' and filter_patterns and not comp_matches_filter):
        for p in comp_policies:
            total_policies += 1
            policy_name = p.get('name', 'Unknown')
            if filter_type == 'policy' and filter_patterns:
                if not matches_filter(policy_name, filter_patterns):
                    continue
            policy_stmts = []
            for s in p.get('statements', []):
                total_statements += 1
                if filter_type == 'keyword' and filter_patterns:
                    if matches_filter(s, filter_patterns):
                        matching_statements += 1
                        policy_stmts.append(s)
                elif filter_type == 'service' and filter_patterns:
                    if matches_service_filter(s, filter_patterns):
                        matching_statements += 1
                        policy_stmts.append(s)
                else:
                    matching_statements += 1
                    policy_stmts.append(s)
            if policy_stmts:
                matching_policies += 1
                filtered_policies.append((policy_name, policy_stmts, p.get('statements', [])))

    child_comps = children.get(comp_id, [])

    # Skip empty branches when filtering
    if filter_patterns and not filtered_policies and depth > 0:
        def has_descendant_match(cid):
            if filter_type == 'compartment':
                c = compartments.get(cid, {})
                if matches_filter(c.get('name', ''), filter_patterns):
                    return True
            for p in policies_by_comp.get(cid, []):
                if filter_type == 'policy':
                    if matches_filter(p.get('name', ''), filter_patterns):
                        return True
                elif filter_type == 'keyword':
                    for s in p.get('statements', []):
                        if matches_filter(s, filter_patterns):
                            return True
                elif filter_type == 'service':
                    for s in p.get('statements', []):
                        if matches_service_filter(s, filter_patterns):
                            return True
            for child in children.get(cid, []):
                if has_descendant_match(child):
                    return True
            return False
        if not has_descendant_match(comp_id):
            return

    # Print compartment header
    bp = branch_policy_counts.get(comp_id, 0)
    policy_count = len(filtered_policies)
    child_count = len(child_comps)

    if depth == 0:
        print(f"\n{BOLD}{BLUE}🏢 {comp_name}{NC} (root tenancy)")
        info_parts = []
        if policy_count > 0:
            info_parts.append(f"{policy_count} policies here" + (f", {bp} total in tree" if bp > policy_count else ""))
        elif bp > 0:
            info_parts.append(f"{bp} policies in tree")
        if child_count > 0:
            info_parts.append(f"{child_count} sub-compartments")
        if info_parts:
            print(f"{DIM}   {', '.join(info_parts)}{NC}")
    else:
        info_parts = []
        if policy_count > 0:
            info_parts.append(f"{policy_count} policies" + (f", {bp} in branch" if bp > policy_count else ""))
        elif bp > 0:
            info_parts.append(f"{bp} in branch")
        if child_count > 0:
            info_parts.append(f"{child_count} sub")
        info_str = f" {DIM}({', '.join(info_parts)}){NC}" if info_parts else ""
        print(f"{prefix}{branch}{BLUE}📁 {comp_name}{NC}{info_str}")

    # Print policies
    policy_prefix = child_prefix if depth > 0 else "   "
    highlight = filter_value if filter_type in ['keyword', 'service'] and filter_patterns else None
    for i, (pol_name, matched_stmts, all_stmts) in enumerate(filtered_policies):
        is_last_policy = (i == len(filtered_policies) - 1) and not child_comps
        pol_branch = "└── " if is_last_policy else "├── "
        stmt_prefix = policy_prefix + ("    " if is_last_policy else "│   ")
        stmt_count = len(all_stmts)
        match_info = ""
        if filter_type in ['keyword', 'service'] and filter_patterns and matched_stmts:
            match_info = f" {GREEN}({len(matched_stmts)} match){NC}"
        print(f"{policy_prefix}{pol_branch}{GREEN}📜 {pol_name}{NC} {DIM}[{stmt_count} statements]{NC}{match_info}")
        stmts_to_show = matched_stmts if filter_type in ['keyword', 'service'] and filter_patterns else all_stmts
        for j, stmt in enumerate(stmts_to_show):
            is_last_stmt = (j == len(stmts_to_show) - 1)
            stmt_branch = "└─ " if is_last_stmt else "├─ "
            formatted = format_statement(stmt, highlight_keyword=highlight)
            print(f"{stmt_prefix}{stmt_branch}{formatted}")

    # Print children
    for i, child_id in enumerate(child_comps):
        is_last_child = (i == len(child_comps) - 1)
        print_compartment(child_id, child_prefix if depth > 0 else "   ", is_last_child, depth + 1)

# Print the tree
print(f"\n{BOLD}{'═' * 70}{NC}")
print(f"{BOLD}  Compartment & Policy Hierarchy{NC}")
print(f"{BOLD}{'═' * 70}{NC}")

print_compartment(tenancy_ocid, depth=0)

# Summary
print(f"\n{BOLD}{'─' * 70}{NC}")
print(f"{BOLD}Summary{NC}")
print(f"{'─' * 70}")

if filter_patterns:
    filter_display = filter_value
    if filter_type == 'compartment':
        filter_display = f"compartment: {filter_value}"
    elif filter_type == 'policy':
        filter_display = f"policy: {filter_value}"
    elif filter_type == 'service':
        filter_display = f"resource-type contains: {filter_value}"
    elif filter_type == 'keyword':
        filter_display = f"keyword: {filter_value}"
    print(f"  Filter: '{YELLOW}{filter_display}{NC}'")
    print(f"  Matching: {GREEN}{matching_policies}{NC} policies, {GREEN}{matching_statements}{NC} statements")
    print(f"  Total scanned: {total_policies} policies, {total_statements} statements")
else:
    print(f"  Total: {GREEN}{total_policies}{NC} policies with {GREEN}{total_statements}{NC} statements")

# Analysis - only when no filter
if not filter_patterns:
    print(f"\n{BOLD}Policy Analysis{NC}")
    print(f"{'─' * 70}")
    
    # Admin policies
    admin_stmts = []
    for p in policies.get('data', []):
        for s in p.get('statements', []):
            if 'manage all-resources' in s.lower():
                admin_stmts.append((p.get('name'), s))
    if admin_stmts:
        print(f"  {YELLOW}⚠{NC}  {len(admin_stmts)} statements grant '{YELLOW}manage all-resources{NC}' (full admin)")
        for pol_name, stmt in admin_stmts[:5]:
            print(f"      {DIM}└─ {pol_name}{NC}")
        if len(admin_stmts) > 5:
            print(f"      {DIM}   ... and {len(admin_stmts) - 5} more{NC}")
    
    # Dynamic group policies
    dg_stmts = [1 for p in policies.get('data', []) for s in p.get('statements', []) if 'dynamic-group' in s.lower()]
    if dg_stmts:
        print(f"  {GREEN}✓{NC}  {len(dg_stmts)} statements use {MAGENTA}dynamic groups{NC}")
    
    # Any-user / any-group (broad access)
    broad_stmts = [1 for p in policies.get('data', []) for s in p.get('statements', [])
                   if 'any-user' in s.lower() or 'any-group' in s.lower()]
    if broad_stmts:
        print(f"  {ORANGE}⚠{NC}  {len(broad_stmts)} statements use broad access (any-user/any-group)")
    
    # Compartment stats
    comps_with_policies = len([c for c in policies_by_comp if policies_by_comp[c]])
    print(f"\n  📊 Compartment Statistics:")
    print(f"      Total compartments: {len(compartments)}")
    print(f"      With policies: {comps_with_policies}")
    
    # Top compartments by policy count
    if policies_by_comp:
        print(f"\n  📋 Top Compartments by Policy Count:")
        sorted_comps = sorted(
            [(cid, len(pols)) for cid, pols in policies_by_comp.items() if pols],
            key=lambda x: -x[1]
        )[:5]
        for cid, count in sorted_comps:
            name = compartments.get(cid, {}).get('name', 'Unknown')
            print(f"      {count:3d} policies: {name}")

POLICY_TREE_EOF
}

#--------------------------------------------------------------------------------
# List compartments with policies for selection (used by manage_policies filter)
#--------------------------------------------------------------------------------
_policy_list_compartments_with_policies() {
    local policies_file="$1"
    local compartments_file="$2"
    local tenancy_id="$3"
    
    python3 - "$policies_file" "$compartments_file" "$tenancy_id" << 'COMP_LIST_EOF'
import json, sys
from collections import defaultdict

with open(sys.argv[1]) as f:
    policies = json.load(f)
with open(sys.argv[2]) as f:
    comps_raw = json.load(f)
tenancy_ocid = sys.argv[3]

comp_names = {tenancy_ocid: '(root)'}
comp_parents = {tenancy_ocid: None}
comp_list = comps_raw.get('data', comps_raw) if isinstance(comps_raw, dict) else comps_raw
for c in comp_list:
    cid = c.get('id', '')
    if c.get('lifecycle-state') == 'ACTIVE':
        comp_names[cid] = c.get('name', 'Unknown')
        comp_parents[cid] = c.get('compartment-id', tenancy_ocid)

def get_comp_path(cid, max_depth=4):
    path = []
    current = cid
    while current and len(path) < max_depth:
        name = comp_names.get(current, '')
        if name:
            path.insert(0, name)
        current = comp_parents.get(current)
    if len(path) > 3:
        return path[0] + '/.../' + '/'.join(path[-2:])
    return '/'.join(path)

comp_counts = {}
comp_paths = {}
for p in policies.get('data', []):
    cid = p.get('compartment-id', '')
    cname = comp_names.get(cid, cid[:30])
    cpath = get_comp_path(cid)
    if cname not in comp_counts:
        comp_counts[cname] = 0
        comp_paths[cname] = cpath
    comp_counts[cname] += 1

items = [(name, count, comp_paths.get(name, name)) for name, count in comp_counts.items()]
items.sort(key=lambda x: x[2])
for i, (name, count, path) in enumerate(items, 1):
    print(f'{i}|{name}|{count}|{path}')
COMP_LIST_EOF
}

#--------------------------------------------------------------------------------
# List all policy names for selection
#--------------------------------------------------------------------------------
_policy_list_names() {
    local policies_file="$1"
    local compartments_file="$2"
    local tenancy_id="$3"
    
    python3 - "$policies_file" "$compartments_file" "$tenancy_id" << 'POL_LIST_EOF'
import json, sys

with open(sys.argv[1]) as f:
    policies = json.load(f)
with open(sys.argv[2]) as f:
    comps_raw = json.load(f)
tenancy_ocid = sys.argv[3]

comp_names = {tenancy_ocid: '(root)'}
comp_parents = {tenancy_ocid: None}
comp_list = comps_raw.get('data', comps_raw) if isinstance(comps_raw, dict) else comps_raw
for c in comp_list:
    cid = c.get('id', '')
    if c.get('lifecycle-state') == 'ACTIVE':
        comp_names[cid] = c.get('name', 'Unknown')
        comp_parents[cid] = c.get('compartment-id', tenancy_ocid)

def get_comp_path(cid, max_depth=4):
    path = []
    current = cid
    while current and len(path) < max_depth:
        name = comp_names.get(current, '')
        if name:
            path.insert(0, name)
        current = comp_parents.get(current)
    if len(path) > 3:
        return path[0] + '/.../' + '/'.join(path[-2:])
    return '/'.join(path)

seen = {}
for p in policies.get('data', []):
    name = p.get('name', 'Unknown')
    cid = p.get('compartment-id', tenancy_ocid)
    comp_path = get_comp_path(cid)
    stmt_count = len(p.get('statements', []))
    if name not in seen:
        seen[name] = (stmt_count, comp_path)

for i, (name, (count, path)) in enumerate(sorted(seen.items()), 1):
    print(f'{i}|{name}|{count}|{path}')
POL_LIST_EOF
}

#--------------------------------------------------------------------------------
# Policy Validation Check - Verify policies for each --manage menu function
# Checks a specified user, group, or dynamic-group against required policies
# for every menu option. Reports found (✓) and missing (✗) policies.
#--------------------------------------------------------------------------------
_policy_validation_check() {
    local tenancy_id="$1"
    
    # Ensure policy cache is loaded
    if [[ ! -f "$POLICIES_ALL_CACHE" ]]; then
        echo ""
        echo -e "${GRAY}Policy cache not loaded. Fetching...${NC}"
        _policy_fetch_all "$tenancy_id"
        if [[ ! -f "$POLICIES_ALL_CACHE" ]]; then
            echo -e "${RED}Failed to load policies${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${WHITE}                                               POLICY VALIDATION CHECK                                                                                ${NC}"
    echo -e "${BOLD}${WHITE}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "  This tool validates whether a ${WHITE}user${NC}, ${MAGENTA}group${NC}, or ${MAGENTA}dynamic-group${NC}"
    echo -e "  has the required policies for each ${YELLOW}--manage${NC} menu function."
    echo ""
    echo -e "${BOLD}${BLUE}─── Select Principal Type ───${NC}"
    echo ""
    echo -e "  ${YELLOW}1${NC})  ${WHITE}Group${NC}                 - Check policies for a group"
    echo -e "  ${YELLOW}2${NC})  ${WHITE}Dynamic Group${NC}         - Check policies for a dynamic-group"
    echo -e "  ${YELLOW}3${NC})  ${WHITE}User (by name)${NC}        - Check policies referencing a specific user"
    echo -e "  ${YELLOW}4${NC})  ${WHITE}any-user${NC}              - Check what any authenticated user can do"
    echo ""
    echo -n -e "${BOLD}${CYAN}[Policy Check] Select type [1-4, back]: ${NC}"
    read -r ptype_choice
    
    local principal_type=""
    local principal_name=""
    
    case "$ptype_choice" in
        ""|back|b|q) return ;;
        1) principal_type="group" ;;
        2) principal_type="dynamic-group" ;;
        3) principal_type="user" ;;
        4) 
            principal_type="any-user"
            principal_name="any-user"
            ;;
        *) echo -e "${RED}Invalid selection${NC}"; sleep 1; return ;;
    esac
    
    # For group/dynamic-group/user, extract list from policies and let user select
    if [[ "$principal_type" != "any-user" ]]; then
        echo ""
        echo -e "${GRAY}Extracting ${principal_type} names referenced in policies...${NC}"
        
        local principal_list
        principal_list=$(python3 - "$POLICIES_ALL_CACHE" "$principal_type" << 'EXTRACT_PRINCIPALS_EOF'
import json, sys, re

with open(sys.argv[1]) as f:
    policies = json.load(f)
ptype = sys.argv[2]

principals = set()
for p in policies.get('data', []):
    for stmt in p.get('statements', []):
        s = stmt.lower()
        if ptype == 'group':
            for m in re.finditer(r'(?<!\w)(?<!dynamic-)group\s+([^\s,]+)', s):
                name = m.group(1).strip("'\"")
                if name not in ('id', 'in', 'to', 'where'):
                    principals.add(name)
        elif ptype == 'dynamic-group':
            for m in re.finditer(r'dynamic-group\s+([^\s,]+)', s):
                name = m.group(1).strip("'\"")
                if name not in ('id', 'in', 'to', 'where'):
                    principals.add(name)
        elif ptype == 'user':
            for m in re.finditer(r'(?<!\w)user\s+([^\s,]+)', s):
                name = m.group(1).strip("'\"")
                if name not in ('id', 'in', 'to', 'where', 'of'):
                    principals.add(name)

for name in sorted(principals):
    print(name)
EXTRACT_PRINCIPALS_EOF
        )
        
        if [[ -z "$principal_list" ]]; then
            echo -e "  ${YELLOW}No ${principal_type} names found in policies.${NC}"
            echo ""
            echo -n -e "  ${WHITE}Enter ${principal_type} name manually: ${NC}"
            read -r principal_name
            if [[ -z "$principal_name" ]]; then
                return
            fi
        else
            echo ""
            echo -e "${BOLD}${WHITE}═══ ${principal_type^}s Referenced in Policies ═══${NC}"
            echo ""
            
            local idx=0
            declare -A _PRINC_MAP
            _PRINC_MAP=()
            while IFS= read -r pname; do
                [[ -z "$pname" ]] && continue
                ((idx++))
                _PRINC_MAP[$idx]="$pname"
                printf "  ${YELLOW}%3s${NC})  ${MAGENTA}%s${NC}\n" "$idx" "$pname"
            done <<< "$principal_list"
            
            echo ""
            echo -n -e "  ${WHITE}Select # or type name [1-${idx}, back]: ${NC}"
            read -r princ_choice
            
            if [[ -z "$princ_choice" || "$princ_choice" == "back" || "$princ_choice" == "b" ]]; then
                return
            elif [[ "$princ_choice" =~ ^[0-9]+$ ]] && [[ -n "${_PRINC_MAP[$princ_choice]:-}" ]]; then
                principal_name="${_PRINC_MAP[$princ_choice]}"
            else
                principal_name="$princ_choice"
            fi
        fi
    fi
    
    echo ""
    echo -e "${GRAY}Analyzing policies for ${principal_type} '${principal_name}'...${NC}"
    echo ""
    
    # Run the full validation in Python
    python3 - "$POLICIES_ALL_CACHE" "$principal_type" "$principal_name" << 'POLICY_CHECK_EOF'
import json, sys, re

pol_file = sys.argv[1]
ptype = sys.argv[2]
pname = sys.argv[3]

# Colors
GREEN = '\033[0;32m'
RED = '\033[0;31m'
YELLOW = '\033[1;33m'
CYAN = '\033[0;36m'
MAGENTA = '\033[0;35m'
WHITE = '\033[1;37m'
GRAY = '\033[0;90m'
BOLD = '\033[1m'
DIM = '\033[2m'
NC = '\033[0m'
BLUE = '\033[0;34m'
ORANGE = '\033[38;5;208m'
BG_GREEN = '\033[42;30m'
BG_RED = '\033[41;37m'

with open(pol_file) as f:
    policies = json.load(f)

# Verb hierarchy: manage > use > read > inspect
VERB_RANK = {"inspect": 1, "read": 2, "use": 3, "manage": 4}

def verb_satisfies(have_verb, need_verb):
    return VERB_RANK.get(have_verb, 0) >= VERB_RANK.get(need_verb, 0)

# Resource family expansion
FAMILY_COVERS = {
    "all-resources": ["*"],
    "virtual-network-family": [
        "subnets", "vnics", "vnic-attachments", "network-security-groups",
        "security-lists", "route-tables", "internet-gateways", "nat-gateways",
        "service-gateways", "local-peering-gateways", "drgs", "drg-attachments",
        "drg-route-tables", "drg-route-distributions", "remote-peering-connections",
        "dns", "dns-zones", "dns-records", "private-ips", "public-ips",
        "network-load-balancers", "vcns",
    ],
    "instance-family": [
        "instances", "instance-configurations", "instance-pools",
        "compute-management-family", "instance-agent-command-family",
        "compute-capacity-reports", "instance-images", "app-catalog-listing",
        "vnics", "vnic-attachments", "volume-attachments",
    ],
    "compute-management-family": [
        "instances", "instance-configurations", "instance-pools",
        "instance-images", "app-catalog-listing",
    ],
    "cluster-family": [
        "clusters", "cluster-node-pools", "cluster-workloads",
        "cluster-pod-shapes", "cluster-addons",
    ],
    "object-family": [
        "buckets", "objects", "objectstorage-namespaces",
        "object-storage-private-endpoints",
    ],
    "file-family": [
        "file-systems", "mount-targets", "export-sets", "snapshots",
    ],
    "volume-family": [
        "volumes", "volume-attachments", "volume-backups",
        "boot-volumes", "boot-volume-backups", "block-volumes",
    ],
    "resource-manager-family": [
        "orm-stacks", "orm-jobs", "orm-work-requests",
    ],
    "tag-family": [
        "tag-namespaces", "tag-definitions", "tags",
    ],
}

def resource_matches(policy_resource, required_resource):
    pr = policy_resource.lower().strip()
    rr = required_resource.lower().strip()
    if pr == rr:
        return True
    if pr == "all-resources":
        return True
    if pr in FAMILY_COVERS:
        covers = FAMILY_COVERS[pr]
        if "*" in covers:
            return True
        if rr in covers:
            return True
        for covered in covers:
            if covered in FAMILY_COVERS:
                sub = FAMILY_COVERS[covered]
                if "*" in sub or rr in sub:
                    return True
    return False

# Extract effective permissions for the principal
def matches_principal(stmt):
    s = stmt.lower()
    pn = pname.lower()
    if ptype == "any-user":
        return "any-user" in s or "any-group" in s
    elif ptype == "group":
        if re.search(r'(?<!\w)(?<!dynamic-)group\s+' + re.escape(pn), s):
            return True
        if "any-group" in s:
            return True
        return False
    elif ptype == "dynamic-group":
        if re.search(r'dynamic-group\s+' + re.escape(pn), s):
            return True
        return False
    elif ptype == "user":
        if re.search(r'(?<!\w)user\s+' + re.escape(pn), s):
            return True
        if "any-user" in s:
            return True
        return False
    return False

effective_perms = []
matched_statements = []

for p in policies.get('data', []):
    pname_pol = p.get('name', 'Unknown')
    for stmt in p.get('statements', []):
        if not matches_principal(stmt):
            continue
        matched_statements.append((pname_pol, stmt))
        s = stmt.lower()
        where_idx = s.find(' where ')
        s_clean = s[:where_idx] if where_idx > -1 else s
        m = re.search(r'\bto\s+(inspect|read|use|manage)\s+(\S+)', s_clean)
        if m:
            verb = m.group(1)
            resource = m.group(2)
            comp_scope = "tenancy"
            cm = re.search(r'in\s+compartment\s+(\S+)', s_clean)
            if cm:
                comp_scope = "compartment:" + cm.group(1)
            effective_perms.append((verb, resource, pname_pol, comp_scope))

# Menu requirements
MENU_REQS = {
    "o": {
        "label": "Environment Overview",
        "section": "Overview",
        "view": [
            ("cluster-family", "inspect", "View OKE clusters"),
            ("cluster-node-pools", "inspect", "View OKE cluster nodepools"),
            ("compute-management-family", "inspect", "View instances and details"),
            ("subnets", "inspect", "View subnets of VCN"),
            ("vnics", "inspect", "View VNICs and NSG membership"),
            ("virtual-network-family", "inspect", "View VCN and details"),
            ("network-security-groups", "inspect", "View NSG configurations"),
            ("dns", "inspect", "View DNS on VCN"),
            ("object-storage-private-endpoints", "inspect", "View endpoint on subnets"),
            ("compute-capacity-topology", "inspect", "View capacity topology"),
            ("compute-hpc-islands", "inspect", "View HPC islands"),
            ("compute-network-blocks", "inspect", "View network blocks"),
            ("compute-bare-metal-hosts", "inspect", "View bare metal hosts"),
            ("compute-gpu-memory-fabrics", "inspect", "View GPU memory fabrics"),
            ("announcements", "inspect", "View announcements in tenancy"),
        ],
        "modify": [],
    },
    "1": {
        "label": "OKE Cluster Environment",
        "section": "Kubernetes",
        "view": [
            ("cluster-family", "inspect", "View OKE clusters"),
            ("cluster-node-pools", "inspect", "View OKE cluster nodepools"),
            ("compute-management-family", "inspect", "View instances and details"),
            ("subnets", "inspect", "View subnets of VCN"),
            ("vnics", "inspect", "View VNICs and NSG membership"),
            ("virtual-network-family", "inspect", "View VCN and details"),
            ("network-security-groups", "inspect", "View NSG configurations"),
            ("dns", "inspect", "View DNS on VCN"),
            ("object-storage-private-endpoints", "inspect", "View endpoint on subnets"),
        ],
        "modify": [
            ("cluster-family", "manage", "Create/update/delete OKE clusters"),
            ("cluster-node-pools", "manage", "Create/update/delete nodepools"),
            ("compute-management-family", "use", "Launch instances via nodepool"),
            ("virtual-network-family", "use", "Attach instances to subnets/NSGs"),
        ],
    },
    "2": {
        "label": "NVIDIA GPU Stack Health",
        "section": "Kubernetes",
        "view": [
            ("cluster-family", "inspect", "View OKE clusters (kubectl context)"),
        ],
        "modify": [],
        "note": "Primarily kubectl operations - requires kubeconfig access",
    },
    "3": {
        "label": "Kubernetes Management",
        "section": "Kubernetes",
        "view": [
            ("cluster-family", "inspect", "View OKE clusters (kubectl context)"),
            ("compute-management-family", "inspect", "View instance details for node lookup"),
        ],
        "modify": [
            ("cluster-node-pools", "use", "Manage node drain/cordon operations"),
        ],
        "note": "Primarily kubectl operations - requires kubeconfig access",
    },
    "4": {
        "label": "Network Resources",
        "section": "Networking",
        "view": [
            ("virtual-network-family", "inspect", "View VCN and details"),
            ("subnets", "inspect", "View subnets"),
            ("network-security-groups", "inspect", "View NSG configurations"),
            ("vnics", "inspect", "View VNICs"),
            ("dns", "inspect", "View DNS labels and zones"),
            ("route-tables", "inspect", "View route tables"),
            ("security-lists", "inspect", "View security lists"),
        ],
        "modify": [
            ("network-security-groups", "manage", "Create/update/delete NSG rules"),
            ("virtual-network-family", "manage", "Manage network resources"),
        ],
    },
    "5": {
        "label": "GPU Memory Fabrics & Clusters",
        "section": "Compute & GPU",
        "view": [
            ("compute-management-family", "inspect", "View compute clusters"),
            ("compute-capacity-topology", "inspect", "View capacity topology"),
            ("compute-hpc-islands", "inspect", "View HPC islands"),
            ("compute-network-blocks", "inspect", "View network blocks"),
            ("compute-bare-metal-hosts", "inspect", "View bare metal hosts"),
            ("compute-gpu-memory-fabrics", "inspect", "View GPU memory fabrics"),
        ],
        "modify": [
            ("compute-management-family", "manage", "Create/delete compute clusters"),
        ],
    },
    "6": {
        "label": "Compute Instances",
        "section": "Compute & GPU",
        "view": [
            ("compute-management-family", "inspect", "View instances and details"),
            ("vnics", "inspect", "View VNICs and IP addresses"),
            ("volume-family", "inspect", "View attached volumes"),
            ("subnets", "inspect", "View subnet details"),
            ("compute-capacity-topology", "inspect", "View capacity topology"),
        ],
        "modify": [
            ("compute-management-family", "manage", "Reboot/stop/start/terminate instances"),
            ("vnics", "use", "Attach/detach VNICs"),
            ("volume-family", "manage", "Attach/detach volumes"),
        ],
    },
    "7": {
        "label": "Instance Configurations",
        "section": "Compute & GPU",
        "view": [
            ("compute-management-family", "inspect", "View instance configurations"),
            ("instance-configurations", "inspect", "View configuration details"),
            ("instance-images", "inspect", "View images for configurations"),
        ],
        "modify": [
            ("instance-configurations", "manage", "Create/delete instance configurations"),
            ("compute-management-family", "manage", "Create configurations from instances"),
            ("instance-images", "read", "Read images for configuration creation"),
        ],
    },
    "8": {
        "label": "Compute Clusters",
        "section": "Compute & GPU",
        "view": [
            ("compute-management-family", "inspect", "View compute clusters"),
            ("compute-capacity-topology", "inspect", "View capacity topology"),
        ],
        "modify": [
            ("compute-management-family", "manage", "Create/delete compute clusters"),
        ],
    },
    "9": {
        "label": "GPU Instance Tagging",
        "section": "Compute & GPU",
        "view": [
            ("tag-namespaces", "inspect", "View tag namespaces"),
            ("compute-management-family", "inspect", "View instances for tagging"),
        ],
        "modify": [
            ("tag-namespaces", "manage", "Create/retire tag namespaces"),
            ("tag-definitions", "manage", "Create/manage tag definitions"),
            ("compute-management-family", "use", "Apply tags to instances"),
        ],
    },
    "10": {
        "label": "Capacity Topology",
        "section": "Compute & GPU",
        "view": [
            ("compute-capacity-topology", "inspect", "View capacity topology"),
            ("compute-bare-metal-hosts", "inspect", "View bare metal host details"),
            ("compute-hpc-islands", "inspect", "View HPC island details"),
            ("compute-network-blocks", "inspect", "View network block details"),
            ("compute-gpu-memory-fabrics", "inspect", "View GPU memory fabrics"),
        ],
        "modify": [],
    },
    "11": {
        "label": "Custom Images",
        "section": "Compute & GPU",
        "view": [
            ("instance-images", "inspect", "View custom images"),
            ("compute-management-family", "inspect", "View instances for image creation"),
        ],
        "modify": [
            ("instance-images", "manage", "Create/import/export/delete images"),
            ("compute-management-family", "use", "Create image from instance"),
            ("object-family", "use", "Import/export images via Object Storage"),
        ],
    },
    "12": {
        "label": "File Storage (FSS)",
        "section": "Storage",
        "view": [
            ("file-family", "inspect", "View file systems and mount targets"),
            ("virtual-network-family", "inspect", "View subnets for mount targets"),
        ],
        "modify": [
            ("file-family", "manage", "Create/delete file systems, mount targets, exports"),
            ("virtual-network-family", "use", "Attach mount targets to subnets"),
        ],
    },
    "13": {
        "label": "Lustre File Systems",
        "section": "Storage",
        "view": [
            ("lustre-file-systems", "inspect", "View Lustre file systems"),
            ("virtual-network-family", "inspect", "View subnets for Lustre"),
        ],
        "modify": [
            ("lustre-file-systems", "manage", "Create/delete Lustre file systems"),
            ("virtual-network-family", "use", "Attach Lustre to subnets"),
            ("object-family", "use", "Link Object Storage to Lustre"),
        ],
    },
    "14": {
        "label": "Object Storage",
        "section": "Storage",
        "view": [
            ("object-family", "inspect", "View buckets and private endpoints"),
            ("buckets", "inspect", "View bucket details"),
            ("object-storage-private-endpoints", "inspect", "View private endpoints"),
        ],
        "modify": [
            ("object-family", "manage", "Create/delete buckets and endpoints"),
            ("virtual-network-family", "use", "Create private endpoints on subnets"),
        ],
    },
    "15": {
        "label": "Compartments",
        "section": "Identity",
        "view": [
            ("compartments", "inspect", "View compartments"),
        ],
        "modify": [
            ("compartments", "manage", "Create/delete sub-compartments"),
        ],
    },
    "16": {
        "label": "Identity Domains",
        "section": "Identity",
        "view": [
            ("domains", "inspect", "View identity domains"),
            ("identity-domains", "inspect", "View domain users/groups/providers"),
        ],
        "modify": [
            ("identity-domains", "manage", "Create users/groups in domain"),
        ],
    },
    "17": {
        "label": "Policies",
        "section": "Identity",
        "view": [
            ("policies", "inspect", "View policies"),
            ("compartments", "inspect", "View compartments for policy listing"),
        ],
        "modify": [
            ("policies", "manage", "Create/update/delete policies"),
        ],
    },
    "18": {
        "label": "Resource Manager Stacks",
        "section": "Infrastructure",
        "view": [
            ("orm-stacks", "inspect", "View stacks, jobs, and outputs"),
            ("resource-manager-family", "inspect", "View Resource Manager resources"),
        ],
        "modify": [
            ("orm-stacks", "manage", "Create/update/delete stacks and jobs"),
        ],
    },
    "19": {
        "label": "Work Requests",
        "section": "Infrastructure",
        "view": [
            ("work-requests", "inspect", "View work requests and logs"),
            ("compute-management-family", "inspect", "View compute work requests"),
        ],
        "modify": [],
    },
    "20": {
        "label": "Maintenance",
        "section": "Infrastructure",
        "view": [
            ("compute-management-family", "inspect", "View instances and maintenance events"),
            ("compute-capacity-topology", "inspect", "View capacity topology state"),
            ("announcements", "inspect", "View maintenance announcements"),
        ],
        "modify": [
            ("compute-management-family", "manage", "Reschedule maintenance events"),
        ],
    },
    "21": {
        "label": "Announcements",
        "section": "Infrastructure",
        "view": [
            ("announcements", "inspect", "View announcements"),
        ],
        "modify": [],
    },
}

def check_permission(required_resource, required_verb):
    best_verb = None
    best_policy = None
    for verb, resource, pol_name, scope in effective_perms:
        if resource_matches(resource, required_resource):
            if verb_satisfies(verb, required_verb):
                if best_verb is None or VERB_RANK.get(verb, 0) > VERB_RANK.get(best_verb, 0):
                    best_verb = verb
                    best_policy = pol_name
    if best_verb:
        return (True, best_verb, best_policy)
    return (False, None, None)

# Display results
ptype_display = ptype.replace("-", " ").title()
print(f"{BOLD}{WHITE}══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════{NC}")
print(f"{BOLD}{WHITE}  Policy Validation: {MAGENTA}{ptype_display} '{pname}'{NC}")
print(f"{BOLD}{WHITE}══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════{NC}")
print()

print(f"  {CYAN}Matched policy statements:{NC} {WHITE}{len(matched_statements)}{NC}")
if effective_perms:
    unique_perms = set()
    for v, r, pn, sc in effective_perms:
        unique_perms.add(f"{v} {r}")
    print(f"  {CYAN}Effective permissions:{NC}     {WHITE}{len(unique_perms)}{NC} unique resource grants")
else:
    print(f"  {YELLOW}⚠  No policy statements found for this principal{NC}")
print()

total_view_ok = 0
total_view_miss = 0
total_modify_ok = 0
total_modify_miss = 0

current_section = None
menu_order = ["o", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21"]

for menu_key in menu_order:
    req = MENU_REQS.get(menu_key, {})
    label = req.get("label", "Unknown")
    section = req.get("section", "Other")
    view_reqs = req.get("view", [])
    modify_reqs = req.get("modify", [])
    note = req.get("note", "")
    
    if section != current_section:
        current_section = section
        print(f"{BOLD}{BLUE}─── {section} ───{NC}")
        print()
    
    all_view_ok = True
    all_modify_ok = True
    view_results = []
    modify_results = []
    
    for resource, verb, desc in view_reqs:
        ok, found_verb, found_pol = check_permission(resource, verb)
        view_results.append((ok, resource, verb, desc, found_verb, found_pol))
        if ok:
            total_view_ok += 1
        else:
            all_view_ok = False
            total_view_miss += 1
    
    for resource, verb, desc in modify_reqs:
        ok, found_verb, found_pol = check_permission(resource, verb)
        modify_results.append((ok, resource, verb, desc, found_verb, found_pol))
        if ok:
            total_modify_ok += 1
        else:
            all_modify_ok = False
            total_modify_miss += 1
    
    view_status = f"{GREEN}✓ VIEW OK{NC}" if all_view_ok and view_results else f"{RED}✗ VIEW MISSING{NC}" if not all_view_ok else f"{GRAY}N/A{NC}"
    modify_status = f"{GREEN}✓ MODIFY OK{NC}" if all_modify_ok and modify_results else f"{RED}✗ MODIFY MISSING{NC}" if not all_modify_ok else f"{GRAY}read-only{NC}"
    
    if all_view_ok and (all_modify_ok or not modify_results):
        overall = f"{BG_GREEN} PASS {NC}"
    elif all_view_ok and not all_modify_ok:
        overall = f"{YELLOW} PARTIAL {NC}"
    else:
        overall = f"{BG_RED} FAIL {NC}"
    
    print(f"  {overall} {YELLOW}{menu_key:>2}){NC} {WHITE}{label}{NC}  [ {view_status} | {modify_status} ]")
    
    if note:
        print(f"       {DIM}{note}{NC}")
    
    for ok, resource, verb, desc, found_verb, found_pol in view_results:
        if ok:
            print(f"       {GREEN}✓{NC} {GRAY}view:{NC}   {DIM}inspect/read/use/manage{NC} {CYAN}{resource}{NC}  {GRAY}─ {desc}  (have: {GREEN}{found_verb}{NC} via {DIM}{found_pol}{NC}){GRAY}{NC}")
        else:
            print(f"       {RED}✗{NC} {WHITE}view:{NC}   {YELLOW}inspect, read, use{NC} or {YELLOW}manage {CYAN}{resource}{NC}  {GRAY}─ {desc}{NC}")
    
    for ok, resource, verb, desc, found_verb, found_pol in modify_results:
        if ok:
            print(f"       {GREEN}✓{NC} {GRAY}modify:{NC} {DIM}{verb}{NC} {CYAN}{resource}{NC}  {GRAY}─ {desc}  (have: {GREEN}{found_verb}{NC} via {DIM}{found_pol}{NC}){GRAY}{NC}")
        else:
            print(f"       {RED}✗{NC} {WHITE}modify:{NC} {YELLOW}{verb} {CYAN}{resource}{NC}  {GRAY}─ {desc}{NC}")
    
    print()

# Summary
print(f"{BOLD}{WHITE}══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════{NC}")
print(f"{BOLD}{WHITE}  Summary for {MAGENTA}{ptype_display} '{pname}'{NC}")
print(f"{BOLD}{WHITE}══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════{NC}")
print()

total_view = total_view_ok + total_view_miss
total_modify = total_modify_ok + total_modify_miss

view_pct = (total_view_ok * 100 // total_view) if total_view > 0 else 0
modify_pct = (total_modify_ok * 100 // total_modify) if total_modify > 0 else 0

view_bar_len = 40
view_filled = (total_view_ok * view_bar_len // total_view) if total_view > 0 else 0
view_bar = f"{GREEN}{'█' * view_filled}{NC}{GRAY}{'░' * (view_bar_len - view_filled)}{NC}"
print(f"  {CYAN}View permissions:{NC}   [{view_bar}] {WHITE}{total_view_ok}/{total_view}{NC} ({view_pct}%)")

modify_bar_len = 40
modify_filled = (total_modify_ok * modify_bar_len // total_modify) if total_modify > 0 else 0
modify_bar = f"{GREEN}{'█' * modify_filled}{NC}{GRAY}{'░' * (modify_bar_len - modify_filled)}{NC}"
print(f"  {CYAN}Modify permissions:{NC} [{modify_bar}] {WHITE}{total_modify_ok}/{total_modify}{NC} ({modify_pct}%)")

print()

if total_view_miss > 0 or total_modify_miss > 0:
    print(f"  {YELLOW}Missing policies can be resolved by:{NC}")
    print(f"    {WHITE}•{NC} {DIM}Broadest:{NC} {GREEN}Allow{NC} {MAGENTA}{ptype} {pname}{NC} to {YELLOW}manage {CYAN}all-resources{NC} in tenancy")
    
    missing_view_res = set()
    missing_modify_res = set()
    for menu_key in menu_order:
        req = MENU_REQS.get(menu_key, {})
        for resource, verb, desc in req.get("view", []):
            ok, _, _ = check_permission(resource, verb)
            if not ok:
                missing_view_res.add(resource)
        for resource, verb, desc in req.get("modify", []):
            ok, _, _ = check_permission(resource, verb)
            if not ok:
                missing_modify_res.add(resource)
    
    if missing_view_res:
        view_families = set()
        for r in missing_view_res:
            found_fam = False
            for fam, children in FAMILY_COVERS.items():
                if fam == "all-resources":
                    continue
                if r in children:
                    view_families.add(fam)
                    found_fam = True
                    break
            if not found_fam:
                view_families.add(r)
        for vf in sorted(view_families):
            print(f"    {WHITE}•{NC} {DIM}View:{NC}   {GREEN}Allow{NC} {MAGENTA}{ptype} {pname}{NC} to {YELLOW}inspect {CYAN}{vf}{NC} in compartment <name>")
    
    if missing_modify_res:
        for mr in sorted(missing_modify_res):
            print(f"    {WHITE}•{NC} {DIM}Modify:{NC} {GREEN}Allow{NC} {MAGENTA}{ptype} {pname}{NC} to {YELLOW}manage {CYAN}{mr}{NC} in compartment <name>")
    
    print()

if matched_statements:
    print(f"  {BOLD}{WHITE}Matched Policy Statements ({len(matched_statements)}):{NC}")
    by_policy = {}
    for pol_name, stmt in matched_statements:
        by_policy.setdefault(pol_name, []).append(stmt)
    for pol_name, stmts in sorted(by_policy.items()):
        print(f"    {GREEN}📜 {pol_name}{NC} {DIM}[{len(stmts)} statement{'s' if len(stmts) > 1 else ''}]{NC}")
        for stmt in stmts[:5]:
            tokens = stmt.split()
            result = []
            i = 0
            while i < len(tokens):
                t = tokens[i]
                tl = t.lower()
                if tl == 'allow':
                    result.append(f'{GREEN}{t}{NC}')
                elif tl == 'deny':
                    result.append(f'{RED}{t}{NC}')
                elif tl in ('any-user', 'any-group'):
                    result.append(f'{ORANGE}{t}{NC}')
                elif tl in ('manage', 'use', 'read', 'inspect'):
                    result.append(f'{YELLOW}{t}{NC}')
                    if i + 1 < len(tokens): i += 1; result.append(f'{CYAN}{tokens[i]}{NC}')
                elif tl == 'dynamic-group' and i + 1 < len(tokens):
                    result.append(f'{MAGENTA}{t}{NC}'); i += 1; result.append(f'{MAGENTA}{tokens[i]}{NC}')
                elif tl == 'group' and i + 1 < len(tokens):
                    prev = tokens[i-1].lower() if i > 0 else ''
                    if prev not in ('dynamic-group', 'any-group'):
                        result.append(f'{MAGENTA}{t}{NC}'); i += 1; result.append(f'{MAGENTA}{tokens[i]}{NC}')
                    else:
                        result.append(t)
                else:
                    result.append(t)
                i += 1
            print(f"      └─ {' '.join(result)}")
        if len(stmts) > 5:
            print(f"      {DIM}... and {len(stmts) - 5} more{NC}")
    print()

POLICY_CHECK_EOF
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Main Policy Management Menu
#--------------------------------------------------------------------------------
manage_policies() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local tenancy_id="${TENANCY_OCID:-}"
    
    if [[ -z "$tenancy_id" ]]; then
        tenancy_id=$(get_tenancy_id_from_compartment "$compartment_id")
    fi
    
    local tenancy_name
    tenancy_name=$(oci iam tenancy get --tenancy-id "$tenancy_id" --query 'data.name' --raw-output 2>/dev/null || echo "Unknown")
    
    # Initial fetch
    echo ""
    echo -e "${GRAY}Loading policies...${NC}"
    _policy_fetch_all "$tenancy_id"
    
    if [[ ! -f "$POLICIES_ALL_CACHE" ]] || [[ ! -f "$POLICIES_COMPS_CACHE" ]]; then
        echo -e "${RED}Failed to load policies${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    while true; do
        echo ""
        echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${GREEN}                                                         POLICY MANAGEMENT                                                                             ${NC}"
        echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        _display_cache_info \
            "${POLICIES_ALL_CACHE}|Policies" \
            "${POLICIES_COMPS_CACHE}|Compartments"
        echo ""
        
        # Show cache status
        local pol_count comp_count cache_age_str=""
        pol_count=$(jq '(.data // []) | length' "$POLICIES_ALL_CACHE" 2>/dev/null || echo 0)
        comp_count=$(jq '(.data // []) | length' "$POLICIES_COMPS_CACHE" 2>/dev/null || echo 0)
        local file_age=$(($(date +%s) - $(stat -c %Y "$POLICIES_ALL_CACHE" 2>/dev/null || echo 0)))
        if [[ $file_age -lt 60 ]]; then
            cache_age_str="${file_age}s ago"
        elif [[ $file_age -lt 3600 ]]; then
            cache_age_str="$((file_age / 60))m ago"
        else
            cache_age_str="$((file_age / 3600))h $((file_age % 3600 / 60))m ago"
        fi
        
        echo -e "  ${CYAN}Tenancy:${NC}  ${WHITE}${tenancy_name}${NC}"
        echo -e "  ${CYAN}Policies:${NC} ${WHITE}${pol_count}${NC} across ${WHITE}${comp_count}${NC} compartments  ${GRAY}(cached ${cache_age_str})${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}═══ Policy Audit Options ═══${NC}"
        echo ""
        echo -e "  ${YELLOW}1${NC})  ${WHITE}View All Policies${NC}             - Full compartment/policy tree"
        echo -e "  ${YELLOW}2${NC})  ${WHITE}Search by Keyword${NC}             - Search statement text"
        echo -e "  ${YELLOW}3${NC})  ${WHITE}Filter by OCI Service${NC}         - Filter by resource type (e.g. compute, cluster-family)"
        echo -e "  ${YELLOW}4${NC})  ${WHITE}Filter by Compartment${NC}         - Show policies in a specific compartment"
        echo -e "  ${YELLOW}5${NC})  ${WHITE}Filter by Policy Name${NC}         - Match by policy name"
        echo -e "  ${YELLOW}6${NC})  ${WHITE}Export JSON${NC}                   - Export all policies to JSON file"
        echo ""
        echo -e "${BOLD}${BLUE}─── Validation ───${NC}"
        echo -e "  ${YELLOW}7${NC})  ${WHITE}Policy Validation Check${NC}       - Verify policies for each --manage menu function"
        echo ""
        echo -e "  ${CYAN}r${NC})  ${WHITE}Refresh Cache${NC}                - Force re-fetch from OCI API"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Policies] Enter selection [1-7, ${MAGENTA}r${CYAN}/back]: ${NC}"
        read -r pol_choice
        
        case "$pol_choice" in
            ""|back|b|q)
                return
                ;;
            1)
                # View all - no filter
                echo ""
                _policy_display_tree "$POLICIES_ALL_CACHE" "$POLICIES_COMPS_CACHE" "$tenancy_id" "" "$tenancy_name"
                echo ""
                echo -e "Press Enter to continue..."
                read -r
                ;;
            2)
                # Keyword search
                echo ""
                echo -n -e "  ${WHITE}Enter keyword to search: ${NC}"
                read -r search_kw
                if [[ -z "$search_kw" ]]; then
                    continue
                fi
                echo ""
                _policy_display_tree "$POLICIES_ALL_CACHE" "$POLICIES_COMPS_CACHE" "$tenancy_id" "$search_kw" "$tenancy_name"
                echo ""
                echo -e "Press Enter to continue..."
                read -r
                ;;
            3)
                # Filter by OCI service/resource type
                echo ""
                echo -e "${BOLD}${WHITE}OCI Services / Resource Types:${NC}"
                echo ""
                echo -e "${YELLOW}Analytics & AI${NC}"
                echo -e "  ai                  generative-ai         generative-ai-family  data-science"
                echo -e "  data-catalog        data-flow             data-integration      streaming"
                echo ""
                echo -e "${YELLOW}Compute${NC}"
                echo -e "  compute             instance-family       compute-management    autoscaling"
                echo ""
                echo -e "${YELLOW}Containers & Kubernetes${NC}"
                echo -e "  cluster-family      container-instances   container-repos"
                echo ""
                echo -e "${YELLOW}Databases${NC}"
                echo -e "  database-family     autonomous-database   mysql                 nosql"
                echo -e "  data-safe           goldengate            psql"
                echo ""
                echo -e "${YELLOW}Developer Services${NC}"
                echo -e "  devops              api-gateway           functions-family      artifacts"
                echo -e "  resource-manager    repos"
                echo ""
                echo -e "${YELLOW}Identity & Security${NC}"
                echo -e "  iam                 identity-domains      vault-family          bastion"
                echo -e "  cloud-guard         waf                   security-zone"
                echo ""
                echo -e "${YELLOW}Networking${NC}"
                echo -e "  virtual-network     vcn                   drg                   load-balancer"
                echo -e "  network-firewall    dns"
                echo ""
                echo -e "${YELLOW}Storage${NC}"
                echo -e "  object-family       volume-family         file-family           buckets"
                echo -e "  lustre-file-systems"
                echo ""
                echo -e "${YELLOW}Observability${NC}"
                echo -e "  logging             monitoring            events                ons"
                echo -e "  log-analytics       apm"
                echo ""
                echo -e "${YELLOW}Resource Families${NC}"
                echo -e "  all-resources       cluster-family        instance-family       volume-family"
                echo -e "  object-family       virtual-network-family  database-family     generative-ai-family"
                echo ""
                echo -n -e "  ${WHITE}Type service/resource name (or Enter to go back): ${NC}"
                read -r svc_input
                if [[ -z "$svc_input" ]]; then
                    continue
                fi
                echo ""
                _policy_display_tree "$POLICIES_ALL_CACHE" "$POLICIES_COMPS_CACHE" "$tenancy_id" "__SERVICE__:${svc_input}" "$tenancy_name"
                echo ""
                echo -e "Press Enter to continue..."
                read -r
                ;;
            4)
                # Filter by compartment
                echo ""
                echo -e "${BOLD}${WHITE}Compartments with policies:${NC}"
                echo ""
                local comp_list_output
                comp_list_output=$(_policy_list_compartments_with_policies "$POLICIES_ALL_CACHE" "$POLICIES_COMPS_CACHE" "$tenancy_id")
                
                if [[ -z "$comp_list_output" ]]; then
                    echo -e "  ${YELLOW}No compartments with policies found${NC}"
                    sleep 1
                    continue
                fi
                
                echo "$comp_list_output" | while IFS='|' read -r num name count path; do
                    printf "  ${GREEN}%3s)${NC} %-40s ${GRAY}[%s policies]${NC}\n" "$num" "$path" "$count"
                done
                
                echo ""
                echo -n -e "  ${WHITE}Select number or type compartment name (or Enter to go back): ${NC}"
                read -r comp_select
                
                if [[ -z "$comp_select" ]]; then
                    continue
                elif [[ "$comp_select" =~ ^[0-9]+$ ]]; then
                    local selected_comp
                    selected_comp=$(echo "$comp_list_output" | sed -n "${comp_select}p" | cut -d'|' -f2)
                    if [[ -n "$selected_comp" ]]; then
                        echo ""
                        _policy_display_tree "$POLICIES_ALL_CACHE" "$POLICIES_COMPS_CACHE" "$tenancy_id" "__COMPARTMENT__:${selected_comp}" "$tenancy_name"
                    else
                        echo -e "${RED}Invalid selection${NC}"
                        sleep 1
                        continue
                    fi
                else
                    echo ""
                    _policy_display_tree "$POLICIES_ALL_CACHE" "$POLICIES_COMPS_CACHE" "$tenancy_id" "__COMPARTMENT__:${comp_select}" "$tenancy_name"
                fi
                echo ""
                echo -e "Press Enter to continue..."
                read -r
                ;;
            5)
                # Filter by policy name
                echo ""
                echo -e "${BOLD}${WHITE}Policy Names:${NC}"
                echo ""
                local pol_list_output
                pol_list_output=$(_policy_list_names "$POLICIES_ALL_CACHE" "$POLICIES_COMPS_CACHE" "$tenancy_id")
                
                if [[ -z "$pol_list_output" ]]; then
                    echo -e "  ${YELLOW}No policies found${NC}"
                    sleep 1
                    continue
                fi
                
                echo "$pol_list_output" | while IFS='|' read -r num name count path; do
                    printf "  ${GREEN}%3s)${NC} %-35s ${GRAY}[%s stmts]${NC} ${BLUE}%s${NC}\n" "$num" "$name" "$count" "$path"
                done
                
                echo ""
                echo -n -e "  ${WHITE}Select number or type policy name (or Enter to go back): ${NC}"
                read -r pol_select
                
                if [[ -z "$pol_select" ]]; then
                    continue
                elif [[ "$pol_select" =~ ^[0-9]+$ ]]; then
                    local selected_pol
                    selected_pol=$(echo "$pol_list_output" | sed -n "${pol_select}p" | cut -d'|' -f2)
                    if [[ -n "$selected_pol" ]]; then
                        echo ""
                        _policy_display_tree "$POLICIES_ALL_CACHE" "$POLICIES_COMPS_CACHE" "$tenancy_id" "__POLICY__:${selected_pol}" "$tenancy_name"
                    else
                        echo -e "${RED}Invalid selection${NC}"
                        sleep 1
                        continue
                    fi
                else
                    echo ""
                    _policy_display_tree "$POLICIES_ALL_CACHE" "$POLICIES_COMPS_CACHE" "$tenancy_id" "__POLICY__:${pol_select}" "$tenancy_name"
                fi
                echo ""
                echo -e "Press Enter to continue..."
                read -r
                ;;
            6)
                # Export to JSON
                local export_file="${TEMP_DIR}/policies_export_$(date +%Y%m%d_%H%M%S).json"
                jq '.' "$POLICIES_ALL_CACHE" > "$export_file" 2>/dev/null
                local export_count
                export_count=$(jq '(.data // []) | length' "$export_file" 2>/dev/null || echo 0)
                echo ""
                echo -e "  ${GREEN}✓${NC} Exported ${WHITE}${export_count}${NC} policies to: ${CYAN}${export_file}${NC}"
                
                # Log the export action
                local log_file="${LOG_DIR}/policy_actions.log"
                mkdir -p "$LOG_DIR"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXPORT: jq '.' \"$POLICIES_ALL_CACHE\" > \"$export_file\"" >> "$log_file"
                echo -e "  ${GRAY}Logged to: ${log_file}${NC}"
                echo ""
                echo -e "Press Enter to continue..."
                read -r
                ;;
            7)
                _policy_validation_check "$tenancy_id"
                ;;
            r|R|refresh)
                echo ""
                _policy_fetch_all "$tenancy_id" "true"
                echo ""
                echo -e "Press Enter to continue..."
                read -r
                ;;
            *)
                echo -e "${RED}Invalid selection${NC}"
                sleep 1
                ;;
        esac
    done
}
_format_cache_duration() {
    local seconds=$1
    if [[ $seconds -lt 60 ]]; then
        echo "${seconds}s"
    elif [[ $seconds -lt 3600 ]]; then
        echo "$((seconds / 60))m $((seconds % 60))s"
    else
        echo "$((seconds / 3600))h $((seconds % 3600 / 60))m"
    fi
}

#--------------------------------------------------------------------------------
# Helper: Get cache status line for a single cache file
#--------------------------------------------------------------------------------
_get_cache_status_line() {
    local cache_file="$1"
    local cache_name="$2"
    local ttl="${3:-3600}"  # Default 1 hour
    
    if [[ ! -f "$cache_file" ]]; then
        printf "  ${GRAY}%-30s${NC} ${RED}%-12s${NC} %8s %10s %12s %10s\n" \
            "$cache_name" "NOT CACHED" "-" "-" "-" "-"
        return
    fi
    
    local file_mtime
    file_mtime=$(stat -c %Y "$cache_file" 2>/dev/null || echo 0)
    local current_time=$(date +%s)
    local age=$((current_time - file_mtime))
    local expires_in=$((ttl - age))
    
    # Count entries (lines for txt, items for json)
    local entry_count=0
    if [[ "$cache_file" == *.json ]]; then
        entry_count=$(jq 'if type == "array" then length else 1 end' "$cache_file" 2>/dev/null || echo 0)
    else
        entry_count=$(wc -l < "$cache_file" 2>/dev/null || echo 0)
    fi
    
    # File size
    local file_size
    file_size=$(du -h "$cache_file" 2>/dev/null | cut -f1)
    
    # Determine status
    local status status_color
    if [[ $expires_in -le 0 ]]; then
        status="EXPIRED"
        status_color="$RED"
    elif [[ $expires_in -lt 300 ]]; then  # < 5 minutes
        status="EXPIRING"
        status_color="$YELLOW"
    else
        status="VALID"
        status_color="$GREEN"
    fi
    
    # Format times
    local age_fmt expires_fmt
    age_fmt=$(_format_cache_duration $age)
    if [[ $expires_in -gt 0 ]]; then
        expires_fmt=$(_format_cache_duration $expires_in)
    else
        expires_fmt="NOW"
    fi
    
    printf "  %-30s ${status_color}%-12s${NC} %8s %10s %12s %10s\n" \
        "$cache_name" "$status" "$entry_count" "$file_size" "$age_fmt" "$expires_fmt"
}

#--------------------------------------------------------------------------------
# Get cache status line for directory-based caches
# Args: $1 = cache_dir, $2 = cache_name, $3 = max_age_seconds
#--------------------------------------------------------------------------------
_get_dir_cache_status_line() {
    local cache_dir="$1"
    local cache_name="$2"
    local max_age="${3:-3600}"
    
    if [[ ! -d "$cache_dir" ]]; then
        printf "  %-30s ${GRAY}%-12s${NC} %8s %10s %12s %10s\n" \
            "$cache_name" "EMPTY" "0" "0B" "-" "-"
        return
    fi
    
    # Count files
    local entry_count
    entry_count=$(find "$cache_dir" -maxdepth 1 -type f -name "*.json" 2>/dev/null | wc -l)
    
    if [[ "$entry_count" -eq 0 ]]; then
        printf "  %-30s ${GRAY}%-12s${NC} %8s %10s %12s %10s\n" \
            "$cache_name" "EMPTY" "0" "0B" "-" "-"
        return
    fi
    
    # Get oldest file modification time for age calculation
    local oldest_mtime newest_mtime now age expires_in
    now=$(date +%s)
    
    # Find oldest and newest file
    oldest_mtime=$(find "$cache_dir" -maxdepth 1 -type f -name "*.json" -printf '%T@\n' 2>/dev/null | sort -n | head -1 | cut -d. -f1)
    newest_mtime=$(find "$cache_dir" -maxdepth 1 -type f -name "*.json" -printf '%T@\n' 2>/dev/null | sort -n | tail -1 | cut -d. -f1)
    
    [[ -z "$oldest_mtime" ]] && oldest_mtime=$now
    [[ -z "$newest_mtime" ]] && newest_mtime=$now
    
    age=$((now - oldest_mtime))
    expires_in=$((max_age - (now - newest_mtime)))
    
    # Total directory size
    local dir_size
    dir_size=$(du -sh "$cache_dir" 2>/dev/null | cut -f1)
    
    # Determine status based on oldest file
    local status status_color
    if [[ $expires_in -le 0 ]]; then
        status="EXPIRED"
        status_color="$RED"
    elif [[ $expires_in -lt 300 ]]; then
        status="EXPIRING"
        status_color="$YELLOW"
    else
        status="VALID"
        status_color="$GREEN"
    fi
    
    # Format times
    local age_fmt expires_fmt
    age_fmt=$(_format_cache_duration $age)
    if [[ $expires_in -gt 0 ]]; then
        expires_fmt=$(_format_cache_duration $expires_in)
    else
        expires_fmt="NOW"
    fi
    
    printf "  %-30s ${status_color}%-12s${NC} %8s %10s %12s %10s\n" \
        "$cache_name" "$status" "$entry_count" "$dir_size" "$age_fmt" "$expires_fmt"
}

#--------------------------------------------------------------------------------
# Display Cache Statistics - Show all cache files with status, age, and TTL
#--------------------------------------------------------------------------------
display_cache_stats() {
    echo ""
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${CYAN}                                                              CACHE STATISTICS                                                                          ${NC}"
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${WHITE}Cache Directory:${NC} ${YELLOW}${CACHE_DIR}${NC}"
    echo ""
    
    # Header
    printf "${BOLD}  %-30s %-12s %8s %10s %12s %10s${NC}\n" \
        "Cache Name" "Status" "Entries" "Size" "Age" "Expires In"
    print_separator 100
    
    echo ""
    echo -e "${BOLD}${WHITE}=== GPU Resources ===${NC}"
    _get_cache_status_line "$FABRIC_CACHE" "GPU Memory Fabrics" 3600
    _get_cache_status_line "$CLUSTER_CACHE" "GPU Memory Clusters" 3600
    _get_cache_status_line "$COMPUTE_CLUSTER_CACHE" "Compute Clusters" 3600
    
    echo ""
    echo -e "${BOLD}${WHITE}=== Compute Resources ===${NC}"
    _get_cache_status_line "$INSTANCE_LIST_CACHE" "Instance List" 300
    _get_cache_status_line "$INSTANCE_CONFIG_CACHE" "Instance Configurations" 3600
    _get_cache_status_line "$BOOT_VOLUME_CACHE" "Boot Volumes" 3600
    _get_cache_status_line "$IMAGE_CACHE" "Images" 3600
    _get_cache_status_line "$CAPACITY_TOPOLOGY_CACHE" "Capacity Topology Hosts" 3600
    
    echo ""
    echo -e "${BOLD}${WHITE}=== OKE Resources ===${NC}"
    _get_cache_status_line "$OKE_ENV_CACHE" "OKE Environment" 3600
    _get_cache_status_line "$NODE_STATE_CACHE" "Node States" 300
    
    echo ""
    echo -e "${BOLD}${WHITE}=== Network Resources ===${NC}"
    _get_cache_status_line "$NETWORK_RESOURCES_CACHE" "Network Resources" 3600
    _get_cache_status_line "$IGW_CACHE" "Internet Gateways" 3600
    _get_cache_status_line "$SGW_CACHE" "Service Gateways" 3600
    _get_cache_status_line "$NAT_CACHE" "NAT Gateways" 3600
    _get_cache_status_line "$DRG_CACHE" "DRG Attachments" 3600
    _get_cache_status_line "$LPG_CACHE" "Local Peering Gateways" 3600
    _get_cache_status_line "$RPC_CACHE" "Remote Peering Connections" 3600
    _get_cache_status_line "$RT_CACHE" "Route Tables" 3600
    _get_cache_status_line "$NSG_RULES_CACHE" "NSG Rules" 3600
    _get_cache_status_line "$SL_CACHE" "Security Lists" 3600
    _get_dir_cache_status_line "$NSG_RULES_DETAIL_DIR" "NSG Rules Detail" 3600
    _get_dir_cache_status_line "$XR_CACHE_DIR" "Cross-Region DRG Map" 180
    _get_cache_status_line "$OS_PE_CACHE" "OS Private Endpoints" 3600
    
    echo ""
    echo -e "${BOLD}${WHITE}=== Storage ===${NC}"
    _get_cache_status_line "$FSS_FS_CACHE" "FSS File Systems" 600
    _get_cache_status_line "$FSS_MT_CACHE" "FSS Mount Targets" 600
    _get_cache_status_line "$FSS_EXPORT_CACHE" "FSS Exports" 600
    
    echo ""
    echo -e "${BOLD}${WHITE}=== Identity ===${NC}"
    _get_cache_status_line "$POLICIES_ALL_CACHE" "Policies (All)" 3600
    _get_cache_status_line "$POLICIES_COMPS_CACHE" "Policy Compartments" 3600
    
    echo ""
    echo -e "${BOLD}${WHITE}=== Other ===${NC}"
    _get_cache_status_line "$ANNOUNCEMENTS_LIST_CACHE" "Announcements" 3600
    _get_cache_status_line "$MAINT_EVENTS_CACHE" "Maintenance Events" "$MAINT_EVENTS_CACHE_TTL"
    
    echo ""
    print_separator 100
    echo ""
    
    # Show total cache size
    local total_size="0"
    if [[ -d "$CACHE_DIR" ]]; then
        total_size=$(du -sh "$CACHE_DIR" 2>/dev/null | cut -f1)
    fi
    echo -e "${WHITE}Total Cache Size:${NC} ${CYAN}${total_size}${NC}"
    echo ""
    
    # Legend
    echo -e "${BOLD}${WHITE}Status Legend:${NC}"
    echo -e "  ${GREEN}VALID${NC}     - Cache is fresh and within TTL"
    echo -e "  ${YELLOW}EXPIRING${NC}  - Cache will expire within 5 minutes"
    echo -e "  ${RED}EXPIRED${NC}   - Cache has exceeded TTL and will be refreshed on next use"
    echo -e "  ${RED}NOT CACHED${NC} - No cache file exists"
    echo ""
    
    echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
    echo -e "  ${YELLOW}1${NC} - Clear GPU caches (fabrics, clusters)"
    echo -e "  ${YELLOW}2${NC} - Clear Compute caches (instances, boot volumes, images)"
    echo -e "  ${YELLOW}3${NC} - Clear Network caches"
    echo -e "  ${YELLOW}4${NC} - Clear OKE caches"
    echo -e "  ${YELLOW}5${NC} - Clear Storage caches (FSS)"
    echo -e "  ${RED}a${NC} - Clear ALL caches"
    echo -e "  ${CYAN}Enter${NC} - Return to menu"
    echo ""
    echo -n -e "${CYAN}Action [1-5/a/Enter]: ${NC}"
    
    local action
    read -r action
    
    case "$action" in
        1)
            echo -e "${YELLOW}Clearing GPU caches...${NC}"
            rm -f "$FABRIC_CACHE" "$CLUSTER_CACHE" "$INSTANCE_CLUSTER_MAP_CACHE" "$COMPUTE_CLUSTER_CACHE"
            echo -e "${GREEN}✓ GPU caches cleared${NC}"
            sleep 1
            display_cache_stats
            ;;
        2)
            echo -e "${YELLOW}Clearing Compute caches...${NC}"
            rm -f "$INSTANCE_LIST_CACHE" "$INSTANCE_CONFIG_CACHE" "$BOOT_VOLUME_CACHE" "$IMAGE_CACHE" "$CAPACITY_TOPOLOGY_CACHE"
            echo -e "${GREEN}✓ Compute caches cleared${NC}"
            sleep 1
            display_cache_stats
            ;;
        3)
            echo -e "${YELLOW}Clearing Network caches...${NC}"
            rm -f "$NETWORK_RESOURCES_CACHE" "$IGW_CACHE" "$SGW_CACHE" "$NAT_CACHE" "$DRG_CACHE" \
                  "$LPG_CACHE" "$RPC_CACHE" "$RT_CACHE" "$NSG_RULES_CACHE" "$SL_CACHE" "$OS_PE_CACHE"
            rm -rf "$NSG_RULES_DETAIL_DIR" 2>/dev/null
            echo -e "${GREEN}✓ Network caches cleared${NC}"
            sleep 1
            display_cache_stats
            ;;
        4)
            echo -e "${YELLOW}Clearing OKE caches...${NC}"
            rm -f "$OKE_ENV_CACHE" "$NODE_STATE_CACHE"
            echo -e "${GREEN}✓ OKE caches cleared${NC}"
            sleep 1
            display_cache_stats
            ;;
        5)
            echo -e "${YELLOW}Clearing Storage caches...${NC}"
            rm -f "$FSS_FS_CACHE" "$FSS_MT_CACHE" "$FSS_EXPORT_CACHE"
            echo -e "${GREEN}✓ Storage caches cleared${NC}"
            sleep 1
            display_cache_stats
            ;;
        a|A|all|ALL)
            echo -e "${YELLOW}Clearing ALL caches...${NC}"
            rm -f "$CACHE_DIR"/*.txt "$CACHE_DIR"/*.json 2>/dev/null
            rm -rf "$NSG_RULES_DETAIL_DIR" 2>/dev/null
            rm -rf "$XR_CACHE_DIR" 2>/dev/null
            echo -e "${GREEN}✓ All caches cleared${NC}"
            sleep 1
            display_cache_stats
            ;;
        *)
            return
            ;;
    esac
}

#--------------------------------------------------------------------------------
# Manage OKE Cluster - Display comprehensive OKE cluster details
#--------------------------------------------------------------------------------
manage_oke_cluster() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    echo ""
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${GREEN}                                                         OKE CLUSTER MANAGEMENT                                                                        ${NC}"
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    _display_cache_info \
        "${OKE_ENV_CACHE}|OKE Env"
    
    # Fetch/refresh cache
    fetch_oke_environment "$compartment_id" "$region"
    
    # Read values from cache
    local cluster_ocid vcn_ocid
    cluster_ocid=$(get_oke_env_value "OKE_CLUSTER_ID")
    vcn_ocid=$(get_oke_env_value "VCN_OCID")
    
    if [[ -z "$cluster_ocid" || "$cluster_ocid" == "N/A" ]]; then
        echo -e "${YELLOW}No OKE cluster found in this compartment/region.${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # Fetch cluster details
    local cluster_json
    cluster_json=$(oci ce cluster get --cluster-id "$cluster_ocid" --output json 2>/dev/null)
    
    if [[ -z "$cluster_json" ]]; then
        echo -e "${RED}Failed to fetch cluster details${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # Extract cluster info
    local cluster_name cluster_state k8s_version
    cluster_name=$(echo "$cluster_json" | jq -r '.data.name // "N/A"')
    cluster_state=$(echo "$cluster_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    k8s_version=$(echo "$cluster_json" | jq -r '.data["kubernetes-version"] // "N/A"')
    local time_created
    time_created=$(echo "$cluster_json" | jq -r '.data["time-created"] // .data.timeCreated // "N/A"' 2>/dev/null)
    
    # State color
    local _cs_color="$GREEN"
    [[ "$cluster_state" != "ACTIVE" ]] && _cs_color="$YELLOW"
    [[ "$cluster_state" == "FAILED" || "$cluster_state" == "DELETED" ]] && _cs_color="$RED"
    
    # Check for available upgrades
    local upgrade_versions=""
    local available_versions_json
    available_versions_json=$(oci ce cluster-options get --cluster-option-id all --output json 2>/dev/null)
    if [[ -n "$available_versions_json" ]]; then
        upgrade_versions=$(echo "$available_versions_json" | jq -r --arg curr "$k8s_version" '
            (.data["kubernetes-versions"] // [])[] |
            select(. > $curr) | .
        ' 2>/dev/null | head -5 | tr '\n' ', ' | sed 's/,$//')
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Cluster Overview ═══${NC}"
    echo ""
    echo -e "${CYAN}Cluster Name:${NC} ${WHITE}$cluster_name${NC}  ${_cs_color}[$cluster_state]${NC}  ${YELLOW}($cluster_ocid)${NC}"
    if [[ -n "$time_created" && "$time_created" != "N/A" ]]; then
        echo -e "  ${CYAN}Created:${NC}      ${WHITE}${time_created:0:19}${NC}"
    fi
    if [[ -n "$upgrade_versions" ]]; then
        echo -e "  ${CYAN}K8s Version:${NC}  ${WHITE}$k8s_version${NC}  ${YELLOW}⬆ Upgradable: ${GREEN}$upgrade_versions${NC}"
    else
        echo -e "  ${CYAN}K8s Version:${NC}  ${WHITE}$k8s_version${NC}  ${GREEN}✓ Latest${NC}"
    fi
    
    # Network info
    echo ""
    echo -e "${BOLD}${WHITE}═══ Network Configuration ═══${NC}"
    echo ""
    
    # Extract OCIDs
    local vcn_id endpoint_subnet_id svc_lb_subnet_id
    vcn_id=$(echo "$cluster_json" | jq -r '.data["vcn-id"] // "N/A"')
    endpoint_subnet_id=$(echo "$cluster_json" | jq -r '.data["endpoint-config"]["subnet-id"] // "N/A"')
    svc_lb_subnet_id=$(echo "$cluster_json" | jq -r '.data.options["service-lb-subnet-ids"][0] // "N/A"')
    local public_endpoint pods_cidr services_cidr cni_type
    public_endpoint=$(echo "$cluster_json" | jq -r '.data["endpoint-config"]["is-public-ip-enabled"] // false')
    pods_cidr=$(echo "$cluster_json" | jq -r '.data.options["kubernetes-network-config"]["pods-cidr"] // "N/A"')
    services_cidr=$(echo "$cluster_json" | jq -r '.data.options["kubernetes-network-config"]["services-cidr"] // "N/A"')
    cni_type=$(echo "$cluster_json" | jq -r '.data["cluster-pod-network-options"][0]["cni-type"] // "N/A"')
    
    # Resolve VCN name (from OKE env cache)
    local vcn_name="N/A"
    if [[ "$vcn_id" != "N/A" && -n "$vcn_id" ]]; then
        vcn_name=$(get_oke_env_value "VCN_NAME")
        # Fallback to API if not in cache
        if [[ -z "$vcn_name" || "$vcn_name" == "N/A" ]]; then
            vcn_name=$(oci network vcn get --vcn-id "$vcn_id" --query 'data."display-name"' --raw-output 2>/dev/null) || vcn_name="N/A"
        fi
    fi
    
    # Resolve Endpoint Subnet name (from network resources cache, fallback to API)
    local endpoint_subnet_name
    endpoint_subnet_name=$(resolve_subnet_name_cached "$endpoint_subnet_id")
    
    # Resolve Service LB Subnet name (from network resources cache, fallback to API)
    local svc_lb_subnet_name
    svc_lb_subnet_name=$(resolve_subnet_name_cached "$svc_lb_subnet_id")
    
    # Display with names (OCIDs) and drill-down labels
    echo -e "${CYAN}[vcn]${NC}      VCN:                 ${GREEN}$vcn_name${NC} ${YELLOW}($vcn_id)${NC}"
    echo -e "${CYAN}[endpoint]${NC} Endpoint Subnet:     ${GREEN}$endpoint_subnet_name${NC} ${YELLOW}($endpoint_subnet_id)${NC}"
    echo -e "           Public Endpoint:     $public_endpoint"
    echo -e "${CYAN}[svc-lb]${NC}   Service LB Subnet:   ${GREEN}$svc_lb_subnet_name${NC} ${YELLOW}($svc_lb_subnet_id)${NC}"
    echo -e "           Pods CIDR:           $pods_cidr"
    echo -e "           Services CIDR:       $services_cidr"
    echo -e "           CNI Type:            $cni_type"
    
    # Endpoints
    echo ""
    echo -e "${BOLD}${WHITE}═══ Cluster Endpoints ═══${NC}"
    echo ""
    echo "$cluster_json" | jq -r '
        (.data.endpoints // {}) |
        "Kubernetes API:      \(.kubernetes // "N/A")",
        "Public Endpoint:     \(.["public-endpoint"] // "N/A")",
        "Private Endpoint:    \(.["private-endpoint"] // "N/A")"
    ' 2>/dev/null
    
    # Addons - show all available with status (installed first, then available)
    echo ""
    echo -e "${BOLD}${WHITE}═══ Cluster Addons ═══${NC}"
    echo ""
    
    # Build addon map for selection (global for action handling)
    declare -gA ADDON_MAP=()
    declare -gA ADDON_STATUS=()
    declare -gA ADDON_VERSIONS=()
    local addon_idx=0
    
    # Try to detect installed addons via kubectl (check kube-system deployments/daemonsets)
    declare -A INSTALLED_ADDONS
    local kubectl_available=false
    if command -v kubectl &>/dev/null; then
        # Get deployments and daemonsets in kube-system
        local kube_resources
        kube_resources=$(kubectl get deployments,daemonsets -n kube-system -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' 2>/dev/null)
        if [[ -n "$kube_resources" ]]; then
            kubectl_available=true
            # Map common addon names to their k8s resource names
            echo "$kube_resources" | grep -qi "cert-manager" && INSTALLED_ADDONS["CertManager"]="ACTIVE"
            echo "$kube_resources" | grep -qi "coredns" && INSTALLED_ADDONS["CoreDNS"]="ACTIVE"
            echo "$kube_resources" | grep -qi "kube-proxy" && INSTALLED_ADDONS["KubeProxy"]="ACTIVE"
            echo "$kube_resources" | grep -qi "nvidia" && INSTALLED_ADDONS["NvidiaGpuPlugin"]="ACTIVE"
            echo "$kube_resources" | grep -qi "amd.*gpu" && INSTALLED_ADDONS["AmdGpuPlugin"]="ACTIVE"
            echo "$kube_resources" | grep -qi "vcn-native\|oci-native" && INSTALLED_ADDONS["OciVcnIpNative"]="ACTIVE"
            echo "$kube_resources" | grep -qi "flannel" && INSTALLED_ADDONS["Flannel"]="ACTIVE"
            echo "$kube_resources" | grep -qi "metrics-server" && INSTALLED_ADDONS["KubernetesMetricsServer"]="ACTIVE"
            echo "$kube_resources" | grep -qi "cluster-autoscaler" && INSTALLED_ADDONS["ClusterAutoscaler"]="ACTIVE"
            echo "$kube_resources" | grep -qi "dashboard" && INSTALLED_ADDONS["KubernetesDashboard"]="ACTIVE"
            echo "$kube_resources" | grep -qi "istio" && INSTALLED_ADDONS["Istio"]="ACTIVE"
            echo "$kube_resources" | grep -qi "weblogic" && INSTALLED_ADDONS["WeblogicKubernetesOperator"]="ACTIVE"
        fi
    fi
    
    # Get all available addon options
    local addon_options_json
    addon_options_json=$(oci ce addon-option list --kubernetes-version "$k8s_version" --all --output json 2>/dev/null)
    
    local has_addons=false
    
    # Collect addons into two arrays: installed and available
    declare -a installed_addons=()
    declare -a available_addons=()
    
    # Parse addon-option list - structure is .data[] with name, description, is-essential, versions[]
    if [[ -n "$addon_options_json" ]] && echo "$addon_options_json" | jq -e '.data' >/dev/null 2>&1; then
        while IFS=$'\t' read -r name description is_essential default_version; do
            [[ -z "$name" ]] && continue
            has_addons=true
            
            local essential_display="No"
            [[ "$is_essential" == "true" ]] && essential_display="Yes"
            
            # Truncate description for display
            local desc_display="${description:0:100}"
            
            # Store as: name|version|description
            local addon_line="${name}|${default_version}|${desc_display}"
            
            # Check if installed via kubectl detection
            if [[ -n "${INSTALLED_ADDONS[$name]:-}" ]]; then
                installed_addons+=("$addon_line")
            else
                available_addons+=("$addon_line")
            fi
        done < <(echo "$addon_options_json" | jq -r '.data[] | [.name, (.description // ""), ((.["is-essential"] // false) | tostring), ((.versions // [])[0]["version-number"] // "N/A")] | @tsv' 2>/dev/null)
    fi
    
    if [[ "$has_addons" == "true" ]]; then
        printf "${BOLD}%-4s %-25s %-12s %-20s %-100s${NC}\n" "#" "Addon Name" "Status" "Version" "Description"
        printf "${WHITE}%-4s %-25s %-12s %-20s %-100s${NC}\n" "----" "-------------------------" "------------" "--------------------" "$(printf '%*s' 100 '' | tr ' ' '-')"
        
        # Display installed addons first (green)
        for addon_line in "${installed_addons[@]}"; do
            IFS='|' read -r name version desc <<< "$addon_line"
            ((addon_idx++))
            ADDON_MAP[$addon_idx]="$name"
            ADDON_VERSIONS[$addon_idx]="$version"
            ADDON_STATUS[$addon_idx]="INSTALLED"
            
            printf "${YELLOW}%-4s${NC} %-25s ${GREEN}%-12s${NC} %-20s %s\n" \
                "$addon_idx" "${name:0:25}" "INSTALLED" "${version:0:20}" "$desc"
        done
        
        # Display available addons (white)
        for addon_line in "${available_addons[@]}"; do
            IFS='|' read -r name version desc <<< "$addon_line"
            ((addon_idx++))
            ADDON_MAP[$addon_idx]="$name"
            ADDON_VERSIONS[$addon_idx]="$version"
            ADDON_STATUS[$addon_idx]="NOT_INSTALLED"
            
            printf "${YELLOW}%-4s${NC} %-25s ${WHITE}%-12s${NC} %-20s %s\n" \
                "$addon_idx" "${name:0:25}" "AVAILABLE" "${version:0:20}" "$desc"
        done
        
        echo ""
        if [[ "$kubectl_available" == "true" ]]; then
            echo -e "${WHITE}(${#installed_addons[@]} installed, ${#available_addons[@]} available - status detected via kubectl)${NC}"
        else
            echo -e "${WHITE}(kubectl not available - cannot detect installed status)${NC}"
        fi
    else
        echo -e "${YELLOW}Unable to fetch addon options for kubernetes version $k8s_version${NC}"
    fi
    
    # Node Pools
    echo ""
    echo -e "${BOLD}${WHITE}═══ Node Pools ═══${NC}"
    echo ""
    local nodepools_json
    nodepools_json=$(oci ce node-pool list --compartment-id "$compartment_id" --cluster-id "$cluster_ocid" --output json 2>/dev/null)
    
    # Build node pool map for selection (global)
    declare -gA NP_MAP      # idx -> node_pool_ocid
    declare -gA NP_NAME_MAP  # idx -> node_pool_name
    NP_MAP=()
    NP_NAME_MAP=()
    local np_idx=0
    
    if [[ -n "$nodepools_json" ]] && echo "$nodepools_json" | jq -e '.data' >/dev/null 2>&1; then
        local nodepool_count
        nodepool_count=$(echo "$nodepools_json" | jq '(.data // []) | length')
        
        if [[ "$nodepool_count" -gt 0 ]]; then
            printf "${BOLD}%-5s %-30s %-12s %-8s %-25s %s${NC}\n" "#" "Node Pool Name" "State" "Size" "Shape" "K8s Version"
            printf "${WHITE}%-5s %-30s %-12s %-8s %-25s %s${NC}\n" "-----" "------------------------------" "------------" "--------" "-------------------------" "---------------"
            
            while IFS=$'\t' read -r np_name np_state np_size np_shape np_version np_id; do
                [[ -z "$np_name" ]] && continue
                ((np_idx++))
                NP_MAP[$np_idx]="$np_id"
                NP_NAME_MAP[$np_idx]="$np_name"
                
                local state_color="$GREEN"
                [[ "$np_state" != "ACTIVE" ]] && state_color="$YELLOW"
                [[ "$np_state" == "FAILED" || "$np_state" == "DELETED" ]] && state_color="$RED"
                printf "${YELLOW}%-5s${NC} %-30s ${state_color}%-12s${NC} %-8s %-25s %s\n" "np${np_idx}" "${np_name:0:30}" "$np_state" "$np_size" "${np_shape:0:25}" "$np_version"
            done < <(echo "$nodepools_json" | jq -r '
                (.data // [])[] |
                [
                    (.name // "N/A"),
                    (.["lifecycle-state"] // "N/A"),
                    ((.["node-config-details"]["size"] // .["node-pool-size"]) // "N/A" | tostring),
                    (.["node-shape"] // "N/A"),
                    (.["kubernetes-version"] // "N/A"),
                    (.id // "N/A")
                ] | @tsv
            ' 2>/dev/null)
            
            # Show node pool details with resolved subnet names
            echo ""
            echo -e "${BOLD}${WHITE}── Node Pool Details ──${NC}"
            
            # Process each node pool
            for i in $(seq 1 $np_idx); do
                local np_id="${NP_MAP[$i]}"
                local np_name="${NP_NAME_MAP[$i]}"
                
                # Get subnet IDs from nodepools_json
                local np_subnet_ids
                np_subnet_ids=$(echo "$nodepools_json" | jq -r --arg npid "$np_id" '
                    (.data // [])[] | select(.id == $npid) |
                    ((.["node-config-details"]["placement-configs"] // []) | map(.["subnet-id"] // "N/A") | unique | join(","))
                ' 2>/dev/null)
                
                echo ""
                echo -e "  ${YELLOW}[np${i}]${NC} ${CYAN}$np_name${NC}"
                
                # Show → Subnet(s) with resolved names
                if [[ -n "$np_subnet_ids" && "$np_subnet_ids" != "N/A" ]]; then
                    IFS=',' read -ra subnet_array <<< "$np_subnet_ids"
                    for subnet_id in "${subnet_array[@]}"; do
                        [[ -z "$subnet_id" || "$subnet_id" == "N/A" ]] && continue
                        local subnet_name
                        subnet_name=$(oci network subnet get --subnet-id "$subnet_id" --query 'data."display-name"' --raw-output 2>/dev/null) || subnet_name="N/A"
                        echo -e "       ${GRAY}→ Subnet:${NC}    ${GREEN}$subnet_name${NC} ${YELLOW}($subnet_id)${NC}"
                    done
                else
                    echo -e "       ${GRAY}→ Subnet:${NC}    N/A"
                fi
                
                # Show → Node Pool OCID
                echo -e "       ${GRAY}→ Node Pool:${NC} ${YELLOW}($np_id)${NC}"
            done
        else
            echo -e "${YELLOW}No node pools configured${NC}"
        fi
    else
        echo -e "${WHITE}No node pools found or unable to fetch${NC}"
    fi
    
    # Helm Deployments
    echo ""
    echo -e "${BOLD}${WHITE}═══ Helm Deployments (GPU) ═══${NC}"
    echo ""
    
    local helm_available=false
    if command -v helm &>/dev/null && command -v kubectl &>/dev/null; then
        helm_available=true
    fi
    
    if [[ "$helm_available" == "true" ]]; then
        printf "${BOLD}%-25s %-25s %-10s %-40s %-12s %-40s${NC}\n" \
            "Release Name" "Namespace" "Revision" "Updated" "Status" "Chart"
        printf "${WHITE}%-25s %-25s %-10s %-40s %-12s %-40s${NC}\n" \
            "-------------------------" "-------------------------" "----------" "----------------------------------------" "------------" "----------------------------------------"
        
        local found_helm_releases=false
        
        # Check gpu-operator namespace
        local gpu_op_json
        gpu_op_json=$(helm list -n gpu-operator -o json 2>/dev/null)
        if [[ -n "$gpu_op_json" && "$gpu_op_json" != "[]" ]]; then
            echo "$gpu_op_json" | jq -r '.[] | [.name, .namespace, (.revision | tostring), .updated, .status, .chart] | @tsv' 2>/dev/null | while IFS=$'\t' read -r name ns rev updated status chart; do
                local status_color="$GREEN"
                [[ "$status" != "deployed" ]] && status_color="$YELLOW"
                [[ "$status" == "failed" ]] && status_color="$RED"
                # Truncate updated timestamp
                local updated_trunc="${updated:0:40}"
                printf "%-25s %-25s %-10s %-40s ${status_color}%-12s${NC} %-40s\n" \
                    "${name:0:25}" "${ns:0:25}" "$rev" "$updated_trunc" "$status" "${chart:0:40}"
            done
            found_helm_releases=true
        fi
        
        # Check nvidia-dra-driver-gpu namespace
        local dra_json
        dra_json=$(helm list -n nvidia-dra-driver-gpu -o json 2>/dev/null)
        if [[ -n "$dra_json" && "$dra_json" != "[]" ]]; then
            echo "$dra_json" | jq -r '.[] | [.name, .namespace, (.revision | tostring), .updated, .status, .chart] | @tsv' 2>/dev/null | while IFS=$'\t' read -r name ns rev updated status chart; do
                local status_color="$GREEN"
                [[ "$status" != "deployed" ]] && status_color="$YELLOW"
                [[ "$status" == "failed" ]] && status_color="$RED"
                # Truncate updated timestamp
                local updated_trunc="${updated:0:40}"
                printf "%-25s %-25s %-10s %-40s ${status_color}%-12s${NC} %-40s\n" \
                    "${name:0:25}" "${ns:0:25}" "$rev" "$updated_trunc" "$status" "${chart:0:40}"
            done
            found_helm_releases=true
        fi
        
        # Check network-operator namespace (common for RDMA/networking)
        local netop_json
        netop_json=$(helm list -n network-operator -o json 2>/dev/null)
        if [[ -n "$netop_json" && "$netop_json" != "[]" ]]; then
            echo "$netop_json" | jq -r '.[] | [.name, .namespace, (.revision | tostring), .updated, .status, .chart] | @tsv' 2>/dev/null | while IFS=$'\t' read -r name ns rev updated status chart; do
                local status_color="$GREEN"
                [[ "$status" != "deployed" ]] && status_color="$YELLOW"
                [[ "$status" == "failed" ]] && status_color="$RED"
                local updated_trunc="${updated:0:40}"
                printf "%-25s %-25s %-10s %-40s ${status_color}%-12s${NC} %-40s\n" \
                    "${name:0:25}" "${ns:0:25}" "$rev" "$updated_trunc" "$status" "${chart:0:40}"
            done
            found_helm_releases=true
        fi
        
        if [[ "$found_helm_releases" == "false" ]]; then
            echo -e "${GRAY}No GPU-related helm releases found in gpu-operator, nvidia-dra-driver-gpu, or network-operator namespaces${NC}"
        fi
    else
        echo -e "${YELLOW}helm and/or kubectl not available - cannot check helm deployments${NC}"
    fi
    
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
    echo -e "  ${BOLD}${WHITE}Network Drill-Down:${NC}"
    echo -e "  ${CYAN}vcn${NC}        - View VCN details (route tables, security lists, DHCP)"
    echo -e "  ${CYAN}endpoint${NC}   - View endpoint subnet details (CIDR, route table, security lists)"
    echo -e "  ${CYAN}svc-lb${NC}     - View service LB subnet details (CIDR, route table, security lists)"
    echo ""
    if [[ $np_idx -gt 0 ]]; then
        echo -e "  ${BOLD}${WHITE}Node Pools:${NC}"
        echo -e "  ${YELLOW}np#${NC}        - View node pool instances (e.g., 'np1') → select instance for detail view"
    fi
    echo ""
    echo -e "  ${BOLD}${WHITE}Addons:${NC}"
    if [[ $addon_idx -gt 0 ]]; then
        echo -e "  ${YELLOW}1-${addon_idx}${NC} / ${CYAN}info #${NC} - Show addon details and install instructions (e.g., 'info 3')"
    else
        echo -e "  ${CYAN}info #${NC}    - Show addon details and install instructions (e.g., 'info 3')"
    fi
    echo ""
    echo -e "  ${BOLD}${WHITE}General:${NC}"
    echo -e "  ${MAGENTA}r${NC}         - Refresh OKE cluster data"
    echo -e "  ${CYAN}back${NC}      - Return to main menu"
    echo ""
    
    while true; do
        local prompt_range=""
        [[ $addon_idx -gt 0 ]] && prompt_range="1-${addon_idx}, "
        local np_hint=""
        [[ $np_idx -gt 0 ]] && np_hint="np#, "
        echo -n -e "${BOLD}${CYAN}[OKE Cluster] Enter # or command [${np_hint}${prompt_range}vcn/endpoint/svc-lb/info/r/back]: ${NC}"
        local input
        read -r input
        
        # Empty input goes back
        if [[ -z "$input" ]]; then
            return
        fi
        
        # Network drill-down commands
        case "$input" in
            vcn|VCN)
                if [[ "$vcn_id" != "N/A" && -n "$vcn_id" ]]; then
                    view_network_resource_detail "VCN|$vcn_id"
                else
                    echo -e "${RED}VCN OCID not available${NC}"
                fi
                continue
                ;;
            endpoint|ENDPOINT|ep)
                if [[ "$endpoint_subnet_id" != "N/A" && -n "$endpoint_subnet_id" ]]; then
                    view_network_resource_detail "SUBNET|$endpoint_subnet_id"
                else
                    echo -e "${RED}Endpoint subnet OCID not available${NC}"
                fi
                continue
                ;;
            svc-lb|SVC-LB|svc_lb|svclb|SVCLB)
                if [[ "$svc_lb_subnet_id" != "N/A" && -n "$svc_lb_subnet_id" ]]; then
                    view_network_resource_detail "SUBNET|$svc_lb_subnet_id"
                else
                    echo -e "${RED}Service LB subnet OCID not available${NC}"
                fi
                continue
                ;;
        esac
        
        # Node pool instance drill-down: np#
        if [[ "$input" =~ ^np([0-9]+)$ ]]; then
            local np_num="${BASH_REMATCH[1]}"
            if [[ -n "${NP_MAP[$np_num]:-}" ]]; then
                local sel_np_id="${NP_MAP[$np_num]}"
                local sel_np_name="${NP_NAME_MAP[$np_num]:-Node Pool}"
                
                echo ""
                echo -e "${BOLD}${CYAN}══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
                echo -e "${BOLD}${CYAN}  Node Pool: ${WHITE}${sel_np_name}${NC}"
                echo -e "${BOLD}${CYAN}══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
                echo ""
                echo -e "${CYAN}Fetching node pool instances...${NC}"
                
                local np_detail_json
                np_detail_json=$(oci ce node-pool get --node-pool-id "$sel_np_id" --output json 2>/dev/null)
                
                if [[ -z "$np_detail_json" ]] || ! echo "$np_detail_json" | jq -e '.data' >/dev/null 2>&1; then
                    echo -e "${RED}Failed to fetch node pool details${NC}"
                    continue
                fi
                
                # Extract nodes array
                local nodes_json
                nodes_json=$(echo "$np_detail_json" | jq '.data.nodes // []' 2>/dev/null)
                local node_count
                node_count=$(echo "$nodes_json" | jq 'length' 2>/dev/null) || node_count=0
                
                if [[ "$node_count" -eq 0 ]]; then
                    echo -e "${YELLOW}No nodes found in this node pool${NC}"
                    echo ""
                    echo -e "${GRAY}The node pool may be scaling or nodes haven't been provisioned yet.${NC}"
                    continue
                fi
                
                # Display node pool summary
                local np_shape np_size np_k8s
                np_shape=$(echo "$np_detail_json" | jq -r '.data["node-shape"] // "N/A"')
                np_size=$(echo "$np_detail_json" | jq -r '.data["node-config-details"]["size"] // .data["node-pool-size"] // "N/A"')
                np_k8s=$(echo "$np_detail_json" | jq -r '.data["kubernetes-version"] // "N/A"')
                
                echo -e "  ${CYAN}Shape:${NC}    ${WHITE}${np_shape}${NC}    ${CYAN}Target Size:${NC} ${WHITE}${np_size}${NC}    ${CYAN}K8s:${NC} ${WHITE}${np_k8s}${NC}"
                echo -e "  ${CYAN}Nodes:${NC}    ${WHITE}${node_count}${NC}"
                echo ""
                
                printf "${BOLD}%-5s %-35s %-12s %-16s %-20s %s${NC}\n" \
                    "#" "Instance Name" "State" "Private IP" "Fault Domain" "Availability Domain"
                printf "${WHITE}%-5s %-35s %-12s %-16s %-20s %s${NC}\n" \
                    "-----" "-----------------------------------" "------------" "----------------" "--------------------" "--------------------"
                
                # Build instance map for selection
                declare -A NP_INSTANCE_MAP
                NP_INSTANCE_MAP=()
                local inst_idx=0
                
                while IFS=$'\t' read -r inst_name inst_id inst_state inst_ip inst_fd inst_ad; do
                    [[ -z "$inst_id" || "$inst_id" == "null" ]] && continue
                    ((inst_idx++))
                    NP_INSTANCE_MAP[$inst_idx]="$inst_id"
                    
                    local state_color="$GREEN"
                    case "$inst_state" in
                        ACTIVE) state_color="$GREEN" ;;
                        CREATING|UPDATING|ACCEPTED) state_color="$YELLOW" ;;
                        DELETED|DELETING|FAILED) state_color="$RED" ;;
                        *) state_color="$GRAY" ;;
                    esac
                    
                    [[ "$inst_ip" == "null" || -z "$inst_ip" ]] && inst_ip="(pending)"
                    local fd_short="${inst_fd##*-}"
                    [[ "$inst_fd" == "null" || -z "$inst_fd" ]] && fd_short="N/A"
                    local ad_short="${inst_ad##*:}"
                    [[ "$inst_ad" == "null" || -z "$inst_ad" ]] && ad_short="N/A"
                    local name_trunc="${inst_name:0:33}"
                    [[ ${#inst_name} -gt 33 ]] && name_trunc="${name_trunc}.."
                    
                    printf "${YELLOW}%-5s${NC} %-35s ${state_color}%-12s${NC} %-16s %-20s %s\n" \
                        "$inst_idx" "$name_trunc" "$inst_state" "$inst_ip" "FD-${fd_short}" "$ad_short"
                done < <(echo "$nodes_json" | jq -r '.[] | [
                    (.name // "N/A"),
                    (.id // ""),
                    (.["lifecycle-state"] // "UNKNOWN"),
                    (.["private-ip"] // "null"),
                    (.["fault-domain"] // "null"),
                    (.["availability-domain"] // "null")
                ] | @tsv' 2>/dev/null)
                
                echo ""
                
                if [[ $inst_idx -eq 0 ]]; then
                    echo -e "${YELLOW}No instance details available yet${NC}"
                    continue
                fi
                
                # Instance selection loop
                while true; do
                    echo -n -e "${CYAN}Select instance # for detail view (1-${inst_idx}), or Enter to go back: ${NC}"
                    local inst_input
                    read -r inst_input
                    
                    [[ -z "$inst_input" ]] && break
                    
                    if [[ "$inst_input" =~ ^[0-9]+$ ]] && [[ -n "${NP_INSTANCE_MAP[$inst_input]:-}" ]]; then
                        local sel_instance_id="${NP_INSTANCE_MAP[$inst_input]}"
                        display_instance_details "$sel_instance_id"
                    else
                        echo -e "${RED}Invalid selection: ${inst_input} (valid: 1-${inst_idx})${NC}"
                    fi
                done
            else
                echo -e "${RED}Invalid node pool number: np${np_num} (valid: np1-np${np_idx})${NC}"
            fi
            continue
        fi
        
        case "$input" in
            [0-9]|[0-9][0-9]|[0-9][0-9][0-9])
                # Direct number input - treat as info command
                local addon_num="$input"
                if [[ -n "${ADDON_MAP[$addon_num]:-}" ]]; then
                    local addon_name="${ADDON_MAP[$addon_num]}"
                    local addon_version="${ADDON_VERSIONS[$addon_num]:-}"
                    local addon_status="${ADDON_STATUS[$addon_num]:-NOT_INSTALLED}"
                    
                    echo ""
                    echo -e "${BOLD}${CYAN}═══ Addon: $addon_name ═══${NC}"
                    echo ""
                    echo -e "  ${WHITE}Version:${NC}  $addon_version"
                    echo -e "  ${WHITE}Status:${NC}   $addon_status"
                    echo ""
                    
                    # Get detailed info from addon-option
                    local addon_detail
                    addon_detail=$(oci ce addon-option list --kubernetes-version "$k8s_version" --addon-name "$addon_name" --output json 2>/dev/null)
                    if [[ -n "$addon_detail" ]] && echo "$addon_detail" | jq -e '.data[0]' >/dev/null 2>&1; then
                        local description
                        description=$(echo "$addon_detail" | jq -r '.data[0].description // "N/A"')
                        local addon_group
                        addon_group=$(echo "$addon_detail" | jq -r '.data[0]["addon-group"] // "N/A"')
                        local is_essential
                        is_essential=$(echo "$addon_detail" | jq -r '.data[0]["is-essential"] // false')
                        
                        echo -e "  ${WHITE}Group:${NC}       $addon_group"
                        echo -e "  ${WHITE}Essential:${NC}   $is_essential"
                        echo -e "  ${WHITE}Description:${NC}"
                        echo "$description" | fold -s -w 70 | sed 's/^/    /'
                        
                        # Show available versions
                        echo ""
                        echo -e "  ${WHITE}Available Versions:${NC}"
                        echo "$addon_detail" | jq -r '.data[0].versions[]? | "    - \(.["version-number"]) (\(.status))"' 2>/dev/null | head -5
                    fi
                    
                    echo ""
                    echo -e "${BOLD}${WHITE}To Install/Remove:${NC}"
                    echo -e "  ${CYAN}OCI Console:${NC} Cluster Details → Resources → Add-ons"
                    echo -e "  ${CYAN}Terraform:${NC}   oci_containerengine_addon resource"
                    echo ""
                    echo -e "  ${WHITE}Terraform Example:${NC}"
                    echo -e "    resource \"oci_containerengine_addon\" \"${addon_name,,}\" {"
                    echo -e "      addon_name                    = \"$addon_name\""
                    echo -e "      cluster_id                    = \"$cluster_ocid\""
                    echo -e "      remove_addon_resources_on_delete = true"
                    echo -e "    }"
                    echo ""
                else
                    echo -e "${RED}Invalid addon number: $addon_num (valid: 1-${addon_idx})${NC}"
                fi
                ;;
            info\ [0-9]*|INFO\ [0-9]*)
                local addon_num="${input#* }"
                if [[ -n "${ADDON_MAP[$addon_num]:-}" ]]; then
                    local addon_name="${ADDON_MAP[$addon_num]}"
                    local addon_version="${ADDON_VERSIONS[$addon_num]:-}"
                    local addon_status="${ADDON_STATUS[$addon_num]:-NOT_INSTALLED}"
                    
                    echo ""
                    echo -e "${BOLD}${CYAN}═══ Addon: $addon_name ═══${NC}"
                    echo ""
                    echo -e "  ${WHITE}Version:${NC}  $addon_version"
                    echo -e "  ${WHITE}Status:${NC}   $addon_status"
                    echo ""
                    
                    # Get detailed info from addon-option
                    local addon_detail
                    addon_detail=$(oci ce addon-option list --kubernetes-version "$k8s_version" --addon-name "$addon_name" --output json 2>/dev/null)
                    if [[ -n "$addon_detail" ]] && echo "$addon_detail" | jq -e '.data[0]' >/dev/null 2>&1; then
                        local description
                        description=$(echo "$addon_detail" | jq -r '.data[0].description // "N/A"')
                        local addon_group
                        addon_group=$(echo "$addon_detail" | jq -r '.data[0]["addon-group"] // "N/A"')
                        local is_essential
                        is_essential=$(echo "$addon_detail" | jq -r '.data[0]["is-essential"] // false')
                        
                        echo -e "  ${WHITE}Group:${NC}       $addon_group"
                        echo -e "  ${WHITE}Essential:${NC}   $is_essential"
                        echo -e "  ${WHITE}Description:${NC}"
                        echo "$description" | fold -s -w 70 | sed 's/^/    /'
                        
                        # Show available versions
                        echo ""
                        echo -e "  ${WHITE}Available Versions:${NC}"
                        echo "$addon_detail" | jq -r '.data[0].versions[]? | "    - \(.["version-number"]) (\(.status))"' 2>/dev/null | head -5
                    fi
                    
                    echo ""
                    echo -e "${BOLD}${WHITE}To Install/Remove:${NC}"
                    echo -e "  ${CYAN}OCI Console:${NC} Cluster Details → Resources → Add-ons"
                    echo -e "  ${CYAN}Terraform:${NC}   oci_containerengine_addon resource"
                    echo ""
                    echo -e "  ${WHITE}Terraform Example:${NC}"
                    echo -e "    resource \"oci_containerengine_addon\" \"${addon_name,,}\" {"
                    echo -e "      addon_name                    = \"$addon_name\""
                    echo -e "      cluster_id                    = \"$cluster_ocid\""
                    echo -e "      remove_addon_resources_on_delete = true"
                    echo -e "    }"
                    echo ""
                else
                    echo -e "${RED}Invalid addon number: $addon_num${NC}"
                fi
                ;;
            enable\ [0-9]*|ENABLE\ [0-9]*|disable\ [0-9]*|DISABLE\ [0-9]*)
                echo -e "${YELLOW}Addon enable/disable is not available via OCI CLI.${NC}"
                echo -e "${WHITE}Use 'info #' to see installation instructions for OCI Console or Terraform.${NC}"
                ;;
            r|R|refresh|REFRESH)
                echo -e "${YELLOW}Refreshing OKE cluster data...${NC}"
                rm -f "$OKE_ENV_CACHE"
                manage_oke_cluster
                return
                ;;
            back|BACK|b|B|q|Q)
                return
                ;;
            *)
                echo -e "${RED}Unknown command. Enter a number (1-${addon_idx}), 'info #', 'r', or 'back'.${NC}"
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# Resolve DRG details - tries multiple strategies to get DRG display-name & info
# Usage: resolve_drg_details DRG_OCID REGION COMP1 [COMP2] [COMP3] ...
# Returns via globals: _DRG_NAME, _DRG_COMP, _DRG_STATE, _DRG_RESOLVED (0/1)
#--------------------------------------------------------------------------------
resolve_drg_details() {
    local drg_id="$1"
    local region="$2"
    shift 2
    local search_comps=("$@")
    
    _DRG_NAME=""
    _DRG_COMP=""
    _DRG_STATE=""
    _DRG_RESOLVED=0
    
    # Strategy 1: Direct drg get with explicit region (cross-compartment)
    local drg_detail
    drg_detail=$(oci network drg get --drg-id "$drg_id" --region "$region" --output json 2>/dev/null)
    
    if [[ -n "$drg_detail" ]] && echo "$drg_detail" | jq -e '.data' > /dev/null 2>&1; then
        _DRG_NAME=$(echo "$drg_detail" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
        _DRG_COMP=$(echo "$drg_detail" | jq -r '.data["compartment-id"] // "N/A"' 2>/dev/null)
        _DRG_STATE=$(echo "$drg_detail" | jq -r '.data["lifecycle-state"] // "N/A"' 2>/dev/null)
        _DRG_RESOLVED=1
        return 0
    fi
    
    # Strategy 2: Try drg list in each compartment, match by ID
    for comp in "${search_comps[@]}"; do
        [[ -z "$comp" ]] && continue
        local drg_list_json
        drg_list_json=$(oci network drg list --compartment-id "$comp" --region "$region" --all --output json 2>/dev/null)
        
        if [[ -n "$drg_list_json" ]] && echo "$drg_list_json" | jq -e '.data[0]' > /dev/null 2>&1; then
            local match
            match=$(echo "$drg_list_json" | jq -r --arg id "$drg_id" '.data[] | select(.id == $id) | "\(.["display-name"])|\(.["compartment-id"])|\(.["lifecycle-state"])"' 2>/dev/null)
            if [[ -n "$match" ]]; then
                _DRG_NAME="${match%%|*}"
                local rest="${match#*|}"
                _DRG_COMP="${rest%%|*}"
                _DRG_STATE="${rest#*|}"
                _DRG_RESOLVED=1
                return 0
            fi
        fi
    done
    
    # Strategy 3: Construct partial info from OCID
    # Parse short identifier from end of OCID for display
    local short_id="${drg_id##*.}"
    short_id="${short_id:0:12}"
    _DRG_NAME="DRG (${short_id}...)"
    _DRG_COMP="${search_comps[0]:-unknown}"
    _DRG_STATE="AVAILABLE"
    _DRG_RESOLVED=0
    return 1
}

#--------------------------------------------------------------------------------
# Port Search - Search all NSGs and Security Lists for rules matching a port
#--------------------------------------------------------------------------------
search_port_in_rules() {
    local search_port="$1"
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    local network_compartment_id="${NETWORK_COMPARTMENT_ID:-$compartment_id}"
    
    echo ""
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${CYAN}                                       PORT SEARCH: ${WHITE}${search_port}${NC}"
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Auto-fetch NSG rules detail if not cached
    local vcn_ocid
    vcn_ocid=$(get_oke_env_value "VCN_OCID" 2>/dev/null)
    
    if [[ -z "$vcn_ocid" || "$vcn_ocid" == "N/A" ]]; then
        echo -e "${YELLOW}Cannot determine VCN OCID - NSG/SL search may be limited${NC}"
        echo ""
    else
        # Ensure network resources are cached (gets NSG names + SLs)
        if [[ ! -f "$NETWORK_RESOURCES_CACHE" ]] || ! is_cache_fresh "$NETWORK_RESOURCES_CACHE" 2>/dev/null; then
            echo -e "${GRAY}Fetching network resources...${NC}"
            local vcn_comp_id
            vcn_comp_id=$(oci network vcn get --vcn-id "$vcn_ocid" --query 'data."compartment-id"' --raw-output 2>/dev/null)
            [[ -z "$vcn_comp_id" ]] && vcn_comp_id="$network_compartment_id"
            fetch_network_resources "$vcn_comp_id" "$vcn_ocid" 2>/dev/null
            fetch_security_lists "$vcn_comp_id" "$vcn_ocid" 2>/dev/null
        fi
        
        # Ensure NSG rules detail cache is populated
        if [[ ! -d "$NSG_RULES_DETAIL_DIR" ]] || [[ -z "$(ls -A "$NSG_RULES_DETAIL_DIR" 2>/dev/null)" ]]; then
            echo -e "${GRAY}Fetching NSG rules (this may take a moment)...${NC}"
            # Collect all NSG OCIDs from network resources cache
            local nsg_ids=""
            if [[ -f "$NETWORK_RESOURCES_CACHE" ]]; then
                nsg_ids=$(grep "^NSG|" "$NETWORK_RESOURCES_CACHE" | while IFS='|' read -r type name _ state ocid; do
                    echo "$ocid"
                done)
            fi
            if [[ -n "$nsg_ids" ]]; then
                fetch_nsg_rules_detail_parallel "$nsg_ids"
            fi
        fi
        
        # Ensure security lists are cached
        if [[ ! -f "$SL_CACHE" ]] || ! is_cache_fresh "$SL_CACHE" 2>/dev/null; then
            echo -e "${GRAY}Fetching security lists...${NC}"
            local vcn_comp_id
            vcn_comp_id=$(oci network vcn get --vcn-id "$vcn_ocid" --query 'data."compartment-id"' --raw-output 2>/dev/null)
            [[ -z "$vcn_comp_id" ]] && vcn_comp_id="$network_compartment_id"
            fetch_security_lists "$vcn_comp_id" "$vcn_ocid" 2>/dev/null
        fi
    fi
    
    local found_count=0
    
    # Build NSG name lookup
    declare -A _PS_NSG_NAMES
    if [[ -f "$NETWORK_RESOURCES_CACHE" ]]; then
        while IFS='|' read -r type name _ state ocid; do
            [[ "$type" == "NSG" && -n "$ocid" ]] && _PS_NSG_NAMES["$ocid"]="$name"
        done < "$NETWORK_RESOURCES_CACHE"
    fi
    
    # ========== SEARCH NSGs ==========
    echo -e "${BOLD}${WHITE}═══ NSG Rules Matching Port ${search_port} ═══${NC}"
    echo ""
    
    local nsg_header_printed=0
    
    if [[ -d "$NSG_RULES_DETAIL_DIR" ]]; then
        for cache_file in "$NSG_RULES_DETAIL_DIR"/*.json; do
            [[ ! -f "$cache_file" ]] && continue
            
            local nsg_short=$(basename "$cache_file" .json)
            
            # Find the full NSG OCID and name
            local nsg_full_id="" nsg_name=""
            for nid in "${!_PS_NSG_NAMES[@]}"; do
                if [[ "$nid" == *"$nsg_short" ]]; then
                    nsg_full_id="$nid"
                    nsg_name="${_PS_NSG_NAMES[$nid]}"
                    break
                fi
            done
            [[ -z "$nsg_name" ]] && nsg_name="NSG ...$nsg_short"
            
            # Search for matching rules using jq
            local matching_rules
            matching_rules=$(jq -r --argjson port "$search_port" '
                (.rules // [])[] |
                select(
                    # ALL protocol matches everything
                    .protocol == "all" or
                    # TCP port match
                    (.protocol == "6" and .["tcp-options"]["destination-port-range"] and
                        (.["tcp-options"]["destination-port-range"]["min"] <= $port) and
                        (.["tcp-options"]["destination-port-range"]["max"] >= $port)) or
                    # TCP source port match
                    (.protocol == "6" and .["tcp-options"]["source-port-range"] and
                        (.["tcp-options"]["source-port-range"]["min"] <= $port) and
                        (.["tcp-options"]["source-port-range"]["max"] >= $port)) or
                    # UDP port match
                    (.protocol == "17" and .["udp-options"]["destination-port-range"] and
                        (.["udp-options"]["destination-port-range"]["min"] <= $port) and
                        (.["udp-options"]["destination-port-range"]["max"] >= $port)) or
                    # UDP source port match
                    (.protocol == "17" and .["udp-options"]["source-port-range"] and
                        (.["udp-options"]["source-port-range"]["min"] <= $port) and
                        (.["udp-options"]["source-port-range"]["max"] >= $port)) or
                    # TCP with no port range = all ports
                    (.protocol == "6" and (.["tcp-options"]["destination-port-range"] | not) and (.["tcp-options"]["source-port-range"] | not)) or
                    # UDP with no port range = all ports
                    (.protocol == "17" and (.["udp-options"]["destination-port-range"] | not) and (.["udp-options"]["source-port-range"] | not))
                ) |
                [
                    .direction,
                    (if .protocol == "6" then "TCP"
                     elif .protocol == "17" then "UDP"
                     elif .protocol == "1" then "ICMP"
                     elif .protocol == "all" then "ALL"
                     else .protocol end),
                    (if .direction == "INGRESS" then (.source // "N/A") else (.destination // "N/A") end),
                    (if .["tcp-options"]["destination-port-range"] then
                        (if .["tcp-options"]["destination-port-range"]["min"] == .["tcp-options"]["destination-port-range"]["max"] then
                            "\(.["tcp-options"]["destination-port-range"]["min"])"
                        else
                            "\(.["tcp-options"]["destination-port-range"]["min"])-\(.["tcp-options"]["destination-port-range"]["max"])"
                        end)
                     elif .["udp-options"]["destination-port-range"] then
                        (if .["udp-options"]["destination-port-range"]["min"] == .["udp-options"]["destination-port-range"]["max"] then
                            "\(.["udp-options"]["destination-port-range"]["min"])"
                        else
                            "\(.["udp-options"]["destination-port-range"]["min"])-\(.["udp-options"]["destination-port-range"]["max"])"
                        end)
                     else "ALL" end),
                    (.description // "-"),
                    (if .protocol == "all" then "ALL-PROTO" else "" end)
                ] | @tsv
            ' "$cache_file" 2>/dev/null)
            
            if [[ -n "$matching_rules" ]]; then
                if [[ $nsg_header_printed -eq 0 ]]; then
                    printf "${BOLD}%-9s | %-8s | %-35s | %-11s | %-10s | %s${NC}\n" \
                        "Direction" "Protocol" "Source/Destination" "Dst Ports" "Match Type" "Description"
                    printf "${WHITE}%-9s-+-%-8s-+-%-35s-+-%-11s-+-%-10s-+-%s${NC}\n" \
                        "---------" "--------" "-----------------------------------" "-----------" "----------" "-------------------------------------------"
                    nsg_header_printed=1
                fi
                
                echo ""
                echo -e "  ${BOLD}${CYAN}NSG: ${GREEN}${nsg_name}${NC}"
                
                while IFS=$'\t' read -r direction proto src_dst dst_ports desc match_type; do
                    ((found_count++))
                    local dir_color="$GREEN"
                    [[ "$direction" == "EGRESS" ]] && dir_color="$RED"
                    
                    local match_label="${CYAN}EXACT${NC}"
                    if [[ "$proto" == "ALL" || "$match_type" == "ALL-PROTO" ]]; then
                        match_label="${YELLOW}ALL-PROTO${NC}"
                    elif [[ "$dst_ports" == "ALL" ]]; then
                        match_label="${YELLOW}ALL-PORTS${NC}"
                    fi
                    
                    # Resolve NSG OCID to name
                    if [[ "$src_dst" == ocid1.networksecuritygroup.* ]]; then
                        local resolved="${_PS_NSG_NAMES[$src_dst]:-}"
                        [[ -n "$resolved" ]] && src_dst="NSG: $resolved"
                    fi
                    
                    printf "  ${dir_color}%-9s${NC} | ${WHITE}%-8s${NC} | %-35s | %-11s | ${match_label}%-1s${NC} | ${GRAY}%s${NC}\n" \
                        "$direction" "$proto" "${src_dst:0:35}" "$dst_ports" "" "${desc:0:43}"
                done <<< "$matching_rules"
            fi
        done
    fi
    
    if [[ $nsg_header_printed -eq 0 ]]; then
        echo -e "  ${GRAY}(No matching NSG rules found)${NC}"
    fi
    
    echo ""
    
    # ========== SEARCH SECURITY LISTS ==========
    echo -e "${BOLD}${WHITE}═══ Security List Rules Matching Port ${search_port} ═══${NC}"
    echo ""
    
    local sl_header_printed=0
    local sl_found=0
    
    if [[ -f "$SL_CACHE" ]]; then
        while IFS='|' read -r sl_id sl_vcn sl_name sl_state sl_in_count sl_eg_count; do
            [[ -z "$sl_id" || "$sl_id" =~ ^# ]] && continue
            [[ "$sl_state" != "AVAILABLE" ]] && continue
            
            # Fetch full security list rules
            local sl_json
            sl_json=$(oci network security-list get --security-list-id "$sl_id" --output json 2>/dev/null)
            [[ -z "$sl_json" ]] && continue
            
            # Search ingress rules
            local sl_matching
            sl_matching=$(echo "$sl_json" | jq -r --argjson port "$search_port" '
                ((.data["ingress-security-rules"] // [])[] |
                    select(
                        .protocol == "all" or
                        (.protocol == "6" and .["tcp-options"]["destination-port-range"] and
                            (.["tcp-options"]["destination-port-range"]["min"] <= $port) and
                            (.["tcp-options"]["destination-port-range"]["max"] >= $port)) or
                        (.protocol == "17" and .["udp-options"]["destination-port-range"] and
                            (.["udp-options"]["destination-port-range"]["min"] <= $port) and
                            (.["udp-options"]["destination-port-range"]["max"] >= $port)) or
                        (.protocol == "6" and (.["tcp-options"] | not or .["tcp-options"]["destination-port-range"] | not)) or
                        (.protocol == "17" and (.["udp-options"] | not or .["udp-options"]["destination-port-range"] | not))
                    ) |
                    [
                        "INGRESS",
                        (if .protocol == "6" then "TCP"
                         elif .protocol == "17" then "UDP"
                         elif .protocol == "1" then "ICMP"
                         elif .protocol == "all" then "ALL"
                         else .protocol end),
                        (.source // "N/A"),
                        (if .["tcp-options"]["destination-port-range"] then
                            (if .["tcp-options"]["destination-port-range"]["min"] == .["tcp-options"]["destination-port-range"]["max"] then
                                "\(.["tcp-options"]["destination-port-range"]["min"])"
                            else
                                "\(.["tcp-options"]["destination-port-range"]["min"])-\(.["tcp-options"]["destination-port-range"]["max"])"
                            end)
                         elif .["udp-options"]["destination-port-range"] then
                            (if .["udp-options"]["destination-port-range"]["min"] == .["udp-options"]["destination-port-range"]["max"] then
                                "\(.["udp-options"]["destination-port-range"]["min"])"
                            else
                                "\(.["udp-options"]["destination-port-range"]["min"])-\(.["udp-options"]["destination-port-range"]["max"])"
                            end)
                         else "ALL" end),
                        (.description // "-"),
                        (if .protocol == "all" then "ALL-PROTO" else "" end)
                    ] | @tsv),
                ((.data["egress-security-rules"] // [])[] |
                    select(
                        .protocol == "all" or
                        (.protocol == "6" and .["tcp-options"]["destination-port-range"] and
                            (.["tcp-options"]["destination-port-range"]["min"] <= $port) and
                            (.["tcp-options"]["destination-port-range"]["max"] >= $port)) or
                        (.protocol == "17" and .["udp-options"]["destination-port-range"] and
                            (.["udp-options"]["destination-port-range"]["min"] <= $port) and
                            (.["udp-options"]["destination-port-range"]["max"] >= $port)) or
                        (.protocol == "6" and (.["tcp-options"] | not or .["tcp-options"]["destination-port-range"] | not)) or
                        (.protocol == "17" and (.["udp-options"] | not or .["udp-options"]["destination-port-range"] | not))
                    ) |
                    [
                        "EGRESS",
                        (if .protocol == "6" then "TCP"
                         elif .protocol == "17" then "UDP"
                         elif .protocol == "1" then "ICMP"
                         elif .protocol == "all" then "ALL"
                         else .protocol end),
                        (.destination // "N/A"),
                        (if .["tcp-options"]["destination-port-range"] then
                            (if .["tcp-options"]["destination-port-range"]["min"] == .["tcp-options"]["destination-port-range"]["max"] then
                                "\(.["tcp-options"]["destination-port-range"]["min"])"
                            else
                                "\(.["tcp-options"]["destination-port-range"]["min"])-\(.["tcp-options"]["destination-port-range"]["max"])"
                            end)
                         elif .["udp-options"]["destination-port-range"] then
                            (if .["udp-options"]["destination-port-range"]["min"] == .["udp-options"]["destination-port-range"]["max"] then
                                "\(.["udp-options"]["destination-port-range"]["min"])"
                            else
                                "\(.["udp-options"]["destination-port-range"]["min"])-\(.["udp-options"]["destination-port-range"]["max"])"
                            end)
                         else "ALL" end),
                        (.description // "-"),
                        (if .protocol == "all" then "ALL-PROTO" else "" end)
                    ] | @tsv)
            ' 2>/dev/null)
            
            if [[ -n "$sl_matching" ]]; then
                if [[ $sl_header_printed -eq 0 ]]; then
                    printf "${BOLD}%-9s | %-8s | %-35s | %-11s | %-10s | %s${NC}\n" \
                        "Direction" "Protocol" "Source/Destination" "Dst Ports" "Match Type" "Description"
                    printf "${WHITE}%-9s-+-%-8s-+-%-35s-+-%-11s-+-%-10s-+-%s${NC}\n" \
                        "---------" "--------" "-----------------------------------" "-----------" "----------" "-------------------------------------------"
                    sl_header_printed=1
                fi
                
                echo ""
                echo -e "  ${BOLD}${CYAN}SL: ${GREEN}${sl_name}${NC}"
                
                while IFS=$'\t' read -r direction proto src_dst dst_ports desc match_type; do
                    [[ -z "$direction" ]] && continue
                    ((found_count++))
                    ((sl_found++))
                    local dir_color="$GREEN"
                    [[ "$direction" == "EGRESS" ]] && dir_color="$RED"
                    
                    local match_label="${CYAN}EXACT${NC}"
                    if [[ "$proto" == "ALL" || "$match_type" == "ALL-PROTO" ]]; then
                        match_label="${YELLOW}ALL-PROTO${NC}"
                    elif [[ "$dst_ports" == "ALL" ]]; then
                        match_label="${YELLOW}ALL-PORTS${NC}"
                    fi
                    
                    printf "  ${dir_color}%-9s${NC} | ${WHITE}%-8s${NC} | %-35s | %-11s | ${match_label}%-1s${NC} | ${GRAY}%s${NC}\n" \
                        "$direction" "$proto" "${src_dst:0:35}" "$dst_ports" "" "${desc:0:43}"
                done <<< "$sl_matching"
            fi
        done < "$SL_CACHE"
    fi
    
    if [[ $sl_header_printed -eq 0 ]]; then
        echo -e "  ${GRAY}(No matching security list rules found)${NC}"
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}Summary:${NC} Found ${GREEN}${found_count}${NC} rule(s) matching port ${CYAN}${search_port}${NC}"
    echo -e "${GRAY}Match types: ${CYAN}EXACT${NC}=port explicitly listed  ${YELLOW}ALL-PORTS${NC}=protocol allows all ports  ${YELLOW}ALL-PROTO${NC}=all traffic allowed${NC}"
    echo ""
}

#--------------------------------------------------------------------------------
# Manage Network Resources - Display subnets and NSGs with numbered selections
#--------------------------------------------------------------------------------
manage_network_resources() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    local network_compartment_id="$compartment_id"
    local variables_file="${VARIABLES_FILE:-./variables.sh}"
    
    # Check if NETWORK_COMPARTMENT_ID is already defined
    if [[ -n "$NETWORK_COMPARTMENT_ID" ]]; then
        network_compartment_id="$NETWORK_COMPARTMENT_ID"
    fi
    
    # Pre-cache compartment names to avoid "Unknown" in all sub-menus
    if [[ -n "$compartment_id" ]]; then
        resolve_compartment_name "$compartment_id" >/dev/null 2>&1
    fi
    if [[ -n "$network_compartment_id" && "$network_compartment_id" != "$compartment_id" ]]; then
        resolve_compartment_name "$network_compartment_id" >/dev/null 2>&1
    fi
    
    # Initialize resource index maps for this menu
    declare -gA NET_RESOURCE_MAP=()
    local resource_idx=0
    
    echo ""
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${CYAN}                                                       NETWORK RESOURCES MANAGEMENT                                                                     ${NC}"
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    _display_cache_info \
        "${NETWORK_RESOURCES_CACHE}|Subnets|SUBNET" \
        "${NETWORK_RESOURCES_CACHE}|NSGs|NSG" \
        "${RT_CACHE}|Routes" \
        "${NSG_RULES_CACHE}|NSG Rules" \
        "${SL_CACHE}|Security Lists" \
        "${IGW_CACHE}|IGW" \
        "${NAT_CACHE}|NAT" \
        "${SGW_CACHE}|SGW" \
        "${DRG_CACHE}|DRG" \
        "${LPG_CACHE}|LPG" \
        "${OS_PE_CACHE}|OS PEs"
    echo ""
    local stored_in_file=0
    if [[ -f "$variables_file" ]] && grep -q "^NETWORK_COMPARTMENT_ID=" "$variables_file" 2>/dev/null; then
        stored_in_file=1
    fi
    
    # If stored in variables.sh, use it silently without prompting
    if [[ $stored_in_file -eq 1 && -n "$NETWORK_COMPARTMENT_ID" ]]; then
        network_compartment_id="$NETWORK_COMPARTMENT_ID"
        # Get network compartment name for display
        local net_comp_name
        net_comp_name=$(resolve_compartment_name "$NETWORK_COMPARTMENT_ID")
        echo -e "${GREEN}✓ Using network compartment from variables.sh: ${WHITE}$net_comp_name${NC}"
        echo ""
    else
        # Show network compartment selection UI
        echo -e "${BOLD}${WHITE}Network Compartment Selection${NC}"
        echo -e "${GRAY}Network resources (VCN, subnets, DRGs) may be in a different compartment.${NC}"
        echo ""
        
        # If NETWORK_COMPARTMENT_ID is set (but not from file), offer to use it
        if [[ -n "$NETWORK_COMPARTMENT_ID" ]]; then
            local net_comp_name
            net_comp_name=$(resolve_compartment_name "$NETWORK_COMPARTMENT_ID")
            echo -e "  ${CYAN}Current Network Compartment:${NC} ${WHITE}$net_comp_name${NC}"
            echo -e "  ${YELLOW}$NETWORK_COMPARTMENT_ID${NC}"
            echo ""
            echo -n -e "${CYAN}Use this network compartment? (Y/n): ${NC}"
            local use_stored
            read -r use_stored
            
            if [[ "$use_stored" == "n" || "$use_stored" == "N" ]]; then
                network_compartment_id="$compartment_id"  # Reset to current
            else
                echo -e "${GREEN}✓ Using network compartment${NC}"
                echo ""
            fi
        fi
        
        # If not using stored compartment, offer to select one
        if [[ -z "$NETWORK_COMPARTMENT_ID" ]] || [[ "$use_stored" == "n" || "$use_stored" == "N" ]]; then
            echo -n -e "${CYAN}Select a different network compartment? (y/N): ${NC}"
            local use_diff_comp
            read -r use_diff_comp
            
            if [[ "$use_diff_comp" == "y" || "$use_diff_comp" == "Y" ]]; then
                echo ""
                
                # Get tenancy ID
                local tenancy_id
                tenancy_id=$(get_tenancy_id_from_compartment "$compartment_id")
                
                # Use centralized compartment selector (show full OCID)
                if display_compartment_selector "$tenancy_id" "$compartment_id" "true"; then
                    echo -n -e "${CYAN}Select compartment number [Enter for current]: ${NC}"
                    local comp_choice
                    read -r comp_choice
                    
                    if [[ -n "$comp_choice" && -n "${COMP_IDX[$comp_choice]}" ]]; then
                        network_compartment_id="${COMP_IDX[$comp_choice]}"
                        
                        # Get compartment name for display
                        local selected_data="${COMP_MAP[$network_compartment_id]}"
                        local selected_name="${selected_data%%|*}"
                        echo -e "${GREEN}✓ Selected: ${WHITE}$selected_name${NC}"
                        
                        # Offer to save to variables.sh
                        echo ""
                        echo -n -e "${CYAN}Save this as default NETWORK_COMPARTMENT_ID in variables.sh? (Y/n): ${NC}"
                        local save_choice
                        read -r save_choice
                        
                        if [[ "$save_choice" != "n" && "$save_choice" != "N" ]]; then
                            # Update or add NETWORK_COMPARTMENT_ID in variables.sh
                            if [[ -f "$variables_file" ]]; then
                                if grep -q "^NETWORK_COMPARTMENT_ID=" "$variables_file" 2>/dev/null; then
                                    # Update existing
                                    sed -i "s|^NETWORK_COMPARTMENT_ID=.*|NETWORK_COMPARTMENT_ID=\"$network_compartment_id\"|" "$variables_file"
                                    echo -e "${GREEN}✓ Updated NETWORK_COMPARTMENT_ID in $variables_file${NC}"
                            else
                                # Append new
                                echo "" >> "$variables_file"
                                echo "# Network compartment for VCN/Subnet/DRG resources" >> "$variables_file"
                                echo "NETWORK_COMPARTMENT_ID=\"$network_compartment_id\"" >> "$variables_file"
                                echo -e "${GREEN}✓ Added NETWORK_COMPARTMENT_ID to $variables_file${NC}"
                            fi
                        else
                            # Create new file
                            echo "#!/bin/bash" > "$variables_file"
                            echo "# Network compartment for VCN/Subnet/DRG resources" >> "$variables_file"
                            echo "NETWORK_COMPARTMENT_ID=\"$network_compartment_id\"" >> "$variables_file"
                            echo -e "${GREEN}✓ Created $variables_file with NETWORK_COMPARTMENT_ID${NC}"
                        fi
                        
                        # Export for current session
                        export NETWORK_COMPARTMENT_ID="$network_compartment_id"
                    fi
                fi
            else
                echo -e "${YELLOW}Could not load compartments. Using current compartment.${NC}"
            fi
            echo ""
        fi
    fi
    fi  # End of outer stored_in_file check
    
    # Get compartment names for display
    local comp_name net_comp_name_display
    comp_name=$(resolve_compartment_name "$compartment_id")
    
    echo -e "${BOLD}${WHITE}Environment:${NC}"
    echo -e "  ${CYAN}Region:${NC}              ${WHITE}${region}${NC}"
    echo -e "  ${CYAN}Compartment:${NC}         ${WHITE}${comp_name}${NC} ${YELLOW}(${compartment_id})${NC}"
    if [[ "$network_compartment_id" != "$compartment_id" ]]; then
        net_comp_name_display=$(resolve_compartment_name "$network_compartment_id")
        echo -e "  ${CYAN}Network Compartment:${NC} ${WHITE}${net_comp_name_display}${NC} ${YELLOW}(${network_compartment_id})${NC}"
    fi
    echo ""
    
    # VCN is in the main compartment ($compartment_id)
    local vcn_compartment_id="$compartment_id"
    
    # Get VCN info from OKE environment cache
    fetch_oke_environment "$compartment_id" "$region"
    local vcn_ocid vcn_name
    vcn_ocid=$(get_oke_env_value "VCN_OCID")
    vcn_name=$(get_oke_env_value "VCN_NAME")
    
    if [[ -z "$vcn_ocid" || "$vcn_ocid" == "N/A" ]]; then
        # Try listing VCNs in the main compartment
        echo -e "${GRAY}No OKE VCN found. Listing VCNs in compartment...${NC}"
        local vcn_list
        vcn_list=$(oci network vcn list --compartment-id "$compartment_id" --all --output json 2>/dev/null)
        
        # If no VCNs in main compartment and network compartment is different, try there
        if { [[ -z "$vcn_list" ]] || ! echo "$vcn_list" | jq -e '.data[0]' > /dev/null 2>&1; } && [[ "$network_compartment_id" != "$compartment_id" ]]; then
            echo -e "${GRAY}No VCNs in main compartment, trying network compartment...${NC}"
            vcn_list=$(oci network vcn list --compartment-id "$network_compartment_id" --all --output json 2>/dev/null)
            [[ -n "$vcn_list" ]] && vcn_compartment_id="$network_compartment_id"
        fi
        
        if [[ -n "$vcn_list" ]] && echo "$vcn_list" | jq -e '.data[0]' > /dev/null 2>&1; then
            local vcn_count
            vcn_count=$(echo "$vcn_list" | jq '.data | length')
            
            if [[ "$vcn_count" -eq 1 ]]; then
                vcn_ocid=$(echo "$vcn_list" | jq -r '.data[0].id')
                vcn_name=$(echo "$vcn_list" | jq -r '.data[0]["display-name"]')
            else
                echo ""
                echo -e "${WHITE}Multiple VCNs found. Select one:${NC}"
                local vcn_idx=0
                declare -A VCN_SELECT_MAP
                
                while IFS='|' read -r v_id v_name v_cidr; do
                    [[ -z "$v_id" ]] && continue
                    ((vcn_idx++))
                    VCN_SELECT_MAP[$vcn_idx]="$v_id|$v_name"
                    printf "  ${YELLOW}%2d${NC}) %-35s ${GRAY}[%s]${NC}\n" "$vcn_idx" "$v_name" "$v_cidr"
                done < <(echo "$vcn_list" | jq -r '.data[] | "\(.id)|\(.["display-name"])|\(.["cidr-block"])"')
                
                echo ""
                echo -n -e "${CYAN}Select VCN [1]: ${NC}"
                local vcn_choice
                read -r vcn_choice
                [[ -z "$vcn_choice" ]] && vcn_choice=1
                
                if [[ -n "${VCN_SELECT_MAP[$vcn_choice]}" ]]; then
                    vcn_ocid="${VCN_SELECT_MAP[$vcn_choice]%%|*}"
                    vcn_name="${VCN_SELECT_MAP[$vcn_choice]#*|}"
                fi
            fi
        fi
        
        if [[ -z "$vcn_ocid" ]]; then
            echo -e "${YELLOW}No VCN found in compartment.${NC}"
            echo ""
            echo -e "Press Enter to return..."
            read -r
            return
        fi
    fi
    
    # Get the VCN's actual compartment
    local vcn_actual_comp
    vcn_actual_comp=$(oci network vcn get --vcn-id "$vcn_ocid" --query 'data."compartment-id"' --raw-output 2>/dev/null)
    [[ -n "$vcn_actual_comp" ]] && vcn_compartment_id="$vcn_actual_comp"
    
    # Fetch network resources - uses cache with TTL (1 hour)
    # Use 'refresh' command to force invalidation
    fetch_network_resources "$vcn_compartment_id" "$vcn_ocid"
    fetch_all_network_gateways "$vcn_compartment_id" "$vcn_ocid"
    
    # Show cache status
    local _cache_age_display=""
    if [[ -f "$NETWORK_RESOURCES_CACHE" ]]; then
        local _cache_mtime _cache_age_secs
        _cache_mtime=$(stat -c %Y "$NETWORK_RESOURCES_CACHE" 2>/dev/null || echo 0)
        _cache_age_secs=$(( $(date +%s) - _cache_mtime ))
        if [[ $_cache_age_secs -lt 60 ]]; then
            _cache_age_display="just now"
        elif [[ $_cache_age_secs -lt 3600 ]]; then
            _cache_age_display="$((_cache_age_secs / 60))m ago"
        else
            _cache_age_display="$((_cache_age_secs / 3600))h $(( (_cache_age_secs % 3600) / 60 ))m ago"
        fi
    fi
    
    echo ""
    
    # 1. VCN
    ((resource_idx++))
    NET_RESOURCE_MAP[$resource_idx]="VCN|$vcn_ocid"
    printf "  ${YELLOW}%2d${NC}) ${BOLD}${MAGENTA}VCN:${NC} ${GREEN}%-35s${NC} ${YELLOW}%s${NC}\n" "$resource_idx" "$vcn_name" "$vcn_ocid"
    
    echo ""
    echo -e "  ${BOLD}${WHITE}── Subnets ──${NC}"
    
    # Subnets
    if [[ -f "$NETWORK_RESOURCES_CACHE" ]]; then
        while IFS='|' read -r type name cidr access state ocid rt_ocid sl_ids dns_label; do
            [[ "$type" != "SUBNET" ]] && continue
            ((resource_idx++))
            NET_RESOURCE_MAP[$resource_idx]="SUBNET|$ocid"
            
            local access_color
            [[ "$access" == "Private" ]] && access_color="$RED" || access_color="$LIGHT_GREEN"
            
            local dns_display=""
            [[ -n "$dns_label" ]] && dns_display=" DNS:$dns_label"
            
            printf "  ${YELLOW}%2d${NC}) ${WHITE}Subnet:${NC} ${GREEN}%-25s${NC} ${WHITE}[${CYAN}%-15s${WHITE}]${NC} ${WHITE}[${access_color}%-7s${WHITE}]${NC}${MAGENTA}%s${NC} ${YELLOW}%s${NC}\n" \
                "$resource_idx" "${name:0:25}" "${cidr:0:15}" "$access" "$dns_display" "$ocid"
        done < <(grep "^SUBNET|" "$NETWORK_RESOURCES_CACHE" 2>/dev/null)
    fi
    
    echo ""
    # Build mappings from Route Tables and Security Lists to Subnet names
    declare -A RT_TO_SUBNETS
    declare -A SL_TO_SUBNETS
    declare -A ASSIGNED_SL_IDS
    
    if [[ -f "$NETWORK_RESOURCES_CACHE" ]]; then
        while IFS='|' read -r type name cidr access state ocid rt_ocid sl_ids dns_label; do
            [[ "$type" != "SUBNET" ]] && continue
            if [[ -n "$rt_ocid" && "$rt_ocid" != "N/A" ]]; then
                if [[ -n "${RT_TO_SUBNETS[$rt_ocid]:-}" ]]; then
                    RT_TO_SUBNETS[$rt_ocid]="${RT_TO_SUBNETS[$rt_ocid]}, $name"
                else
                    RT_TO_SUBNETS[$rt_ocid]="$name"
                fi
            fi
            if [[ -n "$sl_ids" ]]; then
                IFS=',' read -ra sl_array <<< "$sl_ids"
                for sl_id in "${sl_array[@]}"; do
                    [[ -z "$sl_id" ]] && continue
                    ASSIGNED_SL_IDS["$sl_id"]=1
                    if [[ -n "${SL_TO_SUBNETS[$sl_id]:-}" ]]; then
                        SL_TO_SUBNETS[$sl_id]="${SL_TO_SUBNETS[$sl_id]}, $name"
                    else
                        SL_TO_SUBNETS[$sl_id]="$name"
                    fi
                done
            fi
        done < "$NETWORK_RESOURCES_CACHE"
    fi
    
    echo -e "  ${BOLD}${WHITE}── Network Security Groups ──${NC}"
    
    # NSGs
    if [[ -f "$NETWORK_RESOURCES_CACHE" ]]; then
        while IFS='|' read -r type name _ state ocid; do
            [[ "$type" != "NSG" ]] && continue
            ((resource_idx++))
            NET_RESOURCE_MAP[$resource_idx]="NSG|$ocid"
            local rule_counts ingress egress
            rule_counts=$(get_nsg_rule_counts "$ocid")
            ingress=$(echo "$rule_counts" | cut -d'|' -f1)
            egress=$(echo "$rule_counts" | cut -d'|' -f2)
            printf "  ${YELLOW}%2d${NC}) ${WHITE}NSG:${NC} ${CYAN}%-35s${NC} ${WHITE}[In:${GREEN}%-3s${WHITE} Out:${GREEN}%-3s${WHITE}]${NC} ${YELLOW}%s${NC}\n" \
                "$resource_idx" "$name" "$ingress" "$egress" "$ocid"
        done < <(grep "^NSG|" "$NETWORK_RESOURCES_CACHE" 2>/dev/null)
    fi
    
    echo ""
    echo -e "  ${BOLD}${WHITE}── Security Lists ──${NC}"
    
    local sl_count=0
    if [[ -f "$SL_CACHE" ]]; then
        while IFS='|' read -r sl_ocid sl_vcn sl_name sl_state sl_ingress sl_egress; do
            [[ -z "$sl_ocid" || "$sl_ocid" == "#"* ]] && continue
            [[ "$sl_vcn" != "$vcn_ocid" ]] && continue
            ((resource_idx++))
            ((sl_count++))
            NET_RESOURCE_MAP[$resource_idx]="SECURITY_LIST|$sl_ocid"
            local assigned_subnets="${SL_TO_SUBNETS[$sl_ocid]:-}"
            if [[ -n "$assigned_subnets" ]]; then
                printf "  ${YELLOW}%2d${NC}) ${WHITE}SL:${NC} ${MAGENTA}%-28s${NC} ${WHITE}[In:${GREEN}%-2s${WHITE} Out:${GREEN}%-2s${WHITE}]${NC} ${CYAN}→ %-20s${NC} ${YELLOW}%s${NC}\n" \
                    "$resource_idx" "${sl_name:0:28}" "$sl_ingress" "$sl_egress" "${assigned_subnets:0:20}" "$sl_ocid"
            else
                printf "  ${YELLOW}%2d${NC}) ${WHITE}SL:${NC} ${MAGENTA}%-28s${NC} ${WHITE}[In:${GREEN}%-2s${WHITE} Out:${GREEN}%-2s${WHITE}]${NC} ${GRAY}(unassigned)${NC}          ${YELLOW}%s${NC}\n" \
                    "$resource_idx" "${sl_name:0:28}" "$sl_ingress" "$sl_egress" "$sl_ocid"
            fi
        done < "$SL_CACHE"
    fi
    [[ $sl_count -eq 0 ]] && echo -e "  ${WHITE}(No security lists found)${NC}"
    
    echo ""
    echo -e "  ${BOLD}${WHITE}── Route Tables ──${NC}"
    
    if [[ -f "$RT_CACHE" ]]; then
        while IFS='|' read -r rt_ocid rt_vcn rt_name rt_state rt_rules; do
            [[ -z "$rt_ocid" || "$rt_ocid" == "#"* ]] && continue
            [[ "$rt_vcn" != "$vcn_ocid" ]] && continue
            ((resource_idx++))
            NET_RESOURCE_MAP[$resource_idx]="ROUTE_TABLE|$rt_ocid"
            local assigned_subnets="${RT_TO_SUBNETS[$rt_ocid]:-none}"
            printf "  ${YELLOW}%2d${NC}) ${WHITE}RT:${NC} ${MAGENTA}%-28s${NC} ${WHITE}[Rules:${GREEN}%-2s${WHITE}]${NC} ${WHITE}→${NC} ${CYAN}%-20s${NC} ${YELLOW}%s${NC}\n" \
                "$resource_idx" "${rt_name:0:28}" "$rt_rules" "${assigned_subnets:0:20}" "$rt_ocid"
        done < "$RT_CACHE"
    fi
    
    echo ""
    echo -e "  ${BOLD}${WHITE}── Gateways ──${NC}"
    
    # Internet Gateways
    if [[ -f "$IGW_CACHE" ]]; then
        while IFS='|' read -r igw_vcn igw_ocid igw_state igw_name; do
            [[ -z "$igw_ocid" || "$igw_vcn" != "$vcn_ocid" ]] && continue
            ((resource_idx++))
            NET_RESOURCE_MAP[$resource_idx]="GATEWAY|IGW|$igw_ocid"
            local state_color="$GREEN"; [[ "$igw_state" != "AVAILABLE" ]] && state_color="$RED"
            printf "  ${YELLOW}%2d${NC}) ${WHITE}Internet GW:${NC} ${ORANGE}%-30s${NC} ${WHITE}[${state_color}%-9s${WHITE}]${NC} ${YELLOW}%s${NC}\n" \
                "$resource_idx" "${igw_name:-N/A}" "$igw_state" "$igw_ocid"
        done < "$IGW_CACHE"
    fi
    # NAT Gateways
    if [[ -f "$NAT_CACHE" ]]; then
        while IFS='|' read -r nat_vcn nat_ocid nat_state nat_name; do
            [[ -z "$nat_ocid" || "$nat_vcn" != "$vcn_ocid" ]] && continue
            ((resource_idx++))
            NET_RESOURCE_MAP[$resource_idx]="GATEWAY|NAT|$nat_ocid"
            local state_color="$GREEN"; [[ "$nat_state" != "AVAILABLE" ]] && state_color="$RED"
            printf "  ${YELLOW}%2d${NC}) ${WHITE}NAT GW:${NC}      ${ORANGE}%-30s${NC} ${WHITE}[${state_color}%-9s${WHITE}]${NC} ${YELLOW}%s${NC}\n" \
                "$resource_idx" "${nat_name:-N/A}" "$nat_state" "$nat_ocid"
        done < "$NAT_CACHE"
    fi
    # Service Gateways
    if [[ -f "$SGW_CACHE" ]]; then
        while IFS='|' read -r sgw_vcn sgw_ocid sgw_state sgw_name; do
            [[ -z "$sgw_ocid" || "$sgw_vcn" != "$vcn_ocid" ]] && continue
            ((resource_idx++))
            NET_RESOURCE_MAP[$resource_idx]="GATEWAY|SGW|$sgw_ocid"
            local state_color="$GREEN"; [[ "$sgw_state" != "AVAILABLE" ]] && state_color="$RED"
            printf "  ${YELLOW}%2d${NC}) ${WHITE}Service GW:${NC}  ${ORANGE}%-30s${NC} ${WHITE}[${state_color}%-9s${WHITE}]${NC} ${YELLOW}%s${NC}\n" \
                "$resource_idx" "${sgw_name:-N/A}" "$sgw_state" "$sgw_ocid"
        done < "$SGW_CACHE"
    fi
    # Local Peering Gateways
    if [[ -f "$LPG_CACHE" ]]; then
        while IFS='|' read -r lpg_vcn lpg_ocid lpg_state lpg_peer lpg_name; do
            [[ -z "$lpg_ocid" || "$lpg_vcn" != "$vcn_ocid" ]] && continue
            ((resource_idx++))
            NET_RESOURCE_MAP[$resource_idx]="GATEWAY|LPG|$lpg_ocid"
            local state_color="$GREEN"; [[ "$lpg_state" != "AVAILABLE" ]] && state_color="$RED"
            printf "  ${YELLOW}%2d${NC}) ${WHITE}Local Peer GW:${NC} ${ORANGE}%-28s${NC} ${WHITE}[${state_color}%-9s${WHITE}]${NC} ${YELLOW}%s${NC}\n" \
                "$resource_idx" "${lpg_name:-N/A}" "$lpg_state" "$lpg_ocid"
        done < "$LPG_CACHE"
    fi
    
    
    echo ""
    echo -e "  ${BOLD}${WHITE}── DRGs & Attachments ──${NC}"
    
    declare -A SHOWN_DRGS
    declare -A DRG_DETAILS_CACHE
    
    # Step 1: Discover DRG attachments in the VCN compartment for THIS VCN
    echo -ne "  ${GRAY}Discovering DRG attachments for VCN...${NC}"
    
    local att_list_json
    att_list_json=$(oci network drg-attachment list --compartment-id "$vcn_compartment_id" --vcn-id "$vcn_ocid" --all --output json 2>/dev/null)
    
    local att_found=0
    declare -A UNIQUE_DRG_IDS
    
    if [[ -n "$att_list_json" ]] && echo "$att_list_json" | jq -e '.data[0]' > /dev/null 2>&1; then
        # Extract unique DRG IDs from attachments
        while IFS= read -r drg_id_from_att; do
            [[ -z "$drg_id_from_att" ]] && continue
            UNIQUE_DRG_IDS["$drg_id_from_att"]=1
            att_found=1
        done < <(echo "$att_list_json" | jq -r '.data[] | select(.["lifecycle-state"] != "DETACHED" and .["lifecycle-state"] != "DETACHING") | .["drg-id"]' 2>/dev/null | sort -u)
    fi
    
    echo -ne "\r                                                                              \r"
    
    if [[ $att_found -eq 0 ]]; then
        echo -e "  ${GRAY}(No DRG attachments found for this VCN)${NC}"
    else
        # Step 2: For each unique DRG, resolve details (tries drg get, then drg list in all compartments)
        for drg_id in "${!UNIQUE_DRG_IDS[@]}"; do
            [[ -z "$drg_id" ]] && continue
            [[ -n "${SHOWN_DRGS[$drg_id]}" ]] && continue
            
            local drg_name="" drg_comp="" drg_state="" drg_get_ok=0
            
            # Use helper: tries drg get --region, then drg list in main + network compartments
            resolve_drg_details "$drg_id" "$region" "$compartment_id" "$network_compartment_id"
            drg_name="$_DRG_NAME"
            drg_comp="$_DRG_COMP"
            drg_state="$_DRG_STATE"
            drg_get_ok=$_DRG_RESOLVED
            
            DRG_DETAILS_CACHE[$drg_id]="$drg_name|$drg_comp|$drg_state"
            SHOWN_DRGS[$drg_id]=1
            
            # Display the DRG
            ((resource_idx++))
            NET_RESOURCE_MAP[$resource_idx]="GATEWAY|DRG|$drg_id"
            
            local state_color="$GREEN"
            [[ "$drg_state" != "AVAILABLE" ]] && state_color="$YELLOW"
            [[ "$drg_state" == "N/A" ]] && state_color="$GRAY"
            
            local drg_comp_name
            drg_comp_name=$(resolve_compartment_name "$drg_comp")
            
            # Count all attachments - search compartment-based (cross-compartment safe)
            local att_count=0
            for _c in "$compartment_id" "$network_compartment_id"; do
                [[ -z "$_c" ]] && continue
                local _ac
                _ac=$(oci network drg-attachment list --compartment-id "$_c" --all --output json 2>/dev/null \
                    | jq --arg drg "$drg_id" '[.data[] | select(.["drg-id"] == $drg and .["lifecycle-state"] != "DETACHED")] | length' 2>/dev/null)
                [[ -n "$_ac" && "$_ac" =~ ^[0-9]+$ ]] && att_count=$((att_count + _ac))
            done
            # Fallback: if compartment search found 0, try --drg-id directly
            if [[ "$att_count" -eq 0 ]]; then
                local _drg_ac
                _drg_ac=$(oci network drg-attachment list --drg-id "$drg_id" --region "$region" --all --output json 2>/dev/null \
                    | jq '[.data[] | select(.["lifecycle-state"] != "DETACHED")] | length' 2>/dev/null)
                [[ -n "$_drg_ac" && "$_drg_ac" =~ ^[0-9]+$ ]] && att_count=$_drg_ac
            fi
            
            printf "  ${YELLOW}%2d${NC}) ${WHITE}DRG:${NC} ${ORANGE}%-28s${NC} ${WHITE}[${state_color}%-9s${WHITE}]${NC} ${CYAN}[${att_count} attach]${NC} ${YELLOW}%s${NC}\n" \
                "$resource_idx" "${drg_name:0:28}" "$drg_state" "$drg_id"
            printf "      ${GRAY}Compartment: ${WHITE}%s${NC} ${GRAY}(%s)${NC}\n" "$drg_comp_name" "$drg_comp"
            
            # Show VCN attachments for this DRG (from the attachment list we already have)
            while IFS='|' read -r att_id att_name att_state att_comp att_drg att_type att_vcn_id; do
                [[ -z "$att_id" ]] && continue
                [[ "$att_drg" != "$drg_id" ]] && continue
                [[ "$att_state" == "DETACHED" || "$att_state" == "DETACHING" ]] && continue
                
                ((resource_idx++))
                NET_RESOURCE_MAP[$resource_idx]="DRG_ATTACHMENT|$att_id"
                
                local att_state_color="$GREEN"
                [[ "$att_state" != "ATTACHED" ]] && att_state_color="$YELLOW"
                
                # Resolve VCN name
                local att_target=""
                if [[ "$att_type" == "VCN" && -n "$att_vcn_id" && "$att_vcn_id" != "N/A" ]]; then
                    local vcn_display
                    if [[ "$att_vcn_id" == "$vcn_ocid" ]]; then
                        vcn_display="$vcn_name"
                    else
                        vcn_display=$(oci network vcn get --vcn-id "$att_vcn_id" --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                    fi
                    [[ -n "$vcn_display" ]] && att_target=" → VCN: $vcn_display"
                fi
                
                printf "  ${YELLOW}%2d${NC})   ${WHITE}└─ Attach:${NC} ${CYAN}%-22s${NC} ${WHITE}[${att_state_color}%-8s${WHITE}]${NC} ${WHITE}%-4s${NC}${GREEN}%-22s${NC} ${YELLOW}%s${NC}\n" \
                    "$resource_idx" "${att_name:0:22}" "$att_state" "$att_type" "${att_target:0:22}" "$att_id"
            done < <(echo "$att_list_json" | jq -r '.data[] | "\(.id)|\(.["display-name"] // "N/A")|\(.["lifecycle-state"])|\(.["compartment-id"])|\(.["drg-id"])|\(.["attachment-type"] // "VCN")|\(.["network-details"]["id"] // .["vcn-id"] // "N/A")"' 2>/dev/null)
            
            echo ""
        done
    fi
    
    # Also check DRG_CACHE for any DRGs not found via attachment list
    if [[ -f "$DRG_CACHE" ]]; then
        while IFS='|' read -r drg_vcn drg_id drg_att_state drg_att_name; do
            [[ -z "$drg_id" || "$drg_vcn" != "$vcn_ocid" ]] && continue
            [[ -n "${SHOWN_DRGS[$drg_id]}" ]] && continue
            
            resolve_drg_details "$drg_id" "$region" "$compartment_id" "$network_compartment_id"
            local drg_name="$_DRG_NAME" drg_comp="$_DRG_COMP" drg_state="$_DRG_STATE"
            
            DRG_DETAILS_CACHE[$drg_id]="$drg_name|$drg_comp|$drg_state"
            SHOWN_DRGS[$drg_id]=1
            
            ((resource_idx++))
            NET_RESOURCE_MAP[$resource_idx]="GATEWAY|DRG|$drg_id"
            
            local state_color="$GREEN"; [[ "$drg_state" != "AVAILABLE" ]] && state_color="$YELLOW"
            local drg_comp_name; drg_comp_name=$(resolve_compartment_name "$drg_comp")
            
            printf "  ${YELLOW}%2d${NC}) ${WHITE}DRG:${NC} ${ORANGE}%-28s${NC} ${WHITE}[${state_color}%-9s${WHITE}]${NC} ${GRAY}(from cache)${NC} ${YELLOW}%s${NC}\n" \
                "$resource_idx" "${drg_name:0:28}" "$drg_state" "$drg_id"
            printf "      ${GRAY}Compartment: ${WHITE}%s${NC} ${GRAY}(%s)${NC}\n" "$drg_comp_name" "$drg_comp"
            echo ""
        done < "$DRG_CACHE"
    fi
    
    # ========== OBJECT STORAGE PRIVATE ENDPOINTS ==========
    echo ""
    echo -e "  ${BOLD}${WHITE}── Object Storage Private Endpoints ──${NC}"
    
    # Fetch and cache OS Private Endpoints (pass both compartments in one call)
    echo -ne "  ${GRAY}Checking Object Storage Private Endpoints...${NC}"
    fetch_os_private_endpoints "$compartment_id" "$network_compartment_id"
    echo -ne "\r                                                                              \r"
    
    local os_pe_found=0
    declare -A SHOWN_PE_NAMES
    
    if [[ -f "$OS_PE_CACHE" ]]; then
        while IFS='|' read -r pe_name pe_namespace pe_state pe_prefix pe_subnet_id pe_private_ip pe_ocid pe_nsg_ids pe_comp pe_time_created; do
            [[ "$pe_name" =~ ^#.*$ ]] && continue
            [[ -z "$pe_name" ]] && continue
            # Deduplicate by name+namespace
            [[ -n "${SHOWN_PE_NAMES[${pe_name}|${pe_namespace}]:-}" ]] && continue
            SHOWN_PE_NAMES["${pe_name}|${pe_namespace}"]=1
            
            ((os_pe_found++))
            ((resource_idx++))
            # Store name|namespace for detail view lookup
            NET_RESOURCE_MAP[$resource_idx]="OS_PE|${pe_name}|${pe_namespace}"
            
            # State coloring
            local pe_state_color="$GREEN"
            case "$pe_state" in
                ACTIVE) pe_state_color="$GREEN" ;;
                CREATING|UPDATING) pe_state_color="$YELLOW" ;;
                DELETING|DELETED|FAILED) pe_state_color="$RED" ;;
                *) pe_state_color="$GRAY" ;;
            esac
            
            # Resolve subnet name
            local pe_subnet_name="N/A"
            if [[ -n "$pe_subnet_id" && "$pe_subnet_id" != "N/A" && "$pe_subnet_id" != "null" ]]; then
                # Try to get from NETWORK_RESOURCES_CACHE first (already fetched)
                if [[ -f "$NETWORK_RESOURCES_CACHE" ]]; then
                    pe_subnet_name=$(grep "^SUBNET|" "$NETWORK_RESOURCES_CACHE" 2>/dev/null | awk -F'|' -v id="$pe_subnet_id" '$6 == id { print $2; exit }')
                fi
                # Fallback to OCI API if not in cache
                if [[ -z "$pe_subnet_name" || "$pe_subnet_name" == "N/A" ]]; then
                    pe_subnet_name=$(oci network subnet get --subnet-id "$pe_subnet_id" --query 'data."display-name"' --raw-output 2>/dev/null || echo "N/A")
                fi
            fi
            
            # Count NSGs
            local nsg_count=0
            if [[ -n "$pe_nsg_ids" && "$pe_nsg_ids" != "null" ]]; then
                nsg_count=$(echo "$pe_nsg_ids" | tr ',' '\n' | grep -c '.' 2>/dev/null || echo 0)
            fi
            
            # Prefix display
            local prefix_display=""
            [[ -n "$pe_prefix" && "$pe_prefix" != "N/A" && "$pe_prefix" != "null" ]] && prefix_display=" Pfx:${pe_prefix}"
            
            # NSG count display
            local nsg_display=""
            [[ "$nsg_count" -gt 0 ]] && nsg_display=" [${nsg_count} NSG]"
            
            printf "  ${YELLOW}%2d${NC}) ${WHITE}OS-PE:${NC} ${GREEN}%-25s${NC} ${WHITE}[${pe_state_color}%-8s${WHITE}]${NC} ${WHITE}IP:${NC} ${CYAN}%-15s${NC} ${WHITE}Sub:${NC} ${CYAN}%-20s${NC}${MAGENTA}%s${NC}${GRAY}%s${NC}\n" \
                "$resource_idx" "${pe_name:0:25}" "$pe_state" "$pe_private_ip" "${pe_subnet_name:0:20}" "$prefix_display" "$nsg_display"
            printf "      ${GRAY}Namespace: ${WHITE}%s${NC}  ${GRAY}OCID: ${YELLOW}%s${NC}\n" "$pe_namespace" "$pe_ocid"
            
        done < <(grep -v '^#' "$OS_PE_CACHE" 2>/dev/null)
    fi
    
    if [[ $os_pe_found -eq 0 ]]; then
        echo -e "  ${GRAY}(No Object Storage Private Endpoints found)${NC}"
    fi
    
    local max_idx=$resource_idx
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
    if [[ $max_idx -gt 0 ]]; then
        echo -e "  ${YELLOW}1-${max_idx}${NC}       - View resource details"
    fi
    echo -e "  ${CYAN}search${NC}    - Search NSGs and Security Lists for a specific port"
    echo -e "  ${CYAN}drg${NC}       - DRG & Connectivity (Remote Peering, FastConnect, VPN)"
    echo -e "  ${MAGENTA}r${NC}         - Refresh network resources data"
    echo -e "  ${CYAN}back${NC}      - Return to main menu"
    echo ""
    
    while true; do
        local prompt_range=""
        [[ $max_idx -gt 0 ]] && prompt_range="1-${max_idx}, "
        echo -n -e "${BOLD}${CYAN}[Network Resources] Enter # or command [${prompt_range}search/drg/r/back]: ${NC}"
        local input
        read -r input
        
        # Empty input goes back
        if [[ -z "$input" ]]; then
            return
        fi
        
        # Check if it's a number
        if [[ "$input" =~ ^[0-9]+$ ]]; then
            if [[ $input -ge 1 && $input -le $max_idx ]]; then
                local resource_info="${NET_RESOURCE_MAP[$input]}"
                view_network_resource_detail "$resource_info"
            else
                echo -e "${RED}Invalid selection. Enter 1-${max_idx}.${NC}"
            fi
        else
            case "$input" in
                search|SEARCH|search\ *|SEARCH\ *)
                    local port_num=""
                    if [[ "$input" == search\ * || "$input" == SEARCH\ * ]]; then
                        port_num="${input#* }"
                    fi
                    if [[ -z "$port_num" ]]; then
                        echo -n -e "${CYAN}Enter port number to search for: ${NC}"
                        read -r port_num
                    fi
                    if [[ "$port_num" =~ ^[0-9]+$ ]] && [[ "$port_num" -ge 1 && "$port_num" -le 65535 ]]; then
                        search_port_in_rules "$port_num"
                    else
                        echo -e "${RED}Invalid port number: ${port_num} (valid: 1-65535)${NC}"
                    fi
                    ;;
                drg|DRG|d|D)
                    manage_drg_connectivity "$vcn_ocid" "$vcn_compartment_id" "$network_compartment_id"
                    ;;
                r|R|refresh|REFRESH)
                    echo -e "${YELLOW}Refreshing network resources cache...${NC}"
                    rm -f "$NETWORK_RESOURCES_CACHE" "$RT_CACHE" "$IGW_CACHE" "$NAT_CACHE" "$SGW_CACHE" "$DRG_CACHE" "$LPG_CACHE" "$NSG_RULES_CACHE" "$SL_CACHE" "$OS_PE_CACHE"
                    rm -rf "$NSG_RULES_DETAIL_DIR"
                    manage_network_resources
                    return
                    ;;
                back|BACK|b|B|q|Q)
                    return
                    ;;
                *)
                    echo -e "${RED}Unknown command. Enter a number (1-${max_idx}), 'drg', 'r', or 'back'.${NC}"
                    ;;
            esac
        fi
    done
}

#--------------------------------------------------------------------------------
# Manage DRG Connectivity - DRGs, Remote Peering, FastConnect, VPN
#--------------------------------------------------------------------------------
#--------------------------------------------------------------------------------
display_drg_connectivity_map() {
    local drg_id="$1"
    local drg_name="$2"
    local drg_comp="$3"
    local region="$4"
    shift 4
    local search_comps=("$@")
    
    # Build deduped compartment list (drg_comp + search_comps)
    local -a all_comps=()
    local -A seen_comps=()
    for c in "$drg_comp" "${search_comps[@]}"; do
        [[ -z "$c" || -n "${seen_comps[$c]+x}" ]] && continue
        all_comps+=("$c")
        seen_comps[$c]=1
    done
    
    local drg_comp_name
    drg_comp_name=$(resolve_compartment_name "$drg_comp")
    
    # Box drawing characters
    local TL="┌" TR="┐" BL="└" BR="┘" H="─" V="│" LT="├" RT="┤"
    local box_width=120
    
    echo -ne "${GRAY}  Building topology for ${drg_name}...${NC}"
    
    #==========================================================================
    # Phase 1: Gather DRG metadata + all connectivity data
    #==========================================================================
    
    # --- DRG Details: state, redundancy, export distribution ---
    local drg_state="N/A" drg_redundancy="N/A"
    local drg_export_dist_name="" drg_export_dist_type="" drg_export_dist_id=""
    local drg_export_dist_stmts="[]"
    local drg_json
    drg_json=$(oci network drg get --drg-id "$drg_id" --region "$region" --output json 2>/dev/null)
    if [[ -n "$drg_json" ]] && echo "$drg_json" | jq -e '.data' >/dev/null 2>&1; then
        drg_state=$(echo "$drg_json" | jq -r '.data["lifecycle-state"] // "N/A"' 2>/dev/null)
        
        # Default export route distribution
        drg_export_dist_id=$(echo "$drg_json" | jq -r '.data["default-export-drg-route-distribution-id"] // ""' 2>/dev/null)
        if [[ -n "$drg_export_dist_id" && "$drg_export_dist_id" != "null" ]]; then
            local _ed_json
            _ed_json=$(oci network drg-route-distribution get --drg-route-distribution-id "$drg_export_dist_id" \
                --region "$region" --output json 2>/dev/null)
            if [[ -n "$_ed_json" ]] && echo "$_ed_json" | jq -e '.data' >/dev/null 2>&1; then
                drg_export_dist_name=$(echo "$_ed_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                drg_export_dist_type=$(echo "$_ed_json" | jq -r '.data["distribution-type"] // "N/A"' 2>/dev/null)
            fi
            local _ed_stmt_json
            _ed_stmt_json=$(oci network drg-route-distribution-statement list --route-distribution-id "$drg_export_dist_id" --all \
                --region "$region" --output json 2>/dev/null)
            if [[ -n "$_ed_stmt_json" ]]; then
                drg_export_dist_stmts=$(echo "$_ed_stmt_json" | jq '.data // .items // []' 2>/dev/null)
            fi
        fi
    fi
    
    # Redundancy via dedicated API
    local redund_json
    redund_json=$(oci network drg-redundancy-status get --drg-id "$drg_id" --region "$region" --output json 2>/dev/null)
    if [[ -n "$redund_json" ]] && echo "$redund_json" | jq -e '.data' >/dev/null 2>&1; then
        drg_redundancy=$(echo "$redund_json" | jq -r '.data.status // "N/A"' 2>/dev/null)
    fi
    
    # --- DRG Route Tables (cache for lookups) ---
    declare -A DRT_NAME_CACHE DRT_RULES_CACHE
    local drt_json
    drt_json=$(oci network drg-route-table list --drg-id "$drg_id" --region "$region" --all --output json 2>/dev/null)
    if [[ -n "$drt_json" ]] && echo "$drt_json" | jq -e '.data[0]' >/dev/null 2>&1; then
        while IFS='|' read -r drt_id drt_name drt_import_dist; do
            [[ -z "$drt_id" ]] && continue
            DRT_NAME_CACHE[$drt_id]="$drt_name"
            # Get route rules count for this table
            local rules_json
            rules_json=$(oci network drg-route-rule list --drg-route-table-id "$drt_id" --region "$region" --output json 2>/dev/null)
            local rule_count=0
            if [[ -n "$rules_json" ]]; then
                rule_count=$(echo "$rules_json" | jq '(.data // .items // []) | length' 2>/dev/null || echo "0")
            fi
            DRT_RULES_CACHE[$drt_id]="$rule_count"
        done < <(echo "$drt_json" | jq -r '.data[] | "\(.id)|\(.["display-name"])|\(.["import-drg-route-distribution-id"] // "")"' 2>/dev/null)
    fi
    
    # --- VCN Attachments: search each compartment, filter by drg-id ---
    local all_attachments="[]"
    for comp in "${all_comps[@]}"; do
        local att_json
        att_json=$(oci network drg-attachment list --compartment-id "$comp" --region "$region" --all --output json 2>/dev/null)
        if [[ -n "$att_json" ]] && echo "$att_json" | jq -e '.data[0]' >/dev/null 2>&1; then
            local filtered
            filtered=$(echo "$att_json" | jq --arg drg "$drg_id" '[.data[] | select(.["drg-id"] == $drg)]' 2>/dev/null)
            if [[ -n "$filtered" && "$filtered" != "[]" ]]; then
                all_attachments=$(jq -n --argjson a "$all_attachments" --argjson b "$filtered" '$a + $b | unique_by(.id)' 2>/dev/null)
            fi
        fi
    done
    
    # --- RPCs: search each compartment ---
    local all_rpcs="[]"
    for comp in "${all_comps[@]}"; do
        local rpc_json
        rpc_json=$(oci network remote-peering-connection list --compartment-id "$comp" --drg-id "$drg_id" --region "$region" --output json 2>/dev/null)
        if [[ -n "$rpc_json" ]] && echo "$rpc_json" | jq -e '.data[0]' >/dev/null 2>&1; then
            all_rpcs=$(jq -n --argjson a "$all_rpcs" --argjson b "$(echo "$rpc_json" | jq '.data')" '$a + $b | unique_by(.id)' 2>/dev/null)
        fi
    done
    
    # --- IPSec VPN: search each compartment ---
    local all_ipsec="[]"
    for comp in "${all_comps[@]}"; do
        local ipsec_json
        ipsec_json=$(oci network ip-sec-connection list --compartment-id "$comp" --drg-id "$drg_id" --region "$region" --output json 2>/dev/null)
        if [[ -n "$ipsec_json" ]] && echo "$ipsec_json" | jq -e '.data[0]' >/dev/null 2>&1; then
            all_ipsec=$(jq -n --argjson a "$all_ipsec" --argjson b "$(echo "$ipsec_json" | jq '.data')" '$a + $b | unique_by(.id)' 2>/dev/null)
        fi
    done
    
    # --- FastConnect: search each compartment, filter by gateway-id ---
    local all_fc="[]"
    for comp in "${all_comps[@]}"; do
        local vc_json
        vc_json=$(oci network virtual-circuit list --compartment-id "$comp" --region "$region" --output json 2>/dev/null)
        if [[ -n "$vc_json" ]] && echo "$vc_json" | jq -e '.data[0]' >/dev/null 2>&1; then
            local filtered
            filtered=$(echo "$vc_json" | jq --arg drg "$drg_id" '[.data[] | select(.["gateway-id"] == $drg)]' 2>/dev/null)
            if [[ -n "$filtered" && "$filtered" != "[]" ]]; then
                all_fc=$(jq -n --argjson a "$all_fc" --argjson b "$filtered" '$a + $b | unique_by(.id)' 2>/dev/null)
            fi
        fi
    done
    
    # --- LPG: search each compartment (VCN-level, show all in scope) ---
    local all_lpg="[]"
    local attached_vcn_ids
    attached_vcn_ids=$(echo "$all_attachments" | jq -r '.[] | (.["network-details"]["id"] // .["vcn-id"] // empty)' 2>/dev/null | sort -u)
    for comp in "${all_comps[@]}"; do
        local lpg_json
        lpg_json=$(oci network local-peering-gateway list --compartment-id "$comp" --region "$region" --output json 2>/dev/null)
        if [[ -n "$lpg_json" ]] && echo "$lpg_json" | jq -e '.data[0]' >/dev/null 2>&1; then
            if [[ -n "$attached_vcn_ids" ]]; then
                while IFS= read -r vid; do
                    [[ -z "$vid" ]] && continue
                    local filtered
                    filtered=$(echo "$lpg_json" | jq --arg vcn "$vid" '[.data[] | select(.["vcn-id"] == $vcn)]' 2>/dev/null)
                    if [[ -n "$filtered" && "$filtered" != "[]" ]]; then
                        all_lpg=$(jq -n --argjson a "$all_lpg" --argjson b "$filtered" '$a + $b | unique_by(.id)' 2>/dev/null)
                    fi
                done <<< "$attached_vcn_ids"
            fi
        fi
    done
    
    echo -ne "\r                                                                     \r"
    
    #==========================================================================
    # Phase 2: Display
    #==========================================================================
    
    local vcn_count rpc_count vpn_count fc_count lpg_count
    vcn_count=$(echo "$all_attachments" | jq '[.[] | select((.["network-details"]["type"] // "VCN") == "VCN")] | length' 2>/dev/null || echo "0")
    rpc_count=$(echo "$all_rpcs" | jq 'length' 2>/dev/null || echo "0")
    vpn_count=$(echo "$all_ipsec" | jq 'length' 2>/dev/null || echo "0")
    fc_count=$(echo "$all_fc" | jq 'length' 2>/dev/null || echo "0")
    lpg_count=$(echo "$all_lpg" | jq 'length' 2>/dev/null || echo "0")
    
    # --- Header ---
    echo ""
    printf "  ${BOLD}${CYAN}%s%s%s${NC}\n" "$TL" "$(printf '%*s' $((box_width-2)) '' | tr ' ' "$H")" "$TR"
    printf "  ${BOLD}${CYAN}%s${NC} ${BOLD}${WHITE} 🌐 CONNECTIVITY MAP: %-40s${NC}%*s${BOLD}${CYAN}%s${NC}\n" \
        "$V" "$drg_name" $((box_width - 48)) "" "$V"
    printf "  ${BOLD}${CYAN}%s${NC} ${GRAY}    Region: %-20s  Compartment: %-30s${NC}%*s${BOLD}${CYAN}%s${NC}\n" \
        "$V" "$region" "${drg_comp_name:0:30}" $((box_width - 78)) "" "$V"
    printf "  ${BOLD}${CYAN}%s%s%s${NC}\n" "$LT" "$(printf '%*s' $((box_width-2)) '' | tr ' ' "$H")" "$RT"
    
    # --- DRG Hub with State/Redundancy ---
    local state_color="$GREEN"
    case "$drg_state" in
        AVAILABLE) state_color="$GREEN" ;;
        PROVISIONING) state_color="$YELLOW" ;;
        TERMINATED|TERMINATING) state_color="$RED" ;;
        *) state_color="$GRAY" ;;
    esac
    local redundancy_color="$GREEN"
    case "$drg_redundancy" in
        AVAILABLE|NOT_AVAILABLE_DUE_TO_SINGLE_IPSEC*) redundancy_color="$GREEN" ;;
        NOT_AVAILABLE*) redundancy_color="$RED" ;;
        *) redundancy_color="$GRAY" ;;
    esac
    
    printf "  ${CYAN}%s${NC}%*s${CYAN}%s${NC}\n" "$V" $((box_width-2)) "" "$V"
    printf "  ${CYAN}%s${NC}%*s${BOLD}${MAGENTA}╔══════════════════════════════════════════════════════════════╗${NC}%*s${CYAN}%s${NC}\n" "$V" 15 "" $((box_width-79)) "" "$V"
    printf "  ${CYAN}%s${NC}%*s${BOLD}${MAGENTA}║${NC}  ${WHITE}🔷 DRG: %-52s${NC}  ${BOLD}${MAGENTA}║${NC}%*s${CYAN}%s${NC}\n" "$V" 15 "" "${drg_name:0:52}" $((box_width-79)) "" "$V"
    printf "  ${CYAN}%s${NC}%*s${BOLD}${MAGENTA}║${NC}  ${CYAN}State:${NC} ${state_color}%-12s${NC}  ${CYAN}Redundancy:${NC} ${redundancy_color}%-24s${NC}  ${BOLD}${MAGENTA}║${NC}%*s${CYAN}%s${NC}\n" \
        "$V" 15 "" "$drg_state" "${drg_redundancy:0:24}" $((box_width-79)) "" "$V"
    printf "  ${CYAN}%s${NC}%*s${BOLD}${MAGENTA}║${NC}  ${CYAN}Route Tables:${NC} ${WHITE}%-4s${NC} ${CYAN}VCNs:${NC} ${WHITE}%-3s${NC} ${CYAN}RPCs:${NC} ${WHITE}%-3s${NC} ${CYAN}VPNs:${NC} ${WHITE}%-3s${NC} ${CYAN}FC:${NC} ${WHITE}%-3s${NC} ${CYAN}LPGs:${NC} ${WHITE}%-3s${NC}${BOLD}${MAGENTA}║${NC}%*s${CYAN}%s${NC}\n" \
        "$V" 15 "" "${#DRT_NAME_CACHE[@]}" "$vcn_count" "$rpc_count" "$vpn_count" "$fc_count" "$lpg_count" $((box_width-79)) "" "$V"
    printf "  ${CYAN}%s${NC}%*s${BOLD}${MAGENTA}╚══════════════════════════════════════════════════════════════╝${NC}%*s${CYAN}%s${NC}\n" "$V" 15 "" $((box_width-79)) "" "$V"
    
    # Default Export Route Distribution
    if [[ -n "$drg_export_dist_id" && "$drg_export_dist_id" != "null" ]]; then
        printf "  ${CYAN}%s${NC}  ${CYAN}Default Export Distribution:${NC} ${GREEN}%s${NC} ${GRAY}[%s]${NC}%*s${CYAN}%s${NC}\n" \
            "$V" "$drg_export_dist_name" "$drg_export_dist_type" 2 "" "$V"
        printf "  ${CYAN}%s${NC}    ${YELLOW}%s${NC}%*s${CYAN}%s${NC}\n" "$V" "$drg_export_dist_id" 2 "" "$V"
        local _ed_stmt_count
        _ed_stmt_count=$(echo "$drg_export_dist_stmts" | jq 'length' 2>/dev/null || echo "0")
        if [[ "$_ed_stmt_count" -gt 0 ]]; then
            while IFS='|' read -r _es_action _es_priority _es_match_type _es_att_type; do
                [[ -z "$_es_action" ]] && continue
                local _match_d=""
                if [[ -n "$_es_att_type" && "$_es_att_type" != "null" ]]; then
                    _match_d="attachment-type=${_es_att_type}"
                else
                    _match_d="match=${_es_match_type}"
                fi
                printf "  ${CYAN}%s${NC}      Priority ${GREEN}%s${NC}: ${WHITE}%s${NC}  %s%*s${CYAN}%s${NC}\n" \
                    "$V" "$_es_priority" "$_es_action" "$_match_d" 2 "" "$V"
            done < <(echo "$drg_export_dist_stmts" | jq -r '.[] | "\(.action)|\(.priority)|\(.["match-criteria"][0]["match-type"] // "ALL")|\(.["match-criteria"][0]["attachment-type"] // "null")"' 2>/dev/null)
        fi
    fi
    
    printf "  ${CYAN}%s${NC}%*s${CYAN}│${NC}%*s${CYAN}%s${NC}\n" "$V" 45 "" $((box_width-48)) "" "$V"
    
    # ===== VCN ATTACHMENTS (with route table info) =====
    printf "  ${CYAN}%s${NC}  ${BOLD}${GREEN}📦 VCN ATTACHMENTS${NC} %-*s ${CYAN}%s${NC}\n" "$V" $((box_width-24)) "($vcn_count)" "$V"
    printf "  ${CYAN}%s${NC}  %s${CYAN}%s${NC}\n" "$V" "$(printf '%*s' $((box_width-6)) '' | tr ' ' '─')" "$V"
    
    if [[ "$vcn_count" -gt 0 ]]; then
        while IFS='|' read -r att_name att_state vcn_id att_type att_rt_id; do
            [[ -z "$att_name" ]] && continue
            [[ "$att_type" != "VCN" && "$att_type" != "UNKNOWN" && -n "$att_type" ]] && continue
            
            # Get VCN details
            local vcn_name="Unknown" vcn_cidr="N/A"
            if [[ -n "$vcn_id" && "$vcn_id" != "null" && "$vcn_id" != "N/A" ]]; then
                local vcn_detail
                vcn_detail=$(oci network vcn get --vcn-id "$vcn_id" --region "$region" --output json 2>/dev/null)
                if [[ -n "$vcn_detail" ]]; then
                    vcn_name=$(echo "$vcn_detail" | jq -r '.data["display-name"] // "Unknown"' 2>/dev/null)
                    vcn_cidr=$(echo "$vcn_detail" | jq -r '.data["cidr-block"] // "N/A"' 2>/dev/null)
                fi
            fi
            
            local state_icon="✓" s_color="$GREEN"
            [[ "$att_state" != "ATTACHED" ]] && state_icon="○" && s_color="$YELLOW"
            
            # Route table info from cache
            local rt_display=""
            if [[ -n "$att_rt_id" && "$att_rt_id" != "null" ]]; then
                local rt_name="${DRT_NAME_CACHE[$att_rt_id]:-}"
                local rt_rules="${DRT_RULES_CACHE[$att_rt_id]:-?}"
                if [[ -n "$rt_name" ]]; then
                    rt_display="RT: ${rt_name:0:25} [${rt_rules} rules]"
                else
                    rt_display="RT: ...${att_rt_id: -8} [${rt_rules} rules]"
                fi
            fi
            
            printf "  ${CYAN}%s${NC}    ${s_color}%s${NC} ${WHITE}%-22s${NC} ← ${GREEN}VCN: %-18s${NC} ${GRAY}[%-15s]${NC}" \
                "$V" "$state_icon" "${att_name:0:22}" "${vcn_name:0:18}" "${vcn_cidr:0:15}"
            if [[ -n "$rt_display" ]]; then
                printf "  ${YELLOW}%s${NC}" "$rt_display"
            fi
            printf "%*s${CYAN}%s${NC}\n" 2 "" "$V"
        done < <(echo "$all_attachments" | jq -r 'sort_by(if .["network-details"]["type"] == "VCN" then 0 elif .["network-details"]["type"] == "REMOTE_PEERING_CONNECTION" then 1 elif .["network-details"]["type"] == "IPSEC_TUNNEL" then 2 elif .["network-details"]["type"] == "VIRTUAL_CIRCUIT" then 3 else 4 end) | .[] | "\(.["display-name"] // "N/A")|\(.["lifecycle-state"])|\(.["network-details"]["id"] // .["vcn-id"] // "N/A")|\(.["network-details"]["type"] // "VCN")|\(.["drg-route-table-id"] // "null")"' 2>/dev/null)
    else
        printf "  ${CYAN}%s${NC}    ${GRAY}(No VCN attachments found)${NC}%*s${CYAN}%s${NC}\n" "$V" $((box_width-32)) "" "$V"
    fi
    
    printf "  ${CYAN}%s${NC}%*s${CYAN}%s${NC}\n" "$V" $((box_width-2)) "" "$V"
    
    # ===== REMOTE PEERING =====
    printf "  ${CYAN}%s${NC}  ${BOLD}${YELLOW}🌍 REMOTE PEERING (Cross-Region)${NC} %-*s ${CYAN}%s${NC}\n" "$V" $((box_width-38)) "($rpc_count)" "$V"
    printf "  ${CYAN}%s${NC}  %s${CYAN}%s${NC}\n" "$V" "$(printf '%*s' $((box_width-6)) '' | tr ' ' '─')" "$V"
    
    if [[ "$rpc_count" -gt 0 ]]; then
        while IFS='|' read -r rpc_name rpc_state peer_region peer_status peer_rpc_id rpc_id; do
            [[ -z "$rpc_name" ]] && continue
            
            local status_icon="⟷" status_color="$GREEN"
            case "$peer_status" in
                PEERED) status_icon="⟷" ; status_color="$GREEN" ;;
                PENDING) status_icon="⋯" ; status_color="$YELLOW" ;;
                *) status_icon="✗" ; status_color="$RED" ;;
            esac
            
            local peer_region_display="${peer_region:-"(not peered)"}"
            
            printf "  ${CYAN}%s${NC}    ${status_color}%s${NC} ${WHITE}%-20s${NC} ${status_color}──────►${NC} ${BOLD}${YELLOW}%-15s${NC}" \
                "$V" "$status_icon" "${rpc_name:0:20}" "${peer_region_display:0:15}"
            printf "%*s${CYAN}%s${NC}\n" $((box_width-60)) "" "$V"
            
            # ===== REMOTE DRG EXPANSION for PEERED RPCs =====
            if [[ "$peer_status" == "PEERED" && -n "$peer_rpc_id" && "$peer_rpc_id" != "null" && -n "$peer_region" ]]; then
                echo -ne "\r${GRAY}  Resolving remote DRG in ${peer_region}...${NC}"
                
                local remote_rpc_json remote_drg_id="" remote_comp=""
                remote_rpc_json=$(oci network remote-peering-connection get \
                    --remote-peering-connection-id "$peer_rpc_id" \
                    --region "$peer_region" --output json 2>/dev/null)
                
                if [[ -n "$remote_rpc_json" ]] && echo "$remote_rpc_json" | jq -e '.data' >/dev/null 2>&1; then
                    remote_drg_id=$(echo "$remote_rpc_json" | jq -r '.data["drg-id"] // ""' 2>/dev/null)
                    remote_comp=$(echo "$remote_rpc_json" | jq -r '.data["compartment-id"] // ""' 2>/dev/null)
                fi
                
                echo -ne "\r                                                                     \r"
                
                if [[ -n "$remote_drg_id" ]]; then
                    local remote_drg_name="DRG (...${remote_drg_id: -8})" remote_drg_state="N/A" remote_drg_redundancy="N/A"
                    local remote_drg_json
                    remote_drg_json=$(oci network drg get --drg-id "$remote_drg_id" --region "$peer_region" --output json 2>/dev/null)
                    if [[ -n "$remote_drg_json" ]] && echo "$remote_drg_json" | jq -e '.data' >/dev/null 2>&1; then
                        remote_drg_name=$(echo "$remote_drg_json" | jq -r '.data["display-name"] // "Unknown"' 2>/dev/null)
                        remote_drg_state=$(echo "$remote_drg_json" | jq -r '.data["lifecycle-state"] // "N/A"' 2>/dev/null)
                        remote_drg_redundancy=$(echo "$remote_drg_json" | jq -r '.data["redundancy-status"] // "N/A"' 2>/dev/null)
                    fi
                    
                    local remote_state_color="$GREEN"
                    [[ "$remote_drg_state" != "AVAILABLE" ]] && remote_state_color="$YELLOW"
                    local remote_red_color="$GREEN"
                    [[ "$remote_drg_redundancy" == *"NOT_AVAILABLE"* ]] && remote_red_color="$RED"
                    
                    printf "  ${CYAN}%s${NC}       ${WHITE}╰─ Remote DRG:${NC} ${BOLD}${ORANGE}%-22s${NC} ${WHITE}[${remote_state_color}%s${WHITE}]${NC} ${CYAN}Redundancy:${NC} ${remote_red_color}%s${NC}%*s${CYAN}%s${NC}\n" \
                        "$V" "${remote_drg_name:0:22}" "$remote_drg_state" "${remote_drg_redundancy:0:20}" 2 "" "$V"
                    
                    # Remote VCN attachments - use --drg-id directly
                    local remote_att_json
                    remote_att_json=$(oci network drg-attachment list --drg-id "$remote_drg_id" \
                        --region "$peer_region" --all --output json 2>/dev/null)
                    
                    local remote_atts="[]"
                    if [[ -n "$remote_att_json" ]] && echo "$remote_att_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                        remote_atts=$(echo "$remote_att_json" | jq \
                            '[.data[] | select((.["network-details"]["type"] // "VCN") == "VCN")]' 2>/dev/null)
                    fi
                    
                    # Build remote compartment search list
                    local -a remote_search_comps=("${all_comps[@]}")
                    if [[ -n "$remote_comp" ]]; then
                        local _ra=0; for c in "${remote_search_comps[@]}"; do [[ "$c" == "$remote_comp" ]] && _ra=1; done
                        [[ $_ra -eq 0 ]] && remote_search_comps+=("$remote_comp")
                    fi
                    local r_drg_comp
                    r_drg_comp=$(echo "$remote_drg_json" | jq -r '.data["compartment-id"] // ""' 2>/dev/null)
                    if [[ -n "$r_drg_comp" ]]; then
                        local _ra=0; for c in "${remote_search_comps[@]}"; do [[ "$c" == "$r_drg_comp" ]] && _ra=1; done
                        [[ $_ra -eq 0 ]] && remote_search_comps+=("$r_drg_comp")
                    fi
                    
                    local remote_vcn_count
                    remote_vcn_count=$(echo "$remote_atts" | jq 'length' 2>/dev/null || echo "0")
                    
                    if [[ "$remote_vcn_count" -gt 0 ]]; then
                        while IFS='|' read -r r_att_name r_att_state r_vcn_id; do
                            [[ -z "$r_att_name" ]] && continue
                            local r_vcn_name="Unknown" r_vcn_cidr=""
                            if [[ -n "$r_vcn_id" && "$r_vcn_id" != "null" ]]; then
                                local r_vcn_detail
                                r_vcn_detail=$(oci network vcn get --vcn-id "$r_vcn_id" --region "$peer_region" --output json 2>/dev/null)
                                if [[ -n "$r_vcn_detail" ]]; then
                                    r_vcn_name=$(echo "$r_vcn_detail" | jq -r '.data["display-name"] // "Unknown"' 2>/dev/null)
                                    r_vcn_cidr=$(echo "$r_vcn_detail" | jq -r '.data["cidr-block"] // ""' 2>/dev/null)
                                fi
                            fi
                            local r_state_icon="✓"; [[ "$r_att_state" != "ATTACHED" ]] && r_state_icon="○"
                            local cidr_display=""; [[ -n "$r_vcn_cidr" ]] && cidr_display=" ($r_vcn_cidr)"
                            printf "  ${CYAN}%s${NC}          ${GREEN}%s${NC} ${GREEN}📦 VCN: %-20s${NC}${GRAY}%s${NC} ${GRAY}via %s${NC}%*s${CYAN}%s${NC}\n" \
                                "$V" "$r_state_icon" "${r_vcn_name:0:20}" "${cidr_display:0:18}" "${r_att_name:0:20}" 2 "" "$V"
                        done < <(echo "$remote_atts" | jq -r '.[] | "\(.["display-name"] // "N/A")|\(.["lifecycle-state"])|\(.["network-details"]["id"] // .["vcn-id"] // "null")"' 2>/dev/null)
                    fi
                    
                    # Remote FastConnect - search multiple compartments
                    local remote_all_fc="[]"
                    for r_comp in "${remote_search_comps[@]}"; do
                        local remote_fc_json
                        remote_fc_json=$(oci network virtual-circuit list --compartment-id "$r_comp" \
                            --region "$peer_region" --output json 2>/dev/null)
                        if [[ -n "$remote_fc_json" ]] && echo "$remote_fc_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                            local r_fc_filtered
                            r_fc_filtered=$(echo "$remote_fc_json" | jq --arg drg "$remote_drg_id" \
                                '[.data[] | select(.["gateway-id"] == $drg)]' 2>/dev/null)
                            if [[ -n "$r_fc_filtered" && "$r_fc_filtered" != "[]" ]]; then
                                remote_all_fc=$(jq -n --argjson a "$remote_all_fc" --argjson b "$r_fc_filtered" '$a + $b | unique_by(.id)' 2>/dev/null)
                            fi
                        fi
                    done
                    if [[ $(echo "$remote_all_fc" | jq 'length' 2>/dev/null || echo "0") -gt 0 ]]; then
                        while IFS='|' read -r r_fc_name r_fc_state r_fc_bw r_fc_provider r_fc_bgp; do
                            [[ -z "$r_fc_name" ]] && continue
                            local r_fc_icon="⚡" r_fc_color="$GREEN"
                            [[ "$r_fc_state" != "PROVISIONED" ]] && r_fc_icon="○" && r_fc_color="$YELLOW"
                            local r_bgp_color="$GREEN"
                            [[ "$r_fc_bgp" == "DOWN" ]] && r_bgp_color="$RED"
                            [[ "$r_fc_bgp" == "N/A" || -z "$r_fc_bgp" ]] && r_bgp_color="$GRAY"
                            printf "  ${CYAN}%s${NC}          ${r_fc_color}%s${NC} ${MAGENTA}⚡ FC: %-20s${NC} ${WHITE}[%s]${NC} ${GRAY}%s${NC} ${WHITE}%s${NC} BGP:${r_bgp_color}%s${NC}%*s${CYAN}%s${NC}\n" \
                                "$V" "$r_fc_icon" "${r_fc_name:0:20}" "$r_fc_state" "$r_fc_bw" "${r_fc_provider:0:15}" "${r_fc_bgp:-N/A}" 2 "" "$V"
                        done < <(echo "$remote_all_fc" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["bandwidth-shape-name"] // "N/A")|\(.["provider-name"] // "")|\(.["bgp-session-state"] // "N/A")"' 2>/dev/null)
                    fi
                    
                    # Remote VPN - search multiple compartments
                    local remote_all_vpn="[]"
                    for r_comp in "${remote_search_comps[@]}"; do
                        local remote_vpn_json
                        remote_vpn_json=$(oci network ip-sec-connection list --compartment-id "$r_comp" \
                            --drg-id "$remote_drg_id" --region "$peer_region" --output json 2>/dev/null)
                        if [[ -n "$remote_vpn_json" ]] && echo "$remote_vpn_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                            remote_all_vpn=$(jq -n --argjson a "$remote_all_vpn" --argjson b "$(echo "$remote_vpn_json" | jq '.data')" '$a + $b | unique_by(.id)' 2>/dev/null)
                        fi
                    done
                    if [[ $(echo "$remote_all_vpn" | jq 'length' 2>/dev/null || echo "0") -gt 0 ]]; then
                        while IFS='|' read -r r_vpn_name r_vpn_state r_cpe_id; do
                            [[ -z "$r_vpn_name" ]] && continue
                            local r_vpn_icon="🔐" r_vpn_color="$GREEN"
                            [[ "$r_vpn_state" != "AVAILABLE" ]] && r_vpn_icon="○" && r_vpn_color="$YELLOW"
                            local r_cpe_display=""
                            if [[ -n "$r_cpe_id" && "$r_cpe_id" != "null" ]]; then
                                local r_cpe_name r_cpe_ip
                                r_cpe_name=$(oci network cpe get --cpe-id "$r_cpe_id" --region "$peer_region" --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                                r_cpe_ip=$(oci network cpe get --cpe-id "$r_cpe_id" --region "$peer_region" --query 'data."ip-address"' --raw-output 2>/dev/null || echo "")
                                r_cpe_display=" → CPE: ${r_cpe_name:0:15}"
                                [[ -n "$r_cpe_ip" ]] && r_cpe_display="$r_cpe_display ($r_cpe_ip)"
                            fi
                            printf "  ${CYAN}%s${NC}          ${r_vpn_color}%s${NC} ${RED}🔒 VPN: %-20s${NC} ${WHITE}[%s]${NC}${GRAY}%s${NC}%*s${CYAN}%s${NC}\n" \
                                "$V" "$r_vpn_icon" "${r_vpn_name:0:20}" "$r_vpn_state" "${r_cpe_display:0:40}" 2 "" "$V"
                        done < <(echo "$remote_all_vpn" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["cpe-id"] // "")"' 2>/dev/null)
                    fi
                    
                    # Remote LPG - search multiple compartments
                    if [[ "$remote_vcn_count" -gt 0 ]]; then
                        local remote_vcn_ids
                        remote_vcn_ids=$(echo "$remote_atts" | jq -r '.[] | (.["network-details"]["id"] // .["vcn-id"] // empty)' 2>/dev/null)
                        while IFS= read -r r_vid; do
                            [[ -z "$r_vid" ]] && continue
                            for r_comp in "${remote_search_comps[@]}"; do
                                local remote_lpg_json
                                remote_lpg_json=$(oci network local-peering-gateway list --compartment-id "$r_comp" \
                                    --vcn-id "$r_vid" --region "$peer_region" --output json 2>/dev/null)
                                if [[ -n "$remote_lpg_json" ]] && echo "$remote_lpg_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                                    while IFS='|' read -r r_lpg_name r_lpg_peer_status r_lpg_vcn_id r_lpg_peer_id; do
                                        [[ -z "$r_lpg_name" ]] && continue
                                        local r_lpg_icon="⟷" r_lpg_color="$GREEN"
                                        [[ "$r_lpg_peer_status" != "PEERED" ]] && r_lpg_icon="○" && r_lpg_color="$YELLOW"
                                        local r_peer_vcn_display=""
                                        if [[ "$r_lpg_peer_status" == "PEERED" && -n "$r_lpg_peer_id" && "$r_lpg_peer_id" != "null" ]]; then
                                            local r_peer_vcn_id
                                            r_peer_vcn_id=$(oci network local-peering-gateway get --local-peering-gateway-id "$r_lpg_peer_id" \
                                                --region "$peer_region" --query 'data."vcn-id"' --raw-output 2>/dev/null)
                                            if [[ -n "$r_peer_vcn_id" ]]; then
                                                local r_peer_vcn_name
                                                r_peer_vcn_name=$(oci network vcn get --vcn-id "$r_peer_vcn_id" \
                                                    --region "$peer_region" --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                                                [[ -n "$r_peer_vcn_name" ]] && r_peer_vcn_display=" → VCN: $r_peer_vcn_name"
                                            fi
                                        fi
                                        printf "  ${CYAN}%s${NC}          ${r_lpg_color}%s${NC} ${GREEN}🔗 LPG: %-20s${NC} ${WHITE}[%s]${NC}${GREEN}%s${NC}%*s${CYAN}%s${NC}\n" \
                                            "$V" "$r_lpg_icon" "${r_lpg_name:0:20}" "$r_lpg_peer_status" "${r_peer_vcn_display:0:30}" 2 "" "$V"
                                    done < <(echo "$remote_lpg_json" | jq -r '.data[] | "\(.["display-name"])|\(.["peering-status"])|\(.["vcn-id"] // "")|\(.["peer-id"] // "")"' 2>/dev/null)
                                fi
                            done
                        done <<< "$remote_vcn_ids"
                    fi
                else
                    printf "  ${CYAN}%s${NC}       ${GRAY}╰─ (Unable to resolve remote DRG - check permissions)${NC}%*s${CYAN}%s${NC}\n" \
                        "$V" $((box_width-61)) "" "$V"
                fi
            fi
        done < <(echo "$all_rpcs" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["peer-region-name"] // "")|\(.["peering-status"])|\(.["peer-id"] // "")|\(.id)"' 2>/dev/null)
    else
        printf "  ${CYAN}%s${NC}    ${GRAY}(No remote peering connections)${NC}%*s${CYAN}%s${NC}\n" "$V" $((box_width-37)) "" "$V"
    fi
    
    printf "  ${CYAN}%s${NC}%*s${CYAN}%s${NC}\n" "$V" $((box_width-2)) "" "$V"
    
    # ===== LOCAL PEERING =====
    printf "  ${CYAN}%s${NC}  ${BOLD}${GREEN}🔗 LOCAL PEERING (Same-Region VCN-to-VCN)${NC} %-*s ${CYAN}%s${NC}\n" "$V" $((box_width-48)) "($lpg_count)" "$V"
    printf "  ${CYAN}%s${NC}  %s${CYAN}%s${NC}\n" "$V" "$(printf '%*s' $((box_width-6)) '' | tr ' ' '─')" "$V"
    
    if [[ "$lpg_count" -gt 0 ]]; then
        while IFS='|' read -r lpg_name lpg_state peer_status vcn_id peer_lpg_id; do
            [[ -z "$lpg_name" ]] && continue
            
            local status_icon="⟷" status_color="$GREEN"
            case "$peer_status" in
                PEERED) status_icon="⟷" ; status_color="$GREEN" ;;
                PENDING) status_icon="⋯" ; status_color="$YELLOW" ;;
                *) status_icon="○" ; status_color="$GRAY" ;;
            esac
            
            local vcn_name="Unknown"
            if [[ -n "$vcn_id" && "$vcn_id" != "null" ]]; then
                vcn_name=$(oci network vcn get --vcn-id "$vcn_id" --region "$region" --query 'data["display-name"]' --raw-output 2>/dev/null || echo "Unknown")
            fi
            
            local peer_vcn_name=""
            if [[ -n "$peer_lpg_id" && "$peer_lpg_id" != "null" && "$peer_status" == "PEERED" ]]; then
                local peer_vcn_id
                peer_vcn_id=$(oci network local-peering-gateway get --local-peering-gateway-id "$peer_lpg_id" \
                    --region "$region" --query 'data["vcn-id"]' --raw-output 2>/dev/null)
                if [[ -n "$peer_vcn_id" ]]; then
                    peer_vcn_name=$(oci network vcn get --vcn-id "$peer_vcn_id" --region "$region" \
                        --query 'data["display-name"]' --raw-output 2>/dev/null || echo "")
                fi
            fi
            
            printf "  ${CYAN}%s${NC}    ${status_color}%s${NC} ${WHITE}%-20s${NC} ${GREEN}⟺${NC} ${WHITE}VCN: %-15s${NC}" \
                "$V" "$status_icon" "${lpg_name:0:20}" "${vcn_name:0:15}"
            if [[ -n "$peer_vcn_name" ]]; then
                printf " ${GREEN}→ Peer VCN: %s${NC}" "${peer_vcn_name:0:15}"
            fi
            printf "%*s${CYAN}%s${NC}\n" 5 "" "$V"
        done < <(echo "$all_lpg" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["peering-status"])|\(.["vcn-id"] // "")|\(.["peer-id"] // "")"' 2>/dev/null)
    else
        printf "  ${CYAN}%s${NC}    ${GRAY}(No local peering gateways)${NC}%*s${CYAN}%s${NC}\n" "$V" $((box_width-33)) "" "$V"
    fi
    
    printf "  ${CYAN}%s${NC}%*s${CYAN}%s${NC}\n" "$V" $((box_width-2)) "" "$V"
    
    # ===== IPSEC VPN (with tunnel status + BGP) =====
    printf "  ${CYAN}%s${NC}  ${BOLD}${RED}🔒 IPSEC VPN (Site-to-Site)${NC} %-*s ${CYAN}%s${NC}\n" "$V" $((box_width-33)) "($vpn_count)" "$V"
    printf "  ${CYAN}%s${NC}  %s${CYAN}%s${NC}\n" "$V" "$(printf '%*s' $((box_width-6)) '' | tr ' ' '─')" "$V"
    
    if [[ "$vpn_count" -gt 0 ]]; then
        while IFS='|' read -r vpn_name vpn_state cpe_id vpn_id; do
            [[ -z "$vpn_name" ]] && continue
            
            local status_icon="🔐" status_color="$GREEN"
            [[ "$vpn_state" != "AVAILABLE" ]] && status_icon="○" && status_color="$YELLOW"
            
            # Get CPE details
            local cpe_name="Unknown" cpe_ip=""
            if [[ -n "$cpe_id" && "$cpe_id" != "null" ]]; then
                local cpe_detail
                cpe_detail=$(oci network cpe get --cpe-id "$cpe_id" --region "$region" --output json 2>/dev/null)
                if [[ -n "$cpe_detail" ]]; then
                    cpe_name=$(echo "$cpe_detail" | jq -r '.data["display-name"] // "Unknown"' 2>/dev/null)
                    cpe_ip=$(echo "$cpe_detail" | jq -r '.data["ip-address"] // ""' 2>/dev/null)
                fi
            fi
            
            printf "  ${CYAN}%s${NC}    ${status_color}%s${NC} ${WHITE}%-20s${NC} ${RED}══════►${NC} ${WHITE}CPE: %-15s${NC}" \
                "$V" "$status_icon" "${vpn_name:0:20}" "${cpe_name:0:15}"
            [[ -n "$cpe_ip" ]] && printf " ${GRAY}[%s]${NC}" "$cpe_ip"
            printf "%*s${CYAN}%s${NC}\n" 2 "" "$V"
            
            # Tunnel status with BGP
            if [[ -n "$vpn_id" && "$vpn_id" != "null" ]]; then
                local tunnels_json
                tunnels_json=$(oci network ip-sec-connection-tunnel list --ipsc-id "$vpn_id" --region "$region" --output json 2>/dev/null)
                if [[ -n "$tunnels_json" ]] && echo "$tunnels_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                    while IFS='|' read -r tun_status tun_ip tun_bgp tun_routing; do
                        [[ -z "$tun_status" ]] && continue
                        local tun_color="$GREEN"
                        [[ "$tun_status" != "UP" ]] && tun_color="$RED"
                        local bgp_display=""
                        [[ -n "$tun_bgp" && "$tun_bgp" != "N/A" && "$tun_bgp" != "null" ]] && bgp_display=" BGP:${tun_bgp}"
                        local routing_display=""
                        [[ -n "$tun_routing" && "$tun_routing" != "null" ]] && routing_display=" (${tun_routing})"
                        printf "  ${CYAN}%s${NC}       ${GRAY}└─ Tunnel:${NC} ${tun_color}%-4s${NC} ${GRAY}VPN IP: %-15s${NC}${WHITE}%s%s${NC}%*s${CYAN}%s${NC}\n" \
                            "$V" "$tun_status" "$tun_ip" "$bgp_display" "$routing_display" 2 "" "$V"
                    done < <(echo "$tunnels_json" | jq -r '.data[] | "\(.status)|\(.["vpn-ip"] // "N/A")|\(.["bgp-session-info"]["bgp-state"] // "N/A")|\(.routing // "null")"' 2>/dev/null)
                fi
            fi
        done < <(echo "$all_ipsec" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["cpe-id"] // "")|\(.id)"' 2>/dev/null)
    else
        printf "  ${CYAN}%s${NC}    ${GRAY}(No IPSec VPN connections)${NC}%*s${CYAN}%s${NC}\n" "$V" $((box_width-31)) "" "$V"
    fi
    
    printf "  ${CYAN}%s${NC}%*s${CYAN}%s${NC}\n" "$V" $((box_width-2)) "" "$V"
    
    # ===== FASTCONNECT (with BGP details + peering IPs) =====
    printf "  ${CYAN}%s${NC}  ${BOLD}${MAGENTA}⚡ FASTCONNECT (Dedicated/Partner)${NC} %-*s ${CYAN}%s${NC}\n" "$V" $((box_width-40)) "($fc_count)" "$V"
    printf "  ${CYAN}%s${NC}  %s${CYAN}%s${NC}\n" "$V" "$(printf '%*s' $((box_width-6)) '' | tr ' ' '─')" "$V"
    
    if [[ "$fc_count" -gt 0 ]]; then
        while IFS='|' read -r vc_name vc_state vc_type vc_bw provider bgp_state cust_asn oracle_asn vc_id; do
            [[ -z "$vc_name" ]] && continue
            
            local status_icon="⚡" status_color="$GREEN"
            case "$vc_state" in
                PROVISIONED) status_icon="⚡" ; status_color="$GREEN" ;;
                PROVISIONING|PENDING*) status_icon="⋯" ; status_color="$YELLOW" ;;
                *) status_icon="○" ; status_color="$RED" ;;
            esac
            
            printf "  ${CYAN}%s${NC}    ${status_color}%s${NC} ${WHITE}%-20s${NC} ${MAGENTA}══════►${NC} ${WHITE}%-10s${NC} ${GRAY}BW: %-10s${NC}" \
                "$V" "$status_icon" "${vc_name:0:20}" "${vc_type:0:10}" "${vc_bw:0:10}"
            [[ -n "$provider" && "$provider" != "null" ]] && printf " ${GREEN}Provider: %s${NC}" "${provider:0:15}"
            printf "%*s${CYAN}%s${NC}\n" 2 "" "$V"
            
            # BGP details line
            local bgp_color="$GREEN"
            case "$bgp_state" in
                UP) bgp_color="$GREEN" ;;
                DOWN) bgp_color="$RED" ;;
                *) bgp_color="$YELLOW" ;;
            esac
            
            local bgp_info="BGP: ${bgp_state:-N/A}"
            [[ -n "$cust_asn" && "$cust_asn" != "null" && "$cust_asn" != "0" ]] && bgp_info="$bgp_info  Customer ASN: $cust_asn"
            [[ -n "$oracle_asn" && "$oracle_asn" != "null" && "$oracle_asn" != "0" ]] && bgp_info="$bgp_info  Oracle ASN: $oracle_asn"
            
            printf "  ${CYAN}%s${NC}       ${GRAY}└─${NC} ${bgp_color}%s${NC}" "$V" "$bgp_info"
            
            # Get cross-connect mappings for BGP peering IPs
            if [[ -n "$vc_id" && "$vc_id" != "null" ]]; then
                local vc_detail
                vc_detail=$(oci network virtual-circuit get --virtual-circuit-id "$vc_id" --region "$region" --output json 2>/dev/null)
                if [[ -n "$vc_detail" ]] && echo "$vc_detail" | jq -e '.data["cross-connect-mappings"][0]' >/dev/null 2>&1; then
                    local bgp_ipv4_cust bgp_ipv4_oracle
                    bgp_ipv4_cust=$(echo "$vc_detail" | jq -r '.data["cross-connect-mappings"][0]["customer-bgp-peering-ip"] // ""' 2>/dev/null)
                    bgp_ipv4_oracle=$(echo "$vc_detail" | jq -r '.data["cross-connect-mappings"][0]["oracle-bgp-peering-ip"] // ""' 2>/dev/null)
                    if [[ -n "$bgp_ipv4_cust" || -n "$bgp_ipv4_oracle" ]]; then
                        printf "%*s${CYAN}%s${NC}\n" 2 "" "$V"
                        printf "  ${CYAN}%s${NC}       ${GRAY}   Peering:${NC}" "$V"
                        [[ -n "$bgp_ipv4_cust" ]] && printf " ${WHITE}Cust: %s${NC}" "$bgp_ipv4_cust"
                        [[ -n "$bgp_ipv4_oracle" ]] && printf " ${WHITE}Oracle: %s${NC}" "$bgp_ipv4_oracle"
                        
                        # Check for secondary mapping (redundant path)
                        local bgp_ipv4_cust2 bgp_ipv4_oracle2
                        bgp_ipv4_cust2=$(echo "$vc_detail" | jq -r '.data["cross-connect-mappings"][1]["customer-bgp-peering-ip"] // ""' 2>/dev/null)
                        bgp_ipv4_oracle2=$(echo "$vc_detail" | jq -r '.data["cross-connect-mappings"][1]["oracle-bgp-peering-ip"] // ""' 2>/dev/null)
                        if [[ -n "$bgp_ipv4_cust2" || -n "$bgp_ipv4_oracle2" ]]; then
                            printf "%*s${CYAN}%s${NC}\n" 2 "" "$V"
                            printf "  ${CYAN}%s${NC}       ${GRAY}   Peering 2:${NC}" "$V"
                            [[ -n "$bgp_ipv4_cust2" ]] && printf " ${WHITE}Cust: %s${NC}" "$bgp_ipv4_cust2"
                            [[ -n "$bgp_ipv4_oracle2" ]] && printf " ${WHITE}Oracle: %s${NC}" "$bgp_ipv4_oracle2"
                        fi
                    fi
                fi
            fi
            
            printf "%*s${CYAN}%s${NC}\n" 2 "" "$V"
        done < <(echo "$all_fc" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.type)|\(.["bandwidth-shape-name"] // "N/A")|\(.["provider-name"] // "")|\(.["bgp-session-state"] // "N/A")|\(.["customer-bgp-asn"] // "0")|\(.["oracle-bgp-asn"] // "0")|\(.id)"' 2>/dev/null)
    else
        printf "  ${CYAN}%s${NC}    ${GRAY}(No FastConnect virtual circuits)${NC}%*s${CYAN}%s${NC}\n" "$V" $((box_width-39)) "" "$V"
    fi
    
    printf "  ${CYAN}%s${NC}%*s${CYAN}%s${NC}\n" "$V" $((box_width-2)) "" "$V"
    
    # ===== ROUTE TABLES SUMMARY =====
    if [[ ${#DRT_NAME_CACHE[@]} -gt 0 ]]; then
        printf "  ${CYAN}%s${NC}  ${BOLD}${WHITE}📋 DRG ROUTE TABLES${NC} %-*s ${CYAN}%s${NC}\n" "$V" $((box_width-25)) "(${#DRT_NAME_CACHE[@]})" "$V"
        printf "  ${CYAN}%s${NC}  %s${CYAN}%s${NC}\n" "$V" "$(printf '%*s' $((box_width-6)) '' | tr ' ' '─')" "$V"
        
        for drt_id in "${!DRT_NAME_CACHE[@]}"; do
            local drt_name="${DRT_NAME_CACHE[$drt_id]}"
            local drt_rules="${DRT_RULES_CACHE[$drt_id]:-0}"
            
            local rules_color="$WHITE"
            [[ "$drt_rules" -eq 0 ]] && rules_color="$GRAY"
            [[ "$drt_rules" -gt 5 ]] && rules_color="$GREEN"
            
            printf "  ${CYAN}%s${NC}    ${WHITE}%-40s${NC} ${rules_color}[%s routes]${NC} ${YELLOW}...%s${NC}%*s${CYAN}%s${NC}\n" \
                "$V" "${drt_name:0:40}" "$drt_rules" "${drt_id: -12}" 2 "" "$V"
        done
    fi
    
    printf "  ${CYAN}%s${NC}%*s${CYAN}%s${NC}\n" "$V" $((box_width-2)) "" "$V"
    
    # --- Footer ---
    printf "  ${BOLD}${CYAN}%s%s%s${NC}\n" "$BL" "$(printf '%*s' $((box_width-2)) '' | tr ' ' "$H")" "$BR"
    
    # Legend
    echo ""
    echo -e "  ${BOLD}Legend:${NC} ${GREEN}✓${NC}=Active  ${YELLOW}○${NC}=Pending  ${RED}✗${NC}=Error  ${GREEN}⟷${NC}=Peered  ${YELLOW}⋯${NC}=Connecting"
}

#--------------------------------------------------------------------------------
# Cross-Region DRG Map - Cache helpers (3-minute TTL)
#--------------------------------------------------------------------------------
xr_cache_is_fresh() {
    local meta_file="${XR_CACHE_DIR}/.meta"
    [[ ! -f "$meta_file" ]] && return 1
    local file_mtime
    file_mtime=$(stat -c %Y "$meta_file" 2>/dev/null) || return 1
    local current_time
    current_time=$(date +%s)
    local age=$((current_time - file_mtime))
    [[ $age -lt $XR_CACHE_TTL ]]
}

xr_cache_clear() {
    rm -rf "$XR_CACHE_DIR" 2>/dev/null
    echo -e "${GREEN}✓${NC} Cross-region DRG map cache cleared"
}

xr_cache_age_display() {
    local meta_file="${XR_CACHE_DIR}/.meta"
    if [[ -f "$meta_file" ]]; then
        local mtime now age ttl_remain
        mtime=$(stat -c %Y "$meta_file" 2>/dev/null) || return
        now=$(date +%s)
        age=$((now - mtime))
        ttl_remain=$((XR_CACHE_TTL - age))
        if [[ $ttl_remain -gt 0 ]]; then
            echo -e "  ${GRAY}Cache: ${GREEN}VALID${NC} ${GRAY}(${age}s old, expires in ${ttl_remain}s)${NC}"
        else
            echo -e "  ${GRAY}Cache: ${RED}EXPIRED${NC}"
        fi
    else
        # Don't show anything when cache is empty
        :
    fi
}

#--------------------------------------------------------------------------------
# Cross-Region DRG Map - Comprehensive view across all peered regions
# Follows RPC chains to build a unified topology from current DRG outward
# Features: Parallel API calls, 3-minute cache, subnet drill-down, route rules
#--------------------------------------------------------------------------------
display_cross_region_drg_map() {
    local start_drg_id="$1"
    local start_region="$2"
    local force_refresh="${3:-0}"
    shift 3 2>/dev/null || true
    local search_comps=("$@")
    
    local TL="┌" TR="┐" BL="└" BR="┘" H="─" V="│" LT="├" RT="┤"
    local box_width=140
    
    echo ""
    echo -e "${BOLD}${CYAN}══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${WHITE}                                       🌐  CROSS-REGION DRG TOPOLOGY MAP  🌐                                                              ${NC}"
    echo -e "${BOLD}${CYAN}══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Data structures
    declare -A XR_REGION_DRGS          # region -> JSON array of DRG IDs
    declare -A XR_REGION_VCN_ATTACH    # region:drg_id -> JSON array
    declare -A XR_REGION_FC            # region:drg_id -> JSON array
    declare -A XR_REGION_VPN           # region:drg_id -> JSON array
    declare -A XR_REGION_RPCS          # region:drg_id -> JSON array
    declare -A XR_REGION_ROUTE_RULES   # region:drg_id:rt_id -> JSON array
    declare -A XR_REGION_DRT_NAMES     # region:drg_id:rt_id -> route table name
    declare -A XR_DRG_NAMES            # drg_id -> display name
    declare -A XR_DRG_STATES           # drg_id -> state
    declare -A XR_DRG_REGIONS          # drg_id -> region
    declare -A XR_DRG_REDUNDANCY       # drg_id -> redundancy status
    declare -A XR_DRG_COMPS            # drg_id -> compartment OCID
    declare -A XR_DRG_COMP_NAMES       # drg_id -> compartment display name
    declare -A XR_DRG_EXPORT_DIST      # drg_id -> "name|type|ocid"
    declare -A XR_DRG_EXPORT_DIST_STMTS # drg_id -> JSON array of statements
    declare -A XR_DRG_DIST_LIST        # drg_id -> JSON array of all distributions (import + export)
    declare -A XR_VISITED_DRGS         # drg_id -> 1
    declare -A XR_VCN_SUBNETS          # vcn_id -> JSON array of subnets
    declare -A XR_VCN_LPGS             # vcn_id -> JSON array of LPGs
    declare -A XR_VCN_NAMES            # vcn_id -> display name
    declare -A XR_VCN_CIDRS            # vcn_id -> cidr block
    local xr_total_regions=0
    
    # Try loading from cache
    local cache_loaded=0
    if [[ "$force_refresh" -ne 1 ]] && xr_cache_is_fresh; then
        echo -ne "  ${GRAY}Loading from cache...${NC}"
        if [[ -f "${XR_CACHE_DIR}/xr_data.sh" ]]; then
            # Source the cached data (declare -p output)
            source "${XR_CACHE_DIR}/xr_data.sh" 2>/dev/null && cache_loaded=1
            if [[ -f "${XR_CACHE_DIR}/xr_total_regions.txt" ]]; then
                xr_total_regions=$(cat "${XR_CACHE_DIR}/xr_total_regions.txt")
            fi
        fi
        if [[ $cache_loaded -eq 1 ]]; then
            local cache_age
            cache_age=$(( $(date +%s) - $(stat -c %Y "${XR_CACHE_DIR}/.meta" 2>/dev/null || echo "0") ))
            local ttl_remain=$((XR_CACHE_TTL - cache_age))
            echo -e "\r  ${GREEN}✓ Loaded from cache${NC} ${GRAY}(${cache_age}s old, expires in ${ttl_remain}s | use ${WHITE}rc${GRAY} to refresh)${NC}"
        else
            echo -e "\r  ${YELLOW}Cache corrupt, rebuilding...${NC}                    "
        fi
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════════
    # PHASE 1: BFS Traversal with Parallel API Calls
    # ═══════════════════════════════════════════════════════════════════════════════
    if [[ $cache_loaded -eq 0 ]]; then
        echo -ne "  ${GRAY}Discovering cross-region topology (parallel API queries)...${NC}"
        
        mkdir -p "$TEMP_DIR" "$XR_CACHE_DIR"
        
        # Get starting DRG info
        local start_drg_json
        start_drg_json=$(oci network drg get --drg-id "$start_drg_id" --region "$start_region" --output json 2>/dev/null)
        
        # BFS queue: "drg_id|region|comp1,comp2,..."
        local -a drg_queue=()
        drg_queue+=("${start_drg_id}|${start_region}|$(IFS=,; echo "${search_comps[*]}")")
        
        while [[ ${#drg_queue[@]} -gt 0 ]]; do
            local queue_item="${drg_queue[0]}"
            drg_queue=("${drg_queue[@]:1}")
            
            local q_drg_id q_region q_comps_str
            IFS='|' read -r q_drg_id q_region q_comps_str <<< "$queue_item"
            
            [[ -n "${XR_VISITED_DRGS[$q_drg_id]+x}" ]] && continue
            XR_VISITED_DRGS[$q_drg_id]=1
            
            echo -ne "\r  ${GRAY}Scanning ${q_region} / ...${q_drg_id: -16}  (${#XR_VISITED_DRGS[@]} DRGs found)                   ${NC}"
            
            local -a q_comps=()
            IFS=',' read -ra q_comps <<< "$q_comps_str"
            
            # ── Parallel API calls for this DRG ──
            local _par_dir
            _par_dir=$(mktemp -d "${TEMP_DIR}/xr_par.XXXXXX")
            
            # Core queries (always needed)
            oci network drg get --drg-id "$q_drg_id" --region "$q_region" --output json > "$_par_dir/drg.json" 2>/dev/null &
            oci network drg-attachment list --drg-id "$q_drg_id" --region "$q_region" --all --output json > "$_par_dir/att.json" 2>/dev/null &
            oci network drg-route-table list --drg-id "$q_drg_id" --region "$q_region" --all --output json > "$_par_dir/drt.json" 2>/dev/null &
            oci network drg-redundancy-status get --drg-id "$q_drg_id" --region "$q_region" --output json > "$_par_dir/redund.json" 2>/dev/null &
            
            # Per-compartment queries (RPCs, FC, VPN)
            local _ci=0
            for comp in "${q_comps[@]}"; do
                oci network remote-peering-connection list --compartment-id "$comp" --drg-id "$q_drg_id" --region "$q_region" --output json > "$_par_dir/rpc_${_ci}.json" 2>/dev/null &
                oci network virtual-circuit list --compartment-id "$comp" --region "$q_region" --output json > "$_par_dir/fc_${_ci}.json" 2>/dev/null &
                oci network ip-sec-connection list --compartment-id "$comp" --drg-id "$q_drg_id" --region "$q_region" --output json > "$_par_dir/vpn_${_ci}.json" 2>/dev/null &
                ((_ci++))
            done
            
            wait  # Wait for all parallel calls to complete
            
            # ── Process DRG details ──
            local drg_json
            drg_json=$(cat "$_par_dir/drg.json" 2>/dev/null)
            if [[ -n "$drg_json" ]] && echo "$drg_json" | jq -e '.data' >/dev/null 2>&1; then
                XR_DRG_NAMES[$q_drg_id]=$(echo "$drg_json" | jq -r '.data["display-name"] // "Unknown"' 2>/dev/null)
                XR_DRG_STATES[$q_drg_id]=$(echo "$drg_json" | jq -r '.data["lifecycle-state"] // "N/A"' 2>/dev/null)
                XR_DRG_REGIONS[$q_drg_id]="$q_region"
                local drg_comp
                drg_comp=$(echo "$drg_json" | jq -r '.data["compartment-id"] // ""' 2>/dev/null)
                XR_DRG_COMPS[$q_drg_id]="$drg_comp"
                # Resolve compartment name using centralized resolver (leverages cache)
                if [[ -n "$drg_comp" ]]; then
                    local comp_name
                    comp_name=$(resolve_compartment_name "$drg_comp")
                    XR_DRG_COMP_NAMES[$q_drg_id]="${comp_name:-Unknown}"
                    local _ca=0; for c in "${q_comps[@]}"; do [[ "$c" == "$drg_comp" ]] && _ca=1; done
                    [[ $_ca -eq 0 ]] && q_comps+=("$drg_comp")
                fi
            else
                XR_DRG_NAMES[$q_drg_id]="DRG ...${q_drg_id: -8}"
                XR_DRG_STATES[$q_drg_id]="UNKNOWN"
                XR_DRG_REGIONS[$q_drg_id]="$q_region"
            fi
            
            # ── Process redundancy ──
            local redund_json
            redund_json=$(cat "$_par_dir/redund.json" 2>/dev/null)
            if [[ -n "$redund_json" ]] && echo "$redund_json" | jq -e '.data' >/dev/null 2>&1; then
                XR_DRG_REDUNDANCY[$q_drg_id]=$(echo "$redund_json" | jq -r '.data.status // "N/A"' 2>/dev/null)
            else
                XR_DRG_REDUNDANCY[$q_drg_id]="N/A"
            fi
            
            # ── Process default export route distribution ──
            if [[ -n "$drg_json" ]] && echo "$drg_json" | jq -e '.data' >/dev/null 2>&1; then
                local export_dist_id
                export_dist_id=$(echo "$drg_json" | jq -r '.data["default-export-drg-route-distribution-id"] // ""' 2>/dev/null)
                if [[ -n "$export_dist_id" && "$export_dist_id" != "null" ]]; then
                    # Fetch distribution details + statements in parallel
                    oci network drg-route-distribution get --drg-route-distribution-id "$export_dist_id" \
                        --region "$q_region" --output json > "$_par_dir/export_dist.json" 2>/dev/null &
                    oci network drg-route-distribution-statement list --route-distribution-id "$export_dist_id" --all \
                        --region "$q_region" --output json > "$_par_dir/export_dist_stmts.json" 2>/dev/null &
                    wait
                    
                    local exp_dist_json
                    exp_dist_json=$(cat "$_par_dir/export_dist.json" 2>/dev/null)
                    local exp_dist_name="N/A" exp_dist_type="N/A"
                    if [[ -n "$exp_dist_json" ]] && echo "$exp_dist_json" | jq -e '.data' >/dev/null 2>&1; then
                        exp_dist_name=$(echo "$exp_dist_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                        exp_dist_type=$(echo "$exp_dist_json" | jq -r '.data["distribution-type"] // "N/A"' 2>/dev/null)
                    fi
                    XR_DRG_EXPORT_DIST[$q_drg_id]="${exp_dist_name}|${exp_dist_type}|${export_dist_id}"
                    
                    local exp_stmts_json
                    exp_stmts_json=$(cat "$_par_dir/export_dist_stmts.json" 2>/dev/null)
                    if [[ -n "$exp_stmts_json" ]]; then
                        local exp_stmts_data
                        exp_stmts_data=$(echo "$exp_stmts_json" | jq '.data // .items // []' 2>/dev/null)
                        XR_DRG_EXPORT_DIST_STMTS[$q_drg_id]="$exp_stmts_data"
                    fi
                fi
            fi
            
            # ── Collect ALL route distributions (import + export) for Phase 2 display ──
            local _xr_dlist_json
            _xr_dlist_json=$(oci network drg-route-distribution list --drg-id "$q_drg_id" --region "$q_region" --all --output json 2>/dev/null)
            if [[ -n "$_xr_dlist_json" ]] && echo "$_xr_dlist_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                XR_DRG_DIST_LIST[$q_drg_id]=$(echo "$_xr_dlist_json" | jq '.data' 2>/dev/null)
            else
                XR_DRG_DIST_LIST[$q_drg_id]="[]"
            fi
            
            # ── Track region ──
            if [[ -z "${XR_REGION_DRGS[$q_region]+x}" ]]; then
                ((xr_total_regions++))
                XR_REGION_DRGS[$q_region]="[]"
            fi
            XR_REGION_DRGS[$q_region]=$(echo "${XR_REGION_DRGS[$q_region]}" | jq --arg id "$q_drg_id" '. + [$id]' 2>/dev/null)
            
            # ── Process attachments ──
            local att_json
            att_json=$(cat "$_par_dir/att.json" 2>/dev/null)
            if [[ -n "$att_json" ]] && echo "$att_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                XR_REGION_VCN_ATTACH["${q_region}:${q_drg_id}"]=$(echo "$att_json" | jq '.data' 2>/dev/null)
            else
                XR_REGION_VCN_ATTACH["${q_region}:${q_drg_id}"]="[]"
            fi
            
            # ── Process route tables + rules ──
            local drt_json
            drt_json=$(cat "$_par_dir/drt.json" 2>/dev/null)
            if [[ -n "$drt_json" ]] && echo "$drt_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                # Fetch route rules for each table (parallel batch)
                local -a _rt_ids=() _rt_names=()
                while IFS='|' read -r drt_id drt_name; do
                    [[ -z "$drt_id" ]] && continue
                    _rt_ids+=("$drt_id")
                    _rt_names+=("$drt_name")
                    XR_REGION_DRT_NAMES["${q_region}:${q_drg_id}:${drt_id}"]="$drt_name"
                    oci network drg-route-rule list --drg-route-table-id "$drt_id" --region "$q_region" --output json > "$_par_dir/rules_${drt_id: -8}.json" 2>/dev/null &
                done < <(echo "$drt_json" | jq -r '.data[] | "\(.id)|\(.["display-name"])"' 2>/dev/null)
                wait
                
                for drt_id in "${_rt_ids[@]}"; do
                    local rules_file="$_par_dir/rules_${drt_id: -8}.json"
                    if [[ -f "$rules_file" ]]; then
                        local rules_json
                        rules_json=$(cat "$rules_file" 2>/dev/null)
                        if [[ -n "$rules_json" ]]; then
                            XR_REGION_ROUTE_RULES["${q_region}:${q_drg_id}:${drt_id}"]=$(echo "$rules_json" | jq '.data // .items // []' 2>/dev/null)
                        fi
                    fi
                done
            fi
            
            # ── Process RPCs (merge from all compartments) ──
            local all_rpcs="[]"
            for ((_ci=0; _ci<${#q_comps[@]}; _ci++)); do
                local rpc_file="$_par_dir/rpc_${_ci}.json"
                if [[ -f "$rpc_file" ]]; then
                    local rpc_json
                    rpc_json=$(cat "$rpc_file" 2>/dev/null)
                    if [[ -n "$rpc_json" ]] && echo "$rpc_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                        all_rpcs=$(jq -n --argjson a "$all_rpcs" --argjson b "$(echo "$rpc_json" | jq '.data')" '$a + $b | unique_by(.id)')
                    fi
                fi
            done
            XR_REGION_RPCS["${q_region}:${q_drg_id}"]="$all_rpcs"
            
            # ── Process FastConnect (merge, filter by DRG) ──
            local all_fc="[]"
            for ((_ci=0; _ci<${#q_comps[@]}; _ci++)); do
                local fc_file="$_par_dir/fc_${_ci}.json"
                if [[ -f "$fc_file" ]]; then
                    local fc_json
                    fc_json=$(cat "$fc_file" 2>/dev/null)
                    if [[ -n "$fc_json" ]] && echo "$fc_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                        local filtered
                        filtered=$(echo "$fc_json" | jq --arg drg "$q_drg_id" '[.data[] | select(.["gateway-id"] == $drg)]' 2>/dev/null)
                        if [[ -n "$filtered" && "$filtered" != "[]" ]]; then
                            all_fc=$(jq -n --argjson a "$all_fc" --argjson b "$filtered" '$a + $b | unique_by(.id)')
                        fi
                    fi
                fi
            done
            XR_REGION_FC["${q_region}:${q_drg_id}"]="$all_fc"
            
            # ── Process VPN (merge from all compartments) ──
            local all_vpn="[]"
            for ((_ci=0; _ci<${#q_comps[@]}; _ci++)); do
                local vpn_file="$_par_dir/vpn_${_ci}.json"
                if [[ -f "$vpn_file" ]]; then
                    local vpn_json
                    vpn_json=$(cat "$vpn_file" 2>/dev/null)
                    if [[ -n "$vpn_json" ]] && echo "$vpn_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                        all_vpn=$(jq -n --argjson a "$all_vpn" --argjson b "$(echo "$vpn_json" | jq '.data')" '$a + $b | unique_by(.id)')
                    fi
                fi
            done
            XR_REGION_VPN["${q_region}:${q_drg_id}"]="$all_vpn"
            
            # ── Fetch VCN details + subnets + LPGs (parallel per VCN) ──
            local vcn_ids_raw
            vcn_ids_raw=$(echo "${XR_REGION_VCN_ATTACH["${q_region}:${q_drg_id}"]}" | jq -r \
                '.[] | select((.["network-details"]["type"] // "VCN") == "VCN") | .["network-details"]["id"] // .["vcn-id"] // empty' 2>/dev/null | sort -u)
            if [[ -n "$vcn_ids_raw" ]]; then
                while IFS= read -r vcn_id; do
                    [[ -z "$vcn_id" || "$vcn_id" == "null" ]] && continue
                    [[ -n "${XR_VCN_NAMES[$vcn_id]+x}" ]] && continue  # Already fetched
                    oci network vcn get --vcn-id "$vcn_id" --region "$q_region" --output json > "$_par_dir/vcn_${vcn_id: -8}.json" 2>/dev/null &
                    # Subnets: search all compartments
                    for comp in "${q_comps[@]}"; do
                        oci network subnet list --vcn-id "$vcn_id" --compartment-id "$comp" --region "$q_region" --output json > "$_par_dir/sub_${vcn_id: -8}_${comp: -8}.json" 2>/dev/null &
                        oci network local-peering-gateway list --vcn-id "$vcn_id" --compartment-id "$comp" --region "$q_region" --output json > "$_par_dir/lpg_${vcn_id: -8}_${comp: -8}.json" 2>/dev/null &
                    done
                done <<< "$vcn_ids_raw"
                wait
                
                # Process VCN/subnet/LPG results
                while IFS= read -r vcn_id; do
                    [[ -z "$vcn_id" || "$vcn_id" == "null" ]] && continue
                    [[ -n "${XR_VCN_NAMES[$vcn_id]+x}" ]] && continue
                    
                    local vcn_file="$_par_dir/vcn_${vcn_id: -8}.json"
                    if [[ -f "$vcn_file" ]]; then
                        local vcn_det
                        vcn_det=$(cat "$vcn_file" 2>/dev/null)
                        if [[ -n "$vcn_det" ]] && echo "$vcn_det" | jq -e '.data' >/dev/null 2>&1; then
                            XR_VCN_NAMES[$vcn_id]=$(echo "$vcn_det" | jq -r '.data["display-name"] // "Unknown"')
                            XR_VCN_CIDRS[$vcn_id]=$(echo "$vcn_det" | jq -r '.data["cidr-block"] // .data["cidr-blocks"][0] // ""')
                        fi
                    fi
                    [[ -z "${XR_VCN_NAMES[$vcn_id]+x}" ]] && XR_VCN_NAMES[$vcn_id]="Unknown"
                    [[ -z "${XR_VCN_CIDRS[$vcn_id]+x}" ]] && XR_VCN_CIDRS[$vcn_id]=""
                    
                    # Merge subnets from all compartments
                    local all_subs="[]"
                    for comp in "${q_comps[@]}"; do
                        local sub_file="$_par_dir/sub_${vcn_id: -8}_${comp: -8}.json"
                        if [[ -f "$sub_file" ]]; then
                            local sub_json
                            sub_json=$(cat "$sub_file" 2>/dev/null)
                            if [[ -n "$sub_json" ]] && echo "$sub_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                                all_subs=$(jq -n --argjson a "$all_subs" --argjson b "$(echo "$sub_json" | jq '.data')" '$a + $b | unique_by(.id)')
                            fi
                        fi
                    done
                    XR_VCN_SUBNETS[$vcn_id]="$all_subs"
                    
                    # Merge LPGs
                    local all_lpgs="[]"
                    for comp in "${q_comps[@]}"; do
                        local lpg_file="$_par_dir/lpg_${vcn_id: -8}_${comp: -8}.json"
                        if [[ -f "$lpg_file" ]]; then
                            local lpg_json
                            lpg_json=$(cat "$lpg_file" 2>/dev/null)
                            if [[ -n "$lpg_json" ]] && echo "$lpg_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                                all_lpgs=$(jq -n --argjson a "$all_lpgs" --argjson b "$(echo "$lpg_json" | jq '.data')" '$a + $b | unique_by(.id)')
                            fi
                        fi
                    done
                    XR_VCN_LPGS[$vcn_id]="$all_lpgs"
                done <<< "$vcn_ids_raw"
            fi
            
            # ── Follow RPC peering connections to discover remote DRGs ──
            local rpc_count
            rpc_count=$(echo "$all_rpcs" | jq 'length' 2>/dev/null || echo "0")
            if [[ "$rpc_count" -gt 0 ]]; then
                # Parallel resolve of peer RPCs
                while IFS='|' read -r peer_rpc_id peer_region peer_status; do
                    [[ "$peer_status" != "PEERED" ]] && continue
                    [[ -z "$peer_rpc_id" || "$peer_rpc_id" == "null" ]] && continue
                    [[ -z "$peer_region" || "$peer_region" == "null" ]] && continue
                    oci network remote-peering-connection get --remote-peering-connection-id "$peer_rpc_id" \
                        --region "$peer_region" --output json > "$_par_dir/peer_${peer_rpc_id: -8}.json" 2>/dev/null &
                done < <(echo "$all_rpcs" | jq -r '.[] | "\(.["peer-id"] // "")|\(.["peer-region-name"] // "")|\(.["peering-status"])"' 2>/dev/null)
                wait
                
                # Process peer RPC results
                while IFS='|' read -r peer_rpc_id peer_region peer_status; do
                    [[ "$peer_status" != "PEERED" ]] && continue
                    [[ -z "$peer_rpc_id" || "$peer_rpc_id" == "null" ]] && continue
                    
                    local peer_file="$_par_dir/peer_${peer_rpc_id: -8}.json"
                    if [[ -f "$peer_file" ]]; then
                        local peer_rpc_detail
                        peer_rpc_detail=$(cat "$peer_file" 2>/dev/null)
                        if [[ -n "$peer_rpc_detail" ]] && echo "$peer_rpc_detail" | jq -e '.data' >/dev/null 2>&1; then
                            local remote_drg_id remote_comp
                            remote_drg_id=$(echo "$peer_rpc_detail" | jq -r '.data["drg-id"] // ""')
                            remote_comp=$(echo "$peer_rpc_detail" | jq -r '.data["compartment-id"] // ""')
                            if [[ -n "$remote_drg_id" && -z "${XR_VISITED_DRGS[$remote_drg_id]+x}" ]]; then
                                local remote_comps_str
                                remote_comps_str=$(IFS=,; echo "${q_comps[*]}")
                                [[ -n "$remote_comp" ]] && remote_comps_str="$remote_comps_str,$remote_comp"
                                drg_queue+=("${remote_drg_id}|${peer_region}|${remote_comps_str}")
                            fi
                        fi
                    fi
                done < <(echo "$all_rpcs" | jq -r '.[] | "\(.["peer-id"] // "")|\(.["peer-region-name"] // "")|\(.["peering-status"])"' 2>/dev/null)
            fi
            
            # Cleanup temp dir for this DRG
            rm -rf "$_par_dir" 2>/dev/null
        done
        
        echo -ne "\r                                                                                          \r"
        
        # ── Save to cache ──
        mkdir -p "$XR_CACHE_DIR"
        {
            declare -p XR_REGION_DRGS 2>/dev/null
            declare -p XR_REGION_VCN_ATTACH 2>/dev/null
            declare -p XR_REGION_FC 2>/dev/null
            declare -p XR_REGION_VPN 2>/dev/null
            declare -p XR_REGION_RPCS 2>/dev/null
            declare -p XR_REGION_ROUTE_RULES 2>/dev/null
            declare -p XR_REGION_DRT_NAMES 2>/dev/null
            declare -p XR_DRG_NAMES 2>/dev/null
            declare -p XR_DRG_STATES 2>/dev/null
            declare -p XR_DRG_REGIONS 2>/dev/null
            declare -p XR_DRG_REDUNDANCY 2>/dev/null
            declare -p XR_DRG_COMPS 2>/dev/null
            declare -p XR_DRG_COMP_NAMES 2>/dev/null
            declare -p XR_DRG_EXPORT_DIST 2>/dev/null
            declare -p XR_DRG_EXPORT_DIST_STMTS 2>/dev/null
            declare -p XR_DRG_DIST_LIST 2>/dev/null
            declare -p XR_VISITED_DRGS 2>/dev/null
            declare -p XR_VCN_SUBNETS 2>/dev/null
            declare -p XR_VCN_LPGS 2>/dev/null
            declare -p XR_VCN_NAMES 2>/dev/null
            declare -p XR_VCN_CIDRS 2>/dev/null
        } > "${XR_CACHE_DIR}/xr_data.sh"
        echo "$xr_total_regions" > "${XR_CACHE_DIR}/xr_total_regions.txt"
        touch "${XR_CACHE_DIR}/.meta"
        
        echo -e "  ${GREEN}✓ Data collected and cached${NC} ${GRAY}(TTL: ${XR_CACHE_TTL}s)${NC}"
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════════
    # PHASE 2: Display the Comprehensive Map (compacted)
    # ═══════════════════════════════════════════════════════════════════════════════
    echo -e "  ${BOLD}${WHITE}Discovered: ${GREEN}${xr_total_regions} region(s)${NC}, ${WHITE}${#XR_VISITED_DRGS[@]} DRG(s)${NC}"
    
    # Build global attachment lookup (name, type) for route rule resolution
    declare -A XR_ATT_NAMES XR_ATT_TYPES
    for key in "${!XR_REGION_VCN_ATTACH[@]}"; do
        local att_data="${XR_REGION_VCN_ATTACH[$key]}"
        while IFS='|' read -r _aid _aname _atype; do
            [[ -z "$_aid" ]] && continue
            XR_ATT_NAMES[$_aid]="$_aname"
            XR_ATT_TYPES[$_aid]="$_atype"
        done < <(echo "$att_data" | jq -r '.[] | "\(.id)|\(.["display-name"] // "N/A")|\(.["network-details"]["type"] // "VCN")"' 2>/dev/null)
    done
    
    for region_key in $(echo "${!XR_REGION_DRGS[@]}" | tr ' ' '\n' | sort); do
        local is_current_region=""
        [[ "$region_key" == "$start_region" ]] && is_current_region="  ${GREEN}← CURRENT${NC}"
        
        printf "\n  ${BOLD}${CYAN}%s%s%s${NC}\n" "$TL" "$(printf '%*s' $((box_width-2)) '' | tr ' ' "$H")" "$TR"
        printf "  ${BOLD}${CYAN}%s${NC}  ${BOLD}${WHITE}🌍 REGION: %s${NC}%b%*s${BOLD}${CYAN}%s${NC}\n" \
            "$V" "$region_key" "$is_current_region" $((box_width - 18 - ${#region_key})) "" "$V"
        printf "  ${BOLD}${CYAN}%s%s%s${NC}\n" "$LT" "$(printf '%*s' $((box_width-2)) '' | tr ' ' "$H")" "$RT"
        
        local drg_ids_in_region
        drg_ids_in_region=$(echo "${XR_REGION_DRGS[$region_key]}" | jq -r '.[]' 2>/dev/null)
        
        while IFS= read -r drg_id; do
            [[ -z "$drg_id" ]] && continue
            
            local drg_name="${XR_DRG_NAMES[$drg_id]:-Unknown}"
            local drg_state="${XR_DRG_STATES[$drg_id]:-N/A}"
            local drg_redundancy="${XR_DRG_REDUNDANCY[$drg_id]:-N/A}"
            local drg_comp="${XR_DRG_COMPS[$drg_id]:-}"
            local drg_comp_name="${XR_DRG_COMP_NAMES[$drg_id]:-Unknown}"
            local state_color="$GREEN"; [[ "$drg_state" != "AVAILABLE" ]] && state_color="$YELLOW"
            local redund_color="$GREEN"
            case "$drg_redundancy" in
                REDUNDANT) redund_color="$GREEN" ;;
                NOT_AVAILABLE|N/A) redund_color="$GRAY" ;;
                *) redund_color="$YELLOW" ;;
            esac
            
            # DRG header — compact (no inner box)
            printf "  ${CYAN}%s${NC}  ${BOLD}${MAGENTA}🔷 DRG:${NC} ${WHITE}%s${NC} ${GRAY}|${NC} State: ${state_color}%s${NC} ${GRAY}|${NC} Redundancy: ${redund_color}%s${NC}%*s${CYAN}%s${NC}\n" \
                "$V" "$drg_name" "$drg_state" "$drg_redundancy" 2 "" "$V"
            printf "  ${CYAN}%s${NC}  ${CYAN}OCID:${NC} ${GRAY}%s${NC}%*s${CYAN}%s${NC}\n" \
                "$V" "$drg_id" $((box_width - 10 - ${#drg_id})) "" "$V"
            printf "  ${CYAN}%s${NC}  ${CYAN}Compartment:${NC} ${WHITE}%s${NC} ${GRAY}(%s)${NC}%*s${CYAN}%s${NC}\n" \
                "$V" "$drg_comp_name" "$drg_comp" 2 "" "$V"
            
            # Default Export Route Distribution
            local export_dist_info="${XR_DRG_EXPORT_DIST[$drg_id]:-}"
            if [[ -n "$export_dist_info" ]]; then
                local ed_name ed_type ed_ocid
                IFS='|' read -r ed_name ed_type ed_ocid <<< "$export_dist_info"
                printf "  ${CYAN}%s${NC}  ${CYAN}Default Export Distribution:${NC} ${GREEN}%s${NC} ${GRAY}[%s]${NC} ${GRAY}(%s)${NC}\n" \
                    "$V" "$ed_name" "$ed_type" "$ed_ocid"
                # Statements
                local export_stmts="${XR_DRG_EXPORT_DIST_STMTS[$drg_id]:-[]}"
                local export_stmt_count
                export_stmt_count=$(echo "$export_stmts" | jq 'length' 2>/dev/null || echo "0")
                if [[ "$export_stmt_count" -gt 0 ]]; then
                    while IFS='|' read -r es_action es_priority es_match_type es_att_type; do
                        [[ -z "$es_action" ]] && continue
                        local match_d=""
                        if [[ -n "$es_att_type" && "$es_att_type" != "null" ]]; then
                            match_d="attachment-type=${es_att_type}"
                        else
                            match_d="match=${es_match_type}"
                        fi
                        printf "  ${CYAN}%s${NC}    Priority ${GREEN}%s${NC}: ${WHITE}%s${NC}  %s\n" \
                            "$V" "$es_priority" "$es_action" "$match_d"
                    done < <(echo "$export_stmts" | jq -r '.[] | "\(.action)|\(.priority)|\(.["match-criteria"][0]["match-type"] // "ALL")|\(.["match-criteria"][0]["attachment-type"] // "null")"' 2>/dev/null)
                fi
            fi
            
            # ── ALL DRG Attachments (unified: VCN, VIRTUAL_CIRCUIT, IPSEC_TUNNEL, REMOTE_PEERING_CONNECTION) ──
            local att_data="${XR_REGION_VCN_ATTACH["${region_key}:${drg_id}"]:-[]}"
            local all_att_count
            all_att_count=$(echo "$att_data" | jq 'length' 2>/dev/null || echo "0")
            
            if [[ "$all_att_count" -gt 0 ]]; then
                printf "  ${CYAN}%s${NC}  ${GREEN}📦 Attachments (%s):${NC}%*s${CYAN}%s${NC}\n" "$V" "$all_att_count" $((box_width - 22 - ${#all_att_count})) "" "$V"
                while IFS='|' read -r att_name att_state att_id att_type att_net_id att_rt_id; do
                    [[ -z "$att_name" ]] && continue
                    local si="✓" si_color="$GREEN"
                    case "$att_state" in
                        ATTACHED) si="✓"; si_color="$GREEN" ;;
                        ATTACHING) si="◐"; si_color="$YELLOW" ;;
                        DETACHING|DETACHED) si="○"; si_color="$YELLOW" ;;
                        *) si="○"; si_color="$GRAY" ;;
                    esac
                    
                    # Route table assignment
                    local rt_d=""
                    if [[ -n "$att_rt_id" && "$att_rt_id" != "null" ]]; then
                        local rt_n="${XR_REGION_DRT_NAMES["${region_key}:${drg_id}:${att_rt_id}"]:-}"
                        [[ -n "$rt_n" ]] && rt_d="RT: ${rt_n}"
                    fi
                    
                    # Extra detail based on type
                    local extra_detail=""
                    if [[ "$att_type" == "VCN" ]]; then
                        local vcn_name="${XR_VCN_NAMES[$att_net_id]:-Unknown}"
                        local vcn_cidr="${XR_VCN_CIDRS[$att_net_id]:-}"
                        local lpg_data="${XR_VCN_LPGS[$att_net_id]:-[]}"
                        local lpg_count
                        lpg_count=$(echo "$lpg_data" | jq 'length' 2>/dev/null || echo "0")
                        extra_detail="VCN: ${vcn_name}"
                        [[ -n "$vcn_cidr" ]] && extra_detail="${extra_detail} [${vcn_cidr}]"
                        [[ "$lpg_count" -gt 0 ]] && extra_detail="${extra_detail} 🔗LPG(${lpg_count})"
                    elif [[ "$att_type" == "REMOTE_PEERING_CONNECTION" ]]; then
                        # Find matching RPC for peer region, peering status, and RPC display name
                        local rpc_data="${XR_REGION_RPCS["${region_key}:${drg_id}"]:-[]}"
                        local rpc_peer_region rpc_status rpc_display_name
                        rpc_display_name=$(echo "$rpc_data" | jq -r --arg nid "$att_net_id" '.[] | select(.id == $nid) | .["display-name"] // ""' 2>/dev/null)
                        rpc_peer_region=$(echo "$rpc_data" | jq -r --arg nid "$att_net_id" '.[] | select(.id == $nid) | .["peer-region-name"] // ""' 2>/dev/null)
                        rpc_status=$(echo "$rpc_data" | jq -r --arg nid "$att_net_id" '.[] | select(.id == $nid) | .["peering-status"] // ""' 2>/dev/null)
                        [[ -n "$rpc_display_name" ]] && extra_detail="RPC: ${rpc_display_name}"
                        if [[ -n "$rpc_peer_region" ]]; then
                            extra_detail="${extra_detail} → ${rpc_peer_region}"
                        fi
                        if [[ -n "$rpc_status" ]]; then
                            local rpc_sc="${GREEN}"; [[ "$rpc_status" != "PEERED" ]] && rpc_sc="${YELLOW}"
                            extra_detail="${extra_detail} [${rpc_sc}${rpc_status}${NC}]"
                        fi
                    elif [[ "$att_type" == "VIRTUAL_CIRCUIT" ]]; then
                        local fc_data="${XR_REGION_FC["${region_key}:${drg_id}"]:-[]}"
                        local fc_bw fc_bgp fc_provider
                        fc_bw=$(echo "$fc_data" | jq -r --arg nid "$att_net_id" '.[] | select(.id == $nid) | .["bandwidth-shape-name"] // ""' 2>/dev/null)
                        fc_bgp=$(echo "$fc_data" | jq -r --arg nid "$att_net_id" '.[] | select(.id == $nid) | .["bgp-session-state"] // ""' 2>/dev/null)
                        fc_provider=$(echo "$fc_data" | jq -r --arg nid "$att_net_id" '.[] | select(.id == $nid) | .["provider-name"] // ""' 2>/dev/null)
                        [[ -n "$fc_bw" ]] && extra_detail="${fc_bw}"
                        [[ -n "$fc_provider" ]] && extra_detail="${extra_detail} ${fc_provider}"
                        [[ -n "$fc_bgp" ]] && extra_detail="${extra_detail} BGP:${fc_bgp}"
                    elif [[ "$att_type" == "IPSEC_TUNNEL" ]]; then
                        local vpn_data="${XR_REGION_VPN["${region_key}:${drg_id}"]:-[]}"
                        local cpe_id
                        cpe_id=$(echo "$vpn_data" | jq -r --arg nid "$att_net_id" '.[] | select(.id == $nid) | .["cpe-id"] // ""' 2>/dev/null)
                        if [[ -n "$cpe_id" && "$cpe_id" != "null" ]]; then
                            local cpe_name
                            cpe_name=$(oci network cpe get --cpe-id "$cpe_id" --region "$region_key" --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                            [[ -n "$cpe_name" ]] && extra_detail="CPE: ${cpe_name}"
                        fi
                    fi
                    
                    printf "  ${CYAN}%s${NC}    ${si_color}%s${NC} ${WHITE}%-28s${NC} ${YELLOW}%-26s${NC} ${si_color}%-10s${NC} ${GRAY}%s${NC}" \
                        "$V" "$si" "${att_name:0:28}" "${att_type:0:26}" "${att_state:0:10}" "$rt_d"
                    [[ -n "$extra_detail" ]] && printf "  %b" "$extra_detail"
                    printf "\n"
                    
                    # ── Subnet drill-down for VCN attachments ──
                    if [[ "$att_type" == "VCN" && -n "$att_net_id" && "$att_net_id" != "null" ]]; then
                        local sub_data="${XR_VCN_SUBNETS[$att_net_id]:-[]}"
                        local sub_count
                        sub_count=$(echo "$sub_data" | jq 'length' 2>/dev/null || echo "0")
                        local lpg_data="${XR_VCN_LPGS[$att_net_id]:-[]}"
                        local lpg_count
                        lpg_count=$(echo "$lpg_data" | jq 'length' 2>/dev/null || echo "0")
                        if [[ "$sub_count" -gt 0 ]]; then
                            while IFS='|' read -r sub_name sub_cidr sub_access; do
                                [[ -z "$sub_name" ]] && continue
                                local access_icon="🔒"
                                [[ "$sub_access" == "true" ]] && access_icon="🌐"
                                local sub_lpg_flag=""
                                [[ "$lpg_count" -gt 0 ]] && sub_lpg_flag=" ${GREEN}🔗${NC}"
                                printf "  ${CYAN}%s${NC}         %s ${GRAY}%-26s${NC} ${WHITE}%-18s${NC}%b\n" \
                                    "$V" "$access_icon" "${sub_name:0:26}" "${sub_cidr:0:18}" "$sub_lpg_flag"
                            done < <(echo "$sub_data" | jq -r '.[] | "\(.["display-name"] // "N/A")|\(.["cidr-block"] // "")|\(.["prohibit-internet-ingress"] // "true" | if . == false then "true" else "false" end)"' 2>/dev/null)
                        fi
                        if [[ "$lpg_count" -gt 0 ]]; then
                            while IFS='|' read -r lpg_name lpg_status; do
                                [[ -z "$lpg_name" ]] && continue
                                local lpg_color="$GREEN"; [[ "$lpg_status" != "PEERED" ]] && lpg_color="$YELLOW"
                                printf "  ${CYAN}%s${NC}         ${lpg_color}🔗 LPG: %-22s${NC} [${lpg_color}%s${NC}]\n" \
                                    "$V" "${lpg_name:0:22}" "$lpg_status"
                            done < <(echo "$lpg_data" | jq -r '.[] | "\(.["display-name"])|\(.["peering-status"])"' 2>/dev/null)
                        fi
                    fi
                    
                    # ── FastConnect drill-down for VIRTUAL_CIRCUIT attachments ──
                    if [[ "$att_type" == "VIRTUAL_CIRCUIT" && -n "$att_net_id" && "$att_net_id" != "null" ]]; then
                        local _fc_vc_detail
                        _fc_vc_detail=$(oci network virtual-circuit get --virtual-circuit-id "$att_net_id" --region "$region_key" --output json 2>/dev/null)
                        if [[ -n "$_fc_vc_detail" ]] && echo "$_fc_vc_detail" | jq -e '.data' >/dev/null 2>&1; then
                            # Encryption status
                            local _fc_is_transport _fc_encrypt_d
                            _fc_is_transport=$(echo "$_fc_vc_detail" | jq -r '.data["is-transport-mode"] // "null"' 2>/dev/null)
                            if [[ "$_fc_is_transport" == "true" ]]; then
                                _fc_encrypt_d="${GREEN}IPSec Transport Mode${NC}"
                            elif [[ "$_fc_is_transport" == "false" ]]; then
                                _fc_encrypt_d="${GRAY}Not encrypted (IPSec)${NC}"
                            else
                                _fc_encrypt_d="${GRAY}N/A${NC}"
                            fi
                            printf "  ${CYAN}%s${NC}         ${CYAN}Encryption:${NC} %b\n" "$V" "$_fc_encrypt_d"
                            
                            # MTU
                            local _fc_mtu
                            _fc_mtu=$(echo "$_fc_vc_detail" | jq -r '.data["ip-mtu"] // "N/A"' 2>/dev/null)
                            [[ "$_fc_mtu" != "N/A" && "$_fc_mtu" != "null" ]] && \
                                printf "  ${CYAN}%s${NC}         ${CYAN}MTU:${NC} ${WHITE}%s${NC}\n" "$V" "$_fc_mtu"
                            
                            # Cross-connect mappings → physical details
                            local _fc_cc_maps
                            _fc_cc_maps=$(echo "$_fc_vc_detail" | jq -r '.data["cross-connect-mappings"] // []' 2>/dev/null)
                            local _fc_cc_count
                            _fc_cc_count=$(echo "$_fc_cc_maps" | jq 'length' 2>/dev/null || echo "0")
                            
                            if [[ "$_fc_cc_count" -gt 0 ]]; then
                                local _fc_ci=0
                                while [[ $_fc_ci -lt $_fc_cc_count ]]; do
                                    local _fc_ccid
                                    _fc_ccid=$(echo "$_fc_cc_maps" | jq -r ".[$_fc_ci][\"cross-connect-or-cross-connect-group-id\"] // \"null\"" 2>/dev/null)
                                    
                                    if [[ -n "$_fc_ccid" && "$_fc_ccid" != "null" ]]; then
                                        if [[ "$_fc_ccid" == ocid1.crossconnect.* ]]; then
                                            local _fc_cc_json
                                            _fc_cc_json=$(oci network cross-connect get --cross-connect-id "$_fc_ccid" --region "$region_key" --output json 2>/dev/null)
                                            if [[ -n "$_fc_cc_json" ]] && echo "$_fc_cc_json" | jq -e '.data' >/dev/null 2>&1; then
                                                local _fc_loc _fc_phys _fc_logi _fc_port _fc_speed _fc_ms_state _fc_cc_state
                                                _fc_loc=$(echo "$_fc_cc_json" | jq -r '.data["location-name"] // "N/A"' 2>/dev/null)
                                                _fc_phys=$(echo "$_fc_cc_json" | jq -r '.data["oci-physical-device-name"] // "N/A"' 2>/dev/null)
                                                _fc_logi=$(echo "$_fc_cc_json" | jq -r '.data["oci-logical-device-name"] // "N/A"' 2>/dev/null)
                                                _fc_port=$(echo "$_fc_cc_json" | jq -r '.data["port-name"] // "N/A"' 2>/dev/null)
                                                _fc_speed=$(echo "$_fc_cc_json" | jq -r '.data["port-speed-shape-name"] // "N/A"' 2>/dev/null)
                                                _fc_ms_state=$(echo "$_fc_cc_json" | jq -r '.data["macsec-properties"]["state"] // "N/A"' 2>/dev/null)
                                                _fc_cc_state=$(echo "$_fc_cc_json" | jq -r '.data["lifecycle-state"] // "N/A"' 2>/dev/null)
                                                
                                                printf "  ${CYAN}%s${NC}         ${CYAN}Phys Location:${NC} ${WHITE}%s${NC}  ${CYAN}Phys Device:${NC} ${WHITE}%s${NC}  ${CYAN}Logical Device:${NC} ${WHITE}%s${NC}\n" \
                                                    "$V" "$_fc_loc" "$_fc_phys" "$_fc_logi"
                                                
                                                # MACsec
                                                local _fc_ms_c="$GRAY"
                                                [[ "$_fc_ms_state" == "ENABLED" ]] && _fc_ms_c="$GREEN"
                                                [[ "$_fc_ms_state" == "DISABLED" ]] && _fc_ms_c="$YELLOW"
                                                printf "  ${CYAN}%s${NC}         ${CYAN}MACsec:${NC} ${_fc_ms_c}%s${NC}" "$V" "$_fc_ms_state"
                                                if [[ "$_fc_ms_state" == "ENABLED" ]]; then
                                                    local _fc_ms_cipher
                                                    _fc_ms_cipher=$(echo "$_fc_cc_json" | jq -r '.data["macsec-properties"]["encryption-cipher"] // "N/A"' 2>/dev/null)
                                                    printf "  ${CYAN}Cipher:${NC} ${WHITE}%s${NC}" "$_fc_ms_cipher"
                                                fi
                                                printf "\n"
                                                
                                                # Light levels
                                                local _fc_ll_ind _fc_ll_val
                                                _fc_ll_ind=$(echo "$_fc_cc_json" | jq -r '.data["customer-reference-name"] // "N/A"' 2>/dev/null)
                                                [[ "$_fc_ll_ind" != "N/A" && "$_fc_ll_ind" != "null" && -n "$_fc_ll_ind" ]] && \
                                                    printf "  ${CYAN}%s${NC}         ${CYAN}Light Level Ref:${NC} ${WHITE}%s${NC}\n" "$V" "$_fc_ll_ind"
                                                
                                                # Interface state
                                                local _fc_if_c="$GREEN"
                                                case "$_fc_cc_state" in
                                                    PROVISIONED) _fc_if_c="$GREEN" ;;
                                                    PENDING_*|PROVISIONING) _fc_if_c="$YELLOW" ;;
                                                    *) _fc_if_c="$RED" ;;
                                                esac
                                                printf "  ${CYAN}%s${NC}         ${CYAN}Interface State:${NC} ${_fc_if_c}%s${NC}  ${CYAN}Port:${NC} ${WHITE}%s${NC} ${GRAY}(%s)${NC}\n" \
                                                    "$V" "$_fc_cc_state" "$_fc_port" "$_fc_speed"
                                            fi
                                        elif [[ "$_fc_ccid" == ocid1.crossconnectgroup.* ]]; then
                                            # Cross-connect group — show group + member details
                                            local _fc_ccg_json
                                            _fc_ccg_json=$(oci network cross-connect-group get --cross-connect-group-id "$_fc_ccid" --region "$region_key" --output json 2>/dev/null)
                                            if [[ -n "$_fc_ccg_json" ]] && echo "$_fc_ccg_json" | jq -e '.data' >/dev/null 2>&1; then
                                                local _fc_ccg_name _fc_ccg_ms
                                                _fc_ccg_name=$(echo "$_fc_ccg_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                                                _fc_ccg_ms=$(echo "$_fc_ccg_json" | jq -r '.data["macsec-properties"]["state"] // "N/A"' 2>/dev/null)
                                                local _fc_ccg_ms_c="$GRAY"
                                                [[ "$_fc_ccg_ms" == "ENABLED" ]] && _fc_ccg_ms_c="$GREEN"
                                                [[ "$_fc_ccg_ms" == "DISABLED" ]] && _fc_ccg_ms_c="$YELLOW"
                                                printf "  ${CYAN}%s${NC}         ${CYAN}CC Group:${NC} ${WHITE}%s${NC}  ${CYAN}MACsec:${NC} ${_fc_ccg_ms_c}%s${NC}\n" \
                                                    "$V" "$_fc_ccg_name" "$_fc_ccg_ms"
                                            fi
                                            
                                            # List member cross-connects
                                            for _fc_sc in "${search_comps[@]}"; do
                                                [[ -z "$_fc_sc" ]] && continue
                                                local _fc_mem_json
                                                _fc_mem_json=$(oci network cross-connect list --compartment-id "$_fc_sc" \
                                                    --cross-connect-group-id "$_fc_ccid" --region "$region_key" --output json 2>/dev/null)
                                                if [[ -n "$_fc_mem_json" ]] && echo "$_fc_mem_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                                                    while IFS='|' read -r _fm_name _fm_state _fm_loc _fm_phys _fm_logi _fm_port _fm_speed _fm_ms; do
                                                        [[ -z "$_fm_name" ]] && continue
                                                        local _fm_if_c="$GREEN"
                                                        case "$_fm_state" in PROVISIONED) ;; PENDING_*|PROVISIONING) _fm_if_c="$YELLOW" ;; *) _fm_if_c="$RED" ;; esac
                                                        local _fm_ms_c="$GRAY"
                                                        [[ "$_fm_ms" == "ENABLED" ]] && _fm_ms_c="$GREEN"
                                                        [[ "$_fm_ms" == "DISABLED" ]] && _fm_ms_c="$YELLOW"
                                                        
                                                        printf "  ${CYAN}%s${NC}           ${WHITE}%s${NC}  ${CYAN}Loc:${NC}${WHITE}%s${NC}  ${CYAN}Phys:${NC}${WHITE}%s${NC}  ${CYAN}Logi:${NC}${WHITE}%s${NC}\n" \
                                                            "$V" "$_fm_name" "$_fm_loc" "$_fm_phys" "$_fm_logi"
                                                        printf "  ${CYAN}%s${NC}             ${CYAN}Port:${NC}${WHITE}%s${NC} ${GRAY}(%s)${NC}  ${CYAN}State:${NC}${_fm_if_c}%s${NC}  ${CYAN}MACsec:${NC}${_fm_ms_c}%s${NC}\n" \
                                                            "$V" "$_fm_port" "$_fm_speed" "$_fm_state" "$_fm_ms"
                                                    done < <(echo "$_fc_mem_json" | jq -r '.data[] | "\(.["display-name"] // "N/A")|\(.["lifecycle-state"] // "N/A")|\(.["location-name"] // "N/A")|\(.["oci-physical-device-name"] // "N/A")|\(.["oci-logical-device-name"] // "N/A")|\(.["port-name"] // "N/A")|\(.["port-speed-shape-name"] // "N/A")|\(.["macsec-properties"]["state"] // "N/A")"' 2>/dev/null)
                                                    break
                                                fi
                                            done
                                        fi
                                    fi
                                    ((_fc_ci++))
                                done
                            fi
                        fi
                    fi
                done < <(echo "$att_data" | jq -r '.[] | "\(.["display-name"] // "N/A")|\(.["lifecycle-state"])|\(.id)|\(.["network-details"]["type"] // "VCN")|\(.["network-details"]["id"] // "null")|\(.["drg-route-table-id"] // "null")"' 2>/dev/null)
            fi
            
            # ── RPCs not shown as attachments (peer info) ──
            local rpc_data="${XR_REGION_RPCS["${region_key}:${drg_id}"]:-[]}"
            local rpc_count
            rpc_count=$(echo "$rpc_data" | jq 'length' 2>/dev/null || echo "0")
            if [[ "$rpc_count" -gt 0 ]]; then
                # Check if any RPCs were NOT already shown as attachments
                local rpc_shown_as_att=0
                local att_rpc_ids
                att_rpc_ids=$(echo "$att_data" | jq -r '.[] | select(.["network-details"]["type"] == "REMOTE_PEERING_CONNECTION") | .["network-details"]["id"]' 2>/dev/null)
                # Show standalone RPCs section only if there are RPCs not in attachments
                local standalone_rpcs="[]"
                while IFS='|' read -r rpc_id rpc_name peer_region peer_status; do
                    [[ -z "$rpc_id" ]] && continue
                    local found=0
                    if [[ -n "$att_rpc_ids" ]]; then
                        while IFS= read -r aid; do [[ "$aid" == "$rpc_id" ]] && found=1 && break; done <<< "$att_rpc_ids"
                    fi
                    if [[ $found -eq 0 ]]; then
                        standalone_rpcs=$(echo "$standalone_rpcs" | jq --arg n "$rpc_name" --arg r "$peer_region" --arg s "$peer_status" '. + [{"name":$n,"region":$r,"status":$s}]')
                    fi
                done < <(echo "$rpc_data" | jq -r '.[] | "\(.id)|\(.["display-name"])|\(.["peer-region-name"] // "")|\(.["peering-status"])"' 2>/dev/null)
                local standalone_count
                standalone_count=$(echo "$standalone_rpcs" | jq 'length' 2>/dev/null || echo "0")
                if [[ "$standalone_count" -gt 0 ]]; then
                    printf "  ${CYAN}%s${NC}  ${YELLOW}🌍 Remote Peering (%s):${NC}\n" "$V" "$standalone_count"
                    while IFS='|' read -r rpc_name peer_region peer_status; do
                        local ps_c="$GREEN"; [[ "$peer_status" != "PEERED" ]] && ps_c="$YELLOW"
                        printf "  ${CYAN}%s${NC}    ${ps_c}⟷${NC} ${WHITE}%-22s${NC} ${ps_c}──►${NC} ${YELLOW}%s${NC} [${ps_c}%s${NC}]\n" \
                            "$V" "${rpc_name:0:22}" "${peer_region:-N/A}" "$peer_status"
                    done < <(echo "$standalone_rpcs" | jq -r '.[] | "\(.name)|\(.region)|\(.status)"' 2>/dev/null)
                fi
            fi
            
            # ── FC not shown as attachments ──
            local fc_data="${XR_REGION_FC["${region_key}:${drg_id}"]:-[]}"
            local fc_count
            fc_count=$(echo "$fc_data" | jq 'length' 2>/dev/null || echo "0")
            if [[ "$fc_count" -gt 0 ]]; then
                local att_fc_ids
                att_fc_ids=$(echo "$att_data" | jq -r '.[] | select(.["network-details"]["type"] == "VIRTUAL_CIRCUIT") | .["network-details"]["id"]' 2>/dev/null)
                local standalone_fc=0
                while IFS='|' read -r fc_id fc_name fc_state fc_bw fc_provider fc_bgp; do
                    [[ -z "$fc_id" ]] && continue
                    local found=0
                    if [[ -n "$att_fc_ids" ]]; then
                        while IFS= read -r aid; do [[ "$aid" == "$fc_id" ]] && found=1 && break; done <<< "$att_fc_ids"
                    fi
                    if [[ $found -eq 0 ]]; then
                        [[ $standalone_fc -eq 0 ]] && printf "  ${CYAN}%s${NC}  ${MAGENTA}⚡ FastConnect (standalone):${NC}\n" "$V"
                        standalone_fc=1
                        local bgp_c="$GREEN"; [[ "$fc_bgp" == "DOWN" ]] && bgp_c="$RED"; [[ "$fc_bgp" == "N/A" ]] && bgp_c="$GRAY"
                        printf "  ${CYAN}%s${NC}    ⚡ ${WHITE}%-22s${NC} ${GRAY}%s %s${NC} BGP:${bgp_c}%s${NC}\n" \
                            "$V" "${fc_name:0:22}" "$fc_bw" "${fc_provider:0:15}" "${fc_bgp:-N/A}"
                        
                        # Extended FC details for standalone circuits
                        local _sfc_detail
                        _sfc_detail=$(oci network virtual-circuit get --virtual-circuit-id "$fc_id" --region "$region_key" --output json 2>/dev/null)
                        if [[ -n "$_sfc_detail" ]] && echo "$_sfc_detail" | jq -e '.data' >/dev/null 2>&1; then
                            local _sfc_transport _sfc_mtu
                            _sfc_transport=$(echo "$_sfc_detail" | jq -r '.data["is-transport-mode"] // "null"' 2>/dev/null)
                            _sfc_mtu=$(echo "$_sfc_detail" | jq -r '.data["ip-mtu"] // "N/A"' 2>/dev/null)
                            local _sfc_enc_d="${GRAY}N/A${NC}"
                            [[ "$_sfc_transport" == "true" ]] && _sfc_enc_d="${GREEN}IPSec Transport Mode${NC}"
                            [[ "$_sfc_transport" == "false" ]] && _sfc_enc_d="${GRAY}Not encrypted${NC}"
                            printf "  ${CYAN}%s${NC}      ${CYAN}Encryption:${NC} %b" "$V" "$_sfc_enc_d"
                            [[ "$_sfc_mtu" != "N/A" && "$_sfc_mtu" != "null" ]] && printf "  ${CYAN}MTU:${NC} ${WHITE}%s${NC}" "$_sfc_mtu"
                            printf "\n"
                            
                            local _sfc_cc_maps
                            _sfc_cc_maps=$(echo "$_sfc_detail" | jq -r '.data["cross-connect-mappings"] // []' 2>/dev/null)
                            local _sfc_cc_ct
                            _sfc_cc_ct=$(echo "$_sfc_cc_maps" | jq 'length' 2>/dev/null || echo "0")
                            local _sfc_ci=0
                            while [[ $_sfc_ci -lt $_sfc_cc_ct ]]; do
                                local _sfc_ccid
                                _sfc_ccid=$(echo "$_sfc_cc_maps" | jq -r ".[$_sfc_ci][\"cross-connect-or-cross-connect-group-id\"] // \"null\"" 2>/dev/null)
                                if [[ -n "$_sfc_ccid" && "$_sfc_ccid" != "null" && "$_sfc_ccid" == ocid1.crossconnect.* ]]; then
                                    local _sfc_cc_json
                                    _sfc_cc_json=$(oci network cross-connect get --cross-connect-id "$_sfc_ccid" --region "$region_key" --output json 2>/dev/null)
                                    if [[ -n "$_sfc_cc_json" ]] && echo "$_sfc_cc_json" | jq -e '.data' >/dev/null 2>&1; then
                                        local _sfc_loc _sfc_phys _sfc_logi _sfc_port _sfc_speed _sfc_ms _sfc_st
                                        _sfc_loc=$(echo "$_sfc_cc_json" | jq -r '.data["location-name"] // "N/A"' 2>/dev/null)
                                        _sfc_phys=$(echo "$_sfc_cc_json" | jq -r '.data["oci-physical-device-name"] // "N/A"' 2>/dev/null)
                                        _sfc_logi=$(echo "$_sfc_cc_json" | jq -r '.data["oci-logical-device-name"] // "N/A"' 2>/dev/null)
                                        _sfc_port=$(echo "$_sfc_cc_json" | jq -r '.data["port-name"] // "N/A"' 2>/dev/null)
                                        _sfc_speed=$(echo "$_sfc_cc_json" | jq -r '.data["port-speed-shape-name"] // "N/A"' 2>/dev/null)
                                        _sfc_ms=$(echo "$_sfc_cc_json" | jq -r '.data["macsec-properties"]["state"] // "N/A"' 2>/dev/null)
                                        _sfc_st=$(echo "$_sfc_cc_json" | jq -r '.data["lifecycle-state"] // "N/A"' 2>/dev/null)
                                        
                                        local _sfc_ms_c="$GRAY"; [[ "$_sfc_ms" == "ENABLED" ]] && _sfc_ms_c="$GREEN"; [[ "$_sfc_ms" == "DISABLED" ]] && _sfc_ms_c="$YELLOW"
                                        local _sfc_if_c="$GREEN"
                                        case "$_sfc_st" in PROVISIONED) ;; PENDING_*|PROVISIONING) _sfc_if_c="$YELLOW" ;; *) _sfc_if_c="$RED" ;; esac
                                        
                                        printf "  ${CYAN}%s${NC}      ${CYAN}Loc:${NC}${WHITE}%s${NC}  ${CYAN}Phys:${NC}${WHITE}%s${NC}  ${CYAN}Logi:${NC}${WHITE}%s${NC}  ${CYAN}Port:${NC}${WHITE}%s${NC}${GRAY}(%s)${NC}\n" \
                                            "$V" "$_sfc_loc" "$_sfc_phys" "$_sfc_logi" "$_sfc_port" "$_sfc_speed"
                                        printf "  ${CYAN}%s${NC}      ${CYAN}MACsec:${NC}${_sfc_ms_c}%s${NC}  ${CYAN}State:${NC}${_sfc_if_c}%s${NC}\n" \
                                            "$V" "$_sfc_ms" "$_sfc_st"
                                        
                                        local _sfc_ll
                                        _sfc_ll=$(echo "$_sfc_cc_json" | jq -r '.data["customer-reference-name"] // "N/A"' 2>/dev/null)
                                        [[ "$_sfc_ll" != "N/A" && "$_sfc_ll" != "null" && -n "$_sfc_ll" ]] && \
                                            printf "  ${CYAN}%s${NC}      ${CYAN}Light Level Ref:${NC}${WHITE}%s${NC}\n" "$V" "$_sfc_ll"
                                    fi
                                elif [[ -n "$_sfc_ccid" && "$_sfc_ccid" != "null" && "$_sfc_ccid" == ocid1.crossconnectgroup.* ]]; then
                                    local _sfc_ccg_json
                                    _sfc_ccg_json=$(oci network cross-connect-group get --cross-connect-group-id "$_sfc_ccid" --region "$region_key" --output json 2>/dev/null)
                                    if [[ -n "$_sfc_ccg_json" ]] && echo "$_sfc_ccg_json" | jq -e '.data' >/dev/null 2>&1; then
                                        local _sfc_ccg_name _sfc_ccg_ms
                                        _sfc_ccg_name=$(echo "$_sfc_ccg_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                                        _sfc_ccg_ms=$(echo "$_sfc_ccg_json" | jq -r '.data["macsec-properties"]["state"] // "N/A"' 2>/dev/null)
                                        local _sfc_ccg_ms_c="$GRAY"; [[ "$_sfc_ccg_ms" == "ENABLED" ]] && _sfc_ccg_ms_c="$GREEN"
                                        printf "  ${CYAN}%s${NC}      ${CYAN}CC Group:${NC}${WHITE}%s${NC}  ${CYAN}MACsec:${NC}${_sfc_ccg_ms_c}%s${NC}\n" "$V" "$_sfc_ccg_name" "$_sfc_ccg_ms"
                                    fi
                                fi
                                ((_sfc_ci++))
                            done
                        fi
                    fi
                done < <(echo "$fc_data" | jq -r '.[] | "\(.id)|\(.["display-name"])|\(.["lifecycle-state"])|\(.["bandwidth-shape-name"] // "N/A")|\(.["provider-name"] // "")|\(.["bgp-session-state"] // "N/A")"' 2>/dev/null)
            fi
            
            # ── VPN not shown as attachments ──
            local vpn_data="${XR_REGION_VPN["${region_key}:${drg_id}"]:-[]}"
            local vpn_count
            vpn_count=$(echo "$vpn_data" | jq 'length' 2>/dev/null || echo "0")
            if [[ "$vpn_count" -gt 0 ]]; then
                local att_vpn_ids
                att_vpn_ids=$(echo "$att_data" | jq -r '.[] | select(.["network-details"]["type"] == "IPSEC_TUNNEL") | .["network-details"]["id"]' 2>/dev/null)
                local standalone_vpn=0
                while IFS='|' read -r vpn_id vpn_name vpn_state cpe_id; do
                    [[ -z "$vpn_id" ]] && continue
                    local found=0
                    if [[ -n "$att_vpn_ids" ]]; then
                        while IFS= read -r aid; do [[ "$aid" == "$vpn_id" ]] && found=1 && break; done <<< "$att_vpn_ids"
                    fi
                    if [[ $found -eq 0 ]]; then
                        [[ $standalone_vpn -eq 0 ]] && printf "  ${CYAN}%s${NC}  ${RED}🔒 IPSec VPN (standalone):${NC}\n" "$V"
                        standalone_vpn=1
                        printf "  ${CYAN}%s${NC}    🔐 ${WHITE}%-22s${NC}\n" "$V" "${vpn_name:0:22}"
                    fi
                done < <(echo "$vpn_data" | jq -r '.[] | "\(.id)|\(.["display-name"])|\(.["lifecycle-state"])|\(.["cpe-id"] // "")"' 2>/dev/null)
            fi
            
            # ── Route Rules (per DRG, grouped by route table) ──
            local has_rules=0
            for key in "${!XR_REGION_ROUTE_RULES[@]}"; do
                [[ "$key" != "${region_key}:${drg_id}:"* ]] && continue
                local rules="${XR_REGION_ROUTE_RULES[$key]}"
                local rule_count
                rule_count=$(echo "$rules" | jq 'length' 2>/dev/null || echo "0")
                [[ "$rule_count" -gt 0 ]] && has_rules=1 && break
            done
            
            if [[ $has_rules -eq 1 ]]; then
                printf "  ${CYAN}%s${NC}  ${BOLD}${WHITE}📋 Route Rules:${NC}\n" "$V"
                for key in $(echo "${!XR_REGION_ROUTE_RULES[@]}" | tr ' ' '\n' | grep "^${region_key}:${drg_id}:" | sort); do
                    local rt_id="${key##*:}"
                    local rt_name="${XR_REGION_DRT_NAMES[$key]:-$rt_id}"
                    local rules="${XR_REGION_ROUTE_RULES[$key]}"
                    local rule_count
                    rule_count=$(echo "$rules" | jq 'length' 2>/dev/null || echo "0")
                    [[ "$rule_count" -eq 0 ]] && continue
                    
                    printf "  ${CYAN}%s${NC}    ${YELLOW}RT: %s${NC} ${GRAY}(%s rules)${NC}\n" "$V" "$rt_name" "$rule_count"
                    printf "  ${CYAN}%s${NC}    ${BOLD}%-20s %-9s %-16s %s${NC}\n" \
                        "$V" "Destination" "Type" "Origin" "Next Hop"
                    
                    while IFS='|' read -r r_dest r_type r_origin r_hop_id; do
                        [[ -z "$r_dest" ]] && continue
                        local type_color="$WHITE"
                        [[ "$r_type" == "STATIC" ]] && type_color="$YELLOW"
                        [[ "$r_type" == "DYNAMIC" ]] && type_color="$GREEN"
                        
                        local hop_name="" hop_display=""
                        if [[ -n "$r_hop_id" && "$r_hop_id" != "N/A" && "$r_hop_id" != "null" ]]; then
                            hop_name="${XR_ATT_NAMES[$r_hop_id]:-}"
                            if [[ -z "$hop_name" || "$hop_name" == "N/A" ]]; then
                                # API fallback: resolve attachment display-name
                                local _xr_hop_json
                                _xr_hop_json=$(oci network drg-attachment get --drg-attachment-id "$r_hop_id" --region "$region_key" --output json 2>/dev/null)
                                if [[ -n "$_xr_hop_json" ]] && echo "$_xr_hop_json" | jq -e '.data' >/dev/null 2>&1; then
                                    hop_name=$(echo "$_xr_hop_json" | jq -r '.data["display-name"] // ""' 2>/dev/null)
                                    [[ -n "$hop_name" ]] && XR_ATT_NAMES[$r_hop_id]="$hop_name"
                                fi
                            fi
                            if [[ -n "$hop_name" && "$hop_name" != "N/A" ]]; then
                                hop_display="${CYAN}${hop_name}${NC} ${YELLOW}(${r_hop_id})${NC}"
                            else
                                hop_display="${YELLOW}(${r_hop_id})${NC}"
                            fi
                        fi
                        
                        printf "  ${CYAN}%s${NC}      ${WHITE}%-20s${NC} ${type_color}%-9s${NC} %-16s %b\n" \
                            "$V" "${r_dest:0:20}" "${r_type:0:9}" "${r_origin:0:16}" "$hop_display"
                    done < <(echo "$rules" | jq -r '.[] | "\(.destination // "N/A")|\(.["route-type"] // "N/A")|\(.["route-provenance"] // "N/A")|\(.["next-hop-drg-attachment-id"] // "N/A")"' 2>/dev/null)
                done
            fi
            
            # ── Import Route Distributions (per DRG) ──
            local _xr_dist_json="${XR_DRG_DIST_LIST[$drg_id]:-}"
            if [[ -n "$_xr_dist_json" && "$_xr_dist_json" != "[]" ]]; then
                local _xr_imp_found=0
                while IFS='|' read -r _xid_name _xid_type _xid_id; do
                    [[ -z "$_xid_name" || "$_xid_type" != "IMPORT" ]] && continue
                    if [[ $_xr_imp_found -eq 0 ]]; then
                        printf "  ${CYAN}%s${NC}  ${BOLD}${WHITE}📥 Import Route Distributions:${NC}\n" "$V"
                        _xr_imp_found=1
                    fi
                    printf "  ${CYAN}%s${NC}    ${GREEN}%s${NC} ${GRAY}[%s]${NC} ${YELLOW}(%s)${NC}\n" "$V" "$_xid_name" "$_xid_type" "$_xid_id"
                    
                    # Statements
                    local _xid_stmt_json
                    _xid_stmt_json=$(oci network drg-route-distribution-statement list --route-distribution-id "$_xid_id" --all \
                        --region "$region_key" --output json 2>/dev/null)
                    local _xid_stmt_data="[]"
                    if [[ -n "$_xid_stmt_json" ]]; then
                        _xid_stmt_data=$(echo "$_xid_stmt_json" | jq '.data // .items // []' 2>/dev/null)
                        [[ -z "$_xid_stmt_data" || "$_xid_stmt_data" == "null" ]] && _xid_stmt_data="[]"
                    fi
                    local _xid_sc
                    _xid_sc=$(echo "$_xid_stmt_data" | jq 'length' 2>/dev/null || echo "0")
                    [[ -z "$_xid_sc" || "$_xid_sc" == "null" ]] && _xid_sc=0
                    
                    if [[ "$_xid_sc" -gt 0 ]]; then
                        printf "  ${CYAN}%s${NC}      ${BOLD}%-10s %-8s %-24s %-40s %s${NC}\n" "$V" "Action" "Priority" "Match Type" "Match Criteria" "DRG Attachment"
                        while IFS= read -r _xis_line; do
                            [[ -z "$_xis_line" ]] && continue
                            local _xis_a _xis_p _xis_mc
                            _xis_a=$(echo "$_xis_line" | jq -r '.action // "N/A"' 2>/dev/null)
                            _xis_p=$(echo "$_xis_line" | jq -r '.priority // "N/A"' 2>/dev/null)
                            _xis_mc=$(echo "$_xis_line" | jq -r '.["match-criteria"]' 2>/dev/null)
                            local _xis_mc_len
                            _xis_mc_len=$(echo "$_xis_mc" | jq 'length' 2>/dev/null || echo "0")
                            
                            if [[ "$_xis_mc_len" -eq 0 || "$_xis_mc" == "[]" || "$_xis_mc" == "null" ]]; then
                                printf "  ${CYAN}%s${NC}      ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %s\n" \
                                    "$V" "$_xis_a" "$_xis_p" "MATCH_ALL" "(all attachments)" ""
                            else
                                local _xisi=0
                                while [[ $_xisi -lt $_xis_mc_len ]]; do
                                    local _xis_mt _xis_at _xis_dai
                                    _xis_mt=$(echo "$_xis_mc" | jq -r ".[$_xisi][\"match-type\"] // \"N/A\"" 2>/dev/null)
                                    _xis_at=$(echo "$_xis_mc" | jq -r ".[$_xisi][\"attachment-type\"] // \"null\"" 2>/dev/null)
                                    _xis_dai=$(echo "$_xis_mc" | jq -r ".[$_xisi][\"drg-attachment-id\"] // \"null\"" 2>/dev/null)
                                    
                                    local _xis_crit="" _xis_att_d=""
                                    if [[ "$_xis_mt" == "DRG_ATTACHMENT_TYPE" && "$_xis_at" != "null" ]]; then
                                        _xis_crit="attachment-type=$_xis_at"
                                    elif [[ "$_xis_mt" == "DRG_ATTACHMENT_ID" && "$_xis_dai" != "null" ]]; then
                                        _xis_crit="drg-attachment-id"
                                    elif [[ "$_xis_mt" == "MATCH_ALL" ]]; then
                                        _xis_crit="(all attachments)"
                                    else
                                        _xis_crit="$_xis_mt"
                                    fi
                                    if [[ -n "$_xis_dai" && "$_xis_dai" != "null" ]]; then
                                        local _xan="${XR_ATT_NAMES[$_xis_dai]:-}"
                                        [[ -z "$_xan" ]] && _xan=$(oci network drg-attachment get --drg-attachment-id "$_xis_dai" --region "$region_key" \
                                            --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                                        [[ -n "$_xan" ]] && XR_ATT_NAMES[$_xis_dai]="$_xan"
                                        if [[ -n "$_xan" ]]; then
                                            _xis_att_d="${CYAN}${_xan}${NC} ${YELLOW}(${_xis_dai})${NC}"
                                        else
                                            _xis_att_d="${YELLOW}(${_xis_dai})${NC}"
                                        fi
                                    fi
                                    if [[ $_xisi -eq 0 ]]; then
                                        printf "  ${CYAN}%s${NC}      ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %b\n" \
                                            "$V" "$_xis_a" "$_xis_p" "$_xis_mt" "$_xis_crit" "$_xis_att_d"
                                    else
                                        printf "  ${CYAN}%s${NC}      %-10s %-8s %-24s %-40s %b\n" \
                                            "$V" "" "" "$_xis_mt" "$_xis_crit" "$_xis_att_d"
                                    fi
                                    ((_xisi++))
                                done
                            fi
                        done < <(echo "$_xid_stmt_data" | jq -c '.[]' 2>/dev/null)
                    else
                        printf "  ${CYAN}%s${NC}      ${GRAY}(No statements)${NC}\n" "$V"
                    fi
                done < <(echo "$_xr_dist_json" | jq -r '.[] | "\(.["display-name"])|\(.["distribution-type"])|\(.id)"' 2>/dev/null)
                
                # Export distributions
                local _xr_exp_found=0
                while IFS='|' read -r _xed_name _xed_type _xed_id; do
                    [[ -z "$_xed_name" || "$_xed_type" != "EXPORT" ]] && continue
                    if [[ $_xr_exp_found -eq 0 ]]; then
                        printf "  ${CYAN}%s${NC}  ${BOLD}${WHITE}📤 Export Route Distributions:${NC}\n" "$V"
                        _xr_exp_found=1
                    fi
                    printf "  ${CYAN}%s${NC}    ${GREEN}%s${NC} ${GRAY}[%s]${NC} ${YELLOW}(%s)${NC}\n" "$V" "$_xed_name" "$_xed_type" "$_xed_id"
                    
                    # Statements
                    local _xed_stmt_json
                    _xed_stmt_json=$(oci network drg-route-distribution-statement list --route-distribution-id "$_xed_id" --all \
                        --region "$region_key" --output json 2>/dev/null)
                    local _xed_stmt_data="[]"
                    if [[ -n "$_xed_stmt_json" ]]; then
                        _xed_stmt_data=$(echo "$_xed_stmt_json" | jq '.data // .items // []' 2>/dev/null)
                        [[ -z "$_xed_stmt_data" || "$_xed_stmt_data" == "null" ]] && _xed_stmt_data="[]"
                    fi
                    local _xed_sc
                    _xed_sc=$(echo "$_xed_stmt_data" | jq 'length' 2>/dev/null || echo "0")
                    [[ -z "$_xed_sc" || "$_xed_sc" == "null" ]] && _xed_sc=0
                    
                    if [[ "$_xed_sc" -gt 0 ]]; then
                        printf "  ${CYAN}%s${NC}      ${BOLD}%-10s %-8s %-24s %-40s %s${NC}\n" "$V" "Action" "Priority" "Match Type" "Match Criteria" "DRG Attachment"
                        while IFS= read -r _xes_line; do
                            [[ -z "$_xes_line" ]] && continue
                            local _xes_a _xes_p _xes_mc
                            _xes_a=$(echo "$_xes_line" | jq -r '.action // "N/A"' 2>/dev/null)
                            _xes_p=$(echo "$_xes_line" | jq -r '.priority // "N/A"' 2>/dev/null)
                            _xes_mc=$(echo "$_xes_line" | jq -r '.["match-criteria"]' 2>/dev/null)
                            local _xes_mc_len
                            _xes_mc_len=$(echo "$_xes_mc" | jq 'length' 2>/dev/null || echo "0")
                            
                            if [[ "$_xes_mc_len" -eq 0 || "$_xes_mc" == "[]" || "$_xes_mc" == "null" ]]; then
                                printf "  ${CYAN}%s${NC}      ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %s\n" \
                                    "$V" "$_xes_a" "$_xes_p" "MATCH_ALL" "(all attachments)" ""
                            else
                                local _xesi=0
                                while [[ $_xesi -lt $_xes_mc_len ]]; do
                                    local _xes_mt _xes_at _xes_dai
                                    _xes_mt=$(echo "$_xes_mc" | jq -r ".[$_xesi][\"match-type\"] // \"N/A\"" 2>/dev/null)
                                    _xes_at=$(echo "$_xes_mc" | jq -r ".[$_xesi][\"attachment-type\"] // \"null\"" 2>/dev/null)
                                    _xes_dai=$(echo "$_xes_mc" | jq -r ".[$_xesi][\"drg-attachment-id\"] // \"null\"" 2>/dev/null)
                                    
                                    local _xes_crit="" _xes_att_d=""
                                    if [[ "$_xes_mt" == "DRG_ATTACHMENT_TYPE" && "$_xes_at" != "null" ]]; then
                                        _xes_crit="attachment-type=$_xes_at"
                                    elif [[ "$_xes_mt" == "DRG_ATTACHMENT_ID" && "$_xes_dai" != "null" ]]; then
                                        _xes_crit="drg-attachment-id"
                                    elif [[ "$_xes_mt" == "MATCH_ALL" ]]; then
                                        _xes_crit="(all attachments)"
                                    else
                                        _xes_crit="$_xes_mt"
                                    fi
                                    if [[ -n "$_xes_dai" && "$_xes_dai" != "null" ]]; then
                                        local _xean="${XR_ATT_NAMES[$_xes_dai]:-}"
                                        [[ -z "$_xean" ]] && _xean=$(oci network drg-attachment get --drg-attachment-id "$_xes_dai" --region "$region_key" \
                                            --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                                        [[ -n "$_xean" ]] && XR_ATT_NAMES[$_xes_dai]="$_xean"
                                        if [[ -n "$_xean" ]]; then
                                            _xes_att_d="${CYAN}${_xean}${NC} ${YELLOW}(${_xes_dai})${NC}"
                                        else
                                            _xes_att_d="${YELLOW}(${_xes_dai})${NC}"
                                        fi
                                    fi
                                    if [[ $_xesi -eq 0 ]]; then
                                        printf "  ${CYAN}%s${NC}      ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %b\n" \
                                            "$V" "$_xes_a" "$_xes_p" "$_xes_mt" "$_xes_crit" "$_xes_att_d"
                                    else
                                        printf "  ${CYAN}%s${NC}      %-10s %-8s %-24s %-40s %b\n" \
                                            "$V" "" "" "$_xes_mt" "$_xes_crit" "$_xes_att_d"
                                    fi
                                    ((_xesi++))
                                done
                            fi
                        done < <(echo "$_xed_stmt_data" | jq -c '.[]' 2>/dev/null)
                    else
                        printf "  ${CYAN}%s${NC}      ${GRAY}(No statements)${NC}\n" "$V"
                    fi
                done < <(echo "$_xr_dist_json" | jq -r '.[] | "\(.["display-name"])|\(.["distribution-type"])|\(.id)"' 2>/dev/null)
            fi
            
        done <<< "$drg_ids_in_region"
        
        printf "  ${BOLD}${CYAN}%s%s%s${NC}\n" "$BL" "$(printf '%*s' $((box_width-2)) '' | tr ' ' "$H")" "$BR"
    done
    
    # ═══════════════════════════════════════════════════════════════════════════════
    # PHASE 3: Unified Route Summary
    # ═══════════════════════════════════════════════════════════════════════════════
    echo ""
    echo -e "  ${BOLD}${WHITE}═══ UNIFIED ROUTE SUMMARY ═══${NC}"
    printf "  ${BOLD}%-16s %-20s %-20s %-9s %-14s %s${NC}\n" "Region" "DRG" "Destination" "Type" "Origin" "Next Hop"
    printf "  %s\n" "$(printf '%*s' 140 '' | tr ' ' '─')"
    
    for region_key in $(echo "${!XR_REGION_DRGS[@]}" | tr ' ' '\n' | sort); do
        local drg_ids_in_region
        drg_ids_in_region=$(echo "${XR_REGION_DRGS[$region_key]}" | jq -r '.[]' 2>/dev/null)
        while IFS= read -r drg_id; do
            [[ -z "$drg_id" ]] && continue
            local drg_name="${XR_DRG_NAMES[$drg_id]:-Unknown}"
            
            for key in $(echo "${!XR_REGION_ROUTE_RULES[@]}" | tr ' ' '\n' | grep "^${region_key}:${drg_id}:" | sort); do
                local rules="${XR_REGION_ROUTE_RULES[$key]}"
                local rule_count
                rule_count=$(echo "$rules" | jq 'length' 2>/dev/null || echo "0")
                [[ "$rule_count" -eq 0 ]] && continue
                
                while IFS='|' read -r r_dest r_type r_origin r_hop_id; do
                    [[ -z "$r_dest" ]] && continue
                    local type_color="$WHITE"
                    [[ "$r_type" == "STATIC" ]] && type_color="$YELLOW"
                    [[ "$r_type" == "DYNAMIC" ]] && type_color="$GREEN"
                    
                    local hop_display=""
                    if [[ -n "$r_hop_id" && "$r_hop_id" != "N/A" && "$r_hop_id" != "null" ]]; then
                        local hop_name="${XR_ATT_NAMES[$r_hop_id]:-}"
                        if [[ -z "$hop_name" || "$hop_name" == "N/A" ]]; then
                            local _sr_hop_json
                            _sr_hop_json=$(oci network drg-attachment get --drg-attachment-id "$r_hop_id" --region "$region_key" --output json 2>/dev/null)
                            if [[ -n "$_sr_hop_json" ]] && echo "$_sr_hop_json" | jq -e '.data' >/dev/null 2>&1; then
                                hop_name=$(echo "$_sr_hop_json" | jq -r '.data["display-name"] // ""' 2>/dev/null)
                                [[ -n "$hop_name" ]] && XR_ATT_NAMES[$r_hop_id]="$hop_name"
                            fi
                        fi
                        if [[ -n "$hop_name" && "$hop_name" != "N/A" ]]; then
                            hop_display="${CYAN}${hop_name}${NC} ${YELLOW}(${r_hop_id})${NC}"
                        else
                            hop_display="${YELLOW}(${r_hop_id})${NC}"
                        fi
                    fi
                    
                    printf "  ${GRAY}%-16s${NC} ${WHITE}%-20s${NC} ${WHITE}%-20s${NC} ${type_color}%-9s${NC} %-14s %b\n" \
                        "${region_key:0:16}" "${drg_name:0:20}" "${r_dest:0:20}" "${r_type:0:9}" "${r_origin:0:14}" "$hop_display"
                done < <(echo "$rules" | jq -r '.[] | "\(.destination // "N/A")|\(.["route-type"] // "N/A")|\(.["route-provenance"] // "N/A")|\(.["next-hop-drg-attachment-id"] // "N/A")"' 2>/dev/null)
            done
        done <<< "$drg_ids_in_region"
    done
    
    printf "  %s\n" "$(printf '%*s' 140 '' | tr ' ' '─')"
    echo -e "  ${BOLD}${WHITE}Total: ${GREEN}${xr_total_regions} region(s)${NC}, ${WHITE}${#XR_VISITED_DRGS[@]} DRG(s)${NC} traversed via RPC peering chains"
    local start_drg_name="${XR_DRG_NAMES[$start_drg_id]:-Unknown}"
    echo -e "  ${GRAY}Start: ${WHITE}${start_drg_name}${NC} ${GRAY}in ${WHITE}${start_region}${NC}  ${BOLD}Legend:${NC} ${GREEN}✓${NC}=Attached ${YELLOW}◐${NC}=Attaching ${YELLOW}○${NC}=Other 🌐=Public 🔒=Private ${GREEN}🔗${NC}=LPG"
}

manage_drg_connectivity() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    # Accept VCN context from parent (network menu)
    local param_vcn_ocid="${1:-}"
    local param_vcn_compartment_id="${2:-}"
    local param_network_compartment_id="${3:-}"
    
    # Build search compartments from available context
    # Include: main compartment, VCN compartment, network compartment (deduplicated)
    declare -a SEARCH_COMPARTMENTS=("$compartment_id")
    local search_mode="single"
    
    if [[ -n "$param_vcn_compartment_id" && "$param_vcn_compartment_id" != "$compartment_id" ]]; then
        SEARCH_COMPARTMENTS+=("$param_vcn_compartment_id")
        search_mode="multi"
    fi
    if [[ -n "$param_network_compartment_id" && "$param_network_compartment_id" != "$compartment_id" && "$param_network_compartment_id" != "$param_vcn_compartment_id" ]]; then
        SEARCH_COMPARTMENTS+=("$param_network_compartment_id")
        search_mode="multi"
    fi
    # Also check NETWORK_COMPARTMENT_ID from variables.sh
    if [[ -n "$NETWORK_COMPARTMENT_ID" ]]; then
        local already_included=0
        for sc in "${SEARCH_COMPARTMENTS[@]}"; do
            [[ "$sc" == "$NETWORK_COMPARTMENT_ID" ]] && already_included=1
        done
        if [[ $already_included -eq 0 ]]; then
            SEARCH_COMPARTMENTS+=("$NETWORK_COMPARTMENT_ID")
            search_mode="multi"
        fi
    fi
    
    while true; do
        echo ""
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${CYAN}                                         DRG & NETWORK CONNECTIVITY                                               ${NC}"
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        _display_cache_info \
            "${DRG_CACHE}|DRG Attachments"
        echo ""
        
        # Pre-cache compartment names to avoid "Unknown" throughout
        for _pc_comp in "${SEARCH_COMPARTMENTS[@]}"; do
            resolve_compartment_name "$_pc_comp" >/dev/null 2>&1
        done
        
        echo -e "${BOLD}${WHITE}Environment:${NC}"
        echo -e "  ${CYAN}Region:${NC}      ${WHITE}${region}${NC}"
        if [[ -n "$param_vcn_ocid" && "$param_vcn_ocid" != "N/A" ]]; then
            local vcn_display_name="${param_vcn_ocid}"
            # Try to get VCN name for display
            local vdn
            vdn=$(oci network vcn get --vcn-id "$param_vcn_ocid" --query 'data."display-name"' --raw-output 2>/dev/null) && [[ -n "$vdn" ]] && vcn_display_name="$vdn"
            echo -e "  ${CYAN}VCN:${NC}         ${WHITE}${vcn_display_name}${NC}"
        fi
        if [[ ${#SEARCH_COMPARTMENTS[@]} -eq 1 ]]; then
            local env_comp_name
            env_comp_name=$(resolve_compartment_name "$compartment_id")
            echo -e "  ${CYAN}Compartment:${NC} ${WHITE}${env_comp_name}${NC} ${YELLOW}(${compartment_id})${NC}"
        else
            echo -e "  ${CYAN}Compartments:${NC} ${GREEN}Searching ${#SEARCH_COMPARTMENTS[@]} compartments${NC}"
            for sc in "${SEARCH_COMPARTMENTS[@]}"; do
                local sc_name
                sc_name=$(resolve_compartment_name "$sc")
                echo -e "    ${GRAY}• ${WHITE}${sc_name}${NC} ${YELLOW}(${sc})${NC}"
            done
        fi
        echo ""
        
        echo -e "${GRAY}Discovering DRGs and connectivity resources...${NC}"
        
        # Collect DRGs from multiple sources
        # Strategy: attachment-first (same as network menu), then compartment list, then cache
        declare -A DISCOVERED_DRGS  # DRG_ID -> DRG_JSON
        declare -A DRG_COMPARTMENTS # DRG_ID -> list of compartments to search for RPCs
        declare -A DRG_DISCOVERY    # DRG_ID -> discovery method
        local drg_idx=0
        declare -A DRG_MAP
        DRG_MAP=()
        DISCOVERED_DRGS=()
        DRG_COMPARTMENTS=()
        DRG_DISCOVERY=()
        
        # Method 1 (Primary): Find DRGs via VCN attachments - same logic as main network view
        # DRG attachments live in the VCN's compartment, DRG itself may be elsewhere
        if [[ -n "$param_vcn_ocid" && "$param_vcn_ocid" != "N/A" ]]; then
            local vcn_att_comp="${param_vcn_compartment_id:-$compartment_id}"
            echo -ne "\r${GRAY}  Discovering DRG attachments for VCN...${NC}          "
            local vcn_att_json
            vcn_att_json=$(oci network drg-attachment list --compartment-id "$vcn_att_comp" --vcn-id "$param_vcn_ocid" --all --output json 2>/dev/null)
            
            if [[ -n "$vcn_att_json" && "$vcn_att_json" != "null" ]]; then
                while IFS='|' read -r drg_id att_state; do
                    [[ -z "$drg_id" ]] && continue
                    [[ "$att_state" == "DETACHED" || "$att_state" == "DETACHING" || "$att_state" == "TERMINATED" || "$att_state" == "TERMINATING" ]] && continue
                    [[ -n "${DISCOVERED_DRGS[$drg_id]}" ]] && continue
                    
                    echo -ne "\r${GRAY}  Fetching DRG details ...${drg_id: -12}${NC}          "
                    
                    # Use helper: tries drg get --region, then drg list in all compartments
                    resolve_drg_details "$drg_id" "$region" "${SEARCH_COMPARTMENTS[@]}"
                    
                    if [[ $_DRG_RESOLVED -eq 1 ]]; then
                        local drg_data
                        drg_data=$(jq -n --arg id "$drg_id" --arg name "$_DRG_NAME" --arg state "$_DRG_STATE" --arg comp "$_DRG_COMP" \
                            '{"id":$id,"display-name":$name,"lifecycle-state":$state,"compartment-id":$comp}')
                        DISCOVERED_DRGS["$drg_id"]="$drg_data"
                        DRG_COMPARTMENTS["$drg_id"]="$_DRG_COMP"
                        DRG_DISCOVERY["$drg_id"]="via VCN attachment"
                    else
                        # Still add with partial info - never silently drop
                        local drg_data
                        drg_data=$(jq -n --arg id "$drg_id" --arg name "$_DRG_NAME" --arg state "$_DRG_STATE" --arg comp "$_DRG_COMP" \
                            '{"id":$id,"display-name":$name,"lifecycle-state":$state,"compartment-id":$comp}')
                        DISCOVERED_DRGS["$drg_id"]="$drg_data"
                        DRG_COMPARTMENTS["$drg_id"]="${vcn_att_comp}"
                        DRG_DISCOVERY["$drg_id"]="via VCN attachment (cross-compartment)"
                    fi
                done < <(echo "$vcn_att_json" | jq -r '.data[] | "\(.["drg-id"])|\(.["lifecycle-state"])"' 2>/dev/null | sort -u)
            fi
        fi
        
        # Method 2: Search each compartment for DRGs owned there + attachments
        for search_comp in "${SEARCH_COMPARTMENTS[@]}"; do
            echo -ne "\r${GRAY}  Checking compartment ...${search_comp: -12}${NC}          "
            
            # Find DRGs owned by this compartment
            local drg_json
            drg_json=$(oci network drg list --compartment-id "$search_comp" --output json 2>/dev/null)
            
            if [[ -n "$drg_json" && "$drg_json" != "null" ]]; then
                while IFS='|' read -r drg_id drg_data; do
                    [[ -z "$drg_id" ]] && continue
                    if [[ -z "${DISCOVERED_DRGS[$drg_id]}" ]]; then
                        DISCOVERED_DRGS["$drg_id"]="$drg_data"
                        DRG_COMPARTMENTS["$drg_id"]="$search_comp"
                        DRG_DISCOVERY["$drg_id"]="owned"
                    fi
                done < <(echo "$drg_json" | jq -r '.data[] | "\(.id)|\(.)"' 2>/dev/null)
            fi
            
            # Find DRGs via DRG attachments in this compartment
            local attach_json
            attach_json=$(oci network drg-attachment list --compartment-id "$search_comp" --all --output json 2>/dev/null)
            
            if [[ -n "$attach_json" && "$attach_json" != "null" ]]; then
                local attach_count
                attach_count=$(echo "$attach_json" | jq '.data | length // 0' 2>/dev/null)
                
                if [[ "$attach_count" -gt 0 ]]; then
                    while IFS='|' read -r drg_id att_state; do
                        [[ -z "$drg_id" ]] && continue
                        [[ "$att_state" == "TERMINATED" || "$att_state" == "TERMINATING" ]] && continue
                        
                        if [[ -z "${DISCOVERED_DRGS[$drg_id]}" ]]; then
                            echo -ne "\r${GRAY}  Fetching DRG ...${drg_id: -12}${NC}          "
                            
                            resolve_drg_details "$drg_id" "$region" "${SEARCH_COMPARTMENTS[@]}"
                            
                            local drg_data
                            drg_data=$(jq -n --arg id "$drg_id" --arg name "$_DRG_NAME" --arg state "$_DRG_STATE" --arg comp "$_DRG_COMP" \
                                '{"id":$id,"display-name":$name,"lifecycle-state":$state,"compartment-id":$comp}')
                            DISCOVERED_DRGS["$drg_id"]="$drg_data"
                            DRG_COMPARTMENTS["$drg_id"]="$_DRG_COMP"
                            if [[ $_DRG_RESOLVED -eq 1 ]]; then
                                DRG_DISCOVERY["$drg_id"]="via attachment"
                            else
                                DRG_DISCOVERY["$drg_id"]="via attachment (cross-compartment)"
                            fi
                        fi
                        
                        # Track this compartment for RPC searches
                        if [[ -n "${DRG_COMPARTMENTS[$drg_id]}" && "${DRG_COMPARTMENTS[$drg_id]}" != *"$search_comp"* ]]; then
                            DRG_COMPARTMENTS["$drg_id"]="${DRG_COMPARTMENTS[$drg_id]}|$search_comp"
                        fi
                    done < <(echo "$attach_json" | jq -r '.data[] | "\(.["drg-id"])|\(.["lifecycle-state"])"' 2>/dev/null)
                fi
            fi
        done
        
        # Method 3: Check the DRG cache file (populated by network menu)
        if [[ -f "$DRG_CACHE" && -s "$DRG_CACHE" ]]; then
            while IFS='|' read -r vcn_id drg_id att_state att_name; do
                [[ -z "$drg_id" ]] && continue
                [[ "$att_state" == "TERMINATED" || "$att_state" == "TERMINATING" ]] && continue
                
                if [[ -z "${DISCOVERED_DRGS[$drg_id]}" ]]; then
                    echo -ne "\r${GRAY}  Fetching cached DRG ...${drg_id: -12}${NC}          "
                    
                    resolve_drg_details "$drg_id" "$region" "${SEARCH_COMPARTMENTS[@]}"
                    
                    local drg_data
                    drg_data=$(jq -n --arg id "$drg_id" --arg name "$_DRG_NAME" --arg state "$_DRG_STATE" --arg comp "$_DRG_COMP" \
                        '{"id":$id,"display-name":$name,"lifecycle-state":$state,"compartment-id":$comp}')
                    DISCOVERED_DRGS["$drg_id"]="$drg_data"
                    DRG_COMPARTMENTS["$drg_id"]="$_DRG_COMP"
                    if [[ $_DRG_RESOLVED -eq 1 ]]; then
                        DRG_DISCOVERY["$drg_id"]="via cache"
                    else
                        DRG_DISCOVERY["$drg_id"]="via cache (cross-compartment)"
                    fi
                fi
            done < "$DRG_CACHE"
        fi
        
        echo -ne "\r                                                                    \r"
        
        local total_drgs=${#DISCOVERED_DRGS[@]}
        
        echo ""
        echo -e "${BOLD}${WHITE}═══ Dynamic Routing Gateways (DRGs) ═══${NC}"
        echo ""
        
        if [[ "$total_drgs" -eq 0 ]]; then
            echo -e "  ${YELLOW}No DRGs found in searched compartment(s)${NC}"
            echo ""
            echo -e "  ${WHITE}Tips:${NC}"
            echo -e "  ${GRAY}• DRGs may exist in a different compartment${NC}"
        else
            printf "  ${BOLD}%-3s %-35s %-12s %-25s %s${NC}\n" "#" "DRG Name" "State" "Compartment" "Discovery"
            print_separator 120
            
            
            for drg_id in "${!DISCOVERED_DRGS[@]}"; do
                local drg_data="${DISCOVERED_DRGS[$drg_id]}"
                local drg_name drg_state drg_comp
                drg_name=$(echo "$drg_data" | jq -r '.["display-name"] // "Unknown"' 2>/dev/null)
                drg_state=$(echo "$drg_data" | jq -r '.["lifecycle-state"] // "Unknown"' 2>/dev/null)
                drg_comp=$(echo "$drg_data" | jq -r '.["compartment-id"] // "Unknown"' 2>/dev/null)
                
                ((drg_idx++))
                DRG_MAP[$drg_idx]="$drg_id"
                
                local state_color="$GREEN"
                case "$drg_state" in
                    AVAILABLE) state_color="$GREEN" ;;
                    PROVISIONING) state_color="$YELLOW" ;;
                    TERMINATING|TERMINATED) state_color="$RED" ;;
                    *) state_color="$GRAY" ;;
                esac
                
                # Show how we discovered this DRG
                local discovery_method="${DRG_DISCOVERY[$drg_id]:-unknown}"
                
                # Get compartment name (globally cached in resolve_compartment_name)
                local comp_name
                comp_name=$(resolve_compartment_name "$drg_comp")
                
                printf "  ${YELLOW}%-3s${NC} %-35s ${state_color}%-12s${NC} ${WHITE}%-25s${NC} ${GRAY}(%s)${NC} ${GRAY}%s${NC}\n" \
                    "$drg_idx" "${drg_name:0:33}" "$drg_state" "${comp_name:0:25}" "$drg_comp" "$discovery_method"
            done
        fi
        
        echo ""
        
        # Show cross-region DRG map by default (replaces per-DRG maps)
        if [[ "$total_drgs" -gt 0 ]]; then
            local primary_drg_id="${DRG_MAP[1]}"
            display_cross_region_drg_map "$primary_drg_id" "$region" "0" "${SEARCH_COMPARTMENTS[@]}"
        fi
        
        echo ""
        echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
        echo ""
        echo -e "  ${YELLOW}#${NC})    View DRG details (enter number)"
        echo ""
        echo -e "  ${CYAN}vm${NC})   View per-DRG connectivity maps (legacy view)"
        echo ""
        echo -e "  ${MAGENTA}r${NC})    Refresh (re-query cross-region map & clear cache)"
        echo -e "  ${CYAN}b${NC})    Back to network menu"
        echo ""
        xr_cache_age_display
        echo ""
        echo -n -e "${BOLD}${CYAN}[Network > DRG] Enter selection: ${NC}"
        read -r selection
        
        case "$selection" in
            [0-9]|[0-9][0-9])
                if [[ -n "${DRG_MAP[$selection]}" ]]; then
                    drg_view_details "${DRG_MAP[$selection]}"
                else
                    echo -e "${RED}Invalid DRG number${NC}"
                    sleep 1
                fi
                ;;
            xr|XR)
                # Legacy xr command - clear cache and re-display
                xr_cache_clear
                continue
                ;;
            r|R)
                # Clear cross-region cache and refresh
                xr_cache_clear
                continue
                ;;
            rc|RC)
                # Legacy rc command - same as r
                xr_cache_clear
                sleep 1
                ;;
            vm|VM)
                if [[ "$total_drgs" -gt 0 ]]; then
                    echo -e "${BOLD}${WHITE}═══ Per-DRG Connectivity Maps ═══${NC}"
                    for drg_num in $(seq 1 $drg_idx); do
                        local drg_id="${DRG_MAP[$drg_num]}"
                        local drg_data="${DISCOVERED_DRGS[$drg_id]}"
                        local drg_name drg_comp
                        drg_name=$(echo "$drg_data" | jq -r '.["display-name"]' 2>/dev/null)
                        drg_comp=$(echo "$drg_data" | jq -r '.["compartment-id"]' 2>/dev/null)
                        display_drg_connectivity_map "$drg_id" "$drg_name" "$drg_comp" "$region" "${SEARCH_COMPARTMENTS[@]}"
                        echo ""
                    done
                    echo -e "Press Enter to continue..."
                    read -r
                fi
                ;;
            b|B|back|BACK|"") return ;;
            *)
                echo -e "${RED}Invalid selection${NC}"
                sleep 1
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# DRG - View DRG Details (cross-compartment, route rules, distributions)
#--------------------------------------------------------------------------------
drg_view_details() {
    local drg_id="$1"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ DRG Details ═══${NC}"
    echo ""
    
    # Build compartment search list
    local main_comp="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local net_comp="${NETWORK_COMPARTMENT_ID:-}"
    local -a search_comps=("$main_comp")
    [[ -n "$net_comp" && "$net_comp" != "$main_comp" ]] && search_comps+=("$net_comp")
    
    # Try drg get with --region
    local drg_json
    drg_json=$(oci network drg get --drg-id "$drg_id" --region "$region" --output json 2>/dev/null)
    
    if [[ -z "$drg_json" || "$drg_json" == "null" ]] || ! echo "$drg_json" | jq -e '.data' >/dev/null 2>&1; then
        # Fallback: use resolve_drg_details helper
        resolve_drg_details "$drg_id" "$region" "${search_comps[@]}"
        if [[ $_DRG_RESOLVED -eq 0 ]]; then
            echo -e "${RED}Failed to get DRG details - insufficient permissions${NC}"
            echo -e "${GRAY}Tried: drg get --drg-id $drg_id --region $region${NC}"
            echo -e "${GRAY}Also searched compartments:${NC}"
            for _sc in "${search_comps[@]}"; do
                local _scn; _scn=$(resolve_compartment_name "$_sc")
                echo -e "  ${GRAY}• $_scn ($_sc)${NC}"
            done
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
        # Build minimal drg_json from resolved data for consistency
        echo -e "${YELLOW}⚠ Limited DRG details (cross-compartment, partial access)${NC}"
        echo ""
        echo -e "${BOLD}${CYAN}─── Basic Information ───${NC}"
        echo -e "  ${CYAN}Name:${NC}           ${WHITE}$_DRG_NAME${NC}"
        echo -e "  ${CYAN}State:${NC}          ${GREEN}$_DRG_STATE${NC}"
        echo -e "  ${CYAN}DRG OCID:${NC}       ${YELLOW}$drg_id${NC}"
        local comp_name; comp_name=$(resolve_compartment_name "$_DRG_COMP")
        echo -e "  ${CYAN}Compartment:${NC}    ${WHITE}$comp_name${NC} ${GRAY}($_DRG_COMP)${NC}"
        # Redundancy
        local _lim_redund="N/A"
        local _lim_redund_json
        _lim_redund_json=$(oci network drg-redundancy-status get --drg-id "$drg_id" --region "$region" --output json 2>/dev/null)
        if [[ -n "$_lim_redund_json" ]] && echo "$_lim_redund_json" | jq -e '.data' >/dev/null 2>&1; then
            _lim_redund=$(echo "$_lim_redund_json" | jq -r '.data.status // "N/A"' 2>/dev/null)
        fi
        local _lim_rc="$GREEN"
        case "$_lim_redund" in REDUNDANT) _lim_rc="$GREEN" ;; NOT_AVAILABLE|N/A) _lim_rc="$GRAY" ;; *) _lim_rc="$YELLOW" ;; esac
        echo -e "  ${CYAN}Redundancy:${NC}     ${_lim_rc}$_lim_redund${NC}"
        # Add the DRG's compartment to search list
        local drg_comp_id="$_DRG_COMP"
        local already=0; for c in "${search_comps[@]}"; do [[ "$c" == "$drg_comp_id" ]] && already=1; done
        [[ $already -eq 0 && -n "$drg_comp_id" ]] && search_comps+=("$drg_comp_id")
    else
        # Full access - extract all fields
        local name state drg_comp_id time_created
        name=$(echo "$drg_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
        state=$(echo "$drg_json" | jq -r '.data["lifecycle-state"] // "N/A"' 2>/dev/null)
        drg_comp_id=$(echo "$drg_json" | jq -r '.data["compartment-id"] // "N/A"' 2>/dev/null)
        time_created=$(echo "$drg_json" | jq -r '.data["time-created"] // "N/A"' 2>/dev/null)
        
        local state_color="$GREEN"
        [[ "$state" != "AVAILABLE" ]] && state_color="$YELLOW"
        
        echo -e "${BOLD}${CYAN}─── Basic Information ───${NC}"
        echo -e "  ${CYAN}Name:${NC}           ${WHITE}$name${NC}"
        echo -e "  ${CYAN}State:${NC}          ${state_color}$state${NC}"
        echo -e "  ${CYAN}Time Created:${NC}   ${WHITE}${time_created/T/ }${NC}"
        echo -e "  ${CYAN}DRG OCID:${NC}       ${YELLOW}$drg_id${NC}"
        local comp_name; comp_name=$(resolve_compartment_name "$drg_comp_id")
        echo -e "  ${CYAN}Compartment:${NC}    ${WHITE}$comp_name${NC} ${GRAY}($drg_comp_id)${NC}"
        
        # Redundancy status via dedicated API
        local drg_redund_status="N/A"
        local redund_json
        redund_json=$(oci network drg-redundancy-status get --drg-id "$drg_id" --region "$region" --output json 2>/dev/null)
        if [[ -n "$redund_json" ]] && echo "$redund_json" | jq -e '.data' >/dev/null 2>&1; then
            drg_redund_status=$(echo "$redund_json" | jq -r '.data.status // "N/A"' 2>/dev/null)
        fi
        local redund_color="$GREEN"
        case "$drg_redund_status" in
            REDUNDANT) redund_color="$GREEN" ;;
            NOT_AVAILABLE|N/A) redund_color="$GRAY" ;;
            *) redund_color="$YELLOW" ;;
        esac
        echo -e "  ${CYAN}Redundancy:${NC}     ${redund_color}$drg_redund_status${NC}"
        
        # Show default route tables from DRG object
        local def_vcn_rt def_ipsec_rt def_fc_rt def_rpc_rt
        def_vcn_rt=$(echo "$drg_json" | jq -r '.data["default-drg-route-tables"]["vcn"] // "N/A"' 2>/dev/null)
        def_ipsec_rt=$(echo "$drg_json" | jq -r '.data["default-drg-route-tables"]["ipsec-tunnel"] // "N/A"' 2>/dev/null)
        def_fc_rt=$(echo "$drg_json" | jq -r '.data["default-drg-route-tables"]["virtual-circuit"] // "N/A"' 2>/dev/null)
        def_rpc_rt=$(echo "$drg_json" | jq -r '.data["default-drg-route-tables"]["remote-peering-connection"] // "N/A"' 2>/dev/null)
        
        echo ""
        echo -e "  ${CYAN}Default Route Tables:${NC}"
        if [[ "$def_vcn_rt" != "N/A" ]]; then
            local _drt_vcn_name=""
            _drt_vcn_name=$(oci network drg-route-table get --drg-route-table-id "$def_vcn_rt" --region "$region" --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
            echo -e "    VCN:     ${WHITE}${_drt_vcn_name:-N/A}${NC} ${GRAY}($def_vcn_rt)${NC}"
        fi
        if [[ "$def_ipsec_rt" != "N/A" ]]; then
            local _drt_ipsec_name=""
            _drt_ipsec_name=$(oci network drg-route-table get --drg-route-table-id "$def_ipsec_rt" --region "$region" --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
            echo -e "    IPSec:   ${WHITE}${_drt_ipsec_name:-N/A}${NC} ${GRAY}($def_ipsec_rt)${NC}"
        fi
        if [[ "$def_fc_rt" != "N/A" ]]; then
            local _drt_fc_name=""
            _drt_fc_name=$(oci network drg-route-table get --drg-route-table-id "$def_fc_rt" --region "$region" --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
            echo -e "    FC:      ${WHITE}${_drt_fc_name:-N/A}${NC} ${GRAY}($def_fc_rt)${NC}"
        fi
        if [[ "$def_rpc_rt" != "N/A" ]]; then
            local _drt_rpc_name=""
            _drt_rpc_name=$(oci network drg-route-table get --drg-route-table-id "$def_rpc_rt" --region "$region" --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
            echo -e "    RPC:     ${WHITE}${_drt_rpc_name:-N/A}${NC} ${GRAY}($def_rpc_rt)${NC}"
        fi
        
        # Default export route distribution
        local def_export_dist_id
        def_export_dist_id=$(echo "$drg_json" | jq -r '.data["default-export-drg-route-distribution-id"] // ""' 2>/dev/null)
        if [[ -n "$def_export_dist_id" && "$def_export_dist_id" != "null" ]]; then
            local _ded_json _ded_name="N/A" _ded_type="N/A"
            _ded_json=$(oci network drg-route-distribution get --drg-route-distribution-id "$def_export_dist_id" \
                --region "$region" --output json 2>/dev/null)
            if [[ -n "$_ded_json" ]] && echo "$_ded_json" | jq -e '.data' >/dev/null 2>&1; then
                _ded_name=$(echo "$_ded_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                _ded_type=$(echo "$_ded_json" | jq -r '.data["distribution-type"] // "N/A"' 2>/dev/null)
            fi
            echo ""
            echo -e "  ${CYAN}Default Export Distribution:${NC} ${GREEN}$_ded_name${NC} ${GRAY}[$_ded_type]${NC}"
            echo -e "    ${YELLOW}$def_export_dist_id${NC}"
            
            # Statements
            local _ded_stmt_json
            _ded_stmt_json=$(oci network drg-route-distribution-statement list --route-distribution-id "$def_export_dist_id" --all \
                --region "$region" --output json 2>/dev/null)
            if [[ -n "$_ded_stmt_json" ]]; then
                local _ded_stmt_data
                _ded_stmt_data=$(echo "$_ded_stmt_json" | jq '.data // .items // []' 2>/dev/null)
                local _ded_stmt_count
                _ded_stmt_count=$(echo "$_ded_stmt_data" | jq 'length' 2>/dev/null || echo "0")
                if [[ "$_ded_stmt_count" -gt 0 ]]; then
                    echo -e "    ${CYAN}Statements (${_ded_stmt_count}):${NC}"
                    printf "      ${BOLD}%-10s %-8s %-24s %-40s %s${NC}\n" "Action" "Priority" "Match Type" "Match Criteria" "DRG Attachment"
                    printf "      %s\n" "$(printf '%*s' 120 '' | tr ' ' '─')"
                    while IFS= read -r _stmt_line; do
                        [[ -z "$_stmt_line" ]] && continue
                        local _ds_action _ds_priority _ds_mc_raw
                        _ds_action=$(echo "$_stmt_line" | jq -r '.action // "N/A"' 2>/dev/null)
                        _ds_priority=$(echo "$_stmt_line" | jq -r '.priority // "N/A"' 2>/dev/null)
                        _ds_mc_raw=$(echo "$_stmt_line" | jq -r '.["match-criteria"]' 2>/dev/null)
                        local _ds_mc_len
                        _ds_mc_len=$(echo "$_ds_mc_raw" | jq 'length' 2>/dev/null || echo "0")
                        
                        if [[ "$_ds_mc_len" -eq 0 || "$_ds_mc_raw" == "[]" || "$_ds_mc_raw" == "null" ]]; then
                            # Empty match-criteria = match all
                            printf "      ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %s\n" \
                                "$_ds_action" "$_ds_priority" "MATCH_ALL" "(all attachments)" ""
                        else
                            # Iterate each match criterion
                            local _mc_idx=0
                            while [[ $_mc_idx -lt $_ds_mc_len ]]; do
                                local _mc_match_type _mc_att_type _mc_drg_att_id
                                _mc_match_type=$(echo "$_ds_mc_raw" | jq -r ".[$_mc_idx][\"match-type\"] // \"N/A\"" 2>/dev/null)
                                _mc_att_type=$(echo "$_ds_mc_raw" | jq -r ".[$_mc_idx][\"attachment-type\"] // \"null\"" 2>/dev/null)
                                _mc_drg_att_id=$(echo "$_ds_mc_raw" | jq -r ".[$_mc_idx][\"drg-attachment-id\"] // \"null\"" 2>/dev/null)
                                
                                local _mc_criteria="" _mc_att_display=""
                                if [[ "$_mc_match_type" == "DRG_ATTACHMENT_TYPE" && "$_mc_att_type" != "null" ]]; then
                                    _mc_criteria="attachment-type=$_mc_att_type"
                                elif [[ "$_mc_match_type" == "DRG_ATTACHMENT_ID" && "$_mc_drg_att_id" != "null" ]]; then
                                    _mc_criteria="drg-attachment-id"
                                elif [[ "$_mc_match_type" == "MATCH_ALL" ]]; then
                                    _mc_criteria="(all attachments)"
                                else
                                    _mc_criteria="$_mc_match_type"
                                fi
                                
                                # Resolve drg-attachment-id if present
                                if [[ -n "$_mc_drg_att_id" && "$_mc_drg_att_id" != "null" ]]; then
                                    local _dsa_name=""
                                    _dsa_name="${ATT_NAME_LOOKUP[$_mc_drg_att_id]:-}"
                                    if [[ -z "$_dsa_name" ]]; then
                                        _dsa_name=$(oci network drg-attachment get --drg-attachment-id "$_mc_drg_att_id" --region "$region" \
                                            --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                                        [[ -n "$_dsa_name" ]] && ATT_NAME_LOOKUP[$_mc_drg_att_id]="$_dsa_name"
                                    fi
                                    if [[ -n "$_dsa_name" ]]; then
                                        _mc_att_display="${CYAN}${_dsa_name}${NC} ${YELLOW}(${_mc_drg_att_id})${NC}"
                                    else
                                        _mc_att_display="${YELLOW}(${_mc_drg_att_id})${NC}"
                                    fi
                                fi
                                
                                if [[ $_mc_idx -eq 0 ]]; then
                                    printf "      ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %b\n" \
                                        "$_ds_action" "$_ds_priority" "$_mc_match_type" "$_mc_criteria" "$_mc_att_display"
                                else
                                    printf "      %-10s %-8s %-24s %-40s %b\n" \
                                        "" "" "$_mc_match_type" "$_mc_criteria" "$_mc_att_display"
                                fi
                                ((_mc_idx++))
                            done
                        fi
                    done < <(echo "$_ded_stmt_data" | jq -c '.[]' 2>/dev/null)
                else
                    echo -e "    ${GRAY}(No statements)${NC}"
                fi
            else
                echo -e "    ${GRAY}(No statements)${NC}"
            fi
        fi
        
        # Ensure DRG compartment is in search list
        local already=0; for c in "${search_comps[@]}"; do [[ "$c" == "$drg_comp_id" ]] && already=1; done
        [[ $already -eq 0 && -n "$drg_comp_id" ]] && search_comps+=("$drg_comp_id")
    fi
    echo ""
    
    #==========================================================================
    # DRG Attachments - search ALL compartments + drg-id fallback
    #==========================================================================
    echo -e "${BOLD}${CYAN}─── DRG Attachments ───${NC}"
    echo -ne "  ${GRAY}Searching compartments for attachments...${NC}"
    
    local all_attach="[]"
    for comp in "${search_comps[@]}"; do
        local att_json
        att_json=$(oci network drg-attachment list --compartment-id "$comp" --region "$region" --all --output json 2>/dev/null)
        if [[ -n "$att_json" ]] && echo "$att_json" | jq -e '.data[0]' >/dev/null 2>&1; then
            local filtered
            filtered=$(echo "$att_json" | jq --arg drg "$drg_id" '[.data[] | select(.["drg-id"] == $drg)]' 2>/dev/null)
            if [[ -n "$filtered" && "$filtered" != "[]" ]]; then
                all_attach=$(jq -n --argjson a "$all_attach" --argjson b "$filtered" '$a + $b | unique_by(.id)'2>/dev/null)
            fi
        fi
    done
    
    # Fallback: if no attachments found via compartment search, try --drg-id directly
    local attach_count_check
    attach_count_check=$(echo "$all_attach" | jq 'length' 2>/dev/null || echo "0")
    if [[ "$attach_count_check" -eq 0 ]]; then
        echo -ne "\r  ${GRAY}Trying direct DRG query...${NC}                     "
        local drg_att_json
        drg_att_json=$(oci network drg-attachment list --drg-id "$drg_id" --region "$region" --all --output json 2>/dev/null)
        if [[ -n "$drg_att_json" ]] && echo "$drg_att_json" | jq -e '.data[0]' >/dev/null 2>&1; then
            all_attach=$(echo "$drg_att_json" | jq '.data // []' 2>/dev/null)
            
            # Add any new compartments discovered from attachments to search list
            while IFS= read -r att_comp; do
                [[ -z "$att_comp" ]] && continue
                local already_in=0
                for c in "${search_comps[@]}"; do [[ "$c" == "$att_comp" ]] && already_in=1; done
                [[ $already_in -eq 0 ]] && search_comps+=("$att_comp")
            done < <(echo "$all_attach" | jq -r '.[]["compartment-id"] // empty' 2>/dev/null | sort -u)
        fi
    fi
    echo -ne "\r                                                                     \r"
    
    local attach_count
    attach_count=$(echo "$all_attach" | jq 'length' 2>/dev/null || echo "0")
    
    # Build attachment name lookup for route rule next-hop resolution
    declare -A ATT_NAME_LOOKUP ATT_TYPE_LOOKUP
    if [[ "$attach_count" -gt 0 ]]; then
        while IFS='|' read -r _a_id _a_name _a_type; do
            [[ -z "$_a_id" ]] && continue
            ATT_NAME_LOOKUP[$_a_id]="$_a_name"
            ATT_TYPE_LOOKUP[$_a_id]="$_a_type"
        done < <(echo "$all_attach" | jq -r '.[] | "\(.id)|\(.["display-name"] // "N/A")|\(.["network-details"]["type"] // "VCN")"' 2>/dev/null)
    fi
    
    if [[ "$attach_count" -gt 0 ]]; then
        echo -e "  ${WHITE}Found $attach_count attachment(s) across ${#search_comps[@]} compartment(s)${NC}"
        echo ""
        while IFS='|' read -r att_name att_type att_state network_id rt_id att_id att_comp att_created; do
            [[ -z "$att_name" ]] && continue
            
            # State color
            local att_state_color="$GREEN"
            [[ "$att_state" != "ATTACHED" ]] && att_state_color="$YELLOW"
            [[ "$att_state" == "DETACHING" || "$att_state" == "DETACHED" ]] && att_state_color="$RED"
            
            # Line 1: Name, State, Type, OCID
            echo -e "  ${CYAN}$att_name${NC}  ${att_state_color}$att_state${NC}  ${WHITE}$att_type${NC}  ${YELLOW}($att_id)${NC}"
            # Compartment + time created
            if [[ -n "$att_comp" && "$att_comp" != "null" ]]; then
                local _ac_name; _ac_name=$(resolve_compartment_name "$att_comp")
                echo -e "    ${CYAN}Compartment:${NC}  ${WHITE}$_ac_name${NC} ${GRAY}($att_comp)${NC}"
            fi
            echo -e "    ${CYAN}Time Created:${NC} ${WHITE}${att_created:0:19}${NC}"
            
            # VCN details on one line
            if [[ "$att_type" == "VCN" && -n "$network_id" && "$network_id" != "null" ]]; then
                local vcn_details
                vcn_details=$(oci network vcn get --vcn-id "$network_id" --region "$region" --output json 2>/dev/null)
                local vcn_name vcn_cidr
                vcn_name=$(echo "$vcn_details" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                vcn_cidr=$(echo "$vcn_details" | jq -r '.data["cidr-block"] // "N/A"' 2>/dev/null)
                echo -e "    ${CYAN}VCN:${NC}          ${GREEN}$vcn_name${NC}  ${WHITE}$vcn_cidr${NC}  ${YELLOW}($network_id)${NC}"
            fi
            
            if [[ -n "$rt_id" && "$rt_id" != "null" ]]; then
                # DRG Route Table: name, ecmp, ocid on one line
                local drt_name_display="N/A" drt_ecmp="false" drt_import_dist_id=""
                local drt_detail
                drt_detail=$(oci network drg-route-table get --drg-route-table-id "$rt_id" --region "$region" --output json 2>/dev/null)
                if [[ -n "$drt_detail" ]] && echo "$drt_detail" | jq -e '.data' >/dev/null 2>&1; then
                    drt_name_display=$(echo "$drt_detail" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                    drt_ecmp=$(echo "$drt_detail" | jq -r '.data["is-ecmp-enabled"] // false' 2>/dev/null)
                    drt_import_dist_id=$(echo "$drt_detail" | jq -r '.data["import-drg-route-distribution-id"] // ""' 2>/dev/null)
                fi
                echo -e "    ${CYAN}Route Table:${NC}  ${MAGENTA}$drt_name_display${NC}  ${CYAN}ECMP:${NC}${WHITE}$drt_ecmp${NC}  ${YELLOW}($rt_id)${NC}"
                
                # Fetch route rules
                local att_rules_json
                att_rules_json=$(oci network drg-route-rule list --drg-route-table-id "$rt_id" --region "$region" --output json 2>/dev/null)
                local att_rules_data
                att_rules_data=$(echo "$att_rules_json" | jq '.data // .items // []' 2>/dev/null)
                local att_rule_count
                att_rule_count=$(echo "$att_rules_data" | jq 'length' 2>/dev/null || echo "0")
                
                # Route rules are the only child now, always use └─
                echo -e "    └─ ${BOLD}${CYAN}Route Rules (${att_rule_count}):${NC}"
                if [[ "$att_rule_count" -gt 0 ]]; then
                    printf "       ${BOLD}%-22s %-14s %-10s %-16s %s${NC}\n" "Destination" "Dest Type" "Type" "Origin" "Next Hop"
                    printf "       %s\n" "$(printf '%*s' 120 '' | tr ' ' '─')"
                    while IFS='|' read -r r_dest r_dest_type r_type r_origin r_hop; do
                        [[ -z "$r_dest" ]] && continue
                        local r_color="$WHITE"
                        [[ "$r_type" == "STATIC" ]] && r_color="$YELLOW"
                        [[ "$r_type" == "DYNAMIC" ]] && r_color="$GREEN"
                        
                        local hop_display=""
                        if [[ -n "$r_hop" && "$r_hop" != "N/A" && "$r_hop" != "null" ]]; then
                            local hop_name="${ATT_NAME_LOOKUP[$r_hop]:-}"
                            if [[ -z "$hop_name" ]]; then
                                local hop_att_json
                                hop_att_json=$(oci network drg-attachment get --drg-attachment-id "$r_hop" --region "$region" --output json 2>/dev/null)
                                if [[ -n "$hop_att_json" ]] && echo "$hop_att_json" | jq -e '.data' >/dev/null 2>&1; then
                                    hop_name=$(echo "$hop_att_json" | jq -r '.data["display-name"] // ""' 2>/dev/null)
                                    local hop_type
                                    hop_type=$(echo "$hop_att_json" | jq -r '.data["network-details"]["type"] // ""' 2>/dev/null)
                                    [[ -n "$hop_name" ]] && ATT_NAME_LOOKUP[$r_hop]="$hop_name"
                                    [[ -n "$hop_type" ]] && ATT_TYPE_LOOKUP[$r_hop]="$hop_type"
                                fi
                            fi
                            if [[ -n "$hop_name" ]]; then
                                hop_display="${CYAN}${hop_name}${NC} ${YELLOW}(${r_hop})${NC}"
                            else
                                hop_display="${YELLOW}(${r_hop})${NC}"
                            fi
                        fi
                        printf "       ${WHITE}%-22s${NC} %-14s ${r_color}%-10s${NC} %-16s %b\n" \
                            "${r_dest:0:22}" "${r_dest_type:0:14}" "${r_type:0:10}" "${r_origin}" "$hop_display"
                    done < <(echo "$att_rules_data" | jq -r '.[] | "\(.destination // "N/A")|\(.["destination-type"] // "N/A")|\(.["route-type"] // "N/A")|\(.["route-provenance"] // "N/A")|\(.["next-hop-drg-attachment-id"] // "N/A")"' 2>/dev/null)
                else
                    echo -e "       ${GRAY}(No route rules)${NC}"
                fi
            fi
            
            echo ""
        done < <(echo "$all_attach" | jq -r 'sort_by(if .["network-details"]["type"] == "VCN" then 0 elif .["network-details"]["type"] == "REMOTE_PEERING_CONNECTION" then 1 elif .["network-details"]["type"] == "IPSEC_TUNNEL" then 2 elif .["network-details"]["type"] == "VIRTUAL_CIRCUIT" then 3 else 4 end) | .[] | "\(.["display-name"])|\(.["network-details"]["type"] // "UNKNOWN")|\(.["lifecycle-state"])|\(.["network-details"]["id"] // "null")|\(.["drg-route-table-id"] // "null")|\(.id)|\(.["compartment-id"])|\(.["time-created"] // "N/A")"' 2>/dev/null)
    else
        echo -e "  ${GRAY}No attachments found${NC}"
        echo -e "  ${GRAY}Searched compartments:${NC}"
        for comp in "${search_comps[@]}"; do
            local cn; cn=$(resolve_compartment_name "$comp")
            echo -e "    ${GRAY}• $cn ($comp)${NC}"
        done
        echo ""
    fi
    
    #==========================================================================
    # Connectivity - search ALL compartments (no prompt)
    #==========================================================================
    local connectivity_comps=("${search_comps[@]}")
    
    # Remote Peering Connections
    echo -e "${BOLD}${CYAN}─── Remote Peering Connections ───${NC}"
    local all_rpcs="[]"
    for comp in "${connectivity_comps[@]}"; do
        local rpc_json
        rpc_json=$(oci network remote-peering-connection list --compartment-id "$comp" --drg-id "$drg_id" --region "$region" --output json 2>/dev/null)
        if [[ -n "$rpc_json" ]] && echo "$rpc_json" | jq -e '.data[0]' >/dev/null 2>&1; then
            all_rpcs=$(jq -n --argjson a "$all_rpcs" --argjson b "$(echo "$rpc_json" | jq '.data')" '$a + $b | unique_by(.id)' 2>/dev/null)
        fi
    done
    
    local rpc_count
    rpc_count=$(echo "$all_rpcs" | jq 'length' 2>/dev/null || echo "0")
    
    if [[ "$rpc_count" -gt 0 ]]; then
        while IFS='|' read -r rpc_name rpc_state peer_region peer_status peer_id peer_tenancy rpc_id; do
            [[ -z "$rpc_name" ]] && continue
            
            local rpc_state_color="$GREEN"
            [[ "$rpc_state" != "AVAILABLE" ]] && rpc_state_color="$YELLOW"
            
            local peer_status_color="$GREEN"
            case "$peer_status" in
                PEERED) peer_status_color="$GREEN" ;;
                PENDING) peer_status_color="$YELLOW" ;;
                *) peer_status_color="$RED" ;;
            esac
            
            echo -e "  ${WHITE}$rpc_name${NC}"
            echo -e "    ${CYAN}State:${NC}         ${rpc_state_color}$rpc_state${NC}    ${CYAN}Peering:${NC} ${peer_status_color}$peer_status${NC}"
            [[ -n "$peer_region" && "$peer_region" != "null" ]] && echo -e "    ${CYAN}Peer Region:${NC}   ${BOLD}${GREEN}$peer_region${NC}"
            [[ -n "$peer_id" && "$peer_id" != "null" ]] && echo -e "    ${CYAN}Peer RPC ID:${NC}   ${YELLOW}$peer_id${NC}"
            if [[ -n "$peer_tenancy" && "$peer_tenancy" != "null" ]]; then
                local _pt_name=""
                _pt_name=$(oci iam tenancy get --tenancy-id "$peer_tenancy" --query 'data.name' --raw-output 2>/dev/null || echo "")
                if [[ -n "$_pt_name" ]]; then
                    echo -e "    ${CYAN}Peer Tenancy:${NC}  ${WHITE}$_pt_name${NC} ${GRAY}($peer_tenancy)${NC}"
                else
                    echo -e "    ${CYAN}Peer Tenancy:${NC}  ${YELLOW}$peer_tenancy${NC}"
                fi
            fi
            echo -e "    ${CYAN}RPC OCID:${NC}      ${YELLOW}$rpc_id${NC}"
            
            # Expand remote DRG details for peered RPCs
            if [[ "$peer_status" == "PEERED" && -n "$peer_id" && "$peer_id" != "null" && -n "$peer_region" && "$peer_region" != "null" ]]; then
                echo -e "    ${BOLD}${WHITE}── Remote DRG Details ($peer_region) ──${NC}"
                
                # Get remote RPC to find remote DRG
                local remote_rpc_detail
                remote_rpc_detail=$(oci network remote-peering-connection get \
                    --remote-peering-connection-id "$peer_id" --region "$peer_region" --output json 2>/dev/null)
                
                local remote_drg_id="" remote_rpc_comp=""
                if [[ -n "$remote_rpc_detail" ]] && echo "$remote_rpc_detail" | jq -e '.data' >/dev/null 2>&1; then
                    remote_drg_id=$(echo "$remote_rpc_detail" | jq -r '.data["drg-id"] // ""' 2>/dev/null)
                    remote_rpc_comp=$(echo "$remote_rpc_detail" | jq -r '.data["compartment-id"] // ""' 2>/dev/null)
                fi
                
                if [[ -n "$remote_drg_id" ]]; then
                    local remote_drg_json
                    remote_drg_json=$(oci network drg get --drg-id "$remote_drg_id" --region "$peer_region" --output json 2>/dev/null)
                    if [[ -n "$remote_drg_json" ]] && echo "$remote_drg_json" | jq -e '.data' >/dev/null 2>&1; then
                        local r_drg_name r_drg_state r_drg_comp
                        r_drg_name=$(echo "$remote_drg_json" | jq -r '.data["display-name"] // "Unknown"' 2>/dev/null)
                        r_drg_state=$(echo "$remote_drg_json" | jq -r '.data["lifecycle-state"] // "N/A"' 2>/dev/null)
                        r_drg_comp=$(echo "$remote_drg_json" | jq -r '.data["compartment-id"] // ""' 2>/dev/null)
                        
                        echo -e "      ${CYAN}DRG:${NC}       ${ORANGE}$r_drg_name${NC} [${GREEN}$r_drg_state${NC}]"
                        echo -e "      ${CYAN}DRG OCID:${NC}  ${YELLOW}$remote_drg_id${NC}"
                        
                        # Build search compartments for remote
                        local -a r_search=("${search_comps[@]}")
                        [[ -n "$remote_rpc_comp" ]] && { local _a=0; for c in "${r_search[@]}"; do [[ "$c" == "$remote_rpc_comp" ]] && _a=1; done; [[ $_a -eq 0 ]] && r_search+=("$remote_rpc_comp"); }
                        [[ -n "$r_drg_comp" ]] && { local _a=0; for c in "${r_search[@]}"; do [[ "$c" == "$r_drg_comp" ]] && _a=1; done; [[ $_a -eq 0 ]] && r_search+=("$r_drg_comp"); }
                        
                        # Remote VCN Attachments
                        local r_att_json
                        r_att_json=$(oci network drg-attachment list --drg-id "$remote_drg_id" --region "$peer_region" --all --output json 2>/dev/null)
                        if [[ -n "$r_att_json" ]] && echo "$r_att_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                            echo -e "      ${CYAN}VCN Attachments:${NC}"
                            while IFS='|' read -r ra_name ra_state ra_vcn_id ra_type; do
                                [[ -z "$ra_name" ]] && continue
                                local ra_vcn_name="N/A" ra_vcn_cidr=""
                                if [[ -n "$ra_vcn_id" && "$ra_vcn_id" != "null" ]]; then
                                    local ra_vcn_detail
                                    ra_vcn_detail=$(oci network vcn get --vcn-id "$ra_vcn_id" --region "$peer_region" --output json 2>/dev/null)
                                    if [[ -n "$ra_vcn_detail" ]]; then
                                        ra_vcn_name=$(echo "$ra_vcn_detail" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                                        ra_vcn_cidr=$(echo "$ra_vcn_detail" | jq -r '.data["cidr-block"] // ""' 2>/dev/null)
                                    fi
                                fi
                                local cidr_d=""; [[ -n "$ra_vcn_cidr" ]] && cidr_d=" ($ra_vcn_cidr)"
                                echo -e "        ${WHITE}• $ra_name${NC} → VCN: ${GREEN}$ra_vcn_name${NC}${GRAY}$cidr_d${NC}"
                            done < <(echo "$r_att_json" | jq -r '.data[] | select((.["network-details"]["type"] // "VCN") == "VCN") | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["network-details"]["id"] // "null")|\(.["network-details"]["type"] // "VCN")"' 2>/dev/null)
                        fi
                        
                        # Remote FastConnect
                        local r_all_fc="[]"
                        for rc in "${r_search[@]}"; do
                            local r_fc_json
                            r_fc_json=$(oci network virtual-circuit list --compartment-id "$rc" --region "$peer_region" --output json 2>/dev/null)
                            if [[ -n "$r_fc_json" ]] && echo "$r_fc_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                                local r_fc_filtered
                                r_fc_filtered=$(echo "$r_fc_json" | jq --arg drg "$remote_drg_id" '[.data[] | select(.["gateway-id"] == $drg)]' 2>/dev/null)
                                if [[ -n "$r_fc_filtered" && "$r_fc_filtered" != "[]" ]]; then
                                    r_all_fc=$(jq -n --argjson a "$r_all_fc" --argjson b "$r_fc_filtered" '$a + $b | unique_by(.id)' 2>/dev/null)
                                fi
                            fi
                        done
                        
                        local r_fc_count
                        r_fc_count=$(echo "$r_all_fc" | jq 'length' 2>/dev/null || echo "0")
                        if [[ "$r_fc_count" -gt 0 ]]; then
                            echo -e "      ${CYAN}FastConnect ($r_fc_count):${NC}"
                            while IFS='|' read -r rfc_name rfc_state rfc_bw rfc_bgp rfc_provider rfc_type rfc_cust_asn rfc_oracle_asn rfc_id; do
                                [[ -z "$rfc_name" ]] && continue
                                local rfc_color="$GREEN"; [[ "$rfc_state" != "PROVISIONED" ]] && rfc_color="$YELLOW"
                                local bgp_c="$GREEN"; [[ "$rfc_bgp" == "DOWN" ]] && bgp_c="$RED"; [[ "$rfc_bgp" == "N/A" ]] && bgp_c="$GRAY"
                                echo -e "        ${WHITE}⚡ $rfc_name${NC} [${rfc_color}$rfc_state${NC}] BW: ${WHITE}$rfc_bw${NC} BGP: ${bgp_c}${rfc_bgp:-N/A}${NC}"
                                [[ -n "$rfc_provider" && "$rfc_provider" != "null" ]] && echo -e "          Provider: ${GREEN}$rfc_provider${NC} Type: $rfc_type"
                                [[ -n "$rfc_cust_asn" && "$rfc_cust_asn" != "0" && "$rfc_cust_asn" != "null" ]] && \
                                    echo -e "          Customer ASN: ${WHITE}$rfc_cust_asn${NC}  Oracle ASN: ${WHITE}$rfc_oracle_asn${NC}"
                                
                                # Get BGP peering IPs
                                if [[ -n "$rfc_id" && "$rfc_id" != "null" ]]; then
                                    local rfc_detail
                                    rfc_detail=$(oci network virtual-circuit get --virtual-circuit-id "$rfc_id" --region "$peer_region" --output json 2>/dev/null)
                                    if [[ -n "$rfc_detail" ]] && echo "$rfc_detail" | jq -e '.data["cross-connect-mappings"][0]' >/dev/null 2>&1; then
                                        local cc_cust cc_oracle
                                        cc_cust=$(echo "$rfc_detail" | jq -r '.data["cross-connect-mappings"][0]["customer-bgp-peering-ip"] // ""' 2>/dev/null)
                                        cc_oracle=$(echo "$rfc_detail" | jq -r '.data["cross-connect-mappings"][0]["oracle-bgp-peering-ip"] // ""' 2>/dev/null)
                                        [[ -n "$cc_cust" || -n "$cc_oracle" ]] && \
                                            echo -e "          Peering: Cust: ${WHITE}$cc_cust${NC}  Oracle: ${WHITE}$cc_oracle${NC}"
                                    fi
                                fi
                            done < <(echo "$r_all_fc" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["bandwidth-shape-name"] // "N/A")|\(.["bgp-session-state"] // "N/A")|\(.["provider-name"] // "")|\(.type // "")|\(.["customer-bgp-asn"] // "0")|\(.["oracle-bgp-asn"] // "0")|\(.id)"' 2>/dev/null)
                        fi
                        
                        # Remote IPSec VPN
                        local r_all_vpn="[]"
                        for rc in "${r_search[@]}"; do
                            local r_vpn_json
                            r_vpn_json=$(oci network ip-sec-connection list --compartment-id "$rc" --drg-id "$remote_drg_id" --region "$peer_region" --output json 2>/dev/null)
                            if [[ -n "$r_vpn_json" ]] && echo "$r_vpn_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                                r_all_vpn=$(jq -n --argjson a "$r_all_vpn" --argjson b "$(echo "$r_vpn_json" | jq '.data')" '$a + $b | unique_by(.id)' 2>/dev/null)
                            fi
                        done
                        
                        local r_vpn_count
                        r_vpn_count=$(echo "$r_all_vpn" | jq 'length' 2>/dev/null || echo "0")
                        if [[ "$r_vpn_count" -gt 0 ]]; then
                            echo -e "      ${CYAN}IPSec VPN ($r_vpn_count):${NC}"
                            while IFS='|' read -r rv_name rv_state rv_cpe_id; do
                                [[ -z "$rv_name" ]] && continue
                                local rv_cpe_display=""
                                if [[ -n "$rv_cpe_id" && "$rv_cpe_id" != "null" ]]; then
                                    local rv_cpe_name; rv_cpe_name=$(oci network cpe get --cpe-id "$rv_cpe_id" --region "$peer_region" --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                                    [[ -n "$rv_cpe_name" ]] && rv_cpe_display=" → CPE: $rv_cpe_name"
                                fi
                                echo -e "        ${WHITE}🔒 $rv_name${NC} [$rv_state]${GRAY}$rv_cpe_display${NC}"
                            done < <(echo "$r_all_vpn" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["cpe-id"] // "")"' 2>/dev/null)
                        fi
                    else
                        echo -e "      ${GRAY}(Could not fetch remote DRG details)${NC}"
                    fi
                else
                    echo -e "      ${GRAY}(Could not resolve remote DRG from peer RPC)${NC}"
                fi
            fi
            echo ""
        done < <(echo "$all_rpcs" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["peer-region-name"] // "null")|\(.["peering-status"])|\(.["peer-id"] // "null")|\(.["peer-tenancy-id"] // "null")|\(.id)"' 2>/dev/null)
    else
        echo -e "  ${GRAY}No remote peering connections found${NC}"
        echo ""
    fi
    
    # IPSec VPN
    echo -e "${BOLD}${CYAN}─── IPSec VPN Connections ───${NC}"
    local all_ipsec="[]"
    for comp in "${connectivity_comps[@]}"; do
        local ipsec_json
        ipsec_json=$(oci network ip-sec-connection list --compartment-id "$comp" --drg-id "$drg_id" --region "$region" --output json 2>/dev/null)
        if [[ -n "$ipsec_json" ]] && echo "$ipsec_json" | jq -e '.data[0]' >/dev/null 2>&1; then
            all_ipsec=$(jq -n --argjson a "$all_ipsec" --argjson b "$(echo "$ipsec_json" | jq '.data')" '$a + $b | unique_by(.id)' 2>/dev/null)
        fi
    done
    
    local ipsec_count
    ipsec_count=$(echo "$all_ipsec" | jq 'length' 2>/dev/null || echo "0")
    
    if [[ "$ipsec_count" -gt 0 ]]; then
        while IFS='|' read -r vpn_name vpn_state cpe_id static_routes vpn_id; do
            [[ -z "$vpn_name" ]] && continue
            
            local vpn_state_color="$GREEN"
            [[ "$vpn_state" != "AVAILABLE" ]] && vpn_state_color="$YELLOW"
            
            echo -e "  ${WHITE}$vpn_name${NC}"
            echo -e "    ${CYAN}State:${NC}         ${vpn_state_color}$vpn_state${NC}"
            
            if [[ -n "$cpe_id" && "$cpe_id" != "null" ]]; then
                local cpe_json
                cpe_json=$(oci network cpe get --cpe-id "$cpe_id" --region "$region" --output json 2>/dev/null)
                local cpe_name cpe_ip
                cpe_name=$(echo "$cpe_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                cpe_ip=$(echo "$cpe_json" | jq -r '.data["ip-address"] // "N/A"' 2>/dev/null)
                echo -e "    ${CYAN}CPE:${NC}           ${WHITE}$cpe_name${NC} (IP: ${WHITE}$cpe_ip${NC})"
            fi
            
            if [[ -n "$static_routes" && "$static_routes" != "null" && "$static_routes" != "[]" ]]; then
                echo -e "    ${CYAN}Static Routes:${NC} ${WHITE}$static_routes${NC}"
            fi
            
            # Tunnel status
            local tunnels_json
            tunnels_json=$(oci network ip-sec-connection-tunnel list --ipsc-id "$vpn_id" --region "$region" --output json 2>/dev/null)
            if [[ -n "$tunnels_json" ]] && echo "$tunnels_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                echo -e "    ${CYAN}Tunnels:${NC}"
                while IFS='|' read -r tun_status tun_ip tun_bgp; do
                    [[ -z "$tun_status" ]] && continue
                    local tun_color="$GREEN"
                    [[ "$tun_status" != "UP" ]] && tun_color="$RED"
                    echo -e "      Status: ${tun_color}$tun_status${NC}  VPN IP: ${WHITE}$tun_ip${NC}  BGP: ${WHITE}$tun_bgp${NC}"
                done < <(echo "$tunnels_json" | jq -r '.data[] | "\(.status)|\(.["vpn-ip"] // "N/A")|\(.["bgp-session-info"]["bgp-state"] // "N/A")"' 2>/dev/null)
            fi
            
            echo -e "    ${CYAN}IPSec OCID:${NC}    ${YELLOW}$vpn_id${NC}"
            echo ""
        done < <(echo "$all_ipsec" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["cpe-id"] // "null")|\(.["static-routes"] // "null")|\(.id)"' 2>/dev/null)
    else
        echo -e "  ${GRAY}No IPSec VPN connections found${NC}"
        echo ""
    fi
    
    # FastConnect
    echo -e "${BOLD}${CYAN}─── FastConnect Virtual Circuits ───${NC}"
    local all_fc="[]"
    for comp in "${connectivity_comps[@]}"; do
        local vc_json
        vc_json=$(oci network virtual-circuit list --compartment-id "$comp" --region "$region" --output json 2>/dev/null)
        if [[ -n "$vc_json" ]] && echo "$vc_json" | jq -e '.data[0]' >/dev/null 2>&1; then
            local filtered
            filtered=$(echo "$vc_json" | jq --arg drg "$drg_id" '[.data[] | select(.["gateway-id"] == $drg)]' 2>/dev/null)
            if [[ -n "$filtered" && "$filtered" != "[]" ]]; then
                all_fc=$(jq -n --argjson a "$all_fc" --argjson b "$filtered" '$a + $b | unique_by(.id)' 2>/dev/null)
            fi
        fi
    done
    
    local fc_count
    fc_count=$(echo "$all_fc" | jq 'length' 2>/dev/null || echo "0")
    
    if [[ "$fc_count" -gt 0 ]]; then
        while IFS='|' read -r vc_name vc_state vc_type vc_bw vc_bgp provider_name provider_state vc_id; do
            [[ -z "$vc_name" ]] && continue
            
            local vc_state_color="$GREEN"
            case "$vc_state" in
                PROVISIONED) vc_state_color="$GREEN" ;;
                PROVISIONING|PENDING_PROVIDER) vc_state_color="$YELLOW" ;;
                *) vc_state_color="$RED" ;;
            esac
            
            echo -e "  ${BOLD}${WHITE}$vc_name${NC}"
            echo -e "    ${CYAN}State:${NC}           ${vc_state_color}$vc_state${NC}    ${CYAN}Type:${NC} ${WHITE}$vc_type${NC}"
            echo -e "    ${CYAN}Bandwidth:${NC}       ${WHITE}$vc_bw${NC}"
            [[ -n "$provider_name" && "$provider_name" != "null" ]] && echo -e "    ${CYAN}Provider:${NC}        ${GREEN}$provider_name${NC} ${WHITE}($provider_state)${NC}"
            [[ -n "$vc_bgp" && "$vc_bgp" != "null" ]] && echo -e "    ${CYAN}BGP State:${NC}       ${WHITE}$vc_bgp${NC}"
            echo -e "    ${CYAN}VC OCID:${NC}         ${YELLOW}$vc_id${NC}"
            
            # Get full virtual-circuit details for MTU, encryption, cross-connect mappings
            local vc_detail_json
            vc_detail_json=$(oci network virtual-circuit get --virtual-circuit-id "$vc_id" --region "$region" --output json 2>/dev/null)
            
            if [[ -n "$vc_detail_json" ]] && echo "$vc_detail_json" | jq -e '.data' >/dev/null 2>&1; then
                # MTU
                local vc_mtu
                vc_mtu=$(echo "$vc_detail_json" | jq -r '.data["ip-mtu"] // "N/A"' 2>/dev/null)
                [[ "$vc_mtu" != "N/A" && "$vc_mtu" != "null" ]] && echo -e "    ${CYAN}MTU:${NC}             ${WHITE}$vc_mtu${NC}"
                
                # Routing policy
                local vc_routing
                vc_routing=$(echo "$vc_detail_json" | jq -r '.data["routing-policy"] // [] | join(", ")' 2>/dev/null)
                [[ -n "$vc_routing" && "$vc_routing" != "null" ]] && echo -e "    ${CYAN}Routing Policy:${NC}  ${WHITE}$vc_routing${NC}"
                
                # IPSec over FastConnect encryption
                local vc_is_transport
                vc_is_transport=$(echo "$vc_detail_json" | jq -r '.data["is-transport-mode"] // "null"' 2>/dev/null)
                if [[ "$vc_is_transport" == "true" ]]; then
                    echo -e "    ${CYAN}Encryption:${NC}      ${GREEN}IPSec Transport Mode${NC}"
                elif [[ "$vc_is_transport" == "false" ]]; then
                    echo -e "    ${CYAN}Encryption:${NC}      ${GRAY}Not encrypted (IPSec)${NC}"
                fi
                
                # Cross-connect mappings → trace to physical details
                local cc_mappings
                cc_mappings=$(echo "$vc_detail_json" | jq -r '.data["cross-connect-mappings"] // []' 2>/dev/null)
                local cc_map_count
                cc_map_count=$(echo "$cc_mappings" | jq 'length' 2>/dev/null || echo "0")
                
                if [[ "$cc_map_count" -gt 0 ]]; then
                    echo ""
                    echo -e "    ${BOLD}${CYAN}Cross-Connect Details:${NC}"
                    
                    local cc_idx=0
                    while [[ $cc_idx -lt $cc_map_count ]]; do
                        local cc_or_ccg_id cc_vlan cc_cust_bgp cc_oci_bgp
                        cc_or_ccg_id=$(echo "$cc_mappings" | jq -r ".[$cc_idx][\"cross-connect-or-cross-connect-group-id\"] // \"null\"" 2>/dev/null)
                        cc_vlan=$(echo "$cc_mappings" | jq -r ".[$cc_idx].vlan // \"N/A\"" 2>/dev/null)
                        cc_cust_bgp=$(echo "$cc_mappings" | jq -r ".[$cc_idx][\"customer-bgp-peering-ip\"] // \"N/A\"" 2>/dev/null)
                        cc_oci_bgp=$(echo "$cc_mappings" | jq -r ".[$cc_idx][\"oracle-bgp-peering-ip\"] // \"N/A\"" 2>/dev/null)
                        
                        if [[ "$cc_map_count" -gt 1 ]]; then
                            echo -e "      ${WHITE}Mapping $((cc_idx+1)):${NC}"
                        fi
                        
                        echo -e "      ${CYAN}VLAN:${NC}              ${WHITE}$cc_vlan${NC}"
                        [[ "$cc_cust_bgp" != "N/A" && "$cc_cust_bgp" != "null" ]] && echo -e "      ${CYAN}Customer BGP IP:${NC}   ${WHITE}$cc_cust_bgp${NC}"
                        [[ "$cc_oci_bgp" != "N/A" && "$cc_oci_bgp" != "null" ]] && echo -e "      ${CYAN}Oracle BGP IP:${NC}     ${WHITE}$cc_oci_bgp${NC}"
                        
                        # Fetch cross-connect or cross-connect-group details
                        if [[ -n "$cc_or_ccg_id" && "$cc_or_ccg_id" != "null" ]]; then
                            if [[ "$cc_or_ccg_id" == ocid1.crossconnect.* ]]; then
                                # Direct cross-connect
                                local cc_json
                                cc_json=$(oci network cross-connect get --cross-connect-id "$cc_or_ccg_id" --region "$region" --output json 2>/dev/null)
                                if [[ -n "$cc_json" ]] && echo "$cc_json" | jq -e '.data' >/dev/null 2>&1; then
                                    local cc_loc cc_phys_dev cc_logi_dev cc_port cc_port_speed cc_iface_state cc_macsec_state cc_name
                                    cc_name=$(echo "$cc_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                                    cc_loc=$(echo "$cc_json" | jq -r '.data["location-name"] // "N/A"' 2>/dev/null)
                                    cc_phys_dev=$(echo "$cc_json" | jq -r '.data["oci-physical-device-name"] // "N/A"' 2>/dev/null)
                                    cc_logi_dev=$(echo "$cc_json" | jq -r '.data["oci-logical-device-name"] // "N/A"' 2>/dev/null)
                                    cc_port=$(echo "$cc_json" | jq -r '.data["port-name"] // "N/A"' 2>/dev/null)
                                    cc_port_speed=$(echo "$cc_json" | jq -r '.data["port-speed-shape-name"] // "N/A"' 2>/dev/null)
                                    cc_macsec_state=$(echo "$cc_json" | jq -r '.data["macsec-properties"]["state"] // "N/A"' 2>/dev/null)
                                    
                                    echo -e "      ${CYAN}Cross-Connect:${NC}     ${WHITE}$cc_name${NC}  ${YELLOW}($cc_or_ccg_id)${NC}"
                                    echo -e "      ${CYAN}Physical Location:${NC} ${WHITE}$cc_loc${NC}"
                                    echo -e "      ${CYAN}Physical Device:${NC}   ${WHITE}$cc_phys_dev${NC}"
                                    echo -e "      ${CYAN}Logical Device:${NC}    ${WHITE}$cc_logi_dev${NC}"
                                    echo -e "      ${CYAN}Port:${NC}              ${WHITE}$cc_port${NC}  ${GRAY}($cc_port_speed)${NC}"
                                    
                                    # MACsec state with color
                                    local macsec_color="$GRAY"
                                    case "$cc_macsec_state" in
                                        ENABLED) macsec_color="$GREEN" ;;
                                        DISABLED) macsec_color="$YELLOW" ;;
                                    esac
                                    echo -e "      ${CYAN}MACsec State:${NC}      ${macsec_color}$cc_macsec_state${NC}"
                                    
                                    # MACsec cipher if enabled
                                    if [[ "$cc_macsec_state" == "ENABLED" ]]; then
                                        local cc_macsec_cipher
                                        cc_macsec_cipher=$(echo "$cc_json" | jq -r '.data["macsec-properties"]["encryption-cipher"] // "N/A"' 2>/dev/null)
                                        echo -e "      ${CYAN}MACsec Cipher:${NC}     ${WHITE}$cc_macsec_cipher${NC}"
                                        local cc_macsec_unprotected
                                        cc_macsec_unprotected=$(echo "$cc_json" | jq -r '.data["macsec-properties"]["is-unprotected-traffic-allowed"] // "N/A"' 2>/dev/null)
                                        echo -e "      ${CYAN}Unprotected OK:${NC}    ${WHITE}$cc_macsec_unprotected${NC}"
                                    fi
                                    
                                    # Light levels (from cross-connect if available)
                                    local cc_ll_ind cc_ll_val
                                    cc_ll_ind=$(echo "$cc_json" | jq -r '.data["customer-reference-name"] // "N/A"' 2>/dev/null)
                                    [[ "$cc_ll_ind" != "N/A" && "$cc_ll_ind" != "null" && -n "$cc_ll_ind" ]] && \
                                        echo -e "      ${CYAN}Customer Ref:${NC}      ${WHITE}$cc_ll_ind${NC}"
                                    
                                    # Interface state from cross-connect lifecycle
                                    local cc_state
                                    cc_state=$(echo "$cc_json" | jq -r '.data["lifecycle-state"] // "N/A"' 2>/dev/null)
                                    local cc_state_color="$GREEN"
                                    case "$cc_state" in
                                        PROVISIONED) cc_state_color="$GREEN" ;;
                                        PENDING_*|PROVISIONING) cc_state_color="$YELLOW" ;;
                                        *) cc_state_color="$RED" ;;
                                    esac
                                    echo -e "      ${CYAN}Interface State:${NC}   ${cc_state_color}$cc_state${NC}"
                                fi
                            elif [[ "$cc_or_ccg_id" == ocid1.crossconnectgroup.* ]]; then
                                # Cross-connect group — list its member cross-connects
                                local ccg_json
                                ccg_json=$(oci network cross-connect-group get --cross-connect-group-id "$cc_or_ccg_id" --region "$region" --output json 2>/dev/null)
                                if [[ -n "$ccg_json" ]] && echo "$ccg_json" | jq -e '.data' >/dev/null 2>&1; then
                                    local ccg_name ccg_macsec_state
                                    ccg_name=$(echo "$ccg_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                                    ccg_macsec_state=$(echo "$ccg_json" | jq -r '.data["macsec-properties"]["state"] // "N/A"' 2>/dev/null)
                                    
                                    echo -e "      ${CYAN}CC Group:${NC}          ${WHITE}$ccg_name${NC}  ${YELLOW}($cc_or_ccg_id)${NC}"
                                    
                                    local ccg_macsec_color="$GRAY"
                                    case "$ccg_macsec_state" in
                                        ENABLED) ccg_macsec_color="$GREEN" ;;
                                        DISABLED) ccg_macsec_color="$YELLOW" ;;
                                    esac
                                    echo -e "      ${CYAN}MACsec State:${NC}      ${ccg_macsec_color}$ccg_macsec_state${NC}"
                                    
                                    if [[ "$ccg_macsec_state" == "ENABLED" ]]; then
                                        local ccg_macsec_cipher
                                        ccg_macsec_cipher=$(echo "$ccg_json" | jq -r '.data["macsec-properties"]["encryption-cipher"] // "N/A"' 2>/dev/null)
                                        echo -e "      ${CYAN}MACsec Cipher:${NC}     ${WHITE}$ccg_macsec_cipher${NC}"
                                    fi
                                fi
                                
                                # List individual cross-connects in this group
                                for _cc_comp in "${connectivity_comps[@]}"; do
                                    local ccg_members_json
                                    ccg_members_json=$(oci network cross-connect list --compartment-id "$_cc_comp" \
                                        --cross-connect-group-id "$cc_or_ccg_id" --region "$region" --output json 2>/dev/null)
                                    if [[ -n "$ccg_members_json" ]] && echo "$ccg_members_json" | jq -e '.data[0]' >/dev/null 2>&1; then
                                        while IFS='|' read -r _mcc_name _mcc_state _mcc_loc _mcc_phys _mcc_logi _mcc_port _mcc_speed _mcc_macsec _mcc_id; do
                                            [[ -z "$_mcc_name" ]] && continue
                                            
                                            local _mcc_sc="$GREEN"
                                            case "$_mcc_state" in
                                                PROVISIONED) _mcc_sc="$GREEN" ;;
                                                PENDING_*|PROVISIONING) _mcc_sc="$YELLOW" ;;
                                                *) _mcc_sc="$RED" ;;
                                            esac
                                            
                                            echo -e "      ${CYAN}───${NC}"
                                            echo -e "      ${CYAN}Cross-Connect:${NC}     ${WHITE}$_mcc_name${NC}  ${YELLOW}($_mcc_id)${NC}"
                                            echo -e "      ${CYAN}Physical Location:${NC} ${WHITE}$_mcc_loc${NC}"
                                            echo -e "      ${CYAN}Physical Device:${NC}   ${WHITE}$_mcc_phys${NC}"
                                            echo -e "      ${CYAN}Logical Device:${NC}    ${WHITE}$_mcc_logi${NC}"
                                            echo -e "      ${CYAN}Port:${NC}              ${WHITE}$_mcc_port${NC}  ${GRAY}($_mcc_speed)${NC}"
                                            echo -e "      ${CYAN}Interface State:${NC}   ${_mcc_sc}$_mcc_state${NC}"
                                            
                                            local _mcc_macsec_c="$GRAY"
                                            [[ "$_mcc_macsec" == "ENABLED" ]] && _mcc_macsec_c="$GREEN"
                                            [[ "$_mcc_macsec" == "DISABLED" ]] && _mcc_macsec_c="$YELLOW"
                                            echo -e "      ${CYAN}MACsec State:${NC}      ${_mcc_macsec_c}$_mcc_macsec${NC}"
                                        done < <(echo "$ccg_members_json" | jq -r '.data[] | "\(.["display-name"] // "N/A")|\(.["lifecycle-state"] // "N/A")|\(.["location-name"] // "N/A")|\(.["oci-physical-device-name"] // "N/A")|\(.["oci-logical-device-name"] // "N/A")|\(.["port-name"] // "N/A")|\(.["port-speed-shape-name"] // "N/A")|\(.["macsec-properties"]["state"] // "N/A")|\(.id)"' 2>/dev/null)
                                        break  # Found members, no need to check other compartments
                                    fi
                                done
                            fi
                        fi
                        
                        ((cc_idx++))
                    done
                fi
            fi
            echo ""
        done < <(echo "$all_fc" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.type)|\(.["bandwidth-shape-name"] // "N/A")|\(.["bgp-session-state"] // "null")|\(.["provider-name"] // "null")|\(.["provider-state"] // "null")|\(.id)"' 2>/dev/null)
    else
        echo -e "  ${GRAY}No FastConnect virtual circuits found for this DRG${NC}"
        echo ""
    fi
    
    #==========================================================================
    # DRG Route Tables with Route Rules + Distribution Statements
    #==========================================================================
    echo -e "${BOLD}${CYAN}─── DRG Route Tables & Route Rules ───${NC}"
    local drt_json
    drt_json=$(oci network drg-route-table list --drg-id "$drg_id" --region "$region" --all --output json 2>/dev/null)
    
    local drt_count=0
    if [[ -n "$drt_json" && "$drt_json" != "null" ]]; then
        drt_count=$(echo "$drt_json" | jq '.data | length // 0' 2>/dev/null)
    fi
    
    if [[ "$drt_count" -gt 0 ]]; then
        while IFS='|' read -r drt_name drt_state import_dist_id is_ecmp drt_id; do
            [[ -z "$drt_name" ]] && continue
            
            local drt_state_color="$GREEN"
            [[ "$drt_state" != "AVAILABLE" ]] && drt_state_color="$YELLOW"
            
            # Route table: name, ecmp, ocid on one line
            echo -e "  ${BOLD}${WHITE}$drt_name${NC}  ${drt_state_color}$drt_state${NC}  ${CYAN}ECMP:${NC}${WHITE}$is_ecmp${NC}  ${YELLOW}($drt_id)${NC}"
            
            # --- Route Rules with aligned columns ---
            local rules_json
            rules_json=$(oci network drg-route-rule list --drg-route-table-id "$drt_id" \
                --region "$region" --output json 2>/dev/null)
            
            local rules_data
            rules_data=$(echo "$rules_json" | jq '.data // .items // []' 2>/dev/null)
            local rule_count
            rule_count=$(echo "$rules_data" | jq 'length' 2>/dev/null || echo "0")
            
            echo ""
            echo -e "    └─ ${BOLD}${CYAN}Route Rules (${rule_count}):${NC}"
            
            if [[ "$rule_count" -gt 0 ]]; then
                printf "       ${BOLD}%-22s %-14s %-10s %-16s %s${NC}\n" "Destination" "Dest Type" "Type" "Origin" "Next Hop"
                printf "       %s\n" "$(printf '%*s' 120 '' | tr ' ' '─')"
                
                while IFS='|' read -r rule_dest rule_dest_type rule_type rule_origin next_hop_id is_conflict is_blackhole rule_id; do
                    [[ -z "$rule_dest" ]] && continue
                    
                    local origin_color="$WHITE"
                    case "$rule_type" in
                        STATIC) origin_color="$YELLOW" ;;
                        DYNAMIC) origin_color="$GREEN" ;;
                    esac
                    
                    local conflict_flag=""
                    [[ "$is_conflict" == "true" ]] && conflict_flag=" ${RED}⚠CONFLICT${NC}"
                    [[ "$is_blackhole" == "true" ]] && conflict_flag=" ${RED}⬛BLACKHOLE${NC}"
                    
                    # Resolve next-hop: display-name (ocid) combined
                    local hop_display=""
                    if [[ -n "$next_hop_id" && "$next_hop_id" != "N/A" && "$next_hop_id" != "null" ]]; then
                        local hop_name="${ATT_NAME_LOOKUP[$next_hop_id]:-}"
                        if [[ -z "$hop_name" ]]; then
                            local hop_att_json
                            hop_att_json=$(oci network drg-attachment get --drg-attachment-id "$next_hop_id" --region "$region" --output json 2>/dev/null)
                            if [[ -n "$hop_att_json" ]] && echo "$hop_att_json" | jq -e '.data' >/dev/null 2>&1; then
                                hop_name=$(echo "$hop_att_json" | jq -r '.data["display-name"] // ""' 2>/dev/null)
                                local hop_type
                                hop_type=$(echo "$hop_att_json" | jq -r '.data["network-details"]["type"] // ""' 2>/dev/null)
                                [[ -n "$hop_name" ]] && ATT_NAME_LOOKUP[$next_hop_id]="$hop_name"
                                [[ -n "$hop_type" ]] && ATT_TYPE_LOOKUP[$next_hop_id]="$hop_type"
                            fi
                        fi
                        if [[ -n "$hop_name" ]]; then
                            hop_display="${CYAN}${hop_name}${NC} ${YELLOW}(${next_hop_id})${NC}"
                        else
                            hop_display="${YELLOW}(${next_hop_id})${NC}"
                        fi
                    fi
                    
                    printf "       ${WHITE}%-22s${NC} %-14s ${origin_color}%-10s${NC} %-16s %b%b\n" \
                        "${rule_dest:0:22}" "${rule_dest_type:0:14}" "${rule_type:0:10}" "${rule_origin}" "$hop_display" "$conflict_flag"
                done < <(echo "$rules_data" | jq -r '.[] | "\(.destination // "N/A")|\(.["destination-type"] // "N/A")|\(.["route-type"] // "N/A")|\(.["route-provenance"] // "N/A")|\(.["next-hop-drg-attachment-id"] // "N/A")|\(.["is-conflict"] // false)|\(.["is-blackhole"] // false)|\(.id // "")"' 2>/dev/null)
            else
                echo -e "       ${GRAY}(No route rules)${NC}"
            fi
            
            echo ""
            print_separator 100
            echo ""
        done < <(echo "$drt_json" | jq -r '.data[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["import-drg-route-distribution-id"] // "null")|\(.["is-ecmp-enabled"])|\(.id)"' 2>/dev/null)
    else
        echo -e "  ${GRAY}No DRG route tables found${NC}"
        echo ""
    fi
    
    #==========================================================================
    # Import Route Distributions (with full statements)
    #==========================================================================
    echo -e "${BOLD}${CYAN}─── Import Route Distributions ───${NC}"
    local dist_list_json
    dist_list_json=$(oci network drg-route-distribution list --drg-id "$drg_id" --region "$region" --all --output json 2>/dev/null)
    
    local dist_list_count=0
    if [[ -n "$dist_list_json" && "$dist_list_json" != "null" ]]; then
        dist_list_count=$(echo "$dist_list_json" | jq '.data | length // 0' 2>/dev/null)
    fi
    
    local _import_found=0
    if [[ "$dist_list_count" -gt 0 ]]; then
        while IFS='|' read -r d_name d_state d_type d_id; do
            [[ -z "$d_name" ]] && continue
            [[ "$d_type" != "IMPORT" ]] && continue
            _import_found=1
            
            echo -e "  ${BOLD}${WHITE}$d_name${NC}  ${GRAY}[${d_type}]${NC}  ${WHITE}$d_state${NC}"
            echo -e "    ${YELLOW}$d_id${NC}"
            
            # Get distribution statements
            local d_stmt_json
            d_stmt_json=$(oci network drg-route-distribution-statement list --route-distribution-id "$d_id" --all \
                --region "$region" --output json 2>/dev/null)
            
            if [[ -n "$d_stmt_json" ]]; then
                local d_stmt_data
                d_stmt_data=$(echo "$d_stmt_json" | jq '.data // .items // []' 2>/dev/null)
                local d_stmt_count
                d_stmt_count=$(echo "$d_stmt_data" | jq 'length' 2>/dev/null || echo "0")
                
                if [[ "$d_stmt_count" -gt 0 ]]; then
                    echo -e "    ${CYAN}Statements (${d_stmt_count}):${NC}"
                    printf "      ${BOLD}%-10s %-8s %-24s %-40s %s${NC}\n" "Action" "Priority" "Match Type" "Match Criteria" "DRG Attachment"
                    printf "      %s\n" "$(printf '%*s' 120 '' | tr ' ' '─')"
                    while IFS= read -r _dst_line; do
                        [[ -z "$_dst_line" ]] && continue
                        local _ds_action _ds_priority _ds_mc_raw
                        _ds_action=$(echo "$_dst_line" | jq -r '.action // "N/A"' 2>/dev/null)
                        _ds_priority=$(echo "$_dst_line" | jq -r '.priority // "N/A"' 2>/dev/null)
                        _ds_mc_raw=$(echo "$_dst_line" | jq -r '.["match-criteria"]' 2>/dev/null)
                        local _ds_mc_len
                        _ds_mc_len=$(echo "$_ds_mc_raw" | jq 'length' 2>/dev/null || echo "0")
                        
                        if [[ "$_ds_mc_len" -eq 0 || "$_ds_mc_raw" == "[]" || "$_ds_mc_raw" == "null" ]]; then
                            printf "      ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %s\n" \
                                "$_ds_action" "$_ds_priority" "MATCH_ALL" "(all attachments)" ""
                        else
                            local _dmc_idx=0
                            while [[ $_dmc_idx -lt $_ds_mc_len ]]; do
                                local _dmc_mt _dmc_at _dmc_dai
                                _dmc_mt=$(echo "$_ds_mc_raw" | jq -r ".[$_dmc_idx][\"match-type\"] // \"N/A\"" 2>/dev/null)
                                _dmc_at=$(echo "$_ds_mc_raw" | jq -r ".[$_dmc_idx][\"attachment-type\"] // \"null\"" 2>/dev/null)
                                _dmc_dai=$(echo "$_ds_mc_raw" | jq -r ".[$_dmc_idx][\"drg-attachment-id\"] // \"null\"" 2>/dev/null)
                                
                                local _dmc_criteria="" _dmc_att_display=""
                                if [[ "$_dmc_mt" == "DRG_ATTACHMENT_TYPE" && "$_dmc_at" != "null" ]]; then
                                    _dmc_criteria="attachment-type=$_dmc_at"
                                elif [[ "$_dmc_mt" == "DRG_ATTACHMENT_ID" && "$_dmc_dai" != "null" ]]; then
                                    _dmc_criteria="drg-attachment-id"
                                elif [[ "$_dmc_mt" == "MATCH_ALL" ]]; then
                                    _dmc_criteria="(all attachments)"
                                else
                                    _dmc_criteria="$_dmc_mt"
                                fi
                                
                                if [[ -n "$_dmc_dai" && "$_dmc_dai" != "null" ]]; then
                                    local _dsd_name="${ATT_NAME_LOOKUP[$_dmc_dai]:-}"
                                    if [[ -z "$_dsd_name" ]]; then
                                        _dsd_name=$(oci network drg-attachment get --drg-attachment-id "$_dmc_dai" --region "$region" \
                                            --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                                        [[ -n "$_dsd_name" ]] && ATT_NAME_LOOKUP[$_dmc_dai]="$_dsd_name"
                                    fi
                                    if [[ -n "$_dsd_name" ]]; then
                                        _dmc_att_display="${CYAN}${_dsd_name}${NC} ${YELLOW}(${_dmc_dai})${NC}"
                                    else
                                        _dmc_att_display="${YELLOW}(${_dmc_dai})${NC}"
                                    fi
                                fi
                                
                                if [[ $_dmc_idx -eq 0 ]]; then
                                    printf "      ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %b\n" \
                                        "$_ds_action" "$_ds_priority" "$_dmc_mt" "$_dmc_criteria" "$_dmc_att_display"
                                else
                                    printf "      %-10s %-8s %-24s %-40s %b\n" \
                                        "" "" "$_dmc_mt" "$_dmc_criteria" "$_dmc_att_display"
                                fi
                                ((_dmc_idx++))
                            done
                        fi
                    done < <(echo "$d_stmt_data" | jq -c '.[]' 2>/dev/null)
                else
                    echo -e "    ${GRAY}(No statements)${NC}"
                fi
            else
                echo -e "    ${GRAY}(No statements)${NC}"
            fi
            echo ""
        done < <(echo "$dist_list_json" | jq -r '.data[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["distribution-type"])|\(.id)"' 2>/dev/null)
    fi
    [[ $_import_found -eq 0 ]] && echo -e "  ${GRAY}No import route distributions found${NC}" && echo ""
    
    #==========================================================================
    # Export Route Distributions (with full statements)
    #==========================================================================
    echo -e "${BOLD}${CYAN}─── Export Route Distributions ───${NC}"
    local _export_found=0
    if [[ "$dist_list_count" -gt 0 ]]; then
        while IFS='|' read -r d_name d_state d_type d_id; do
            [[ -z "$d_name" ]] && continue
            [[ "$d_type" != "EXPORT" ]] && continue
            _export_found=1
            
            echo -e "  ${BOLD}${WHITE}$d_name${NC}  ${GRAY}[${d_type}]${NC}  ${WHITE}$d_state${NC}"
            echo -e "    ${YELLOW}$d_id${NC}"
            
            # Get distribution statements
            local e_stmt_json
            e_stmt_json=$(oci network drg-route-distribution-statement list --route-distribution-id "$d_id" --all \
                --region "$region" --output json 2>/dev/null)
            
            if [[ -n "$e_stmt_json" ]]; then
                local e_stmt_data
                e_stmt_data=$(echo "$e_stmt_json" | jq '.data // .items // []' 2>/dev/null)
                local e_stmt_count
                e_stmt_count=$(echo "$e_stmt_data" | jq 'length' 2>/dev/null || echo "0")
                
                if [[ "$e_stmt_count" -gt 0 ]]; then
                    echo -e "    ${CYAN}Statements (${e_stmt_count}):${NC}"
                    printf "      ${BOLD}%-10s %-8s %-24s %-40s %s${NC}\n" "Action" "Priority" "Match Type" "Match Criteria" "DRG Attachment"
                    printf "      %s\n" "$(printf '%*s' 120 '' | tr ' ' '─')"
                    while IFS= read -r _est_line; do
                        [[ -z "$_est_line" ]] && continue
                        local _es_action _es_priority _es_mc_raw
                        _es_action=$(echo "$_est_line" | jq -r '.action // "N/A"' 2>/dev/null)
                        _es_priority=$(echo "$_est_line" | jq -r '.priority // "N/A"' 2>/dev/null)
                        _es_mc_raw=$(echo "$_est_line" | jq -r '.["match-criteria"]' 2>/dev/null)
                        local _es_mc_len
                        _es_mc_len=$(echo "$_es_mc_raw" | jq 'length' 2>/dev/null || echo "0")
                        
                        if [[ "$_es_mc_len" -eq 0 || "$_es_mc_raw" == "[]" || "$_es_mc_raw" == "null" ]]; then
                            printf "      ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %s\n" \
                                "$_es_action" "$_es_priority" "MATCH_ALL" "(all attachments)" ""
                        else
                            local _emc_idx=0
                            while [[ $_emc_idx -lt $_es_mc_len ]]; do
                                local _emc_mt _emc_at _emc_dai
                                _emc_mt=$(echo "$_es_mc_raw" | jq -r ".[$_emc_idx][\"match-type\"] // \"N/A\"" 2>/dev/null)
                                _emc_at=$(echo "$_es_mc_raw" | jq -r ".[$_emc_idx][\"attachment-type\"] // \"null\"" 2>/dev/null)
                                _emc_dai=$(echo "$_es_mc_raw" | jq -r ".[$_emc_idx][\"drg-attachment-id\"] // \"null\"" 2>/dev/null)
                                
                                local _emc_criteria="" _emc_att_display=""
                                if [[ "$_emc_mt" == "DRG_ATTACHMENT_TYPE" && "$_emc_at" != "null" ]]; then
                                    _emc_criteria="attachment-type=$_emc_at"
                                elif [[ "$_emc_mt" == "DRG_ATTACHMENT_ID" && "$_emc_dai" != "null" ]]; then
                                    _emc_criteria="drg-attachment-id"
                                elif [[ "$_emc_mt" == "MATCH_ALL" ]]; then
                                    _emc_criteria="(all attachments)"
                                else
                                    _emc_criteria="$_emc_mt"
                                fi
                                
                                if [[ -n "$_emc_dai" && "$_emc_dai" != "null" ]]; then
                                    local _esd_name="${ATT_NAME_LOOKUP[$_emc_dai]:-}"
                                    if [[ -z "$_esd_name" ]]; then
                                        _esd_name=$(oci network drg-attachment get --drg-attachment-id "$_emc_dai" --region "$region" \
                                            --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                                        [[ -n "$_esd_name" ]] && ATT_NAME_LOOKUP[$_emc_dai]="$_esd_name"
                                    fi
                                    if [[ -n "$_esd_name" ]]; then
                                        _emc_att_display="${CYAN}${_esd_name}${NC} ${YELLOW}(${_emc_dai})${NC}"
                                    else
                                        _emc_att_display="${YELLOW}(${_emc_dai})${NC}"
                                    fi
                                fi
                                
                                if [[ $_emc_idx -eq 0 ]]; then
                                    printf "      ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %b\n" \
                                        "$_es_action" "$_es_priority" "$_emc_mt" "$_emc_criteria" "$_emc_att_display"
                                else
                                    printf "      %-10s %-8s %-24s %-40s %b\n" \
                                        "" "" "$_emc_mt" "$_emc_criteria" "$_emc_att_display"
                                fi
                                ((_emc_idx++))
                            done
                        fi
                    done < <(echo "$e_stmt_data" | jq -c '.[]' 2>/dev/null)
                else
                    echo -e "    ${GRAY}(No statements)${NC}"
                fi
            else
                echo -e "    ${GRAY}(No statements)${NC}"
            fi
            echo ""
        done < <(echo "$dist_list_json" | jq -r '.data[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["distribution-type"])|\(.id)"' 2>/dev/null)
    fi
    [[ $_export_found -eq 0 ]] && echo -e "  ${GRAY}No export route distributions found${NC}" && echo ""
    
    # Peer regions action
    local peer_regions=()
    if [[ "$rpc_count" -gt 0 ]]; then
        while read -r pr; do
            [[ -n "$pr" && "$pr" != "null" ]] && peer_regions+=("$pr")
        done < <(echo "$all_rpcs" | jq -r '.[]["peer-region-name"] // empty' 2>/dev/null | sort -u)
    fi
    
    if [[ ${#peer_regions[@]} -gt 0 ]]; then
        echo -e "${BOLD}${CYAN}─── Actions ───${NC}"
        echo ""
        echo -e "  ${GREEN}This DRG has peering connections to other regions.${NC}"
        echo -e "  ${WHITE}Peer Regions:${NC} ${peer_regions[*]}"
        echo ""
        echo -n -e "  ${CYAN}Query a peer region? (y/N): ${NC}"
        local query_peer
        read -r query_peer
        
        if [[ "$query_peer" == "y" || "$query_peer" == "Y" ]]; then
            if [[ ${#peer_regions[@]} -eq 1 ]]; then
                drg_query_remote_region "${peer_regions[0]}" "$main_comp"
            else
                echo ""
                echo -e "  ${WHITE}Select peer region:${NC}"
                local pr_idx=0
                declare -A PR_MAP
                for pr in "${peer_regions[@]}"; do
                    ((pr_idx++))
                    PR_MAP[$pr_idx]="$pr"
                    echo -e "    ${YELLOW}$pr_idx${NC}) $pr"
                done
                echo ""
                echo -n -e "  ${CYAN}Select region #: ${NC}"
                local pr_sel
                read -r pr_sel
                
                if [[ -n "${PR_MAP[$pr_sel]}" ]]; then
                    drg_query_remote_region "${PR_MAP[$pr_sel]}" "$main_comp"
                fi
            fi
        fi
    else
        echo -e "Press Enter to continue..."
        read -r
    fi
}


#--------------------------------------------------------------------------------
# DRG - Search Additional Compartments
#--------------------------------------------------------------------------------
drg_search_compartments() {
    local -n compartment_array=$1
    local tenancy_id="${TENANCY_ID}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Search Additional Compartments ═══${NC}"
    echo ""
    
    # If TENANCY_ID not set, try to derive it
    if [[ -z "$tenancy_id" ]]; then
        local comp_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
        
        # Check if compartment ID is actually a tenancy
        if [[ "$comp_id" == ocid1.tenancy.* ]]; then
            tenancy_id="$comp_id"
        else
            # Try to get tenancy from OCI CLI config
            echo -e "${GRAY}Deriving tenancy ID...${NC}"
            tenancy_id=$(oci iam region-subscription list --query 'data[0]."tenancy-id"' --raw-output 2>/dev/null)
        fi
    fi
    
    if [[ -z "$tenancy_id" || "$tenancy_id" == "null" ]]; then
        echo -e "${RED}Could not determine tenancy ID${NC}"
        echo -e "${GRAY}Set TENANCY_ID in variables.sh${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo -e "${GRAY}Fetching compartments from tenancy...${NC}"
    
    local comp_json
    comp_json=$(oci iam compartment list --compartment-id "$tenancy_id" --compartment-id-in-subtree true --all --output json 2>&1)
    
    if [[ -z "$comp_json" ]] || ! echo "$comp_json" | jq -e '.data' > /dev/null 2>&1; then
        echo -e "${RED}Failed to list compartments${NC}"
        echo -e "${GRAY}Error: ${comp_json:0:200}${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local comp_count
    comp_count=$(echo "$comp_json" | jq '.data | length // 0' 2>/dev/null)
    
    if [[ "$comp_count" -eq 0 ]]; then
        echo -e "${YELLOW}No compartments found${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo ""
    echo -e "${WHITE}Available Compartments:${NC}"
    printf "  ${BOLD}%-3s %-50s %-12s${NC}\n" "#" "Compartment Name" "State"
    print_separator 80
    
    local idx=0
    declare -A COMP_MAP
    COMP_MAP=()
    
    # Add root tenancy first
    ((idx++))
    COMP_MAP[$idx]="$tenancy_id"
    local root_selected=""
    for existing in "${compartment_array[@]}"; do
        [[ "$existing" == "$tenancy_id" ]] && root_selected="*"
    done
    printf "  ${YELLOW}%-3s${NC} %-50s ${GREEN}%-12s${NC} %s\n" \
        "$idx" "(root) Tenancy" "ACTIVE" "$root_selected"
    
    while IFS='|' read -r comp_name comp_state comp_id; do
        [[ -z "$comp_name" ]] && continue
        [[ "$comp_state" != "ACTIVE" ]] && continue
        ((idx++))
        
        COMP_MAP[$idx]="$comp_id"
        
        # Check if already selected
        local is_selected=""
        for existing in "${compartment_array[@]}"; do
            [[ "$existing" == "$comp_id" ]] && is_selected="*"
        done
        
        printf "  ${YELLOW}%-3s${NC} %-50s ${GREEN}%-12s${NC} %s\n" \
            "$idx" "${comp_name:0:48}" "$comp_state" "$is_selected"
            
    done < <(echo "$comp_json" | jq -r '.data[] | "\(.name)|\(.["lifecycle-state"])|\(.id)"' 2>/dev/null | sort)
    
    echo ""
    echo -e "  ${GRAY}* = already selected${NC}"
    echo ""
    echo -e "${CYAN}Options:${NC}"
    echo -e "  Enter compartment numbers separated by spaces (e.g., '1 3 5')"
    echo -e "  Enter 'all' to search all compartments"
    echo -e "  Enter to cancel"
    echo ""
    echo -n -e "${CYAN}Select compartments: ${NC}"
    read -r comp_selection
    
    if [[ -z "$comp_selection" ]]; then
        return
    fi
    
    if [[ "$comp_selection" == "all" || "$comp_selection" == "ALL" ]]; then
        # Add all compartments
        compartment_array=()
        for i in $(seq 1 $idx); do
            compartment_array+=("${COMP_MAP[$i]}")
        done
        echo -e "${GREEN}Added all $idx compartments to search${NC}"
    else
        # Add selected compartments
        for num in $comp_selection; do
            if [[ -n "${COMP_MAP[$num]}" ]]; then
                # Check if already in array
                local already_exists="false"
                for existing in "${compartment_array[@]}"; do
                    [[ "$existing" == "${COMP_MAP[$num]}" ]] && already_exists="true"
                done
                
                if [[ "$already_exists" == "false" ]]; then
                    compartment_array+=("${COMP_MAP[$num]}")
                    echo -e "${GREEN}Added compartment #$num${NC}"
                fi
            fi
        done
    fi
    
    echo ""
    echo -e "${WHITE}Now searching ${#compartment_array[@]} compartment(s)${NC}"
    sleep 1
}

#--------------------------------------------------------------------------------
# DRG - Guidance Wizard (Help users discover DRG resources)
#--------------------------------------------------------------------------------
drg_guidance_wizard() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    echo ""
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${CYAN}                                    DRG CONNECTIVITY DISCOVERY WIZARD                                              ${NC}"
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${GRAY}This wizard will help you discover DRG resources and connectivity in your environment.${NC}"
    echo ""
    
    # Step 1: Check for DRGs in current compartment
    echo -e "${BOLD}${WHITE}Step 1: Checking for DRGs in current compartment...${NC}"
    echo -e "  ${CYAN}Compartment:${NC} ${WHITE}$(resolve_compartment_name "$compartment_id")${NC} ${GRAY}($compartment_id)${NC}"
    echo -e "  ${CYAN}Region:${NC}      ${WHITE}$region${NC}"
    echo ""
    
    local drg_json
    drg_json=$(oci network drg list --compartment-id "$compartment_id" --output json 2>/dev/null)
    
    local drg_count=0
    if [[ -n "$drg_json" && "$drg_json" != "null" ]]; then
        drg_count=$(echo "$drg_json" | jq '.data | length // 0' 2>/dev/null)
    fi
    
    if [[ "$drg_count" -eq 0 ]]; then
        echo -e "  ${YELLOW}⚠ No DRGs found in current compartment${NC}"
        echo ""
        echo -e "  ${WHITE}Would you like to search other compartments?${NC}"
        echo -n -e "  ${CYAN}Search other compartments? (y/N): ${NC}"
        read -r search_others
        
        if [[ "$search_others" == "y" || "$search_others" == "Y" ]]; then
            # Search parent/sibling compartments
            drg_discover_in_other_compartments
        fi
        
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo -e "  ${GREEN}✓ Found $drg_count DRG(s) in current compartment${NC}"
    echo ""
    
    # Step 2: List DRGs and their attachments
    echo -e "${BOLD}${WHITE}Step 2: DRG Summary${NC}"
    echo ""
    
    local drg_idx=0
    declare -A WIZARD_DRG_MAP
    declare -A WIZARD_DRG_REGIONS
    WIZARD_DRG_MAP=()
    WIZARD_DRG_REGIONS=()
    
    while IFS='|' read -r drg_name drg_state drg_id; do
        [[ -z "$drg_name" ]] && continue
        ((drg_idx++))
        
        WIZARD_DRG_MAP[$drg_idx]="$drg_id"
        
        echo -e "  ${BOLD}${MAGENTA}DRG #$drg_idx: $drg_name${NC}"
        echo -e "    ${CYAN}State:${NC} ${GREEN}$drg_state${NC}"
        echo -e "    ${CYAN}OCID:${NC}  ${GRAY}$drg_id${NC}"
        
        # Get attachments
        local attach_json
        attach_json=$(oci network drg-attachment list --drg-id "$drg_id" --output json 2>/dev/null)
        local attach_count=0
        if [[ -n "$attach_json" ]]; then
            attach_count=$(echo "$attach_json" | jq '.data | length // 0' 2>/dev/null)
        fi
        
        if [[ "$attach_count" -gt 0 ]]; then
            echo -e "    ${CYAN}VCN Attachments:${NC} $attach_count"
            echo "$attach_json" | jq -r '.data[] | "      • \(.["display-name"]) [\(.["lifecycle-state"])]"' 2>/dev/null
        else
            echo -e "    ${YELLOW}VCN Attachments: None${NC}"
        fi
        
        # Get Remote Peering Connections and track peer regions
        local rpc_json
        rpc_json=$(oci network remote-peering-connection list --compartment-id "$compartment_id" --drg-id "$drg_id" --output json 2>/dev/null)
        local rpc_count=0
        if [[ -n "$rpc_json" ]]; then
            rpc_count=$(echo "$rpc_json" | jq '.data | length // 0' 2>/dev/null)
        fi
        
        if [[ "$rpc_count" -gt 0 ]]; then
            echo -e "    ${CYAN}Remote Peering:${NC} $rpc_count connection(s)"
            
            # Collect peer regions
            local peer_regions=""
            while IFS='|' read -r rpc_name peer_region peer_status; do
                [[ -z "$rpc_name" ]] && continue
                
                local peer_color="$GREEN"
                [[ "$peer_status" != "PEERED" ]] && peer_color="$YELLOW"
                
                echo -e "      ${WHITE}• $rpc_name${NC} ${peer_color}[$peer_status]${NC}"
                
                if [[ -n "$peer_region" && "$peer_region" != "null" ]]; then
                    echo -e "        ${BOLD}${GREEN}→ Peer Region: $peer_region${NC}"
                    peer_regions+="$peer_region "
                fi
            done < <(echo "$rpc_json" | jq -r '.data[] | "\(.["display-name"])|\(.["peer-region-name"] // "null")|\(.["peering-status"])"' 2>/dev/null)
            
            WIZARD_DRG_REGIONS[$drg_idx]="$peer_regions"
        else
            echo -e "    ${GRAY}Remote Peering: None${NC}"
        fi
        
        # Get VPN connections
        local ipsec_json
        ipsec_json=$(oci network ip-sec-connection list --compartment-id "$compartment_id" --drg-id "$drg_id" --output json 2>/dev/null)
        local ipsec_count=0
        if [[ -n "$ipsec_json" ]]; then
            ipsec_count=$(echo "$ipsec_json" | jq '.data | length // 0' 2>/dev/null)
        fi
        
        if [[ "$ipsec_count" -gt 0 ]]; then
            echo -e "    ${CYAN}VPN Connections:${NC} $ipsec_count"
        fi
        
        # Get FastConnect
        local vc_json
        vc_json=$(oci network virtual-circuit list --compartment-id "$compartment_id" --output json 2>/dev/null)
        local fc_count=0
        if [[ -n "$vc_json" ]]; then
            fc_count=$(echo "$vc_json" | jq --arg drg "$drg_id" '[.data[] | select(.["gateway-id"] == $drg)] | length // 0' 2>/dev/null)
        fi
        
        if [[ "$fc_count" -gt 0 ]]; then
            echo -e "    ${CYAN}FastConnect:${NC} $fc_count virtual circuit(s)"
        fi
        
        echo ""
    done < <(echo "$drg_json" | jq -r '.data[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.id)"' 2>/dev/null)
    
    # Step 3: Offer to query peer regions
    echo -e "${BOLD}${WHITE}Step 3: Remote Region Discovery${NC}"
    echo ""
    
    local has_peer_regions="false"
    for drg_num in $(seq 1 $drg_idx); do
        local regions="${WIZARD_DRG_REGIONS[$drg_num]}"
        if [[ -n "$regions" ]]; then
            has_peer_regions="true"
            break
        fi
    done
    
    if [[ "$has_peer_regions" == "true" ]]; then
        echo -e "  ${GREEN}✓ Remote peering connections found with peer regions${NC}"
        echo ""
        echo -e "  ${WHITE}Would you like to query a remote region for DRG resources?${NC}"
        echo -n -e "  ${CYAN}Query remote region? (y/N): ${NC}"
        read -r query_remote
        
        if [[ "$query_remote" == "y" || "$query_remote" == "Y" ]]; then
            # Build list of unique peer regions
            declare -A unique_regions
            for drg_num in $(seq 1 $drg_idx); do
                local regions="${WIZARD_DRG_REGIONS[$drg_num]}"
                for pr in $regions; do
                    [[ -n "$pr" ]] && unique_regions[$pr]=1
                done
            done
            
            echo ""
            echo -e "  ${WHITE}Available peer regions:${NC}"
            local region_idx=0
            declare -A REGION_MAP
            for pr in "${!unique_regions[@]}"; do
                ((region_idx++))
                REGION_MAP[$region_idx]="$pr"
                echo -e "    ${YELLOW}$region_idx${NC}) $pr"
            done
            
            echo ""
            echo -n -e "  ${CYAN}Select region # to query: ${NC}"
            read -r region_sel
            
            if [[ -n "${REGION_MAP[$region_sel]}" ]]; then
                drg_query_remote_region "${REGION_MAP[$region_sel]}" "$compartment_id"
            fi
        fi
    else
        echo -e "  ${GRAY}No remote peering connections with peer regions found${NC}"
        echo -e "  ${GRAY}Remote region discovery is available when RPC connections exist${NC}"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# DRG - Discover in Other Compartments
#--------------------------------------------------------------------------------
drg_discover_in_other_compartments() {
    local tenancy_id="${TENANCY_ID}"
    
    # Derive tenancy if not set
    if [[ -z "$tenancy_id" ]]; then
        tenancy_id=$(oci iam region-subscription list --query 'data[0]."tenancy-id"' --raw-output 2>/dev/null)
    fi
    
    if [[ -z "$tenancy_id" ]]; then
        echo -e "  ${RED}Could not determine tenancy ID${NC}"
        return
    fi
    
    echo ""
    echo -e "  ${GRAY}Searching all compartments for DRGs...${NC}"
    
    # Get all active compartments
    local comp_json
    comp_json=$(oci iam compartment list --compartment-id "$tenancy_id" --compartment-id-in-subtree true --all --output json 2>/dev/null)
    
    local found_drgs=0
    declare -A DISCOVERED_DRGS
    
    # Check root tenancy first
    echo -e "  ${GRAY}Checking root tenancy...${NC}"
    local drg_in_root
    drg_in_root=$(oci network drg list --compartment-id "$tenancy_id" --output json 2>/dev/null)
    if [[ -n "$drg_in_root" ]]; then
        local root_drg_count
        root_drg_count=$(echo "$drg_in_root" | jq '.data | length // 0' 2>/dev/null)
        if [[ "$root_drg_count" -gt 0 ]]; then
            ((found_drgs+=root_drg_count))
            echo -e "    ${GREEN}✓ Found $root_drg_count DRG(s) in root tenancy${NC}"
            DISCOVERED_DRGS["root"]="$tenancy_id|$root_drg_count"
        fi
    fi
    
    # Check each compartment (limit to prevent timeout)
    local comp_count=0
    local max_compartments=20
    
    while IFS='|' read -r comp_name comp_id; do
        [[ -z "$comp_name" ]] && continue
        ((comp_count++))
        
        [[ "$comp_count" -gt "$max_compartments" ]] && break
        
        echo -e "  ${GRAY}Checking: ${comp_name:0:40}...${NC}\r"
        
        local drg_in_comp
        drg_in_comp=$(oci network drg list --compartment-id "$comp_id" --output json 2>/dev/null)
        
        if [[ -n "$drg_in_comp" ]]; then
            local comp_drg_count
            comp_drg_count=$(echo "$drg_in_comp" | jq '.data | length // 0' 2>/dev/null)
            if [[ "$comp_drg_count" -gt 0 ]]; then
                ((found_drgs+=comp_drg_count))
                echo -e "    ${GREEN}✓ Found $comp_drg_count DRG(s) in: $comp_name${NC}"
                DISCOVERED_DRGS["$comp_name"]="$comp_id|$comp_drg_count"
            fi
        fi
    done < <(echo "$comp_json" | jq -r '.data[] | select(.["lifecycle-state"] == "ACTIVE") | "\(.name)|\(.id)"' 2>/dev/null)
    
    echo ""
    
    if [[ "$found_drgs" -eq 0 ]]; then
        echo -e "  ${YELLOW}No DRGs found in any compartment (checked $comp_count compartments)${NC}"
    else
        echo -e "  ${GREEN}Total DRGs found: $found_drgs${NC}"
        echo ""
        
        echo -e "  ${WHITE}Compartments with DRGs:${NC}"
        local idx=0
        declare -A COMP_SELECT_MAP
        for comp_name in "${!DISCOVERED_DRGS[@]}"; do
            ((idx++))
            local comp_info="${DISCOVERED_DRGS[$comp_name]}"
            local comp_id="${comp_info%%|*}"
            local drg_cnt="${comp_info#*|}"
            COMP_SELECT_MAP[$idx]="$comp_id"
            echo -e "    ${YELLOW}$idx${NC}) $comp_name (${drg_cnt} DRG(s))"
        done
        
        echo ""
        echo -n -e "  ${CYAN}Switch to compartment # (or Enter to skip): ${NC}"
        read -r comp_sel
        
        if [[ -n "${COMP_SELECT_MAP[$comp_sel]}" ]]; then
            EFFECTIVE_COMPARTMENT_ID="${COMP_SELECT_MAP[$comp_sel]}"
            echo -e "  ${GREEN}Switched to compartment. Return to DRG menu to view.${NC}"
        fi
    fi
}

#--------------------------------------------------------------------------------
# DRG - Query Remote Region
#--------------------------------------------------------------------------------
drg_query_remote_region() {
    local target_region="$1"
    local compartment_id="$2"
    local current_region="${EFFECTIVE_REGION:-$REGION}"
    
    # Build compartment search list (primary + network)
    local -a query_comps=("$compartment_id")
    if [[ -n "$NETWORK_COMPARTMENT_ID" && "$NETWORK_COMPARTMENT_ID" != "$compartment_id" ]]; then
        query_comps+=("$NETWORK_COMPARTMENT_ID")
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Querying Remote Region: $target_region ═══${NC}"
    echo ""
    echo -e "${CYAN}Searching ${#query_comps[@]} compartment(s) in ${target_region}:${NC}"
    for qc in "${query_comps[@]}"; do
        local qc_name; qc_name=$(resolve_compartment_name "$qc")
        echo -e "  ${GRAY}• ${WHITE}$qc_name${NC}"
    done
    echo ""
    
    # List DRGs across all compartments in remote region
    local all_remote_drgs="[]"
    for qc in "${query_comps[@]}"; do
        local remote_drg_json
        remote_drg_json=$(oci network drg list --compartment-id "$qc" --region "$target_region" --output json 2>/dev/null)
        if [[ -n "$remote_drg_json" ]] && echo "$remote_drg_json" | jq -e '.data[0]' >/dev/null 2>&1; then
            all_remote_drgs=$(jq -n --argjson a "$all_remote_drgs" --argjson b "$(echo "$remote_drg_json" | jq '.data')" '$a + $b | unique_by(.id)')
        fi
    done
    
    local remote_drg_count
    remote_drg_count=$(echo "$all_remote_drgs" | jq 'length' 2>/dev/null || echo "0")
    
    if [[ "$remote_drg_count" -eq 0 ]]; then
        echo -e "${YELLOW}No DRGs found in any searched compartment for region: $target_region${NC}"
        echo -e "${GRAY}This could mean:${NC}"
        echo -e "  ${GRAY}• No DRGs exist in these compartments for this region${NC}"
        echo -e "  ${GRAY}• You don't have permission to list DRGs in this region${NC}"
        echo -e "  ${GRAY}• The DRGs may be in a different compartment${NC}"
        echo ""
        echo -n -e "${CYAN}Would you like to try a different compartment? (y/N): ${NC}"
        read -r try_other
        
        if [[ "$try_other" == "y" || "$try_other" == "Y" ]]; then
            drg_select_compartment_for_region "$target_region"
        fi
        return
    fi
    
    echo -e "${GREEN}✓ Found $remote_drg_count DRG(s) in $target_region${NC}"
    echo ""
    
    printf "  ${BOLD}%-3s %-35s %-12s %-25s %s${NC}\n" "#" "DRG Name" "State" "Compartment" "DRG OCID"
    print_separator 120
    
    local idx=0
    declare -A REMOTE_DRG_MAP
    
    while IFS='|' read -r drg_name drg_state drg_id drg_comp; do
        [[ -z "$drg_name" ]] && continue
        ((idx++))
        
        REMOTE_DRG_MAP[$idx]="$drg_id"
        
        local state_color="$GREEN"
        [[ "$drg_state" != "AVAILABLE" ]] && state_color="$YELLOW"
        
        local comp_name; comp_name=$(resolve_compartment_name "$drg_comp")
        
        printf "  ${YELLOW}%-3s${NC} %-35s ${state_color}%-12s${NC} ${WHITE}%-25s${NC} ${GRAY}%s${NC}\n" \
            "$idx" "${drg_name:0:33}" "$drg_state" "${comp_name:0:25}" "$drg_id"
    done < <(echo "$all_remote_drgs" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.id)|\(.["compartment-id"])"' 2>/dev/null)
    
    echo ""
    
    # Show connectivity for each DRG
    for drg_num in $(seq 1 $idx); do
        local drg_id="${REMOTE_DRG_MAP[$drg_num]}"
        local drg_name drg_comp_id
        drg_name=$(echo "$all_remote_drgs" | jq -r --arg id "$drg_id" '.[] | select(.id == $id) | .["display-name"]')
        drg_comp_id=$(echo "$all_remote_drgs" | jq -r --arg id "$drg_id" '.[] | select(.id == $id) | .["compartment-id"]')
        
        echo -e "  ${BOLD}${MAGENTA}$drg_name - Connectivity:${NC}"
        
        # Build per-DRG compartment search list
        local -a drg_search_comps=()
        for qc in "${query_comps[@]}"; do
            drg_search_comps+=("$qc")
        done
        # Add DRG's own compartment if not already included
        local _already=0
        for qc in "${drg_search_comps[@]}"; do [[ "$qc" == "$drg_comp_id" ]] && _already=1; done
        [[ $_already -eq 0 && -n "$drg_comp_id" ]] && drg_search_comps+=("$drg_comp_id")
        
        # Get RPC connections (search all compartments)
        local all_rpc_remote="[]"
        for qc in "${drg_search_comps[@]}"; do
            local rpc_json
            rpc_json=$(oci network remote-peering-connection list --compartment-id "$qc" --drg-id "$drg_id" --region "$target_region" --output json 2>/dev/null)
            if [[ -n "$rpc_json" ]] && echo "$rpc_json" | jq -e '.data[0]' > /dev/null 2>&1; then
                all_rpc_remote=$(jq -n --argjson a "$all_rpc_remote" --argjson b "$(echo "$rpc_json" | jq '.data')" '$a + $b | unique_by(.id)')
            fi
        done
        
        local rpc_remote_count
        rpc_remote_count=$(echo "$all_rpc_remote" | jq 'length' 2>/dev/null || echo "0")
        
        if [[ "$rpc_remote_count" -gt 0 ]]; then
            echo -e "    ${CYAN}Remote Peering Connections:${NC}"
            while IFS='|' read -r rpc_name peer_region peer_status; do
                [[ -z "$rpc_name" ]] && continue
                
                local back_to_current=""
                [[ "$peer_region" == "$current_region" ]] && back_to_current=" ${BOLD}${GREEN}← (peered to your current region)${NC}"
                
                local peer_color="$GREEN"
                [[ "$peer_status" != "PEERED" ]] && peer_color="$YELLOW"
                
                echo -e "      ${WHITE}• $rpc_name${NC} → ${BOLD}$peer_region${NC} [${peer_color}$peer_status${NC}]$back_to_current"
            done < <(echo "$all_rpc_remote" | jq -r '.[] | "\(.["display-name"])|\(.["peer-region-name"] // "null")|\(.["peering-status"])"' 2>/dev/null)
        fi
        
        # Get VCN attachments (try --drg-id first, then compartment search)
        local attach_json
        attach_json=$(oci network drg-attachment list --drg-id "$drg_id" --region "$target_region" --all --output json 2>/dev/null)
        
        if [[ -n "$attach_json" ]] && echo "$attach_json" | jq -e '.data[0]' > /dev/null 2>&1; then
            echo -e "    ${CYAN}VCN Attachments:${NC}"
            while IFS='|' read -r att_name att_state vcn_id att_type; do
                [[ -z "$att_name" ]] && continue
                
                local vcn_name="N/A" vcn_cidr=""
                if [[ -n "$vcn_id" && "$vcn_id" != "null" ]]; then
                    local vcn_detail
                    vcn_detail=$(oci network vcn get --vcn-id "$vcn_id" --region "$target_region" --output json 2>/dev/null)
                    if [[ -n "$vcn_detail" ]]; then
                        vcn_name=$(echo "$vcn_detail" | jq -r '.data["display-name"] // "N/A"')
                        vcn_cidr=$(echo "$vcn_detail" | jq -r '.data["cidr-block"] // ""')
                    fi
                fi
                
                local cidr_display=""
                [[ -n "$vcn_cidr" ]] && cidr_display=" ($vcn_cidr)"
                
                echo -e "      ${WHITE}• $att_name${NC} → VCN: ${GREEN}$vcn_name${NC}${GRAY}$cidr_display${NC} [${att_type:-VCN}] [$att_state]"
            done < <(echo "$attach_json" | jq -r '.data[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["network-details"]["id"] // "null")|\(.["network-details"]["type"] // "VCN")"' 2>/dev/null)
        fi
        
        # Get FastConnect virtual circuits (search all compartments)
        local all_fc_remote="[]"
        for qc in "${drg_search_comps[@]}"; do
            local fc_json
            fc_json=$(oci network virtual-circuit list --compartment-id "$qc" --region "$target_region" --output json 2>/dev/null)
            if [[ -n "$fc_json" ]] && echo "$fc_json" | jq -e '.data[0]' > /dev/null 2>&1; then
                local filtered
                filtered=$(echo "$fc_json" | jq --arg drg "$drg_id" '[.data[] | select(.["gateway-id"] == $drg)]' 2>/dev/null)
                if [[ -n "$filtered" && "$filtered" != "[]" ]]; then
                    all_fc_remote=$(jq -n --argjson a "$all_fc_remote" --argjson b "$filtered" '$a + $b | unique_by(.id)')
                fi
            fi
        done
        
        local fc_remote_count
        fc_remote_count=$(echo "$all_fc_remote" | jq 'length' 2>/dev/null || echo "0")
        
        if [[ "$fc_remote_count" -gt 0 ]]; then
            echo -e "    ${CYAN}FastConnect Virtual Circuits:${NC}"
            while IFS='|' read -r fc_name fc_state fc_bw fc_bgp fc_provider fc_type; do
                [[ -z "$fc_name" ]] && continue
                local fc_color="$GREEN"; [[ "$fc_state" != "PROVISIONED" ]] && fc_color="$YELLOW"
                local bgp_color="$GREEN"
                [[ "$fc_bgp" == "DOWN" ]] && bgp_color="$RED"
                [[ "$fc_bgp" == "N/A" || "$fc_bgp" == "null" ]] && bgp_color="$GRAY"
                echo -e "      ${WHITE}• $fc_name${NC} [${fc_color}$fc_state${NC}] ${WHITE}$fc_bw${NC} BGP:${bgp_color}${fc_bgp:-N/A}${NC} ${GRAY}$fc_provider ($fc_type)${NC}"
            done < <(echo "$all_fc_remote" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["bandwidth-shape-name"] // "N/A")|\(.["bgp-session-state"] // "N/A")|\(.["provider-name"] // "")|\(.type // "")"' 2>/dev/null)
        fi
        
        # Get IPSec VPN connections (search all compartments)
        local all_vpn_remote="[]"
        for qc in "${drg_search_comps[@]}"; do
            local vpn_json
            vpn_json=$(oci network ip-sec-connection list --compartment-id "$qc" --drg-id "$drg_id" --region "$target_region" --output json 2>/dev/null)
            if [[ -n "$vpn_json" ]] && echo "$vpn_json" | jq -e '.data[0]' > /dev/null 2>&1; then
                all_vpn_remote=$(jq -n --argjson a "$all_vpn_remote" --argjson b "$(echo "$vpn_json" | jq '.data')" '$a + $b | unique_by(.id)')
            fi
        done
        
        local vpn_remote_count
        vpn_remote_count=$(echo "$all_vpn_remote" | jq 'length' 2>/dev/null || echo "0")
        
        if [[ "$vpn_remote_count" -gt 0 ]]; then
            echo -e "    ${CYAN}IPSec VPN Connections:${NC}"
            while IFS='|' read -r vpn_name vpn_state cpe_id; do
                [[ -z "$vpn_name" ]] && continue
                local cpe_display=""
                if [[ -n "$cpe_id" && "$cpe_id" != "null" ]]; then
                    local cpe_name cpe_ip
                    cpe_name=$(oci network cpe get --cpe-id "$cpe_id" --region "$target_region" --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                    cpe_ip=$(oci network cpe get --cpe-id "$cpe_id" --region "$target_region" --query 'data."ip-address"' --raw-output 2>/dev/null || echo "")
                    [[ -n "$cpe_name" ]] && cpe_display=" → CPE: $cpe_name"
                    [[ -n "$cpe_ip" ]] && cpe_display="$cpe_display ($cpe_ip)"
                fi
                echo -e "      ${WHITE}• $vpn_name${NC} [$vpn_state]${GRAY}$cpe_display${NC}"
            done < <(echo "$all_vpn_remote" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["cpe-id"] // "")"' 2>/dev/null)
        fi
        
        echo ""
    done
    
    echo -e "${GRAY}Note: You are viewing resources in region: $target_region${NC}"
    echo -e "${GRAY}      Your current region is: $current_region${NC}"
}

#--------------------------------------------------------------------------------
# DRG - Select Compartment for Region Query
#--------------------------------------------------------------------------------
drg_select_compartment_for_region() {
    local target_region="$1"
    local tenancy_id="${TENANCY_ID}"
    
    # Derive tenancy if not set
    if [[ -z "$tenancy_id" ]]; then
        tenancy_id=$(oci iam region-subscription list --query 'data[0]."tenancy-id"' --raw-output 2>/dev/null)
    fi
    
    if [[ -z "$tenancy_id" ]]; then
        echo -e "${RED}Could not determine tenancy ID${NC}"
        return
    fi
    
    echo ""
    echo -e "${WHITE}Select a compartment to query in $target_region:${NC}"
    
    local comp_json
    comp_json=$(oci iam compartment list --compartment-id "$tenancy_id" --compartment-id-in-subtree true --all --output json 2>/dev/null)
    
    local idx=0
    declare -A COMP_MAP
    
    # Add root tenancy
    ((idx++))
    COMP_MAP[$idx]="$tenancy_id"
    echo -e "  ${YELLOW}$idx${NC}) (root) Tenancy"
    
    while IFS='|' read -r comp_name comp_id; do
        [[ -z "$comp_name" ]] && continue
        ((idx++))
        COMP_MAP[$idx]="$comp_id"
        echo -e "  ${YELLOW}$idx${NC}) $comp_name"
        
        [[ "$idx" -ge 20 ]] && { echo -e "  ${GRAY}... (showing first 20)${NC}"; break; }
    done < <(echo "$comp_json" | jq -r '.data[] | select(.["lifecycle-state"] == "ACTIVE") | "\(.name)|\(.id)"' 2>/dev/null | head -20)
    
    echo ""
    echo -n -e "${CYAN}Select compartment #: ${NC}"
    read -r comp_sel
    
    if [[ -n "${COMP_MAP[$comp_sel]}" ]]; then
        drg_query_remote_region "$target_region" "${COMP_MAP[$comp_sel]}"
    fi
}

#--------------------------------------------------------------------------------
# DRG - Query Region Menu (list subscribed regions and select one to query)
#--------------------------------------------------------------------------------
drg_query_region_menu() {
    local compartment_id="$1"
    local current_region="${EFFECTIVE_REGION:-$REGION}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Query Remote Region ═══${NC}"
    echo ""
    echo -e "${CYAN}Current Region:${NC} ${WHITE}$current_region${NC}"
    echo ""
    
    echo -e "${GRAY}Fetching subscribed regions...${NC}"
    
    # Get subscribed regions
    local regions_json
    regions_json=$(oci iam region-subscription list --output json 2>/dev/null)
    
    if [[ -z "$regions_json" ]] || ! echo "$regions_json" | jq -e '.data' > /dev/null 2>&1; then
        echo -e "${RED}Failed to list subscribed regions${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local region_count
    region_count=$(echo "$regions_json" | jq '.data | length // 0' 2>/dev/null)
    
    if [[ "$region_count" -eq 0 ]]; then
        echo -e "${YELLOW}No subscribed regions found${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo ""
    echo -e "${WHITE}Subscribed Regions:${NC}"
    printf "  ${BOLD}%-3s %-25s %-15s %s${NC}\n" "#" "Region Name" "Region Key" "Status"
    print_separator 60
    
    local idx=0
    declare -A REGION_SELECT_MAP
    
    while IFS='|' read -r region_name region_key is_home status; do
        [[ -z "$region_name" ]] && continue
        ((idx++))
        
        REGION_SELECT_MAP[$idx]="$region_name"
        
        local home_marker=""
        [[ "$is_home" == "true" ]] && home_marker=" (home)"
        
        local current_marker=""
        [[ "$region_name" == "$current_region" ]] && current_marker=" ${GREEN}← current${NC}"
        
        local status_color="$GREEN"
        [[ "$status" != "READY" ]] && status_color="$YELLOW"
        
        printf "  ${YELLOW}%-3s${NC} %-25s %-15s ${status_color}%-10s${NC}%s%s\n" \
            "$idx" "$region_name" "$region_key" "$status" "$home_marker" "$current_marker"
            
    done < <(echo "$regions_json" | jq -r '.data[] | "\(.["region-name"])|\(.["region-key"])|\(.["is-home-region"])|\(.status)"' 2>/dev/null)
    
    echo ""
    echo -n -e "${CYAN}Select region # to query (or Enter to cancel): ${NC}"
    read -r region_sel
    
    if [[ -z "$region_sel" ]]; then
        return
    fi
    
    if [[ -n "${REGION_SELECT_MAP[$region_sel]}" ]]; then
        local target_region="${REGION_SELECT_MAP[$region_sel]}"
        
        if [[ "$target_region" == "$current_region" ]]; then
            echo -e "${YELLOW}That's your current region. Use the main DRG menu to view resources.${NC}"
            sleep 2
            return
        fi
        
        drg_query_remote_region "$target_region" "$compartment_id"
    else
        echo -e "${RED}Invalid selection${NC}"
        sleep 1
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# View Network Resource Detail
#--------------------------------------------------------------------------------
view_network_resource_detail() {
    local resource_info="$1"
    local resource_type resource_ocid
    
    # Parse resource info (format: TYPE|OCID or GATEWAY|GW_TYPE|OCID)
    IFS='|' read -r resource_type resource_ocid extra_info <<< "$resource_info"
    
    echo ""
    
    case "$resource_type" in
        VCN)
            echo -e "${BOLD}${MAGENTA}=== VCN Details ===${NC}"
            
            local vcn_json
            vcn_json=$(oci network vcn get --vcn-id "$resource_ocid" --output json 2>/dev/null)
            
            if [[ -n "$vcn_json" ]]; then
                local vcn_name
                vcn_name=$(echo "$vcn_json" | jq -r '.data["display-name"] // "N/A"')
                echo -e "${WHITE}Name:${NC} ${GREEN}$vcn_name${NC}"
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$resource_ocid${NC}"
                echo ""
                
                # Extract basic info
                local vcn_state vcn_cidr vcn_cidrs vcn_dns vcn_created
                vcn_state=$(echo "$vcn_json" | jq -r '.data["lifecycle-state"] // "N/A"')
                vcn_cidr=$(echo "$vcn_json" | jq -r '.data["cidr-block"] // "N/A"')
                vcn_cidrs=$(echo "$vcn_json" | jq -r '(.data["cidr-blocks"] // []) | if length > 0 then join(", ") else "N/A" end')
                vcn_dns=$(echo "$vcn_json" | jq -r '.data["dns-label"] // "N/A"')
                vcn_created=$(echo "$vcn_json" | jq -r '.data["time-created"] // "N/A"')
                
                # Extract and resolve default resource OCIDs
                local default_rt_id default_sl_id default_dhcp_id
                default_rt_id=$(echo "$vcn_json" | jq -r '.data["default-route-table-id"] // "N/A"')
                default_sl_id=$(echo "$vcn_json" | jq -r '.data["default-security-list-id"] // "N/A"')
                default_dhcp_id=$(echo "$vcn_json" | jq -r '.data["default-dhcp-options-id"] // "N/A"')
                
                # Resolve display names
                local default_rt_name="N/A" default_sl_name="N/A" default_dhcp_name="N/A"
                if [[ "$default_rt_id" != "N/A" && -n "$default_rt_id" ]]; then
                    default_rt_name=$(oci network route-table get --rt-id "$default_rt_id" --query 'data."display-name"' --raw-output 2>/dev/null) || default_rt_name="N/A"
                fi
                if [[ "$default_sl_id" != "N/A" && -n "$default_sl_id" ]]; then
                    default_sl_name=$(oci network security-list get --security-list-id "$default_sl_id" --query 'data."display-name"' --raw-output 2>/dev/null) || default_sl_name="N/A"
                fi
                if [[ "$default_dhcp_id" != "N/A" && -n "$default_dhcp_id" ]]; then
                    default_dhcp_name=$(oci network dhcp-options get --dhcp-id "$default_dhcp_id" --query 'data."display-name"' --raw-output 2>/dev/null) || default_dhcp_name="N/A"
                fi
                
                echo "State:                 $vcn_state"
                echo "CIDR Block:            $vcn_cidr"
                echo "CIDR Blocks:           $vcn_cidrs"
                echo "DNS Label:             $vcn_dns"
                echo -e "Default Route Table:   ${GREEN}$default_rt_name${NC} ${YELLOW}($default_rt_id)${NC}"
                echo -e "Default Security List: ${GREEN}$default_sl_name${NC} ${YELLOW}($default_sl_id)${NC}"
                echo -e "Default DHCP Options:  ${GREEN}$default_dhcp_name${NC} ${YELLOW}($default_dhcp_id)${NC}"
                echo "Time Created:          $vcn_created"
            else
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$resource_ocid${NC}"
                echo ""
                echo -e "${RED}Failed to fetch VCN details${NC}"
            fi
            ;;
            
        SUBNET)
            echo -e "${BOLD}${GREEN}=== Subnet Details ===${NC}"
            
            local subnet_json
            subnet_json=$(oci network subnet get --subnet-id "$resource_ocid" --output json 2>/dev/null)
            
            if [[ -n "$subnet_json" ]]; then
                local subnet_name
                subnet_name=$(echo "$subnet_json" | jq -r '.data["display-name"] // "N/A"')
                echo -e "${WHITE}Name:${NC} ${GREEN}$subnet_name${NC}"
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$resource_ocid${NC}"
                echo ""
                
                # Extract basic info
                local subnet_state subnet_cidr subnet_ad subnet_dns subnet_created
                local prohibit_public prohibit_internet vr_ip vr_mac
                subnet_state=$(echo "$subnet_json" | jq -r '.data["lifecycle-state"] // "N/A"')
                subnet_cidr=$(echo "$subnet_json" | jq -r '.data["cidr-block"] // "N/A"')
                subnet_ad=$(echo "$subnet_json" | jq -r '.data["availability-domain"] // "Regional"')
                subnet_dns=$(echo "$subnet_json" | jq -r '.data["dns-label"] // "N/A"')
                prohibit_public=$(echo "$subnet_json" | jq -r '.data["prohibit-public-ip-on-vnic"] // false')
                prohibit_internet=$(echo "$subnet_json" | jq -r '.data["prohibit-internet-ingress"] // false')
                vr_ip=$(echo "$subnet_json" | jq -r '.data["virtual-router-ip"] // "N/A"')
                vr_mac=$(echo "$subnet_json" | jq -r '.data["virtual-router-mac"] // "N/A"')
                subnet_created=$(echo "$subnet_json" | jq -r '.data["time-created"] // "N/A"')
                
                # Extract resource OCIDs
                local rt_id dhcp_id
                rt_id=$(echo "$subnet_json" | jq -r '.data["route-table-id"] // "N/A"')
                dhcp_id=$(echo "$subnet_json" | jq -r '.data["dhcp-options-id"] // "N/A"')
                
                # Get security list IDs as array
                local sl_ids_json
                sl_ids_json=$(echo "$subnet_json" | jq -r '.data["security-list-ids"] // []')
                
                # Resolve route table name
                local rt_name="N/A"
                if [[ "$rt_id" != "N/A" && -n "$rt_id" ]]; then
                    rt_name=$(oci network route-table get --rt-id "$rt_id" --query 'data."display-name"' --raw-output 2>/dev/null) || rt_name="N/A"
                fi
                
                # Resolve DHCP options name
                local dhcp_name="N/A"
                if [[ "$dhcp_id" != "N/A" && -n "$dhcp_id" ]]; then
                    dhcp_name=$(oci network dhcp-options get --dhcp-id "$dhcp_id" --query 'data."display-name"' --raw-output 2>/dev/null) || dhcp_name="N/A"
                fi
                
                # Resolve security list names
                local sl_display=""
                local sl_count=0
                while IFS= read -r sl_id; do
                    [[ -z "$sl_id" || "$sl_id" == "null" ]] && continue
                    local sl_name
                    sl_name=$(oci network security-list get --security-list-id "$sl_id" --query 'data."display-name"' --raw-output 2>/dev/null) || sl_name="N/A"
                    ((sl_count++))
                    if [[ $sl_count -eq 1 ]]; then
                        sl_display="${GREEN}$sl_name${NC} ${YELLOW}($sl_id)${NC}"
                    else
                        sl_display="$sl_display"$'\n'"                       ${GREEN}$sl_name${NC} ${YELLOW}($sl_id)${NC}"
                    fi
                done < <(echo "$sl_ids_json" | jq -r '.[]' 2>/dev/null)
                [[ -z "$sl_display" ]] && sl_display="None"
                
                echo "State:                 $subnet_state"
                echo "CIDR Block:            $subnet_cidr"
                echo "Availability Domain:   $subnet_ad"
                echo "DNS Label:             $subnet_dns"
                echo "Prohibit Public IP:    $prohibit_public"
                echo "Prohibit Internet:     $prohibit_internet"
                echo -e "Route Table:           ${GREEN}$rt_name${NC} ${YELLOW}($rt_id)${NC}"
                echo -e "Security Lists:        $sl_display"
                echo -e "DHCP Options:          ${GREEN}$dhcp_name${NC} ${YELLOW}($dhcp_id)${NC}"
                echo "Virtual Router IP:     $vr_ip"
                echo "Virtual Router MAC:    $vr_mac"
                echo "Time Created:          $subnet_created"
            else
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$resource_ocid${NC}"
                echo ""
                echo -e "${RED}Failed to fetch subnet details${NC}"
            fi
            ;;
            
        NSG)
            echo -e "${BOLD}${CYAN}=== Network Security Group Details ===${NC}"
            
            local nsg_json
            nsg_json=$(oci network nsg get --nsg-id "$resource_ocid" --output json 2>/dev/null)
            local nsg_name="N/A"
            
            if [[ -n "$nsg_json" ]]; then
                nsg_name=$(echo "$nsg_json" | jq -r '.data["display-name"] // "N/A"')
            fi
            echo -e "${WHITE}Name:${NC} ${CYAN}$nsg_name${NC}"
            echo -e "${WHITE}OCID:${NC} ${YELLOW}$resource_ocid${NC}"
            echo ""
            
            local rules_json
            rules_json=$(oci network nsg rules list --nsg-id "$resource_ocid" --output json 2>/dev/null)
            
            # Use shared function with cache lookup enabled
            display_nsg_rules_table "$rules_json" "true"
            ;;
            
        ROUTE_TABLE)
            echo -e "${BOLD}${MAGENTA}=== Route Table Details ===${NC}"
            
            local rt_json
            rt_json=$(oci network route-table get --rt-id "$resource_ocid" --output json 2>/dev/null)
            
            if [[ -n "$rt_json" ]]; then
                local rt_name
                rt_name=$(echo "$rt_json" | jq -r '.data["display-name"] // "N/A"')
                echo -e "${WHITE}Name:${NC} ${MAGENTA}$rt_name${NC}"
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$resource_ocid${NC}"
                echo ""
                
                local rule_count
                rule_count=$(echo "$rt_json" | jq '(.data["route-rules"] // []) | length')
                echo -e "Found ${GREEN}$rule_count${NC} route rule(s)"
                echo ""
                
                if [[ "$rule_count" -gt 0 ]]; then
                    echo -e "${BOLD}${CYAN}▶▶▶ ROUTE RULES (${rule_count}) ▶▶▶${NC}"
                    echo ""
                    printf "${BOLD}%-6s | %-22s | %-12s | %-45s | %s${NC}\n" \
                        "Rule #" "Destination" "Type" "Target" "Description"
                    printf "${WHITE}%-6s-+-%-22s-+-%-12s-+-%-45s-+-%s${NC}\n" \
                        "------" "----------------------" "------------" "----------------------------------------------" "----------------------------------------"
                    
                    local rule_num=0
                    echo "$rt_json" | jq -r '
                        (.data["route-rules"] // [])[] |
                        [
                            (.destination // "N/A"),
                            (.["destination-type"] // "CIDR_BLOCK"),
                            (.["network-entity-id"] // "N/A"),
                            (.description // "-")
                        ] | @tsv
                    ' 2>/dev/null | while IFS=$'\t' read -r dest dtype target desc; do
                        ((rule_num++))
                        # Resolve target OCID to name
                        local target_display="$target"
                        if [[ "$target" == ocid1.internetgateway.* ]]; then
                            local gw_name
                            gw_name=$(oci network internet-gateway get --ig-id "$target" --query 'data."display-name"' --raw-output 2>/dev/null) || gw_name=""
                            [[ -n "$gw_name" ]] && target_display="IGW: $gw_name"
                        elif [[ "$target" == ocid1.natgateway.* ]]; then
                            local gw_name
                            gw_name=$(oci network nat-gateway get --nat-gateway-id "$target" --query 'data."display-name"' --raw-output 2>/dev/null) || gw_name=""
                            [[ -n "$gw_name" ]] && target_display="NAT: $gw_name"
                        elif [[ "$target" == ocid1.servicegateway.* ]]; then
                            local gw_name
                            gw_name=$(oci network service-gateway get --service-gateway-id "$target" --query 'data."display-name"' --raw-output 2>/dev/null) || gw_name=""
                            [[ -n "$gw_name" ]] && target_display="SGW: $gw_name"
                        elif [[ "$target" == ocid1.drg.* ]]; then
                            local gw_name
                            gw_name=$(oci network drg get --drg-id "$target" --query 'data."display-name"' --raw-output 2>/dev/null) || gw_name=""
                            [[ -n "$gw_name" ]] && target_display="DRG: $gw_name"
                        elif [[ "$target" == ocid1.localpeeringgateway.* ]]; then
                            local gw_name
                            gw_name=$(oci network local-peering-gateway get --local-peering-gateway-id "$target" --query 'data."display-name"' --raw-output 2>/dev/null) || gw_name=""
                            [[ -n "$gw_name" ]] && target_display="LPG: $gw_name"
                        fi
                        # Truncate if still too long
                        if [[ ${#target_display} -gt 45 ]]; then
                            target_display="${target_display:0:42}..."
                        fi
                        printf "${YELLOW}%-6s${NC} | ${GREEN}%-22s${NC} | ${WHITE}%-12s${NC} | ${CYAN}%-45s${NC} | ${WHITE}%s${NC}\n" \
                            "$rule_num" "${dest:0:22}" "${dtype:0:12}" "$target_display" "$desc"
                    done
                else
                    echo -e "${YELLOW}No route rules defined${NC}"
                fi
            else
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$resource_ocid${NC}"
                echo ""
                echo -e "${RED}Failed to fetch route table details${NC}"
            fi
            ;;
            
        SECURITY_LIST)
            echo -e "${BOLD}${MAGENTA}=== Security List Details ===${NC}"
            
            local sl_json
            sl_json=$(oci network security-list get --security-list-id "$resource_ocid" --output json 2>/dev/null)
            
            if [[ -n "$sl_json" ]]; then
                local sl_name
                sl_name=$(echo "$sl_json" | jq -r '.data["display-name"] // "N/A"')
                echo -e "${WHITE}Name:${NC} ${MAGENTA}$sl_name${NC}"
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$resource_ocid${NC}"
                echo ""
                
                local ingress_count egress_count
                ingress_count=$(echo "$sl_json" | jq '(.data["ingress-security-rules"] // []) | length')
                egress_count=$(echo "$sl_json" | jq '(.data["egress-security-rules"] // []) | length')
                local total_count=$((ingress_count + egress_count))
                echo -e "Found ${GREEN}$total_count${NC} security rule(s)"
                echo ""
                
                # Display ingress rules
                if [[ "$ingress_count" -gt 0 ]]; then
                    echo -e "${BOLD}${GREEN}▼▼▼ INGRESS RULES (${ingress_count}) ▼▼▼${NC}"
                    echo ""
                    printf "${BOLD}%-6s | %-8s | %-22s | %-9s | %-9s | %s${NC}\n" \
                        "Rule #" "Protocol" "Source" "Src Ports" "Dst Ports" "Description"
                    printf "${WHITE}%-6s-+-%-8s-+-%-22s-+-%-9s-+-%-9s-+-%s${NC}\n" \
                        "------" "--------" "----------------------" "---------" "---------" "-------------------------------------------------------------"
                    
                    local rule_num=0
                    echo "$sl_json" | jq -r '
                        (.data["ingress-security-rules"] // [])[] |
                        [
                            (if .protocol == "6" then "TCP"
                             elif .protocol == "17" then "UDP"
                             elif .protocol == "1" then "ICMP"
                             elif .protocol == "all" then "ALL"
                             else .protocol end),
                            (.source // "N/A"),
                            (if .["tcp-options"]["source-port-range"] then
                                "\(.["tcp-options"]["source-port-range"]["min"])-\(.["tcp-options"]["source-port-range"]["max"])"
                             elif .["udp-options"]["source-port-range"] then
                                "\(.["udp-options"]["source-port-range"]["min"])-\(.["udp-options"]["source-port-range"]["max"])"
                             else "ALL" end),
                            (if .["tcp-options"]["destination-port-range"] then
                                (if .["tcp-options"]["destination-port-range"]["min"] == .["tcp-options"]["destination-port-range"]["max"] then
                                    "\(.["tcp-options"]["destination-port-range"]["min"])"
                                else
                                    "\(.["tcp-options"]["destination-port-range"]["min"])-\(.["tcp-options"]["destination-port-range"]["max"])"
                                end)
                             elif .["udp-options"]["destination-port-range"] then
                                (if .["udp-options"]["destination-port-range"]["min"] == .["udp-options"]["destination-port-range"]["max"] then
                                    "\(.["udp-options"]["destination-port-range"]["min"])"
                                else
                                    "\(.["udp-options"]["destination-port-range"]["min"])-\(.["udp-options"]["destination-port-range"]["max"])"
                                end)
                             elif .["icmp-options"] then "ALL"
                             else "ALL" end),
                            (.description // "-")
                        ] | @tsv
                    ' 2>/dev/null | while IFS=$'\t' read -r proto source src_ports dst_ports desc; do
                        ((rule_num++))
                        printf "${YELLOW}%-6s${NC} | ${WHITE}%-8s${NC} | ${GREEN}%-22s${NC} | %-9s | %-9s | ${WHITE}%s${NC}\n" \
                            "$rule_num" "$proto" "${source:0:22}" "$src_ports" "$dst_ports" "$desc"
                    done
                    echo ""
                fi
                
                # Display egress rules
                if [[ "$egress_count" -gt 0 ]]; then
                    echo -e "${BOLD}${RED}▲▲▲ EGRESS RULES (${egress_count}) ▲▲▲${NC}"
                    echo ""
                    printf "${BOLD}%-6s | %-8s | %-22s | %-9s | %-9s | %s${NC}\n" \
                        "Rule #" "Protocol" "Destination" "Src Ports" "Dst Ports" "Description"
                    printf "${WHITE}%-6s-+-%-8s-+-%-22s-+-%-9s-+-%-9s-+-%s${NC}\n" \
                        "------" "--------" "----------------------" "---------" "---------" "-------------------------------------------------------------"
                    
                    local rule_num=0
                    echo "$sl_json" | jq -r '
                        (.data["egress-security-rules"] // [])[] |
                        [
                            (if .protocol == "6" then "TCP"
                             elif .protocol == "17" then "UDP"
                             elif .protocol == "1" then "ICMP"
                             elif .protocol == "all" then "ALL"
                             else .protocol end),
                            (.destination // "N/A"),
                            (if .["tcp-options"]["source-port-range"] then
                                "\(.["tcp-options"]["source-port-range"]["min"])-\(.["tcp-options"]["source-port-range"]["max"])"
                             elif .["udp-options"]["source-port-range"] then
                                "\(.["udp-options"]["source-port-range"]["min"])-\(.["udp-options"]["source-port-range"]["max"])"
                             else "ALL" end),
                            (if .["tcp-options"]["destination-port-range"] then
                                (if .["tcp-options"]["destination-port-range"]["min"] == .["tcp-options"]["destination-port-range"]["max"] then
                                    "\(.["tcp-options"]["destination-port-range"]["min"])"
                                else
                                    "\(.["tcp-options"]["destination-port-range"]["min"])-\(.["tcp-options"]["destination-port-range"]["max"])"
                                end)
                             elif .["udp-options"]["destination-port-range"] then
                                (if .["udp-options"]["destination-port-range"]["min"] == .["udp-options"]["destination-port-range"]["max"] then
                                    "\(.["udp-options"]["destination-port-range"]["min"])"
                                else
                                    "\(.["udp-options"]["destination-port-range"]["min"])-\(.["udp-options"]["destination-port-range"]["max"])"
                                end)
                             elif .["icmp-options"] then "ALL"
                             else "ALL" end),
                            (.description // "-")
                        ] | @tsv
                    ' 2>/dev/null | while IFS=$'\t' read -r proto dest src_ports dst_ports desc; do
                        ((rule_num++))
                        printf "${YELLOW}%-6s${NC} | ${WHITE}%-8s${NC} | ${GREEN}%-22s${NC} | %-9s | %-9s | ${WHITE}%s${NC}\n" \
                            "$rule_num" "$proto" "${dest:0:22}" "$src_ports" "$dst_ports" "$desc"
                    done
                fi
            else
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$resource_ocid${NC}"
                echo ""
                echo -e "${RED}Failed to fetch security list details${NC}"
            fi
            ;;
            
        GATEWAY)
            local gw_type="$resource_ocid"
            local gw_ocid="$extra_info"
            
            echo -e "${BOLD}${ORANGE}=== Gateway Details ($gw_type) ===${NC}"
            
            case "$gw_type" in
                IGW)
                    local igw_json
                    igw_json=$(oci network internet-gateway get --ig-id "$gw_ocid" --output json 2>/dev/null)
                    if [[ -n "$igw_json" ]]; then
                        local gw_name gw_state gw_enabled gw_vcn_id gw_created
                        gw_name=$(echo "$igw_json" | jq -r '.data["display-name"] // "N/A"')
                        gw_state=$(echo "$igw_json" | jq -r '.data["lifecycle-state"] // "N/A"')
                        gw_enabled=$(echo "$igw_json" | jq -r '.data["is-enabled"] // false')
                        gw_vcn_id=$(echo "$igw_json" | jq -r '.data["vcn-id"] // "N/A"')
                        gw_created=$(echo "$igw_json" | jq -r '.data["time-created"] // "N/A"')
                        
                        # Resolve VCN name
                        local vcn_name="N/A"
                        if [[ "$gw_vcn_id" != "N/A" && -n "$gw_vcn_id" ]]; then
                            vcn_name=$(oci network vcn get --vcn-id "$gw_vcn_id" --query 'data."display-name"' --raw-output 2>/dev/null) || vcn_name="N/A"
                        fi
                        
                        echo -e "${WHITE}Name:${NC} ${ORANGE}$gw_name${NC}"
                        echo -e "${WHITE}OCID:${NC} ${YELLOW}$gw_ocid${NC}"
                        echo ""
                        echo "State:                 $gw_state"
                        echo "Is Enabled:            $gw_enabled"
                        echo -e "VCN:                   ${GREEN}$vcn_name${NC} ${YELLOW}($gw_vcn_id)${NC}"
                        echo "Time Created:          $gw_created"
                    else
                        echo -e "${WHITE}OCID:${NC} ${YELLOW}$gw_ocid${NC}"
                        echo ""
                        echo -e "${RED}Failed to fetch Internet Gateway details${NC}"
                    fi
                    ;;
                NAT)
                    local nat_json
                    nat_json=$(oci network nat-gateway get --nat-gateway-id "$gw_ocid" --output json 2>/dev/null)
                    if [[ -n "$nat_json" ]]; then
                        local gw_name gw_state gw_block gw_ip gw_vcn_id gw_created
                        gw_name=$(echo "$nat_json" | jq -r '.data["display-name"] // "N/A"')
                        gw_state=$(echo "$nat_json" | jq -r '.data["lifecycle-state"] // "N/A"')
                        gw_block=$(echo "$nat_json" | jq -r '.data["block-traffic"] // false')
                        gw_ip=$(echo "$nat_json" | jq -r '.data["nat-ip"] // "N/A"')
                        gw_vcn_id=$(echo "$nat_json" | jq -r '.data["vcn-id"] // "N/A"')
                        gw_created=$(echo "$nat_json" | jq -r '.data["time-created"] // "N/A"')
                        
                        # Resolve VCN name
                        local vcn_name="N/A"
                        if [[ "$gw_vcn_id" != "N/A" && -n "$gw_vcn_id" ]]; then
                            vcn_name=$(oci network vcn get --vcn-id "$gw_vcn_id" --query 'data."display-name"' --raw-output 2>/dev/null) || vcn_name="N/A"
                        fi
                        
                        echo -e "${WHITE}Name:${NC} ${ORANGE}$gw_name${NC}"
                        echo -e "${WHITE}OCID:${NC} ${YELLOW}$gw_ocid${NC}"
                        echo ""
                        echo "State:                 $gw_state"
                        echo "Block Traffic:         $gw_block"
                        echo "Public IP:             $gw_ip"
                        echo -e "VCN:                   ${GREEN}$vcn_name${NC} ${YELLOW}($gw_vcn_id)${NC}"
                        echo "Time Created:          $gw_created"
                    else
                        echo -e "${WHITE}OCID:${NC} ${YELLOW}$gw_ocid${NC}"
                        echo ""
                        echo -e "${RED}Failed to fetch NAT Gateway details${NC}"
                    fi
                    ;;
                SGW)
                    local sgw_json
                    sgw_json=$(oci network service-gateway get --service-gateway-id "$gw_ocid" --output json 2>/dev/null)
                    if [[ -n "$sgw_json" ]]; then
                        local gw_name gw_state gw_block gw_vcn_id gw_services gw_created
                        gw_name=$(echo "$sgw_json" | jq -r '.data["display-name"] // "N/A"')
                        gw_state=$(echo "$sgw_json" | jq -r '.data["lifecycle-state"] // "N/A"')
                        gw_block=$(echo "$sgw_json" | jq -r '.data["block-traffic"] // false')
                        gw_vcn_id=$(echo "$sgw_json" | jq -r '.data["vcn-id"] // "N/A"')
                        gw_services=$(echo "$sgw_json" | jq -r '(.data.services // []) | map(.["service-name"] // "unknown") | if length > 0 then join(", ") else "None" end')
                        gw_created=$(echo "$sgw_json" | jq -r '.data["time-created"] // "N/A"')
                        
                        # Resolve VCN name
                        local vcn_name="N/A"
                        if [[ "$gw_vcn_id" != "N/A" && -n "$gw_vcn_id" ]]; then
                            vcn_name=$(oci network vcn get --vcn-id "$gw_vcn_id" --query 'data."display-name"' --raw-output 2>/dev/null) || vcn_name="N/A"
                        fi
                        
                        echo -e "${WHITE}Name:${NC} ${ORANGE}$gw_name${NC}"
                        echo -e "${WHITE}OCID:${NC} ${YELLOW}$gw_ocid${NC}"
                        echo ""
                        echo "State:                 $gw_state"
                        echo "Block Traffic:         $gw_block"
                        echo -e "VCN:                   ${GREEN}$vcn_name${NC} ${YELLOW}($gw_vcn_id)${NC}"
                        echo "Services:              $gw_services"
                        echo "Time Created:          $gw_created"
                    else
                        echo -e "${WHITE}OCID:${NC} ${YELLOW}$gw_ocid${NC}"
                        echo ""
                        echo -e "${RED}Failed to fetch Service Gateway details${NC}"
                    fi
                    ;;
                DRG)
                    local _drg_region="${EFFECTIVE_REGION:-$REGION}"
                    # Check if this is a DRG OCID or a DRG Attachment OCID
                    if [[ "$gw_ocid" == ocid1.drg.* ]]; then
                        # This is a DRG OCID - get DRG details directly
                        local drg_json
                        drg_json=$(oci network drg get --drg-id "$gw_ocid" --region "$_drg_region" --output json 2>/dev/null)
                        if [[ -n "$drg_json" ]]; then
                            local gw_name gw_state gw_created gw_compartment
                            gw_name=$(echo "$drg_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                            gw_state=$(echo "$drg_json" | jq -r '.data["lifecycle-state"] // "N/A"' 2>/dev/null)
                            gw_created=$(echo "$drg_json" | jq -r '.data["time-created"] // "N/A"' 2>/dev/null)
                            gw_compartment=$(echo "$drg_json" | jq -r '.data["compartment-id"] // "N/A"' 2>/dev/null)
                            
                            local gw_state_color="$GREEN"
                            [[ "$gw_state" != "AVAILABLE" ]] && gw_state_color="$YELLOW"
                            
                            echo -e "${ORANGE}$gw_name${NC}  ${gw_state_color}$gw_state${NC}  ${YELLOW}($gw_ocid)${NC}"
                            local gw_comp_name; gw_comp_name=$(resolve_compartment_name "$gw_compartment")
                            echo -e "    ${CYAN}Compartment:${NC}  ${WHITE}$gw_comp_name${NC} ${GRAY}($gw_compartment)${NC}"
                            echo -e "    ${CYAN}Time Created:${NC} ${WHITE}${gw_created:0:19}${NC}"
                            
                            # ── Collect attachments for name lookup & display ──
                            echo ""
                            echo -e "  ${BOLD}${CYAN}─── DRG Attachments ───${NC}"
                            local _att_comps_drg=("${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}")
                            [[ -n "$NETWORK_COMPARTMENT_ID" && "$NETWORK_COMPARTMENT_ID" != "${_att_comps_drg[0]}" ]] && _att_comps_drg+=("$NETWORK_COMPARTMENT_ID")
                            [[ -n "$gw_compartment" && "$gw_compartment" != "N/A" ]] && {
                                local _dup=0; for _cc in "${_att_comps_drg[@]}"; do [[ "$_cc" == "$gw_compartment" ]] && _dup=1; done
                                [[ $_dup -eq 0 ]] && _att_comps_drg+=("$gw_compartment")
                            }
                            
                            local all_drg_atts="[]"
                            for _ac in "${_att_comps_drg[@]}"; do
                                local _att_res
                                _att_res=$(oci network drg-attachment list --compartment-id "$_ac" --region "$_drg_region" --all --output json 2>/dev/null) || continue
                                if echo "$_att_res" | jq -e '.data[0]' >/dev/null 2>&1; then
                                    local _filt
                                    _filt=$(echo "$_att_res" | jq --arg drg "$gw_ocid" '[.data[] | select(.["drg-id"] == $drg)]' 2>/dev/null)
                                    [[ -n "$_filt" && "$_filt" != "[]" ]] && all_drg_atts=$(jq -n --argjson a "$all_drg_atts" --argjson b "$_filt" '$a + $b | unique_by(.id)' 2>/dev/null)
                                fi
                            done
                            
                            # Fallback: try --drg-id directly
                            local att_count
                            att_count=$(echo "$all_drg_atts" | jq 'length' 2>/dev/null || echo "0")
                            if [[ "$att_count" -eq 0 ]]; then
                                local _drg_att_fb
                                _drg_att_fb=$(oci network drg-attachment list --drg-id "$gw_ocid" --region "$_drg_region" --all --output json 2>/dev/null)
                                if [[ -n "$_drg_att_fb" ]] && echo "$_drg_att_fb" | jq -e '.data[0]' >/dev/null 2>&1; then
                                    all_drg_atts=$(echo "$_drg_att_fb" | jq '.data // []' 2>/dev/null)
                                    att_count=$(echo "$all_drg_atts" | jq 'length' 2>/dev/null || echo "0")
                                fi
                            fi
                            
                            # Build attachment name/type lookup for next-hop resolution
                            declare -A _DRG_ATT_NAMES _DRG_ATT_TYPES
                            if [[ "$att_count" -gt 0 ]]; then
                                while IFS='|' read -r _ai _an _at; do
                                    [[ -z "$_ai" ]] && continue
                                    _DRG_ATT_NAMES[$_ai]="$_an"
                                    _DRG_ATT_TYPES[$_ai]="$_at"
                                done < <(echo "$all_drg_atts" | jq -r '.[] | "\(.id)|\(.["display-name"] // "N/A")|\(.["network-details"]["type"] // "VCN")"' 2>/dev/null)
                            fi
                            
                            if [[ "$att_count" -gt 0 ]]; then
                                echo -e "    ${WHITE}Found $att_count attachment(s)${NC}"
                                echo ""
                                while IFS='|' read -r _da_name _da_type _da_state _da_net_id _da_id _da_comp; do
                                    [[ -z "$_da_name" ]] && continue
                                    local _da_sc="$GREEN"
                                    [[ "$_da_state" != "ATTACHED" ]] && _da_sc="$YELLOW"
                                    [[ "$_da_state" == "DETACHING" || "$_da_state" == "DETACHED" ]] && _da_sc="$RED"
                                    echo -e "    ${CYAN}$_da_name${NC}  ${_da_sc}$_da_state${NC}  ${WHITE}$_da_type${NC}  ${YELLOW}($_da_id)${NC}"
                                    # VCN details
                                    if [[ "$_da_type" == "VCN" && -n "$_da_net_id" && "$_da_net_id" != "null" ]]; then
                                        local _dv_json
                                        _dv_json=$(oci network vcn get --vcn-id "$_da_net_id" --region "$_drg_region" --output json 2>/dev/null)
                                        local _dv_name _dv_cidr
                                        _dv_name=$(echo "$_dv_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                                        _dv_cidr=$(echo "$_dv_json" | jq -r '.data["cidr-block"] // "N/A"' 2>/dev/null)
                                        echo -e "      ${CYAN}VCN:${NC} ${GREEN}$_dv_name${NC}  ${WHITE}$_dv_cidr${NC}  ${YELLOW}($_da_net_id)${NC}"
                                    fi
                                    if [[ -n "$_da_comp" && "$_da_comp" != "null" ]]; then
                                        local _da_cn; _da_cn=$(resolve_compartment_name "$_da_comp")
                                        echo -e "      ${CYAN}Compartment:${NC} ${WHITE}$_da_cn${NC} ${GRAY}($_da_comp)${NC}"
                                    fi
                                done < <(echo "$all_drg_atts" | jq -r 'sort_by(if .["network-details"]["type"] == "VCN" then 0 elif .["network-details"]["type"] == "REMOTE_PEERING_CONNECTION" then 1 elif .["network-details"]["type"] == "IPSEC_TUNNEL" then 2 elif .["network-details"]["type"] == "VIRTUAL_CIRCUIT" then 3 else 4 end) | .[] | "\(.["display-name"])|\(.["network-details"]["type"] // "UNKNOWN")|\(.["lifecycle-state"])|\(.["network-details"]["id"] // "null")|\(.id)|\(.["compartment-id"])"' 2>/dev/null)
                            else
                                echo -e "    ${GRAY}No attachments found (searched ${#_att_comps_drg[@]} compartments)${NC}"
                            fi
                            
                            # ── DRG Route Tables & Route Rules ──
                            echo ""
                            echo -e "  ${BOLD}${CYAN}─── DRG Route Tables & Route Rules ───${NC}"
                            local _drt_json
                            _drt_json=$(oci network drg-route-table list --drg-id "$gw_ocid" --region "$_drg_region" --all --output json 2>/dev/null)
                            local _drt_count=0
                            if [[ -n "$_drt_json" && "$_drt_json" != "null" ]]; then
                                _drt_count=$(echo "$_drt_json" | jq '.data | length // 0' 2>/dev/null || echo "0")
                                [[ -z "$_drt_count" || "$_drt_count" == "null" ]] && _drt_count=0
                            fi
                            
                            if [[ "$_drt_count" -gt 0 ]]; then
                                while IFS='|' read -r _dt_name _dt_state _dt_imp_id _dt_ecmp _dt_id; do
                                    [[ -z "$_dt_name" ]] && continue
                                    
                                    local _dt_sc="$GREEN"; [[ "$_dt_state" != "AVAILABLE" ]] && _dt_sc="$YELLOW"
                                    echo -e "    ${MAGENTA}$_dt_name${NC}  ${_dt_sc}$_dt_state${NC}  ${CYAN}ECMP:${NC}${WHITE}$_dt_ecmp${NC}  ${YELLOW}($_dt_id)${NC}"
                                    
                                    # Route rules
                                    local _dt_rules_j
                                    _dt_rules_j=$(oci network drg-route-rule list --drg-route-table-id "$_dt_id" --region "$_drg_region" --output json 2>/dev/null)
                                    local _dt_rules_d=""
                                    if [[ -n "$_dt_rules_j" ]]; then
                                        _dt_rules_d=$(echo "$_dt_rules_j" | jq '.data // .items // []' 2>/dev/null)
                                    fi
                                    [[ -z "$_dt_rules_d" || "$_dt_rules_d" == "null" ]] && _dt_rules_d="[]"
                                    local _dt_rc
                                    _dt_rc=$(echo "$_dt_rules_d" | jq 'length' 2>/dev/null || echo "0")
                                    [[ -z "$_dt_rc" || "$_dt_rc" == "null" ]] && _dt_rc=0
                                    
                                    echo -e "      └─ ${BOLD}${CYAN}Route Rules (${_dt_rc}):${NC}"
                                    if [[ "$_dt_rc" -gt 0 ]]; then
                                        printf "         ${BOLD}%-22s %-14s %-10s %-16s %s${NC}\n" "Destination" "Dest Type" "Type" "Origin" "Next Hop"
                                        printf "         %s\n" "$(printf '%*s' 120 '' | tr ' ' '─')"
                                        while IFS='|' read -r _dr_d _dr_dt _dr_t _dr_o _dr_nh _dr_cf _dr_bh; do
                                            [[ -z "$_dr_d" ]] && continue
                                            local _dr_c="$WHITE"; [[ "$_dr_t" == "STATIC" ]] && _dr_c="$YELLOW"; [[ "$_dr_t" == "DYNAMIC" ]] && _dr_c="$GREEN"
                                            local _dr_flags=""
                                            [[ "$_dr_cf" == "true" ]] && _dr_flags=" ${RED}⚠CONFLICT${NC}"
                                            [[ "$_dr_bh" == "true" ]] && _dr_flags=" ${RED}⬛BLACKHOLE${NC}"
                                            # Resolve next-hop name from lookup or API
                                            local _dr_hop=""
                                            if [[ -n "$_dr_nh" && "$_dr_nh" != "N/A" && "$_dr_nh" != "null" ]]; then
                                                local _nh_n="${_DRG_ATT_NAMES[$_dr_nh]:-}"
                                                if [[ -z "$_nh_n" ]]; then
                                                    _nh_n=$(oci network drg-attachment get --drg-attachment-id "$_dr_nh" --region "$_drg_region" \
                                                        --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                                                    [[ -n "$_nh_n" ]] && _DRG_ATT_NAMES[$_dr_nh]="$_nh_n"
                                                fi
                                                if [[ -n "$_nh_n" ]]; then
                                                    _dr_hop="${CYAN}${_nh_n}${NC} ${YELLOW}(${_dr_nh})${NC}"
                                                else
                                                    _dr_hop="${YELLOW}(${_dr_nh})${NC}"
                                                fi
                                            fi
                                            printf "         ${WHITE}%-22s${NC} %-14s ${_dr_c}%-10s${NC} %-16s %b%b\n" \
                                                "${_dr_d:0:22}" "${_dr_dt:0:14}" "${_dr_t:0:10}" "${_dr_o:0:16}" "$_dr_hop" "$_dr_flags"
                                        done < <(echo "$_dt_rules_d" | jq -r '.[] | "\(.destination // "N/A")|\(.["destination-type"] // "N/A")|\(.["route-type"] // "N/A")|\(.["route-provenance"] // "N/A")|\(.["next-hop-drg-attachment-id"] // "N/A")|\(.["is-conflict"] // false)|\(.["is-blackhole"] // false)"' 2>/dev/null)
                                    else
                                        echo -e "         ${GRAY}(No route rules)${NC}"
                                    fi
                                    echo ""
                                done < <(echo "$_drt_json" | jq -r '.data[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["import-drg-route-distribution-id"] // "null")|\(.["is-ecmp-enabled"])|\(.id)"' 2>/dev/null)
                            else
                                echo -e "    ${GRAY}No DRG route tables found${NC}"
                                echo ""
                            fi
                            
                            # ── Import & Export Route Distributions ──
                            local _dist_json
                            _dist_json=$(oci network drg-route-distribution list --drg-id "$gw_ocid" --region "$_drg_region" --all --output json 2>/dev/null)
                            local _dist_count=0
                            if [[ -n "$_dist_json" && "$_dist_json" != "null" ]]; then
                                _dist_count=$(echo "$_dist_json" | jq '.data | length // 0' 2>/dev/null || echo "0")
                                [[ -z "$_dist_count" || "$_dist_count" == "null" ]] && _dist_count=0
                            fi
                            
                            if [[ "$_dist_count" -gt 0 ]]; then
                                # ── Import Route Distributions ──
                                echo -e "  ${BOLD}${CYAN}─── Import Route Distributions ───${NC}"
                                local _imp_found=0
                                while IFS='|' read -r _dd_name _dd_state _dd_type _dd_id; do
                                    [[ -z "$_dd_name" ]] && continue
                                    [[ "$_dd_type" != "IMPORT" ]] && continue
                                    _imp_found=1
                                    
                                    local _dd_sc="$GREEN"; [[ "$_dd_state" != "AVAILABLE" ]] && _dd_sc="$YELLOW"
                                    echo -e "    ${GREEN}$_dd_name${NC}  ${_dd_sc}$_dd_state${NC}  ${GRAY}[IMPORT]${NC}  ${YELLOW}($_dd_id)${NC}"
                                    
                                    # Statements
                                    local _ds_json
                                    _ds_json=$(oci network drg-route-distribution-statement list --route-distribution-id "$_dd_id" \
                                        --region "$_drg_region" --all --output json 2>/dev/null)
                                    local _ds_data=""
                                    if [[ -n "$_ds_json" ]]; then
                                        _ds_data=$(echo "$_ds_json" | jq '.data // .items // []' 2>/dev/null)
                                    fi
                                    [[ -z "$_ds_data" || "$_ds_data" == "null" ]] && _ds_data="[]"
                                    local _ds_cnt
                                    _ds_cnt=$(echo "$_ds_data" | jq 'length' 2>/dev/null || echo "0")
                                    [[ -z "$_ds_cnt" || "$_ds_cnt" == "null" ]] && _ds_cnt=0
                                    
                                    echo -e "      └─ ${BOLD}${CYAN}Statements (${_ds_cnt}):${NC}"
                                    if [[ "$_ds_cnt" -gt 0 ]]; then
                                        printf "         ${BOLD}%-10s %-8s %-24s %-40s %s${NC}\n" "Action" "Priority" "Match Type" "Match Criteria" "DRG Attachment"
                                        printf "         %s\n" "$(printf '%*s' 120 '' | tr ' ' '─')"
                                        while IFS= read -r _st_line; do
                                            [[ -z "$_st_line" ]] && continue
                                            local _st_act _st_pri _st_mc
                                            _st_act=$(echo "$_st_line" | jq -r '.action // "N/A"' 2>/dev/null)
                                            _st_pri=$(echo "$_st_line" | jq -r '.priority // "N/A"' 2>/dev/null)
                                            _st_mc=$(echo "$_st_line" | jq -r '.["match-criteria"]' 2>/dev/null)
                                            local _st_mc_len
                                            _st_mc_len=$(echo "$_st_mc" | jq 'length' 2>/dev/null || echo "0")
                                            
                                            if [[ "$_st_mc_len" -eq 0 || "$_st_mc" == "[]" || "$_st_mc" == "null" ]]; then
                                                printf "         ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %s\n" \
                                                    "$_st_act" "$_st_pri" "MATCH_ALL" "(all attachments)" ""
                                            else
                                                local _mi=0
                                                while [[ $_mi -lt $_st_mc_len ]]; do
                                                    local _mmt _mat _mdai
                                                    _mmt=$(echo "$_st_mc" | jq -r ".[$_mi][\"match-type\"] // \"N/A\"" 2>/dev/null)
                                                    _mat=$(echo "$_st_mc" | jq -r ".[$_mi][\"attachment-type\"] // \"null\"" 2>/dev/null)
                                                    _mdai=$(echo "$_st_mc" | jq -r ".[$_mi][\"drg-attachment-id\"] // \"null\"" 2>/dev/null)
                                                    
                                                    local _mcrit="" _matt=""
                                                    if [[ "$_mmt" == "DRG_ATTACHMENT_TYPE" && "$_mat" != "null" ]]; then
                                                        _mcrit="attachment-type=$_mat"
                                                    elif [[ "$_mmt" == "DRG_ATTACHMENT_ID" && "$_mdai" != "null" ]]; then
                                                        _mcrit="drg-attachment-id"
                                                    elif [[ "$_mmt" == "MATCH_ALL" ]]; then
                                                        _mcrit="(all attachments)"
                                                    else
                                                        _mcrit="$_mmt"
                                                    fi
                                                    
                                                    if [[ -n "$_mdai" && "$_mdai" != "null" ]]; then
                                                        local _man="${_DRG_ATT_NAMES[$_mdai]:-}"
                                                        if [[ -z "$_man" ]]; then
                                                            _man=$(oci network drg-attachment get --drg-attachment-id "$_mdai" --region "$_drg_region" \
                                                                --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                                                            [[ -n "$_man" ]] && _DRG_ATT_NAMES[$_mdai]="$_man"
                                                        fi
                                                        if [[ -n "$_man" ]]; then
                                                            _matt="${CYAN}${_man}${NC} ${YELLOW}(${_mdai})${NC}"
                                                        else
                                                            _matt="${YELLOW}(${_mdai})${NC}"
                                                        fi
                                                    fi
                                                    
                                                    if [[ $_mi -eq 0 ]]; then
                                                        printf "         ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %b\n" \
                                                            "$_st_act" "$_st_pri" "$_mmt" "$_mcrit" "$_matt"
                                                    else
                                                        printf "         %-10s %-8s %-24s %-40s %b\n" \
                                                            "" "" "$_mmt" "$_mcrit" "$_matt"
                                                    fi
                                                    ((_mi++))
                                                done
                                            fi
                                        done < <(echo "$_ds_data" | jq -c '.[]' 2>/dev/null)
                                    else
                                        echo -e "         ${GRAY}(No statements)${NC}"
                                    fi
                                    echo ""
                                done < <(echo "$_dist_json" | jq -r '.data[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["distribution-type"])|\(.id)"' 2>/dev/null)
                                [[ $_imp_found -eq 0 ]] && echo -e "    ${GRAY}(No import route distributions)${NC}" && echo ""
                                
                                # ── Export Route Distributions ──
                                echo -e "  ${BOLD}${CYAN}─── Export Route Distributions ───${NC}"
                                local _exp_found=0
                                while IFS='|' read -r _ed_name _ed_state _ed_type _ed_id; do
                                    [[ -z "$_ed_name" ]] && continue
                                    [[ "$_ed_type" != "EXPORT" ]] && continue
                                    _exp_found=1
                                    
                                    local _ed_sc="$GREEN"; [[ "$_ed_state" != "AVAILABLE" ]] && _ed_sc="$YELLOW"
                                    echo -e "    ${GREEN}$_ed_name${NC}  ${_ed_sc}$_ed_state${NC}  ${GRAY}[EXPORT]${NC}  ${YELLOW}($_ed_id)${NC}"
                                    
                                    # Statements
                                    local _es_json
                                    _es_json=$(oci network drg-route-distribution-statement list --route-distribution-id "$_ed_id" \
                                        --region "$_drg_region" --all --output json 2>/dev/null)
                                    local _es_data=""
                                    if [[ -n "$_es_json" ]]; then
                                        _es_data=$(echo "$_es_json" | jq '.data // .items // []' 2>/dev/null)
                                    fi
                                    [[ -z "$_es_data" || "$_es_data" == "null" ]] && _es_data="[]"
                                    local _es_cnt
                                    _es_cnt=$(echo "$_es_data" | jq 'length' 2>/dev/null || echo "0")
                                    [[ -z "$_es_cnt" || "$_es_cnt" == "null" ]] && _es_cnt=0
                                    
                                    echo -e "      └─ ${BOLD}${CYAN}Statements (${_es_cnt}):${NC}"
                                    if [[ "$_es_cnt" -gt 0 ]]; then
                                        printf "         ${BOLD}%-10s %-8s %-24s %-40s %s${NC}\n" "Action" "Priority" "Match Type" "Match Criteria" "DRG Attachment"
                                        printf "         %s\n" "$(printf '%*s' 120 '' | tr ' ' '─')"
                                        while IFS= read -r _est_line; do
                                            [[ -z "$_est_line" ]] && continue
                                            local _est_act _est_pri _est_mc
                                            _est_act=$(echo "$_est_line" | jq -r '.action // "N/A"' 2>/dev/null)
                                            _est_pri=$(echo "$_est_line" | jq -r '.priority // "N/A"' 2>/dev/null)
                                            _est_mc=$(echo "$_est_line" | jq -r '.["match-criteria"]' 2>/dev/null)
                                            local _est_mc_len
                                            _est_mc_len=$(echo "$_est_mc" | jq 'length' 2>/dev/null || echo "0")
                                            
                                            if [[ "$_est_mc_len" -eq 0 || "$_est_mc" == "[]" || "$_est_mc" == "null" ]]; then
                                                printf "         ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %s\n" \
                                                    "$_est_act" "$_est_pri" "MATCH_ALL" "(all attachments)" ""
                                            else
                                                local _emi=0
                                                while [[ $_emi -lt $_est_mc_len ]]; do
                                                    local _emmt _emat _emdai
                                                    _emmt=$(echo "$_est_mc" | jq -r ".[$_emi][\"match-type\"] // \"N/A\"" 2>/dev/null)
                                                    _emat=$(echo "$_est_mc" | jq -r ".[$_emi][\"attachment-type\"] // \"null\"" 2>/dev/null)
                                                    _emdai=$(echo "$_est_mc" | jq -r ".[$_emi][\"drg-attachment-id\"] // \"null\"" 2>/dev/null)
                                                    
                                                    local _emcrit="" _ematt=""
                                                    if [[ "$_emmt" == "DRG_ATTACHMENT_TYPE" && "$_emat" != "null" ]]; then
                                                        _emcrit="attachment-type=$_emat"
                                                    elif [[ "$_emmt" == "DRG_ATTACHMENT_ID" && "$_emdai" != "null" ]]; then
                                                        _emcrit="drg-attachment-id"
                                                    elif [[ "$_emmt" == "MATCH_ALL" ]]; then
                                                        _emcrit="(all attachments)"
                                                    else
                                                        _emcrit="$_emmt"
                                                    fi
                                                    
                                                    if [[ -n "$_emdai" && "$_emdai" != "null" ]]; then
                                                        local _eman="${_DRG_ATT_NAMES[$_emdai]:-}"
                                                        if [[ -z "$_eman" ]]; then
                                                            _eman=$(oci network drg-attachment get --drg-attachment-id "$_emdai" --region "$_drg_region" \
                                                                --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                                                            [[ -n "$_eman" ]] && _DRG_ATT_NAMES[$_emdai]="$_eman"
                                                        fi
                                                        if [[ -n "$_eman" ]]; then
                                                            _ematt="${CYAN}${_eman}${NC} ${YELLOW}(${_emdai})${NC}"
                                                        else
                                                            _ematt="${YELLOW}(${_emdai})${NC}"
                                                        fi
                                                    fi
                                                    
                                                    if [[ $_emi -eq 0 ]]; then
                                                        printf "         ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %b\n" \
                                                            "$_est_act" "$_est_pri" "$_emmt" "$_emcrit" "$_ematt"
                                                    else
                                                        printf "         %-10s %-8s %-24s %-40s %b\n" \
                                                            "" "" "$_emmt" "$_emcrit" "$_ematt"
                                                    fi
                                                    ((_emi++))
                                                done
                                            fi
                                        done < <(echo "$_es_data" | jq -c '.[]' 2>/dev/null)
                                    else
                                        echo -e "         ${GRAY}(No statements)${NC}"
                                    fi
                                    echo ""
                                done < <(echo "$_dist_json" | jq -r '.data[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["distribution-type"])|\(.id)"' 2>/dev/null)
                                [[ $_exp_found -eq 0 ]] && echo -e "    ${GRAY}(No export route distributions)${NC}" && echo ""
                            else
                                echo ""
                                echo -e "  ${BOLD}${CYAN}─── Route Distributions ───${NC}"
                                echo -e "    ${GRAY}No route distributions found${NC}"
                                echo ""
                            fi
                        else
                            echo -e "${WHITE}OCID:${NC} ${YELLOW}$gw_ocid${NC}"
                            echo ""
                            echo -e "${RED}Failed to fetch DRG details${NC}"
                        fi
                    else
                        # This is a DRG Attachment OCID
                        local drg_att_json
                        drg_att_json=$(oci network drg-attachment get --drg-attachment-id "$gw_ocid" --region "$_drg_region" --output json 2>/dev/null)
                        if [[ -n "$drg_att_json" ]]; then
                            local gw_name gw_state gw_drg_id gw_vcn_id gw_rt_id gw_created gw_att_type gw_att_comp
                            gw_name=$(echo "$drg_att_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                            gw_state=$(echo "$drg_att_json" | jq -r '.data["lifecycle-state"] // "N/A"' 2>/dev/null)
                            gw_drg_id=$(echo "$drg_att_json" | jq -r '.data["drg-id"] // "N/A"' 2>/dev/null)
                            gw_vcn_id=$(echo "$drg_att_json" | jq -r '.data["network-details"]["id"] // .data["vcn-id"] // "N/A"' 2>/dev/null)
                            gw_rt_id=$(echo "$drg_att_json" | jq -r '.data["drg-route-table-id"] // "N/A"' 2>/dev/null)
                            gw_created=$(echo "$drg_att_json" | jq -r '.data["time-created"] // "N/A"' 2>/dev/null)
                            gw_att_type=$(echo "$drg_att_json" | jq -r '.data["network-details"]["type"] // "N/A"' 2>/dev/null)
                            gw_att_comp=$(echo "$drg_att_json" | jq -r '.data["compartment-id"] // "N/A"' 2>/dev/null)
                            
                            # State color
                            local gw_sc="$GREEN"
                            [[ "$gw_state" != "ATTACHED" ]] && gw_sc="$YELLOW"
                            [[ "$gw_state" == "DETACHING" || "$gw_state" == "DETACHED" ]] && gw_sc="$RED"
                            
                            # Header: name, state, type, OCID
                            echo -e "${CYAN}$gw_name${NC}  ${gw_sc}$gw_state${NC}  ${WHITE}$gw_att_type${NC}  ${YELLOW}($gw_ocid)${NC}"
                            local _gw_comp_n; _gw_comp_n=$(resolve_compartment_name "$gw_att_comp")
                            echo -e "    ${CYAN}Compartment:${NC}  ${WHITE}$_gw_comp_n${NC} ${GRAY}($gw_att_comp)${NC}"
                            echo -e "    ${CYAN}Time Created:${NC} ${WHITE}${gw_created:0:19}${NC}"
                            
                            # Resolve DRG name + state
                            echo ""
                            echo -e "  ${BOLD}${WHITE}Linked DRG:${NC}"
                            if [[ "$gw_drg_id" != "N/A" && -n "$gw_drg_id" ]]; then
                                local _gd_json
                                _gd_json=$(oci network drg get --drg-id "$gw_drg_id" --region "$_drg_region" --output json 2>/dev/null)
                                if [[ -n "$_gd_json" ]]; then
                                    local _gd_name _gd_state _gd_comp
                                    _gd_name=$(echo "$_gd_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                                    _gd_state=$(echo "$_gd_json" | jq -r '.data["lifecycle-state"] // "N/A"' 2>/dev/null)
                                    _gd_comp=$(echo "$_gd_json" | jq -r '.data["compartment-id"] // "N/A"' 2>/dev/null)
                                    local _gd_sc="$GREEN"; [[ "$_gd_state" != "AVAILABLE" ]] && _gd_sc="$YELLOW"
                                    local _gd_cn; _gd_cn=$(resolve_compartment_name "$_gd_comp")
                                    echo -e "    ${ORANGE}$_gd_name${NC}  ${_gd_sc}$_gd_state${NC}  ${YELLOW}($gw_drg_id)${NC}"
                                    echo -e "    ${CYAN}Compartment:${NC} ${WHITE}$_gd_cn${NC} ${GRAY}($_gd_comp)${NC}"
                                else
                                    echo -e "    ${YELLOW}($gw_drg_id)${NC} ${RED}(could not fetch details)${NC}"
                                fi
                            else
                                echo -e "    ${GRAY}No DRG linked${NC}"
                            fi
                            
                            # VCN details
                            echo ""
                            echo -e "  ${BOLD}${WHITE}Attached VCN:${NC}"
                            if [[ "$gw_vcn_id" != "N/A" && -n "$gw_vcn_id" ]]; then
                                local _gv_json
                                _gv_json=$(oci network vcn get --vcn-id "$gw_vcn_id" --region "$_drg_region" --output json 2>/dev/null)
                                local _gv_name _gv_cidr
                                _gv_name=$(echo "$_gv_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                                _gv_cidr=$(echo "$_gv_json" | jq -r '.data["cidr-block"] // "N/A"' 2>/dev/null)
                                echo -e "    ${GREEN}$_gv_name${NC}  ${WHITE}$_gv_cidr${NC}  ${YELLOW}($gw_vcn_id)${NC}"
                            else
                                echo -e "    ${GRAY}No VCN attached${NC}"
                            fi
                            
                            # Build attachment name lookup (for next-hop resolution)
                            declare -A _GA_ATT_NAMES
                            if [[ "$gw_drg_id" != "N/A" && -n "$gw_drg_id" ]]; then
                                local _ga_att_list
                                _ga_att_list=$(oci network drg-attachment list --drg-id "$gw_drg_id" --region "$_drg_region" --all --output json 2>/dev/null)
                                if [[ -n "$_ga_att_list" ]] && echo "$_ga_att_list" | jq -e '.data[0]' >/dev/null 2>&1; then
                                    while IFS='|' read -r _gai _gan; do
                                        [[ -z "$_gai" ]] && continue
                                        _GA_ATT_NAMES[$_gai]="$_gan"
                                    done < <(echo "$_ga_att_list" | jq -r '.data[] | "\(.id)|\(.["display-name"] // "N/A")"' 2>/dev/null)
                                fi
                            fi
                            
                            # DRG Route Table + rules + distributions
                            if [[ "$gw_rt_id" != "N/A" && -n "$gw_rt_id" && "$gw_rt_id" != "null" ]]; then
                                echo ""
                                echo -e "  ${BOLD}${WHITE}DRG Route Table:${NC}"
                                local _grt_json
                                _grt_json=$(oci network drg-route-table get --drg-route-table-id "$gw_rt_id" --region "$_drg_region" --output json 2>/dev/null)
                                local _grt_name="N/A" _grt_ecmp="false" _grt_imp_id=""
                                if [[ -n "$_grt_json" ]]; then
                                    _grt_name=$(echo "$_grt_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                                    _grt_ecmp=$(echo "$_grt_json" | jq -r '.data["is-ecmp-enabled"] // false' 2>/dev/null)
                                    _grt_imp_id=$(echo "$_grt_json" | jq -r '.data["import-drg-route-distribution-id"] // ""' 2>/dev/null)
                                fi
                                echo -e "    ${MAGENTA}$_grt_name${NC}  ${CYAN}ECMP:${NC}${WHITE}$_grt_ecmp${NC}  ${YELLOW}($gw_rt_id)${NC}"
                                
                                # Route rules
                                local _grt_rules_j
                                _grt_rules_j=$(oci network drg-route-rule list --drg-route-table-id "$gw_rt_id" --region "$_drg_region" --output json 2>/dev/null)
                                local _grt_rules_d=""
                                if [[ -n "$_grt_rules_j" ]]; then
                                    _grt_rules_d=$(echo "$_grt_rules_j" | jq '.data // .items // []' 2>/dev/null)
                                fi
                                [[ -z "$_grt_rules_d" || "$_grt_rules_d" == "null" ]] && _grt_rules_d="[]"
                                local _grt_rc
                                _grt_rc=$(echo "$_grt_rules_d" | jq 'length' 2>/dev/null || echo "0")
                                [[ -z "$_grt_rc" || "$_grt_rc" == "null" ]] && _grt_rc=0
                                
                                # Determine tree branches
                                local _has_imp=0
                                [[ -n "$_grt_imp_id" && "$_grt_imp_id" != "null" && "$_grt_imp_id" != "" ]] && _has_imp=1
                                local _tb="└─" _ti="   "
                                [[ $_has_imp -eq 1 ]] && _tb="├─" && _ti="│  "
                                
                                echo -e "    ${_tb} ${BOLD}${CYAN}Route Rules (${_grt_rc}):${NC}"
                                if [[ "$_grt_rc" -gt 0 ]]; then
                                    printf "    ${_ti} ${BOLD}%-22s %-14s %-10s %-16s %s${NC}\n" "Destination" "Dest Type" "Type" "Origin" "Next Hop"
                                    printf "    ${_ti} %s\n" "$(printf '%*s' 120 '' | tr ' ' '─')"
                                    while IFS='|' read -r _grd _grdt _grt _gro _grnh; do
                                        [[ -z "$_grd" ]] && continue
                                        local _grc="$WHITE"; [[ "$_grt" == "STATIC" ]] && _grc="$YELLOW"; [[ "$_grt" == "DYNAMIC" ]] && _grc="$GREEN"
                                        local _gr_hop=""
                                        if [[ -n "$_grnh" && "$_grnh" != "N/A" && "$_grnh" != "null" ]]; then
                                            local _grn="${_GA_ATT_NAMES[$_grnh]:-}"
                                            if [[ -z "$_grn" ]]; then
                                                _grn=$(oci network drg-attachment get --drg-attachment-id "$_grnh" --region "$_drg_region" \
                                                    --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                                                [[ -n "$_grn" ]] && _GA_ATT_NAMES[$_grnh]="$_grn"
                                            fi
                                            if [[ -n "$_grn" ]]; then
                                                _gr_hop="${CYAN}${_grn}${NC} ${YELLOW}(${_grnh})${NC}"
                                            else
                                                _gr_hop="${YELLOW}(${_grnh})${NC}"
                                            fi
                                        fi
                                        printf "    ${_ti} ${WHITE}%-22s${NC} %-14s ${_grc}%-10s${NC} %-16s %b\n" \
                                            "${_grd:0:22}" "${_grdt:0:14}" "${_grt:0:10}" "${_gro:0:16}" "$_gr_hop"
                                    done < <(echo "$_grt_rules_d" | jq -r '.[] | "\(.destination // "N/A")|\(.["destination-type"] // "N/A")|\(.["route-type"] // "N/A")|\(.["route-provenance"] // "N/A")|\(.["next-hop-drg-attachment-id"] // "N/A")"' 2>/dev/null)
                                else
                                    echo -e "    ${_ti} ${GRAY}(No route rules)${NC}"
                                fi
                            fi
                            
                            # Export distributions for this DRG (not tied to route table)
                            if [[ "$gw_drg_id" != "N/A" && -n "$gw_drg_id" ]]; then
                                local _gex_json
                                _gex_json=$(oci network drg-route-distribution list --drg-id "$gw_drg_id" --region "$_drg_region" --all --output json 2>/dev/null)
                                local _gex_count=0
                                if [[ -n "$_gex_json" && "$_gex_json" != "null" ]]; then
                                    _gex_count=$(echo "$_gex_json" | jq '[.data[] | select(.["distribution-type"] == "EXPORT")] | length' 2>/dev/null || echo "0")
                                fi
                                if [[ "$_gex_count" -gt 0 ]]; then
                                    echo ""
                                    echo -e "  ${BOLD}${CYAN}─── Export Route Distributions ───${NC}"
                                    while IFS='|' read -r _ge_name _ge_state _ge_type _ge_id; do
                                        [[ -z "$_ge_name" ]] && continue
                                        [[ "$_ge_type" != "EXPORT" ]] && continue
                                        
                                        local _ge_sc="$GREEN"; [[ "$_ge_state" != "AVAILABLE" ]] && _ge_sc="$YELLOW"
                                        echo -e "    ${GREEN}$_ge_name${NC}  ${_ge_sc}$_ge_state${NC}  ${GRAY}[EXPORT]${NC}  ${YELLOW}($_ge_id)${NC}"
                                        
                                        local _ges_json
                                        _ges_json=$(oci network drg-route-distribution-statement list --route-distribution-id "$_ge_id" \
                                            --region "$_drg_region" --all --output json 2>/dev/null)
                                        local _ges_data=""
                                        if [[ -n "$_ges_json" ]]; then
                                            _ges_data=$(echo "$_ges_json" | jq '.data // .items // []' 2>/dev/null)
                                        fi
                                        [[ -z "$_ges_data" || "$_ges_data" == "null" ]] && _ges_data="[]"
                                        local _ges_cnt
                                        _ges_cnt=$(echo "$_ges_data" | jq 'length' 2>/dev/null || echo "0")
                                        [[ -z "$_ges_cnt" || "$_ges_cnt" == "null" ]] && _ges_cnt=0
                                        
                                        echo -e "      └─ ${BOLD}${CYAN}Statements (${_ges_cnt}):${NC}"
                                        if [[ "$_ges_cnt" -gt 0 ]]; then
                                            printf "         ${BOLD}%-10s %-8s %-24s %-40s %s${NC}\n" "Action" "Priority" "Match Type" "Match Criteria" "DRG Attachment"
                                            printf "         %s\n" "$(printf '%*s' 120 '' | tr ' ' '─')"
                                            while IFS= read -r _ges_line; do
                                                [[ -z "$_ges_line" ]] && continue
                                                local _ges_a _ges_p _ges_mc
                                                _ges_a=$(echo "$_ges_line" | jq -r '.action // "N/A"' 2>/dev/null)
                                                _ges_p=$(echo "$_ges_line" | jq -r '.priority // "N/A"' 2>/dev/null)
                                                _ges_mc=$(echo "$_ges_line" | jq -r '.["match-criteria"]' 2>/dev/null)
                                                local _ges_mc_len
                                                _ges_mc_len=$(echo "$_ges_mc" | jq 'length' 2>/dev/null || echo "0")
                                                
                                                if [[ "$_ges_mc_len" -eq 0 || "$_ges_mc" == "[]" || "$_ges_mc" == "null" ]]; then
                                                    printf "         ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %s\n" \
                                                        "$_ges_a" "$_ges_p" "MATCH_ALL" "(all attachments)" ""
                                                else
                                                    local _gei=0
                                                    while [[ $_gei -lt $_ges_mc_len ]]; do
                                                        local _ge_mt _ge_at _ge_dai
                                                        _ge_mt=$(echo "$_ges_mc" | jq -r ".[$_gei][\"match-type\"] // \"N/A\"" 2>/dev/null)
                                                        _ge_at=$(echo "$_ges_mc" | jq -r ".[$_gei][\"attachment-type\"] // \"null\"" 2>/dev/null)
                                                        _ge_dai=$(echo "$_ges_mc" | jq -r ".[$_gei][\"drg-attachment-id\"] // \"null\"" 2>/dev/null)
                                                        local _ge_crit="" _ge_att=""
                                                        if [[ "$_ge_mt" == "DRG_ATTACHMENT_TYPE" && "$_ge_at" != "null" ]]; then
                                                            _ge_crit="attachment-type=$_ge_at"
                                                        elif [[ "$_ge_mt" == "DRG_ATTACHMENT_ID" && "$_ge_dai" != "null" ]]; then
                                                            _ge_crit="drg-attachment-id"
                                                        elif [[ "$_ge_mt" == "MATCH_ALL" ]]; then
                                                            _ge_crit="(all attachments)"
                                                        else
                                                            _ge_crit="$_ge_mt"
                                                        fi
                                                        if [[ -n "$_ge_dai" && "$_ge_dai" != "null" ]]; then
                                                            local _gen="${_GA_ATT_NAMES[$_ge_dai]:-}"
                                                            if [[ -z "$_gen" ]]; then
                                                                _gen=$(oci network drg-attachment get --drg-attachment-id "$_ge_dai" --region "$_drg_region" \
                                                                    --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                                                                [[ -n "$_gen" ]] && _GA_ATT_NAMES[$_ge_dai]="$_gen"
                                                            fi
                                                            [[ -n "$_gen" ]] && _ge_att="${CYAN}${_gen}${NC} ${YELLOW}(${_ge_dai})${NC}" || _ge_att="${YELLOW}(${_ge_dai})${NC}"
                                                        fi
                                                        if [[ $_gei -eq 0 ]]; then
                                                            printf "         ${WHITE}%-10s${NC} ${GREEN}%-8s${NC} %-24s %-40s %b\n" \
                                                                "$_ges_a" "$_ges_p" "$_ge_mt" "$_ge_crit" "$_ge_att"
                                                        else
                                                            printf "         %-10s %-8s %-24s %-40s %b\n" \
                                                                "" "" "$_ge_mt" "$_ge_crit" "$_ge_att"
                                                        fi
                                                        ((_gei++))
                                                    done
                                                fi
                                            done < <(echo "$_ges_data" | jq -c '.[]' 2>/dev/null)
                                        else
                                            echo -e "         ${GRAY}(No statements)${NC}"
                                        fi
                                        echo ""
                                    done < <(echo "$_gex_json" | jq -r '.data[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["distribution-type"])|\(.id)"' 2>/dev/null)
                                fi
                            fi
                        else
                            echo -e "${WHITE}OCID:${NC} ${YELLOW}$gw_ocid${NC}"
                            echo ""
                            echo -e "${RED}Failed to fetch DRG Attachment details${NC}"
                        fi
                    fi
                    ;;
                LPG)
                    local lpg_json
                    lpg_json=$(oci network local-peering-gateway get --local-peering-gateway-id "$gw_ocid" --output json 2>/dev/null)
                    if [[ -n "$lpg_json" ]]; then
                        local gw_name gw_state gw_peer_status gw_peer_cidr gw_vcn_id gw_created
                        gw_name=$(echo "$lpg_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                        gw_state=$(echo "$lpg_json" | jq -r '.data["lifecycle-state"] // "N/A"' 2>/dev/null)
                        gw_peer_status=$(echo "$lpg_json" | jq -r '.data["peering-status"] // "N/A"' 2>/dev/null)
                        gw_peer_cidr=$(echo "$lpg_json" | jq -r '.data["peer-advertised-cidr"] // "N/A"' 2>/dev/null)
                        gw_vcn_id=$(echo "$lpg_json" | jq -r '.data["vcn-id"] // "N/A"' 2>/dev/null)
                        gw_created=$(echo "$lpg_json" | jq -r '.data["time-created"] // "N/A"' 2>/dev/null)
                        
                        # Resolve VCN name
                        local vcn_name="N/A"
                        if [[ "$gw_vcn_id" != "N/A" && -n "$gw_vcn_id" ]]; then
                            vcn_name=$(oci network vcn get --vcn-id "$gw_vcn_id" --query 'data."display-name"' --raw-output 2>/dev/null) || vcn_name="N/A"
                        fi
                        
                        echo -e "${WHITE}Name:${NC} ${ORANGE}$gw_name${NC}"
                        echo -e "${WHITE}OCID:${NC} ${YELLOW}$gw_ocid${NC}"
                        echo ""
                        echo "State:                 $gw_state"
                        echo "Peering Status:        $gw_peer_status"
                        echo "Peer Advertised CIDR:  $gw_peer_cidr"
                        echo -e "VCN:                   ${GREEN}$vcn_name${NC} ${YELLOW}($gw_vcn_id)${NC}"
                        echo "Time Created:          $gw_created"
                    else
                        echo -e "${WHITE}OCID:${NC} ${YELLOW}$gw_ocid${NC}"
                        echo ""
                        echo -e "${RED}Failed to fetch Local Peering Gateway details${NC}"
                    fi
                    ;;
                *)
                    echo -e "${WHITE}OCID:${NC} ${YELLOW}$gw_ocid${NC}"
                    echo ""
                    echo -e "${YELLOW}Gateway type $gw_type details not implemented${NC}"
                    ;;
            esac
            ;;
        
        DRG_ATTACHMENT)
            echo -e "${BOLD}${CYAN}=== DRG Attachment Details ===${NC}"
            
            local _region="${EFFECTIVE_REGION:-$REGION}"
            local att_json
            att_json=$(oci network drg-attachment get --drg-attachment-id "$resource_ocid" --region "$_region" --output json 2>/dev/null)
            
            if [[ -n "$att_json" ]]; then
                local att_name att_state att_comp att_drg_id att_type att_vcn_id att_created att_rt_id
                att_name=$(echo "$att_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                att_state=$(echo "$att_json" | jq -r '.data["lifecycle-state"] // "N/A"' 2>/dev/null)
                att_comp=$(echo "$att_json" | jq -r '.data["compartment-id"] // "N/A"' 2>/dev/null)
                att_drg_id=$(echo "$att_json" | jq -r '.data["drg-id"] // "N/A"' 2>/dev/null)
                att_type=$(echo "$att_json" | jq -r '.data["network-details"]["type"] // "N/A"' 2>/dev/null)
                att_vcn_id=$(echo "$att_json" | jq -r '.data["network-details"]["id"] // .data["vcn-id"] // "N/A"' 2>/dev/null)
                att_created=$(echo "$att_json" | jq -r '.data["time-created"] // "N/A"' 2>/dev/null)
                att_rt_id=$(echo "$att_json" | jq -r '.data["drg-route-table-id"] // "N/A"' 2>/dev/null)
                
                # State color
                local att_state_color="$GREEN"
                [[ "$att_state" != "ATTACHED" ]] && att_state_color="$YELLOW"
                [[ "$att_state" == "DETACHING" || "$att_state" == "DETACHED" ]] && att_state_color="$RED"
                
                # Line 1: Name, State, Type, OCID
                echo -e "${CYAN}${att_name}${NC}  ${att_state_color}${att_state}${NC}  ${WHITE}${att_type}${NC}  ${YELLOW}(${resource_ocid})${NC}"
                # Line 2-3: Compartment + Time Created
                local att_comp_name; att_comp_name=$(resolve_compartment_name "$att_comp")
                echo -e "  ${CYAN}Compartment:${NC}  ${WHITE}$att_comp_name${NC} ${GRAY}($att_comp)${NC}"
                echo -e "  ${CYAN}Time Created:${NC} ${WHITE}${att_created:0:19}${NC}"
                echo ""
                
                # Linked DRG: name, state, ocid on one line
                echo -e "${BOLD}${WHITE}Linked DRG:${NC}"
                if [[ "$att_drg_id" != "N/A" && -n "$att_drg_id" ]]; then
                    local drg_json
                    drg_json=$(oci network drg get --drg-id "$att_drg_id" --region "$_region" --output json 2>/dev/null)
                    if [[ -n "$drg_json" ]]; then
                        local drg_name drg_state drg_comp
                        drg_name=$(echo "$drg_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                        drg_state=$(echo "$drg_json" | jq -r '.data["lifecycle-state"] // "N/A"' 2>/dev/null)
                        drg_comp=$(echo "$drg_json" | jq -r '.data["compartment-id"] // "N/A"' 2>/dev/null)
                        local drg_state_color="$GREEN"
                        [[ "$drg_state" != "AVAILABLE" ]] && drg_state_color="$YELLOW"
                        
                        local drg_comp_name; drg_comp_name=$(resolve_compartment_name "$drg_comp")
                        echo -e "  ${ORANGE}$drg_name${NC}  ${drg_state_color}$drg_state${NC}  ${YELLOW}($att_drg_id)${NC}"
                        echo -e "  ${CYAN}Compartment:${NC} ${WHITE}$drg_comp_name${NC} ${GRAY}($drg_comp)${NC}"
                    else
                        echo -e "  ${YELLOW}($att_drg_id)${NC} ${RED}(could not fetch details)${NC}"
                    fi
                else
                    echo -e "  ${GRAY}No DRG linked${NC}"
                fi
                
                # Attached VCN: name, cidr, ocid on one line
                echo ""
                echo -e "${BOLD}${WHITE}Attached VCN:${NC}"
                if [[ "$att_vcn_id" != "N/A" && -n "$att_vcn_id" ]]; then
                    local vcn_json
                    vcn_json=$(oci network vcn get --vcn-id "$att_vcn_id" --region "$_region" --output json 2>/dev/null)
                    local vcn_name vcn_cidr
                    vcn_name=$(echo "$vcn_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null) || vcn_name="N/A"
                    vcn_cidr=$(echo "$vcn_json" | jq -r '.data["cidr-block"] // "N/A"' 2>/dev/null) || vcn_cidr="N/A"
                    echo -e "  ${GREEN}$vcn_name${NC}  ${WHITE}$vcn_cidr${NC}  ${YELLOW}($att_vcn_id)${NC}"
                else
                    echo -e "  ${GRAY}No VCN attached${NC}"
                fi
                
                # DRG Route Table: name, ecmp, ocid on one line + tree branches
                if [[ "$att_rt_id" != "N/A" && -n "$att_rt_id" && "$att_rt_id" != "null" ]]; then
                    echo ""
                    echo -e "${BOLD}${WHITE}DRG Route Table:${NC}"
                    local rt_json
                    rt_json=$(oci network drg-route-table get --drg-route-table-id "$att_rt_id" --region "$_region" --output json 2>/dev/null)
                    local rt_name="N/A" rt_ecmp="false" rt_import_dist_id=""
                    if [[ -n "$rt_json" ]]; then
                        rt_name=$(echo "$rt_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
                        rt_ecmp=$(echo "$rt_json" | jq -r '.data["is-ecmp-enabled"] // false' 2>/dev/null)
                        rt_import_dist_id=$(echo "$rt_json" | jq -r '.data["import-drg-route-distribution-id"] // ""' 2>/dev/null)
                    fi
                    echo -e "  ${MAGENTA}$rt_name${NC}  ${CYAN}ECMP:${NC}${WHITE}$rt_ecmp${NC}  ${YELLOW}($att_rt_id)${NC}"
                    
                    # ├─ Route Rules
                    local rules_json
                    rules_json=$(oci network drg-route-rule list --drg-route-table-id "$att_rt_id" --region "$_region" --output json 2>/dev/null)
                    local rules_data
                    rules_data=$(echo "$rules_json" | jq '.data // .items // []' 2>/dev/null)
                    local rule_count
                    rule_count=$(echo "$rules_data" | jq 'length' 2>/dev/null || echo "0")
                    
                    # Determine if we have import distribution (to decide ├─ vs └─)
                    local has_import_dist=0
                    [[ -n "$rt_import_dist_id" && "$rt_import_dist_id" != "null" && "$rt_import_dist_id" != "" ]] && has_import_dist=1
                    
                    local tree_branch="└─"
                    local tree_indent="   "
                    [[ $has_import_dist -eq 1 ]] && tree_branch="├─" && tree_indent="│  "
                    
                    echo -e "  ${tree_branch} ${BOLD}${CYAN}Route Rules (${rule_count}):${NC}"
                    if [[ "$rule_count" -gt 0 ]]; then
                        printf "  ${tree_indent} ${BOLD}%-22s %-14s %-10s %-16s %-30s %s${NC}\n" "Destination" "Dest Type" "Type" "Origin" "Next Hop Name" "Next Hop OCID"
                        printf "  ${tree_indent} %s\n" "$(printf '%*s' 130 '' | tr ' ' '─')"
                        
                        declare -A _nh_cache
                        while IFS='|' read -r rule_dest rule_dest_type rule_type rule_origin next_hop_id is_conflict is_blackhole; do
                            [[ -z "$rule_dest" ]] && continue
                            
                            local origin_color="$WHITE"
                            case "$rule_type" in
                                STATIC) origin_color="$YELLOW" ;;
                                DYNAMIC) origin_color="$GREEN" ;;
                            esac
                            
                            local flags=""
                            [[ "$is_conflict" == "true" ]] && flags=" ${RED}⚠CONFLICT${NC}"
                            [[ "$is_blackhole" == "true" ]] && flags=" ${RED}⬛BLACKHOLE${NC}"
                            
                            local hop_name_display="" hop_ocid_display=""
                            if [[ -n "$next_hop_id" && "$next_hop_id" != "N/A" && "$next_hop_id" != "null" ]]; then
                                local _nh_name=""
                                if [[ -n "${_nh_cache[$next_hop_id]+x}" ]]; then
                                    _nh_name="${_nh_cache[$next_hop_id]}"
                                else
                                    _nh_name=$(oci network drg-attachment get --drg-attachment-id "$next_hop_id" --region "$_region" \
                                        --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
                                    _nh_cache[$next_hop_id]="$_nh_name"
                                fi
                                hop_name_display="$_nh_name"
                                hop_ocid_display="$next_hop_id"
                            fi
                            
                            printf "  ${tree_indent} ${WHITE}%-22s${NC} %-14s ${origin_color}%-10s${NC} %-16s ${CYAN}%-30s${NC} ${YELLOW}%s${NC}%b\n" \
                                "${rule_dest:0:22}" "${rule_dest_type:0:14}" "${rule_type:0:10}" "${rule_origin:0:16}" \
                                "${hop_name_display:0:30}" "$hop_ocid_display" "$flags"
                        done < <(echo "$rules_data" | jq -r '.[] | "\(.destination // "N/A")|\(.["destination-type"] // "N/A")|\(.["route-type"] // "N/A")|\(.["route-provenance"] // "N/A")|\(.["next-hop-drg-attachment-id"] // "N/A")|\(.["is-conflict"] // false)|\(.["is-blackhole"] // false)"' 2>/dev/null)
                    else
                        echo -e "  ${tree_indent} ${GRAY}(No route rules)${NC}"
                    fi
                fi
            else
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$resource_ocid${NC}"
                echo ""
                echo -e "${RED}Failed to fetch DRG Attachment details${NC}"
            fi
            ;;
            
        OS_PE)
            # resource_ocid = pe_name, extra_info = pe_namespace
            local pe_ref="${resource_ocid}|${extra_info}"
            os_view_private_endpoint_details "$pe_ref"
            ;;
            
        *)
            echo -e "${RED}Unknown resource type: $resource_type${NC}"
            ;;
    esac
    
    echo ""
}

#===============================================================================
# COMPUTE INSTANCE MANAGEMENT
#===============================================================================

#--------------------------------------------------------------------------------
# Helper: Parse instance targets (i1, i1,i3, i1-i5, all) into validated arrays
# Args: $1 = target string, expects INSTANCE_INDEX_MAP to be populated
# Sets global: _PARSED_IDS=() _PARSED_OCIDS=()
# Returns: 0 if any valid targets, 1 if none
#--------------------------------------------------------------------------------
parse_instance_targets() {
    local targets="$1"
    _PARSED_IDS=()
    _PARSED_OCIDS=()
    
    if [[ -z "$targets" ]]; then
        return 1
    fi
    
    declare -a raw_ids=()
    
    if [[ "${targets,,}" == "all" ]]; then
        for tkey in "${!INSTANCE_INDEX_MAP[@]}"; do
            raw_ids+=("$tkey")
        done
    else
        IFS=',' read -ra parts <<< "$targets"
        for part in "${parts[@]}"; do
            part=$(echo "$part" | tr -d ' ')
            # Range: i1-i5 or i1-5 or 1-5
            if [[ "$part" =~ ^i?([0-9]+)-i?([0-9]+)$ ]]; then
                local rstart="${BASH_REMATCH[1]}" rend="${BASH_REMATCH[2]}"
                for ((ri=rstart; ri<=rend; ri++)); do
                    [[ -n "${INSTANCE_INDEX_MAP[i${ri}]:-}" ]] && raw_ids+=("i${ri}")
                done
            # Single: i1 or 1
            elif [[ "$part" =~ ^i?([0-9]+)$ ]]; then
                local num="${BASH_REMATCH[1]}"
                [[ -n "${INSTANCE_INDEX_MAP[i${num}]:-}" ]] && raw_ids+=("i${num}")
            fi
        done
    fi
    
    # Deduplicate and sort
    local -A seen=()
    for rid in "${raw_ids[@]}"; do
        if [[ -z "${seen[$rid]:-}" ]]; then
            seen[$rid]=1
            _PARSED_IDS+=("$rid")
            _PARSED_OCIDS+=("${INSTANCE_INDEX_MAP[$rid]}")
        fi
    done
    
    # Sort numerically
    if [[ ${#_PARSED_IDS[@]} -gt 0 ]]; then
        local sorted
        sorted=$(for idx in "${!_PARSED_IDS[@]}"; do
            echo "${_PARSED_IDS[$idx]}|${_PARSED_OCIDS[$idx]}"
        done | sort -t'i' -k2 -n)
        
        _PARSED_IDS=()
        _PARSED_OCIDS=()
        while IFS='|' read -r sid socid; do
            _PARSED_IDS+=("$sid")
            _PARSED_OCIDS+=("$socid")
        done <<< "$sorted"
        return 0
    fi
    
    return 1
}

#--------------------------------------------------------------------------------
# Helper: Resolve K8s node name from OCI instance OCID
# Args: $1 = instance OCID, $2 = k8s_nodes_json
# Prints: k8s node name or empty string
#--------------------------------------------------------------------------------
resolve_k8s_node_name() {
    local ocid="$1" k8s_json="$2"
    [[ -z "$k8s_json" ]] && return
    echo "$k8s_json" | jq -r --arg ocid "$ocid" \
        '.items[] | select(.spec.providerID | contains($ocid)) | .metadata.name' 2>/dev/null | head -1
}

manage_compute_instances() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    while true; do
        echo ""
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${CYAN}                                                         COMPUTE INSTANCE MANAGEMENT                                                                    ${NC}"
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        _display_cache_info \
            "${INSTANCE_LIST_CACHE}|Instances"
        echo ""
        
        echo -e "${BOLD}${WHITE}Environment:${NC}"
        echo -e "  ${CYAN}Region:${NC}      ${WHITE}${region}${NC}"
        echo -e "  ${CYAN}Compartment:${NC} ${WHITE}$(resolve_compartment_name "${compartment_id}")${NC} ${GRAY}(${compartment_id})${NC}"
        echo ""
        
        # Fetch instances (with caching - 5 minute TTL)
        local instances_json
        local instance_cache_ttl=300
        if is_cache_fresh "$INSTANCE_LIST_CACHE" "$instance_cache_ttl"; then
            log_info "Using cached instance list..."
            instances_json=$(cat "$INSTANCE_LIST_CACHE")
        else
            log_info "Fetching instances from OCI..."
            instances_json=$(oci compute instance list \
                --compartment-id "$compartment_id" \
                --region "$region" \
                --all \
                --output json 2>/dev/null)
            if [[ -n "$instances_json" ]] && echo "$instances_json" | jq -e '.data' > /dev/null 2>&1; then
                echo "$instances_json" > "$INSTANCE_LIST_CACHE"
            fi
        fi
        
        if [[ -z "$instances_json" ]] || ! echo "$instances_json" | jq -e '.data' > /dev/null 2>&1; then
            echo -e "${RED}Failed to fetch instances${NC}"
            echo ""
            echo -e "Press Enter to return..."
            read -r
            return
        fi
        
        # Build instance index map
        declare -A INSTANCE_INDEX_MAP=()
        local instance_idx=0
        
        # Clear any old temp file
        rm -f ${TEMP_DIR}/instance_map_$$
        
        # Fetch K8s nodes once for lookup (include taints and unschedulable status)
        local k8s_nodes_json
        k8s_nodes_json=$(kubectl get nodes -o json 2>/dev/null)
        
        # Fetch pods per node
        local pods_per_node
        pods_per_node=$(kubectl get pods --all-namespaces --field-selector=status.phase=Running -o json 2>/dev/null | \
            jq -r '.items[] | .spec.nodeName' 2>/dev/null | sort | uniq -c | awk '{print $2"|"$1}')
        
        # Build lookup: providerID|nodeName|readyStatus|newNodeTaint|unschedulable
        local k8s_lookup
        k8s_lookup=$(echo "$k8s_nodes_json" | jq -r '
            .items[] | 
            (.spec.taints // [] | map(select(.key == "newNode")) | if length > 0 then .[0].effect else "N/A" end) as $newNodeTaint |
            (.spec.unschedulable // false) as $unschedulable |
            "\(.spec.providerID)|\(.metadata.name)|\(.status.conditions[] | select(.type=="Ready") | .status)|\($newNodeTaint)|\($unschedulable)"
        ' 2>/dev/null)
        
        # Display instances table
        echo -e "${BOLD}${WHITE}═══ Instances ═══${NC}"
        echo ""
        printf "${BOLD}%-5s %-55s %-10s %-8s %-8s %-10s %-5s %-24s %-18s %-18s %s${NC}\n" \
            "ID" "Display Name" "State" "K8s" "Cordon" "Taint" "Pods" "Shape" "Avail Domain" "Created" "Instance OCID"
        print_separator 268
        
        # Sort by time-created (ascending - oldest first, newest last)
        echo "$instances_json" | jq -r '
            .data[] | 
            select(.["lifecycle-state"] != "TERMINATED") |
            "\(.["time-created"] // "N/A")|\(.["display-name"])|\(.["lifecycle-state"])|\(.shape)|\(.["availability-domain"])|\(.id)"
        ' 2>/dev/null | sort -t'|' -k1,1 | while IFS='|' read -r time_created name state shape ad ocid; do
            ((instance_idx++))
            local iid="i${instance_idx}"
            
            # Store in map (need to use a temp file since we're in a subshell)
            echo "${iid}|${ocid}" >> ${TEMP_DIR}/instance_map_$$
            
            # Color state
            local state_color="$GREEN"
            case "$state" in
                RUNNING) state_color="$GREEN" ;;
                STOPPED) state_color="$RED" ;;
                STARTING|STOPPING) state_color="$YELLOW" ;;
                PROVISIONING) state_color="$CYAN" ;;
                *) state_color="$WHITE" ;;
            esac
            
            # Check if in K8s and get taint/cordon info
            local k8s_status="No"
            local k8s_color="$YELLOW"
            local cordon_status="-"
            local cordon_color="$GRAY"
            local taint_status="-"
            local taint_color="$GRAY"
            local pod_count="-"
            local pod_color="$GRAY"
            local k8s_node_name=""
            
            local k8s_match
            k8s_match=$(echo "$k8s_lookup" | grep "$ocid" 2>/dev/null)
            
            if [[ -n "$k8s_match" ]]; then
                local k8s_ready unschedulable new_node_taint
                k8s_node_name=$(echo "$k8s_match" | cut -d'|' -f2)
                k8s_ready=$(echo "$k8s_match" | cut -d'|' -f3)
                new_node_taint=$(echo "$k8s_match" | cut -d'|' -f4)
                unschedulable=$(echo "$k8s_match" | cut -d'|' -f5)
                
                if [[ "$k8s_ready" == "True" ]]; then
                    k8s_status="Ready"
                    k8s_color="$GREEN"
                else
                    k8s_status="NotRdy"
                    k8s_color="$RED"
                fi
                
                # Check cordon status
                if [[ "$unschedulable" == "true" ]]; then
                    cordon_status="Yes"
                    cordon_color="$YELLOW"
                else
                    cordon_status="-"
                    cordon_color="$GRAY"
                fi
                
                # Check newNode taint
                if [[ "$new_node_taint" != "N/A" && -n "$new_node_taint" ]]; then
                    taint_status="newNode"
                    taint_color="$CYAN"
                fi
                
                # Get pod count for this node
                local node_pods
                node_pods=$(echo "$pods_per_node" | grep "^${k8s_node_name}|" | cut -d'|' -f2)
                if [[ -n "$node_pods" ]]; then
                    pod_count="$node_pods"
                    pod_color="$CYAN"
                else
                    pod_count="0"
                    pod_color="$GRAY"
                fi
            fi
            
            # Show full name, truncate shape if needed
            local shape_trunc="${shape:0:24}"
            local ad_short="${ad##*:}"
            
            # Format time_created - show date and time portion
            local time_display="$time_created"
            if [[ "$time_display" != "N/A" && -n "$time_display" ]]; then
                # Format: 2026-01-27T03:29:11.123Z -> 2026-01-27 03:29
                time_display="${time_display:0:16}"
                time_display="${time_display/T/ }"
            fi
            
            printf "${YELLOW}%-5s${NC} %-55s ${state_color}%-10s${NC} ${k8s_color}%-8s${NC} ${cordon_color}%-8s${NC} ${taint_color}%-10s${NC} ${pod_color}%-5s${NC} %-24s %-18s ${GRAY}%-18s${NC} ${YELLOW}%s${NC}\n" \
                "$iid" "$name" "$state" "$k8s_status" "$cordon_status" "$taint_status" "$pod_count" "$shape_trunc" "$ad_short" "$time_display" "$ocid"
        done
        
        # Read map from temp file
        if [[ -f ${TEMP_DIR}/instance_map_$$ ]]; then
            while IFS='|' read -r iid ocid; do
                INSTANCE_INDEX_MAP[$iid]="$ocid"
            done < ${TEMP_DIR}/instance_map_$$
            rm -f ${TEMP_DIR}/instance_map_$$
        fi
        
        local total_instances=${#INSTANCE_INDEX_MAP[@]}
        echo ""
        echo -e "${GRAY}Total: ${total_instances} instances (excluding TERMINATED)${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
        echo -e "  ${YELLOW}i#${NC}         - View instance details (e.g., 'i1', 'i5')"
        echo -e "  ${YELLOW}ocid1...${NC}   - View instance by OCID directly"
        echo -e "  ${YELLOW}p${NC}          - View all instances with OCI properties (shape, mem, boot vol, cloud-init)"
        echo -e "  ${ORANGE}taint${NC}      - Apply newNode=true:NoSchedule taint (e.g., 'taint i1', 'taint i1,i3', 'taint all')"
        echo -e "  ${ORANGE}untaint${NC}    - Remove newNode=true:NoSchedule taint (e.g., 'untaint i1', 'untaint i1-i5')"
        echo -e "  ${ORANGE}cordon${NC}     - Cordon K8s node(s) (e.g., 'cordon i1', 'cordon i1,i3')"
        echo -e "  ${ORANGE}uncordon${NC}   - Uncordon K8s node(s) (e.g., 'uncordon i1', 'uncordon all')"
        echo -e "  ${RED}cdt${NC}        - Cordon → Drain → Tag → Terminate (e.g., 'cdt i1', 'cdt i1-i5', 'cdt all')"
        echo -e "  ${RED}terminate${NC}  - Terminate instances (e.g., 'terminate i1,i3' or 'terminate i1-i5' or 'terminate all')"
        echo -e "  ${GREEN}bvr${NC}        - Boot Volume Replacement (upgrade OKE nodes without reboot)"
        echo -e "  ${MAGENTA}r${NC}          - Refresh instance list"
        echo -e "  ${CYAN}back${NC}       - Return to main menu"
        echo ""
        echo -e "${GRAY}Tip: From command line, use:${NC}"
        echo -e "${GRAY}  $0 <instance-ocid>                  # Basic info (OCI + K8s)${NC}"
        echo -e "${GRAY}  $0 <instance-ocid> --details        # Full details (network, volumes)${NC}"
        echo -e "${GRAY}  $0 <instance-ocid> --console-history # Boot logs (debug cloud-init)${NC}"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Compute Instances] Enter selection [i#/taint/untaint/cordon/uncordon/cdt/terminate/p/bvr/r/back]: ${NC}"
        
        local input
        read -r input
        
        # Empty input goes back
        if [[ -z "$input" ]]; then
            return
        fi
        
        #----------------------------------------------------------------------
        # Taint: Apply newNode=true:NoSchedule
        # Usage: taint i1 / taint i1,i3 / taint i1-i5 / taint all
        #----------------------------------------------------------------------
        if [[ "$input" =~ ^taint[[:space:]]+(.+)$ ]]; then
            local taint_targets="${BASH_REMATCH[1]}"
            local taint_log_file="${LOGS_DIR}/instance_taint_actions.log"
            mkdir -p "$(dirname "$taint_log_file")" 2>/dev/null
            
            if ! parse_instance_targets "$taint_targets"; then
                echo -e "${RED}No valid instances selected. Use: taint i1, taint i1,i3, taint i1-i5, taint all${NC}"
                sleep 2
                continue
            fi
            
            echo ""
            echo -e "${BOLD}${CYAN}═══ Apply Taint: newNode=true:NoSchedule ═══${NC}"
            echo ""
            
            # Resolve K8s node names and display
            declare -a TAINT_VALID=()
            printf "  ${BOLD}%-5s %-45s %-40s %-8s${NC}\n" "ID" "Display Name" "K8s Node Name" "Status"
            print_separator 105
            
            for ti in "${!_PARSED_IDS[@]}"; do
                local t_iid="${_PARSED_IDS[$ti]}"
                local t_ocid="${_PARSED_OCIDS[$ti]}"
                local t_name
                t_name=$(echo "$instances_json" | jq -r --arg id "$t_ocid" '.data[] | select(.id == $id) | .["display-name"] // "Unknown"' 2>/dev/null)
                local t_k8s_node
                t_k8s_node=$(resolve_k8s_node_name "$t_ocid" "$k8s_nodes_json")
                
                if [[ -z "$t_k8s_node" ]]; then
                    printf "  ${YELLOW}%-5s${NC} %-45s ${RED}%-40s${NC} ${RED}%-8s${NC}\n" "$t_iid" "$t_name" "(not in K8s)" "Skip"
                else
                    printf "  ${YELLOW}%-5s${NC} %-45s ${CYAN}%-40s${NC} ${GREEN}%-8s${NC}\n" "$t_iid" "$t_name" "$t_k8s_node" "Ready"
                    TAINT_VALID+=("$t_iid|$t_ocid|$t_name|$t_k8s_node")
                fi
            done
            
            if [[ ${#TAINT_VALID[@]} -eq 0 ]]; then
                echo ""
                echo -e "${RED}No selected instances are K8s nodes${NC}"
                echo -e "Press Enter to continue..."
                read -r
                continue
            fi
            
            echo ""
            echo -e "${BOLD}${WHITE}Commands to execute:${NC}"
            for tv in "${TAINT_VALID[@]}"; do
                local tv_node
                tv_node=$(echo "$tv" | cut -d'|' -f4)
                echo -e "  ${GRAY}kubectl taint node ${tv_node} newNode=true:NoSchedule${NC}"
            done
            echo ""
            echo -n -e "${CYAN}Apply taint to ${#TAINT_VALID[@]} node(s)? [y/N]: ${NC}"
            local taint_confirm
            read -r taint_confirm
            
            if [[ ! "$taint_confirm" =~ ^[Yy] ]]; then
                echo -e "${YELLOW}Cancelled${NC}"
                echo -e "Press Enter to continue..."
                read -r
                continue
            fi
            
            echo ""
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] ===== TAINT: Apply newNode=true:NoSchedule to ${#TAINT_VALID[@]} node(s) =====" >> "$taint_log_file"
            local taint_ok=0 taint_fail=0
            
            for tv in "${TAINT_VALID[@]}"; do
                IFS='|' read -r tv_iid tv_ocid tv_name tv_node <<< "$tv"
                local cmd="kubectl taint node ${tv_node} newNode=true:NoSchedule"
                
                echo -e "${WHITE}[${tv_iid}] ${tv_name} → ${tv_node}${NC}"
                echo -e "${GRAY}$ ${cmd}${NC}"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: ${cmd}" >> "$taint_log_file"
                
                local result
                result=$(eval "$cmd" 2>&1)
                if [[ $? -eq 0 ]]; then
                    echo -e "  ${GREEN}✓ Taint applied${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Tainted ${tv_node} (${tv_name})" >> "$taint_log_file"
                    ((taint_ok++))
                else
                    # Check if already tainted
                    if [[ "$result" == *"already has"* || "$result" == *"already exists"* ]]; then
                        echo -e "  ${YELLOW}⚠ Already tainted${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SKIPPED: ${tv_node} already tainted" >> "$taint_log_file"
                        ((taint_ok++))
                    else
                        echo -e "  ${RED}✗ Failed: ${result}${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Taint ${tv_node}: ${result}" >> "$taint_log_file"
                        ((taint_fail++))
                    fi
                fi
            done
            
            echo ""
            echo -e "${BOLD}${WHITE}─── Taint Summary ───${NC}"
            echo -e "  ${GREEN}Succeeded:${NC} ${taint_ok}  ${RED}Failed:${NC} ${taint_fail}"
            echo -e "  ${GRAY}Log: ${taint_log_file}${NC}"
            echo ""
            echo -e "Press Enter to refresh..."
            read -r
            continue
        fi
        
        #----------------------------------------------------------------------
        # Untaint: Remove newNode=true:NoSchedule
        # Usage: untaint i1 / untaint i1,i3 / untaint i1-i5 / untaint all
        #----------------------------------------------------------------------
        if [[ "$input" =~ ^untaint[[:space:]]+(.+)$ ]]; then
            local untaint_targets="${BASH_REMATCH[1]}"
            local untaint_log_file="${LOGS_DIR}/instance_taint_actions.log"
            mkdir -p "$(dirname "$untaint_log_file")" 2>/dev/null
            
            if ! parse_instance_targets "$untaint_targets"; then
                echo -e "${RED}No valid instances selected. Use: untaint i1, untaint i1,i3, untaint i1-i5, untaint all${NC}"
                sleep 2
                continue
            fi
            
            echo ""
            echo -e "${BOLD}${GREEN}═══ Remove Taint: newNode=true:NoSchedule ═══${NC}"
            echo ""
            
            declare -a UNTAINT_VALID=()
            printf "  ${BOLD}%-5s %-45s %-40s %-8s${NC}\n" "ID" "Display Name" "K8s Node Name" "Status"
            print_separator 105
            
            for ti in "${!_PARSED_IDS[@]}"; do
                local t_iid="${_PARSED_IDS[$ti]}"
                local t_ocid="${_PARSED_OCIDS[$ti]}"
                local t_name
                t_name=$(echo "$instances_json" | jq -r --arg id "$t_ocid" '.data[] | select(.id == $id) | .["display-name"] // "Unknown"' 2>/dev/null)
                local t_k8s_node
                t_k8s_node=$(resolve_k8s_node_name "$t_ocid" "$k8s_nodes_json")
                
                if [[ -z "$t_k8s_node" ]]; then
                    printf "  ${YELLOW}%-5s${NC} %-45s ${RED}%-40s${NC} ${RED}%-8s${NC}\n" "$t_iid" "$t_name" "(not in K8s)" "Skip"
                else
                    printf "  ${YELLOW}%-5s${NC} %-45s ${CYAN}%-40s${NC} ${GREEN}%-8s${NC}\n" "$t_iid" "$t_name" "$t_k8s_node" "Ready"
                    UNTAINT_VALID+=("$t_iid|$t_ocid|$t_name|$t_k8s_node")
                fi
            done
            
            if [[ ${#UNTAINT_VALID[@]} -eq 0 ]]; then
                echo ""
                echo -e "${RED}No selected instances are K8s nodes${NC}"
                echo -e "Press Enter to continue..."
                read -r
                continue
            fi
            
            echo ""
            echo -e "${BOLD}${WHITE}Commands to execute:${NC}"
            for tv in "${UNTAINT_VALID[@]}"; do
                local tv_node
                tv_node=$(echo "$tv" | cut -d'|' -f4)
                echo -e "  ${GRAY}kubectl taint node ${tv_node} newNode=true:NoSchedule-${NC}"
            done
            echo ""
            echo -n -e "${CYAN}Remove taint from ${#UNTAINT_VALID[@]} node(s)? [y/N]: ${NC}"
            local untaint_confirm
            read -r untaint_confirm
            
            if [[ ! "$untaint_confirm" =~ ^[Yy] ]]; then
                echo -e "${YELLOW}Cancelled${NC}"
                echo -e "Press Enter to continue..."
                read -r
                continue
            fi
            
            echo ""
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] ===== UNTAINT: Remove newNode=true:NoSchedule from ${#UNTAINT_VALID[@]} node(s) =====" >> "$untaint_log_file"
            local untaint_ok=0 untaint_fail=0
            
            for tv in "${UNTAINT_VALID[@]}"; do
                IFS='|' read -r tv_iid tv_ocid tv_name tv_node <<< "$tv"
                local cmd="kubectl taint node ${tv_node} newNode=true:NoSchedule-"
                
                echo -e "${WHITE}[${tv_iid}] ${tv_name} → ${tv_node}${NC}"
                echo -e "${GRAY}$ ${cmd}${NC}"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: ${cmd}" >> "$untaint_log_file"
                
                local result
                result=$(eval "$cmd" 2>&1)
                if [[ $? -eq 0 ]]; then
                    echo -e "  ${GREEN}✓ Taint removed${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Untainted ${tv_node} (${tv_name})" >> "$untaint_log_file"
                    ((untaint_ok++))
                else
                    if [[ "$result" == *"not found"* ]]; then
                        echo -e "  ${YELLOW}⚠ Taint not present${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SKIPPED: ${tv_node} taint not found" >> "$untaint_log_file"
                        ((untaint_ok++))
                    else
                        echo -e "  ${RED}✗ Failed: ${result}${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Untaint ${tv_node}: ${result}" >> "$untaint_log_file"
                        ((untaint_fail++))
                    fi
                fi
            done
            
            echo ""
            echo -e "${BOLD}${WHITE}─── Untaint Summary ───${NC}"
            echo -e "  ${GREEN}Succeeded:${NC} ${untaint_ok}  ${RED}Failed:${NC} ${untaint_fail}"
            echo -e "  ${GRAY}Log: ${untaint_log_file}${NC}"
            echo ""
            echo -e "Press Enter to refresh..."
            read -r
            continue
        fi
        
        #----------------------------------------------------------------------
        # Cordon: kubectl cordon node(s)
        # Usage: cordon i1 / cordon i1,i3 / cordon i1-i5 / cordon all
        #----------------------------------------------------------------------
        if [[ "$input" =~ ^cordon[[:space:]]+(.+)$ ]]; then
            local cordon_targets="${BASH_REMATCH[1]}"
            local cordon_log_file="${LOGS_DIR}/instance_cordon_actions.log"
            mkdir -p "$(dirname "$cordon_log_file")" 2>/dev/null
            
            if ! parse_instance_targets "$cordon_targets"; then
                echo -e "${RED}No valid instances selected. Use: cordon i1, cordon i1,i3, cordon i1-i5, cordon all${NC}"
                sleep 2
                continue
            fi
            
            echo ""
            echo -e "${BOLD}${YELLOW}═══ Cordon K8s Nodes ═══${NC}"
            echo ""
            
            declare -a CORDON_VALID=()
            printf "  ${BOLD}%-5s %-45s %-40s %-8s${NC}\n" "ID" "Display Name" "K8s Node Name" "Status"
            print_separator 105
            
            for ti in "${!_PARSED_IDS[@]}"; do
                local t_iid="${_PARSED_IDS[$ti]}"
                local t_ocid="${_PARSED_OCIDS[$ti]}"
                local t_name
                t_name=$(echo "$instances_json" | jq -r --arg id "$t_ocid" '.data[] | select(.id == $id) | .["display-name"] // "Unknown"' 2>/dev/null)
                local t_k8s_node
                t_k8s_node=$(resolve_k8s_node_name "$t_ocid" "$k8s_nodes_json")
                
                if [[ -z "$t_k8s_node" ]]; then
                    printf "  ${YELLOW}%-5s${NC} %-45s ${RED}%-40s${NC} ${RED}%-8s${NC}\n" "$t_iid" "$t_name" "(not in K8s)" "Skip"
                else
                    printf "  ${YELLOW}%-5s${NC} %-45s ${CYAN}%-40s${NC} ${GREEN}%-8s${NC}\n" "$t_iid" "$t_name" "$t_k8s_node" "Ready"
                    CORDON_VALID+=("$t_iid|$t_ocid|$t_name|$t_k8s_node")
                fi
            done
            
            if [[ ${#CORDON_VALID[@]} -eq 0 ]]; then
                echo ""
                echo -e "${RED}No selected instances are K8s nodes${NC}"
                echo -e "Press Enter to continue..."
                read -r
                continue
            fi
            
            echo ""
            echo -e "${BOLD}${WHITE}Commands to execute:${NC}"
            for tv in "${CORDON_VALID[@]}"; do
                local tv_node
                tv_node=$(echo "$tv" | cut -d'|' -f4)
                echo -e "  ${GRAY}kubectl cordon ${tv_node}${NC}"
            done
            echo ""
            echo -n -e "${CYAN}Cordon ${#CORDON_VALID[@]} node(s)? [y/N]: ${NC}"
            local cordon_confirm
            read -r cordon_confirm
            
            if [[ ! "$cordon_confirm" =~ ^[Yy] ]]; then
                echo -e "${YELLOW}Cancelled${NC}"
                echo -e "Press Enter to continue..."
                read -r
                continue
            fi
            
            echo ""
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] ===== CORDON: ${#CORDON_VALID[@]} node(s) =====" >> "$cordon_log_file"
            local cordon_ok=0 cordon_fail=0
            
            for tv in "${CORDON_VALID[@]}"; do
                IFS='|' read -r tv_iid tv_ocid tv_name tv_node <<< "$tv"
                local cmd="kubectl cordon ${tv_node}"
                
                echo -e "${WHITE}[${tv_iid}] ${tv_name} → ${tv_node}${NC}"
                echo -e "${GRAY}$ ${cmd}${NC}"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: ${cmd}" >> "$cordon_log_file"
                
                local result
                result=$(eval "$cmd" 2>&1)
                if [[ $? -eq 0 ]]; then
                    echo -e "  ${GREEN}✓ Cordoned${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Cordoned ${tv_node} (${tv_name})" >> "$cordon_log_file"
                    ((cordon_ok++))
                else
                    echo -e "  ${RED}✗ Failed: ${result}${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Cordon ${tv_node}: ${result}" >> "$cordon_log_file"
                    ((cordon_fail++))
                fi
            done
            
            echo ""
            echo -e "${BOLD}${WHITE}─── Cordon Summary ───${NC}"
            echo -e "  ${GREEN}Succeeded:${NC} ${cordon_ok}  ${RED}Failed:${NC} ${cordon_fail}"
            echo -e "  ${GRAY}Log: ${cordon_log_file}${NC}"
            echo ""
            echo -e "Press Enter to refresh..."
            read -r
            continue
        fi
        
        #----------------------------------------------------------------------
        # Uncordon: kubectl uncordon node(s)
        # Usage: uncordon i1 / uncordon i1,i3 / uncordon i1-i5 / uncordon all
        #----------------------------------------------------------------------
        if [[ "$input" =~ ^uncordon[[:space:]]+(.+)$ ]]; then
            local uncordon_targets="${BASH_REMATCH[1]}"
            local uncordon_log_file="${LOGS_DIR}/instance_cordon_actions.log"
            mkdir -p "$(dirname "$uncordon_log_file")" 2>/dev/null
            
            if ! parse_instance_targets "$uncordon_targets"; then
                echo -e "${RED}No valid instances selected. Use: uncordon i1, uncordon i1,i3, uncordon i1-i5, uncordon all${NC}"
                sleep 2
                continue
            fi
            
            echo ""
            echo -e "${BOLD}${GREEN}═══ Uncordon K8s Nodes ═══${NC}"
            echo ""
            
            declare -a UNCORDON_VALID=()
            printf "  ${BOLD}%-5s %-45s %-40s %-8s${NC}\n" "ID" "Display Name" "K8s Node Name" "Status"
            print_separator 105
            
            for ti in "${!_PARSED_IDS[@]}"; do
                local t_iid="${_PARSED_IDS[$ti]}"
                local t_ocid="${_PARSED_OCIDS[$ti]}"
                local t_name
                t_name=$(echo "$instances_json" | jq -r --arg id "$t_ocid" '.data[] | select(.id == $id) | .["display-name"] // "Unknown"' 2>/dev/null)
                local t_k8s_node
                t_k8s_node=$(resolve_k8s_node_name "$t_ocid" "$k8s_nodes_json")
                
                if [[ -z "$t_k8s_node" ]]; then
                    printf "  ${YELLOW}%-5s${NC} %-45s ${RED}%-40s${NC} ${RED}%-8s${NC}\n" "$t_iid" "$t_name" "(not in K8s)" "Skip"
                else
                    printf "  ${YELLOW}%-5s${NC} %-45s ${CYAN}%-40s${NC} ${GREEN}%-8s${NC}\n" "$t_iid" "$t_name" "$t_k8s_node" "Ready"
                    UNCORDON_VALID+=("$t_iid|$t_ocid|$t_name|$t_k8s_node")
                fi
            done
            
            if [[ ${#UNCORDON_VALID[@]} -eq 0 ]]; then
                echo ""
                echo -e "${RED}No selected instances are K8s nodes${NC}"
                echo -e "Press Enter to continue..."
                read -r
                continue
            fi
            
            echo ""
            echo -e "${BOLD}${WHITE}Commands to execute:${NC}"
            for tv in "${UNCORDON_VALID[@]}"; do
                local tv_node
                tv_node=$(echo "$tv" | cut -d'|' -f4)
                echo -e "  ${GRAY}kubectl uncordon ${tv_node}${NC}"
            done
            echo ""
            echo -n -e "${CYAN}Uncordon ${#UNCORDON_VALID[@]} node(s)? [y/N]: ${NC}"
            local uncordon_confirm
            read -r uncordon_confirm
            
            if [[ ! "$uncordon_confirm" =~ ^[Yy] ]]; then
                echo -e "${YELLOW}Cancelled${NC}"
                echo -e "Press Enter to continue..."
                read -r
                continue
            fi
            
            echo ""
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] ===== UNCORDON: ${#UNCORDON_VALID[@]} node(s) =====" >> "$uncordon_log_file"
            local uncordon_ok=0 uncordon_fail=0
            
            for tv in "${UNCORDON_VALID[@]}"; do
                IFS='|' read -r tv_iid tv_ocid tv_name tv_node <<< "$tv"
                local cmd="kubectl uncordon ${tv_node}"
                
                echo -e "${WHITE}[${tv_iid}] ${tv_name} → ${tv_node}${NC}"
                echo -e "${GRAY}$ ${cmd}${NC}"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: ${cmd}" >> "$uncordon_log_file"
                
                local result
                result=$(eval "$cmd" 2>&1)
                if [[ $? -eq 0 ]]; then
                    echo -e "  ${GREEN}✓ Uncordoned${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Uncordoned ${tv_node} (${tv_name})" >> "$uncordon_log_file"
                    ((uncordon_ok++))
                else
                    echo -e "  ${RED}✗ Failed: ${result}${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Uncordon ${tv_node}: ${result}" >> "$uncordon_log_file"
                    ((uncordon_fail++))
                fi
            done
            
            echo ""
            echo -e "${BOLD}${WHITE}─── Uncordon Summary ───${NC}"
            echo -e "  ${GREEN}Succeeded:${NC} ${uncordon_ok}  ${RED}Failed:${NC} ${uncordon_fail}"
            echo -e "  ${GRAY}Log: ${uncordon_log_file}${NC}"
            echo ""
            echo -e "Press Enter to refresh..."
            read -r
            continue
        fi
        
        #----------------------------------------------------------------------
        # CDT: Cordon → Drain → Tag → Terminate workflow
        # Usage: cdt i1 / cdt i1,i3 / cdt i1-i5 / cdt all
        #----------------------------------------------------------------------
        if [[ "$input" =~ ^cdt[[:space:]]+(.+)$ ]]; then
            local cdt_targets="${BASH_REMATCH[1]}"
            local cdt_log_file="${LOGS_DIR}/instance_cdt_actions.log"
            mkdir -p "$(dirname "$cdt_log_file")" 2>/dev/null
            
            if ! parse_instance_targets "$cdt_targets"; then
                echo -e "${RED}No valid instances selected. Use: cdt i1, cdt i1,i3, cdt i1-i5, cdt all${NC}"
                sleep 2
                continue
            fi
            
            echo ""
            echo -e "${RED}╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════╗${NC}"
            echo -e "${RED}║                            ⚠️  CORDON → DRAIN → TAG → TERMINATE  ⚠️                                        ║${NC}"
            echo -e "${RED}╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════╝${NC}"
            echo ""
            echo -e "${WHITE}This workflow will execute the following steps for each instance:${NC}"
            echo -e "  ${YELLOW}1.${NC} ${CYAN}Cordon${NC}    - Mark K8s node as unschedulable"
            echo -e "  ${YELLOW}2.${NC} ${CYAN}Drain${NC}     - Evict all pods (--ignore-daemonsets --delete-emptydir-data --force --timeout=300s)"
            echo -e "  ${YELLOW}3.${NC} ${CYAN}Tag${NC}       - Apply defined-tag ${MAGENTA}ComputeInstanceHostActions.CustomerReportedHostStatus=unhealthy${NC}"
            echo -e "  ${YELLOW}4.${NC} ${RED}Terminate${NC} - Terminate OCI instance (boot volume deleted)"
            echo ""
            
            # Build validated list
            declare -a CDT_VALID=()
            printf "  ${BOLD}%-5s %-45s %-40s %-10s %-8s %-10s${NC}\n" "ID" "Display Name" "K8s Node Name" "State" "Cordon" "Taint"
            print_separator 125
            
            for ti in "${!_PARSED_IDS[@]}"; do
                local t_iid="${_PARSED_IDS[$ti]}"
                local t_ocid="${_PARSED_OCIDS[$ti]}"
                local t_name t_state
                t_name=$(echo "$instances_json" | jq -r --arg id "$t_ocid" '.data[] | select(.id == $id) | .["display-name"] // "Unknown"' 2>/dev/null)
                t_state=$(echo "$instances_json" | jq -r --arg id "$t_ocid" '.data[] | select(.id == $id) | .["lifecycle-state"] // "Unknown"' 2>/dev/null)
                
                local t_k8s_node=""
                local t_cordon_status="-"
                local t_taint_status="-"
                
                t_k8s_node=$(resolve_k8s_node_name "$t_ocid" "$k8s_nodes_json")
                
                if [[ -n "$t_k8s_node" ]]; then
                    # Get cordon and taint status
                    local k8s_match
                    k8s_match=$(echo "$k8s_lookup" | grep "$t_ocid" 2>/dev/null)
                    if [[ -n "$k8s_match" ]]; then
                        local unschedulable new_node_taint
                        new_node_taint=$(echo "$k8s_match" | cut -d'|' -f4)
                        unschedulable=$(echo "$k8s_match" | cut -d'|' -f5)
                        [[ "$unschedulable" == "true" ]] && t_cordon_status="Yes"
                        [[ "$new_node_taint" != "N/A" && -n "$new_node_taint" ]] && t_taint_status="newNode"
                    fi
                fi
                
                # Color state
                local state_color="$GREEN"
                case "$t_state" in STOPPED) state_color="$RED" ;; STARTING|STOPPING) state_color="$YELLOW" ;; esac
                local cordon_color="$GRAY"
                [[ "$t_cordon_status" == "Yes" ]] && cordon_color="$YELLOW"
                local taint_color="$GRAY"
                [[ "$t_taint_status" == "newNode" ]] && taint_color="$CYAN"
                
                local k8s_display="${t_k8s_node:-(not in K8s)}"
                local k8s_col="$CYAN"
                [[ -z "$t_k8s_node" ]] && k8s_col="$RED"
                
                printf "  ${YELLOW}%-5s${NC} %-45s ${k8s_col}%-40s${NC} ${state_color}%-10s${NC} ${cordon_color}%-8s${NC} ${taint_color}%-10s${NC}\n" \
                    "$t_iid" "$t_name" "$k8s_display" "$t_state" "$t_cordon_status" "$t_taint_status"
                
                CDT_VALID+=("$t_iid|$t_ocid|$t_name|$t_state|$t_k8s_node")
            done
            
            if [[ ${#CDT_VALID[@]} -eq 0 ]]; then
                echo ""
                echo -e "${RED}No valid instances selected${NC}"
                echo -e "Press Enter to continue..."
                read -r
                continue
            fi
            
            # K8s warnings
            local cdt_no_k8s=0
            for tv in "${CDT_VALID[@]}"; do
                local tv_node
                tv_node=$(echo "$tv" | cut -d'|' -f5)
                [[ -z "$tv_node" ]] && ((cdt_no_k8s++))
            done
            if [[ $cdt_no_k8s -gt 0 ]]; then
                echo ""
                echo -e "${YELLOW}⚠ ${cdt_no_k8s} instance(s) not in K8s - cordon/drain steps will be skipped for those${NC}"
            fi
            
            echo ""
            echo -e "${RED}⚠️  WARNING: This will PERMANENTLY TERMINATE ${#CDT_VALID[@]} instance(s)!${NC}"
            echo -e "${RED}   Boot volumes will be deleted. This action cannot be undone!${NC}"
            echo ""
            echo -n -e "${RED}Type 'CDT' to confirm cordon-drain-tag-terminate of ${#CDT_VALID[@]} instance(s): ${NC}"
            local cdt_confirm
            read -r cdt_confirm
            
            if [[ "$cdt_confirm" != "CDT" ]]; then
                echo -e "${YELLOW}Cancelled${NC}"
                echo -e "Press Enter to continue..."
                read -r
                continue
            fi
            
            echo ""
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] ===== CDT WORKFLOW: ${#CDT_VALID[@]} instance(s) =====" >> "$cdt_log_file"
            
            local cdt_success=0 cdt_fail=0
            
            for tv in "${CDT_VALID[@]}"; do
                IFS='|' read -r tv_iid tv_ocid tv_name tv_state tv_node <<< "$tv"
                
                echo -e "${BOLD}${WHITE}═══ [${tv_iid}] ${tv_name} ═══${NC}"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] --- CDT START: ${tv_name} (${tv_ocid}) ---" >> "$cdt_log_file"
                
                local cdt_abort=false
                
                # ── Step 1: Cordon ──
                if [[ -n "$tv_node" ]]; then
                    local cmd="kubectl cordon ${tv_node}"
                    echo -e "  ${CYAN}Step 1: Cordon${NC}"
                    echo -e "  ${GRAY}$ ${cmd}${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: ${cmd}" >> "$cdt_log_file"
                    
                    local result
                    result=$(eval "$cmd" 2>&1)
                    if [[ $? -eq 0 || "$result" == *"already cordoned"* ]]; then
                        echo -e "  ${GREEN}✓ Cordoned${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Cordoned ${tv_node}" >> "$cdt_log_file"
                    else
                        echo -e "  ${RED}✗ Cordon failed: ${result}${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Cordon ${tv_node}: ${result}" >> "$cdt_log_file"
                        echo -n -e "  ${YELLOW}Continue anyway? [y/N]: ${NC}"
                        local cordon_cont
                        read -r cordon_cont
                        if [[ ! "$cordon_cont" =~ ^[Yy] ]]; then
                            echo -e "  ${RED}Skipping this instance${NC}"
                            echo "[$(date '+%Y-%m-%d %H:%M:%S')] ABORTED: CDT for ${tv_name} (cordon failed)" >> "$cdt_log_file"
                            cdt_abort=true
                        fi
                    fi
                else
                    echo -e "  ${YELLOW}Step 1: Cordon - Skipped (not in K8s)${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] SKIPPED: Cordon - ${tv_name} not in K8s" >> "$cdt_log_file"
                fi
                
                # ── Step 2: Drain ──
                if [[ "$cdt_abort" != "true" && -n "$tv_node" ]]; then
                    local cmd="kubectl drain ${tv_node} --ignore-daemonsets --delete-emptydir-data --force --timeout=300s"
                    echo -e "  ${CYAN}Step 2: Drain${NC}"
                    echo -e "  ${GRAY}$ ${cmd}${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: ${cmd}" >> "$cdt_log_file"
                    
                    echo -e "  ${YELLOW}Draining pods (timeout 300s)...${NC}"
                    local result
                    result=$(eval "$cmd" 2>&1)
                    local drain_exit=$?
                    
                    if [[ $drain_exit -eq 0 ]]; then
                        echo -e "  ${GREEN}✓ Drained${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Drained ${tv_node}" >> "$cdt_log_file"
                    else
                        echo -e "  ${RED}✗ Drain failed (exit code: ${drain_exit})${NC}"
                        echo -e "  ${GRAY}${result}${NC}" | tail -5
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Drain ${tv_node}: exit=${drain_exit}" >> "$cdt_log_file"
                        echo -n -e "  ${YELLOW}Continue to terminate anyway? [y/N]: ${NC}"
                        local drain_cont
                        read -r drain_cont
                        if [[ ! "$drain_cont" =~ ^[Yy] ]]; then
                            echo -e "  ${RED}Skipping this instance${NC}"
                            echo "[$(date '+%Y-%m-%d %H:%M:%S')] ABORTED: CDT for ${tv_name} (drain failed)" >> "$cdt_log_file"
                            cdt_abort=true
                        fi
                    fi
                elif [[ "$cdt_abort" != "true" ]]; then
                    echo -e "  ${YELLOW}Step 2: Drain - Skipped (not in K8s)${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] SKIPPED: Drain - ${tv_name} not in K8s" >> "$cdt_log_file"
                fi
                
                # ── Step 3: Tag (ComputeInstanceHostActions.CustomerReportedHostStatus=unhealthy) ──
                if [[ "$cdt_abort" != "true" ]]; then
                    local tag_namespace="ComputeInstanceHostActions"
                    local tag_key="CustomerReportedHostStatus"
                    local tag_value="unhealthy"
                    
                    echo -e "  ${CYAN}Step 3: Tag${NC} ${MAGENTA}${tag_namespace}.${tag_key}=${tag_value}${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Step 3: Tag ${tag_namespace}.${tag_key}=${tag_value}" >> "$cdt_log_file"
                    
                    # Fetch current defined tags (preserve existing)
                    local inst_json
                    inst_json=$(oci compute instance get \
                        --instance-id "$tv_ocid" \
                        --region "${EFFECTIVE_REGION:-$REGION}" \
                        --output json 2>/dev/null)
                    
                    if [[ -n "$inst_json" ]]; then
                        local current_defined_tags
                        current_defined_tags=$(echo "$inst_json" | jq -r '.data["defined-tags"] // {}')
                        
                        # Merge new tag preserving all existing
                        local updated_defined_tags
                        updated_defined_tags=$(echo "$current_defined_tags" | jq --arg ns "$tag_namespace" --arg key "$tag_key" --arg val "$tag_value" '
                            .[$ns] = ((.[$ns] // {}) + {($key): $val})
                        ')
                        
                        local updated_tags_compact
                        updated_tags_compact=$(echo "$updated_defined_tags" | jq -c '.')
                        
                        local cmd="oci compute instance update --instance-id ${tv_ocid} --region ${EFFECTIVE_REGION:-$REGION} --defined-tags '${updated_tags_compact}' --force"
                        echo -e "  ${GRAY}$ oci compute instance update --instance-id ${tv_ocid} \\${NC}"
                        echo -e "  ${GRAY}    --region ${EFFECTIVE_REGION:-$REGION} --defined-tags '<merged-tags>' --force${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: ${cmd}" >> "$cdt_log_file"
                        
                        local tag_result
                        tag_result=$(oci compute instance update \
                            --instance-id "$tv_ocid" \
                            --region "${EFFECTIVE_REGION:-$REGION}" \
                            --defined-tags "$updated_defined_tags" \
                            --force \
                            --output json 2>&1)
                        
                        if [[ $? -eq 0 ]]; then
                            # Verify the tag was applied
                            local applied_tag
                            applied_tag=$(echo "$tag_result" | jq -r --arg ns "$tag_namespace" --arg key "$tag_key" '.data["defined-tags"][$ns][$key] // "NOT_SET"' 2>/dev/null)
                            echo -e "  ${GREEN}✓ Tagged: ${MAGENTA}${tag_namespace}.${tag_key}${NC} = ${RED}${applied_tag}${NC}"
                            echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Tagged ${tv_name} ${tag_namespace}.${tag_key}=${applied_tag}" >> "$cdt_log_file"
                        else
                            echo -e "  ${YELLOW}⚠ Tag failed (non-fatal): ${tag_result}${NC}"
                            echo "[$(date '+%Y-%m-%d %H:%M:%S')] WARNING: Tag failed for ${tv_name}: ${tag_result}" >> "$cdt_log_file"
                            # Check if namespace doesn't exist
                            if echo "$tag_result" | grep -qi "TagDefinition\|TagNamespace\|does not exist"; then
                                echo -e "  ${YELLOW}  ↳ Tag namespace '${tag_namespace}' may not exist in this tenancy${NC}"
                            fi
                        fi
                    else
                        echo -e "  ${YELLOW}⚠ Could not fetch instance tags (non-fatal)${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] WARNING: Could not fetch tags for ${tv_name}" >> "$cdt_log_file"
                    fi
                fi
                
                # ── Step 4: Terminate ──
                if [[ "$cdt_abort" != "true" ]]; then
                    local cmd="oci compute instance terminate --instance-id ${tv_ocid} --region ${EFFECTIVE_REGION:-$REGION} --preserve-boot-volume false --force"
                    echo -e "  ${RED}Step 4: Terminate${NC}"
                    echo -e "  ${GRAY}$ ${cmd}${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: ${cmd}" >> "$cdt_log_file"
                    
                    local result
                    result=$(oci compute instance terminate \
                        --instance-id "$tv_ocid" \
                        --region "${EFFECTIVE_REGION:-$REGION}" \
                        --preserve-boot-volume false \
                        --force 2>&1)
                    if [[ $? -eq 0 ]]; then
                        echo -e "  ${GREEN}✓ Terminate initiated${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Terminated ${tv_name} (${tv_ocid})" >> "$cdt_log_file"
                        ((cdt_success++))
                    else
                        echo -e "  ${RED}✗ Terminate failed: ${result}${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Terminate ${tv_name}: ${result}" >> "$cdt_log_file"
                        ((cdt_fail++))
                    fi
                else
                    ((cdt_fail++))
                fi
                
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] --- CDT END: ${tv_name} ---" >> "$cdt_log_file"
                echo ""
            done
            
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] ===== CDT COMPLETE: Success=${cdt_success} Failed=${cdt_fail} Total=${#CDT_VALID[@]} =====" >> "$cdt_log_file"
            echo -e "${BOLD}${WHITE}═══ CDT Workflow Complete ═══${NC}"
            echo -e "  ${GREEN}Success:${NC} ${cdt_success}  ${RED}Failed/Skipped:${NC} ${cdt_fail}  ${WHITE}Total:${NC} ${#CDT_VALID[@]}"
            echo -e "  ${GRAY}Log: ${cdt_log_file}${NC}"
            echo ""
            rm -f "$INSTANCE_LIST_CACHE"
            echo -e "Press Enter to refresh..."
            read -r
            continue
        fi
        
        #----------------------------------------------------------------------
        # Terminate instances: terminate i1,i3 / terminate i1-i5 / terminate all
        #----------------------------------------------------------------------
        if [[ "$input" =~ ^terminate[[:space:]]+(.+)$ ]]; then
            local term_targets="${BASH_REMATCH[1]}"
            local term_log_file="${LOGS_DIR}/instance_terminate_actions.log"
            mkdir -p "$(dirname "$term_log_file")" 2>/dev/null
            
            # Parse targets into i# indices
            declare -a term_indices=()
            
            if [[ "$term_targets" == "all" || "$term_targets" == "ALL" ]]; then
                # Add all instance indices
                for tkey in "${!INSTANCE_INDEX_MAP[@]}"; do
                    term_indices+=("$tkey")
                done
            else
                IFS=',' read -ra term_parts <<< "$term_targets"
                for tpart in "${term_parts[@]}"; do
                    tpart=$(echo "$tpart" | tr -d ' ')
                    # Handle range: i1-i5 or i1-5
                    if [[ "$tpart" =~ ^i?([0-9]+)-i?([0-9]+)$ ]]; then
                        local tr_start="${BASH_REMATCH[1]}" tr_end="${BASH_REMATCH[2]}"
                        for ((ti=tr_start; ti<=tr_end; ti++)); do
                            [[ -n "${INSTANCE_INDEX_MAP[i${ti}]:-}" ]] && term_indices+=("i${ti}")
                        done
                    # Handle single: i1 or just 1
                    elif [[ "$tpart" =~ ^i?([0-9]+)$ ]]; then
                        local tnum="${BASH_REMATCH[1]}"
                        [[ -n "${INSTANCE_INDEX_MAP[i${tnum}]:-}" ]] && term_indices+=("i${tnum}")
                    fi
                done
            fi
            
            # Deduplicate
            local -A term_seen=()
            local -a term_unique=()
            for tidx in "${term_indices[@]}"; do
                if [[ -z "${term_seen[$tidx]:-}" ]]; then
                    term_seen[$tidx]=1
                    term_unique+=("$tidx")
                fi
            done
            term_indices=("${term_unique[@]}")
            
            if [[ ${#term_indices[@]} -eq 0 ]]; then
                echo -e "${RED}No valid instances selected. Use: terminate i1,i3 or terminate i1-i5 or terminate all${NC}"
                sleep 2
                continue
            fi
            
            # Sort indices numerically for display
            IFS=$'\n' term_indices=($(for tidx in "${term_indices[@]}"; do echo "$tidx"; done | sort -t'i' -k2 -n)); unset IFS
            
            # Look up instance details for display
            echo ""
            echo -e "${RED}╔════════════════════════════════════════════════════════════════════════════════════════════════╗${NC}"
            echo -e "${RED}║                                   ⚠️  TERMINATE INSTANCES  ⚠️                                    ║${NC}"
            echo -e "${RED}╚════════════════════════════════════════════════════════════════════════════════════════════════╝${NC}"
            echo ""
            
            declare -a term_valid=()
            declare -a term_invalid=()
            
            printf "  ${BOLD}%-5s %-45s %-12s %-8s %-55s${NC}\n" "ID" "Display Name" "State" "K8s" "Instance OCID"
            print_separator 130
            
            for tidx in "${term_indices[@]}"; do
                local tocid="${INSTANCE_INDEX_MAP[$tidx]:-}"
                if [[ -z "$tocid" ]]; then
                    term_invalid+=("$tidx")
                    continue
                fi
                
                # Get instance name and state
                local tname tstate
                tname=$(echo "$instances_json" | jq -r --arg id "$tocid" '.data[] | select(.id == $id) | .["display-name"] // "Unknown"' 2>/dev/null)
                tstate=$(echo "$instances_json" | jq -r --arg id "$tocid" '.data[] | select(.id == $id) | .["lifecycle-state"] // "Unknown"' 2>/dev/null)
                
                # Check K8s membership
                local tk8s_status="No"
                if [[ -n "$k8s_nodes_json" ]]; then
                    local tk8s_node
                    tk8s_node=$(echo "$k8s_nodes_json" | jq -r --arg ocid "$tocid" \
                        '.items[] | select(.spec.providerID | contains($ocid)) | .metadata.name' 2>/dev/null)
                    [[ -n "$tk8s_node" ]] && tk8s_status="Yes"
                fi
                
                # Color state
                local tstate_color="$GREEN"
                case "$tstate" in
                    RUNNING) tstate_color="$GREEN" ;;
                    STOPPED) tstate_color="$RED" ;;
                    *) tstate_color="$YELLOW" ;;
                esac
                local tk8s_color="$GRAY"
                [[ "$tk8s_status" == "Yes" ]] && tk8s_color="$YELLOW"
                
                printf "  ${YELLOW}%-5s${NC} %-45s ${tstate_color}%-12s${NC} ${tk8s_color}%-8s${NC} ${GRAY}%-55s${NC}\n" \
                    "$tidx" "${tname:0:45}" "$tstate" "$tk8s_status" "$tocid"
                
                term_valid+=("$tidx|$tocid|$tname|$tstate|$tk8s_status")
            done
            
            [[ ${#term_invalid[@]} -gt 0 ]] && echo -e "${RED}Invalid IDs skipped: ${term_invalid[*]}${NC}"
            
            if [[ ${#term_valid[@]} -eq 0 ]]; then
                echo -e "${RED}No valid instances to terminate${NC}"
                echo ""
                echo -n -e "${CYAN}Press Enter to continue...${NC}"
                read -r
                continue
            fi
            
            # Show warnings
            echo ""
            echo -e "${RED}⚠️  WARNING: This will PERMANENTLY TERMINATE ${#term_valid[@]} instance(s)!${NC}"
            echo -e "${RED}   Boot volumes will also be deleted. This action cannot be undone!${NC}"
            
            # Check if any are K8s nodes
            local k8s_count=0
            for tv in "${term_valid[@]}"; do
                local tv_k8s
                tv_k8s=$(echo "$tv" | cut -d'|' -f5)
                [[ "$tv_k8s" == "Yes" ]] && ((k8s_count++))
            done
            if [[ $k8s_count -gt 0 ]]; then
                echo -e "${YELLOW}   ⚠️  ${k8s_count} instance(s) are Kubernetes nodes - consider draining first!${NC}"
            fi
            
            echo ""
            echo -e "${BOLD}${WHITE}Commands to be executed:${NC}"
            for tv in "${term_valid[@]}"; do
                local tv_idx tv_ocid tv_name
                IFS='|' read -r tv_idx tv_ocid tv_name _ _ <<< "$tv"
                echo -e "  ${GRAY}[${tv_idx}] oci compute instance terminate --instance-id ${tv_ocid} --preserve-boot-volume false --force${NC}"
            done
            echo ""
            echo -n -e "${RED}Type 'TERMINATE' to confirm deletion of ${#term_valid[@]} instance(s): ${NC}"
            local term_confirm
            read -r term_confirm
            
            if [[ "$term_confirm" != "TERMINATE" ]]; then
                echo -e "${YELLOW}Termination cancelled${NC}"
                echo ""
                echo -n -e "${CYAN}Press Enter to continue...${NC}"
                read -r
                continue
            fi
            
            # Execute terminations
            echo ""
            echo -e "${BOLD}${WHITE}═══ Executing Terminations ═══${NC}"
            echo ""
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] ===== BULK TERMINATE: ${#term_valid[@]} instance(s) =====" >> "$term_log_file"
            
            local term_success=0 term_fail=0
            for tv in "${term_valid[@]}"; do
                local tv_idx tv_ocid tv_name tv_state tv_k8s
                IFS='|' read -r tv_idx tv_ocid tv_name tv_state tv_k8s <<< "$tv"
                
                local term_cmd="oci compute instance terminate --instance-id ${tv_ocid} --preserve-boot-volume false --force"
                
                echo -e "${WHITE}[${tv_idx}] ${tv_name}${NC}"
                echo -e "${GRAY}$ ${term_cmd}${NC}"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: ${term_cmd}" >> "$term_log_file"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')]   Instance: ${tv_name} (${tv_state}) K8s=${tv_k8s}" >> "$term_log_file"
                
                if eval "$term_cmd" 2>&1; then
                    echo -e "  ${GREEN}✓ Terminate initiated: ${tv_name}${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Terminated ${tv_name} (${tv_ocid})" >> "$term_log_file"
                    ((term_success++))
                else
                    echo -e "  ${RED}✗ Failed to terminate: ${tv_name}${NC}"
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Terminate ${tv_name} (${tv_ocid})" >> "$term_log_file"
                    ((term_fail++))
                fi
                echo ""
            done
            
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] ===== BULK TERMINATE COMPLETE: Success=${term_success} Failed=${term_fail} Total=${#term_valid[@]} =====" >> "$term_log_file"
            echo ""
            echo -e "${BOLD}${WHITE}═══ Terminate Complete ═══${NC}"
            echo -e "  ${GREEN}Success:${NC} $term_success  ${RED}Failed:${NC} $term_fail  ${WHITE}Total:${NC} ${#term_valid[@]}"
            echo -e "  ${GRAY}Log:${NC} $term_log_file"
            echo ""
            rm -f "$INSTANCE_LIST_CACHE"
            echo -n -e "${CYAN}Press Enter to refresh instance list...${NC}"
            read -r
            continue
        fi
        
        case "$input" in
            properties|PROPERTIES|props|p)
                display_instances_properties_view
                ;;
            bvr|BVR)
                compute_boot_volume_replacement
                ;;
            r|R|refresh|REFRESH)
                rm -f "$INSTANCE_LIST_CACHE"
                echo -e "${YELLOW}Cache cleared, refreshing...${NC}"
                ;;
            quit|QUIT|q|Q|exit|EXIT|back|BACK|b|B)
                return
                ;;
            i[0-9]*)
                local instance_ocid="${INSTANCE_INDEX_MAP[$input]:-}"
                if [[ -z "$instance_ocid" ]]; then
                    echo -e "${RED}Invalid instance ID: $input${NC}"
                    sleep 1
                else
                    # Loop to handle refresh requests
                    while true; do
                        display_instance_details "$instance_ocid"
                        local ret=$?
                        [[ $ret -ne 2 ]] && break  # Exit loop unless refresh requested
                    done
                fi
                ;;
            ocid1.instance.*)
                # Direct OCID input - loop to handle refresh requests
                while true; do
                    display_instance_details "$input"
                    local ret=$?
                    [[ $ret -ne 2 ]] && break  # Exit loop unless refresh requested
                done
                ;;
            *)
                echo -e "${RED}Unknown command: $input${NC}"
                sleep 1
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# Boot Volume Replacement (BVR) - Upgrade OKE nodes without reboot
# Uses: https://github.com/oracle-quickstart/oci-hpc-oke/blob/main/docs/files/bvr-script.py
#--------------------------------------------------------------------------------
compute_boot_volume_replacement() {
    local pre_selected_instance="${1:-}"
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    local log_file="${LOGS_DIR}/bvr_actions.log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    
    echo ""
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${CYAN}                                                    BOOT VOLUME REPLACEMENT (BVR)                                                                       ${NC}"
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${GRAY}Replaces boot volumes on OKE worker nodes to change images or upgrade K8s without rebooting.${NC}"
    echo -e "${GRAY}Source: https://github.com/oracle-quickstart/oci-hpc-oke/blob/main/docs/files/bvr-script.py${NC}"
    echo ""
    
    #==========================================================================
    # Step 0: Ensure uv is installed
    #==========================================================================
    echo -e "${BOLD}${WHITE}─── Checking Prerequisites ───${NC}"
    if ! command -v uv &>/dev/null; then
        # Check if uv is in $HOME/.local/bin (common install path) but not in PATH
        if [[ -f "$HOME/.local/bin/uv" ]]; then
            export PATH="$HOME/.local/bin:$PATH"
            echo -e "  ${GREEN}✓${NC} uv found at $HOME/.local/bin/uv (added to PATH)"
        else
            echo -e "  ${YELLOW}⚠ uv not found - installing...${NC}"
            curl -LsSf https://astral.sh/uv/install.sh | sh 2>/dev/null
            export PATH="$HOME/.local/bin:$PATH"
            if ! command -v uv &>/dev/null; then
                echo -e "  ${RED}✗ Failed to install uv${NC}"
                echo -e "  ${GRAY}Install manually: curl -LsSf https://astral.sh/uv/install.sh | sh${NC}"
                echo -e "Press Enter to continue..."
                read -r
                return
            fi
            echo -e "  ${GREEN}✓${NC} uv installed successfully"
        fi
    else
        echo -e "  ${GREEN}✓${NC} uv $(uv --version 2>/dev/null || echo 'installed')"
    fi
    
    #==========================================================================
    # Step 0b: Ensure bvr-script.py is available
    #==========================================================================
    local bvr_script="${HOME}/bvr-script.py"
    if [[ ! -f "$bvr_script" ]]; then
        echo -e "  ${YELLOW}⚠ bvr-script.py not found - downloading...${NC}"
        curl -sSL "https://raw.githubusercontent.com/oracle-quickstart/oci-hpc-oke/main/docs/files/bvr-script.py" -o "$bvr_script" 2>/dev/null
        if [[ ! -f "$bvr_script" || ! -s "$bvr_script" ]]; then
            echo -e "  ${RED}✗ Failed to download bvr-script.py${NC}"
            echo -e "  ${GRAY}Download manually from: https://github.com/oracle-quickstart/oci-hpc-oke/blob/main/docs/files/bvr-script.py${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
        echo -e "  ${GREEN}✓${NC} bvr-script.py downloaded to ${bvr_script}"
    else
        echo -e "  ${GREEN}✓${NC} bvr-script.py found at ${bvr_script}"
    fi
    echo ""
    
    #==========================================================================
    # Common arrays used downstream
    #==========================================================================
    declare -a BVR_NODE_NAMES=()
    declare -a BVR_NODE_OCIDS=()
    declare -a BVR_NODE_IMAGE_IDS=()
    declare -a BVR_NODE_BV_SIZES=()
    declare -a BVR_NODE_VERSIONS=()
    declare -a selected_indices=()
    local K8S_NODE_NAME=""
    local first_image_id=""
    local first_bv_size=""
    
    if [[ -n "$pre_selected_instance" ]]; then
        #======================================================================
        # Pre-selected instance path (called from instance details view)
        #======================================================================
        echo -e "${BOLD}${WHITE}─── Pre-selected Instance ───${NC}"
        echo ""
        echo -e "${GRAY}Looking up K8s node for instance...${NC}"
        
        # Look up K8s node name from provider ID
        local ps_k8s_node_name=""
        ps_k8s_node_name=$(kubectl get nodes -o json 2>/dev/null | jq -r --arg ocid "$pre_selected_instance" \
            '.items[] | select(.spec.providerID | contains($ocid)) | .metadata.name' 2>/dev/null)
        
        if [[ -z "$ps_k8s_node_name" ]]; then
            echo -e "${RED}This instance is not a Kubernetes node - cannot perform BVR${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
        
        # Fetch instance details from OCI
        local ps_inst_json
        ps_inst_json=$(oci compute instance get --instance-id "$pre_selected_instance" --region "$region" --output json 2>/dev/null)
        
        if [[ -z "$ps_inst_json" ]] || ! echo "$ps_inst_json" | jq -e '.data' &>/dev/null; then
            echo -e "${RED}Failed to fetch instance details${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
        
        local ps_inst_name ps_inst_shape ps_inst_ad ps_inst_image_id ps_kubelet_version
        ps_inst_name=$(echo "$ps_inst_json" | jq -r '.data["display-name"] // "N/A"')
        ps_inst_shape=$(echo "$ps_inst_json" | jq -r '.data.shape // "N/A"')
        ps_inst_ad=$(echo "$ps_inst_json" | jq -r '.data["availability-domain"] // "N/A"')
        ps_inst_image_id=$(echo "$ps_inst_json" | jq -r '.data["image-id"] // ""')
        
        # Get K8s version
        ps_kubelet_version=$(kubectl get node "$ps_k8s_node_name" -o jsonpath='{.status.nodeInfo.kubeletVersion}' 2>/dev/null || echo "N/A")
        
        # Get boot volume size
        local ps_bv_size="N/A"
        local ps_bv_attach_json ps_bv_id
        ps_bv_attach_json=$(oci compute boot-volume-attachment list \
            --compartment-id "$compartment_id" \
            --availability-domain "$ps_inst_ad" \
            --instance-id "$pre_selected_instance" \
            --output json 2>/dev/null)
        ps_bv_id=$(echo "$ps_bv_attach_json" | jq -r '.data[0]["boot-volume-id"] // empty' 2>/dev/null)
        if [[ -n "$ps_bv_id" && "$ps_bv_id" != "null" ]]; then
            ps_bv_size=$(oci bv boot-volume get --boot-volume-id "$ps_bv_id" \
                --query 'data."size-in-gbs"' --raw-output 2>/dev/null || echo "N/A")
        fi
        
        # Populate arrays with single entry
        BVR_NODE_NAMES=("$ps_k8s_node_name")
        BVR_NODE_OCIDS=("$pre_selected_instance")
        BVR_NODE_IMAGE_IDS=("${ps_inst_image_id:-}")
        BVR_NODE_BV_SIZES=("${ps_bv_size:-N/A}")
        BVR_NODE_VERSIONS=("$ps_kubelet_version")
        selected_indices=(1)
        
        K8S_NODE_NAME="$ps_k8s_node_name"
        first_image_id="${ps_inst_image_id:-}"
        first_bv_size="${ps_bv_size:-N/A}"
        
        echo -e "${CYAN}Instance:${NC}    ${WHITE}$ps_inst_name${NC}"
        echo -e "${CYAN}OCID:${NC}        ${YELLOW}$pre_selected_instance${NC}"
        echo -e "${CYAN}K8s Node:${NC}    ${WHITE}$ps_k8s_node_name${NC}"
        echo -e "${CYAN}Shape:${NC}       ${WHITE}$ps_inst_shape${NC}"
        echo -e "${CYAN}Boot Vol:${NC}    ${WHITE}${ps_bv_size} GB${NC}"
        echo -e "${CYAN}K8s Version:${NC} ${WHITE}$ps_kubelet_version${NC}"
        echo -e "${CYAN}AD:${NC}          ${WHITE}${ps_inst_ad##*:}${NC}"
        echo ""
        
    else
        #======================================================================
        # Full listing path (instance-first, matching --manage 5 pattern)
        #======================================================================
        echo -e "${BOLD}${WHITE}─── K8s Worker Nodes ───${NC}"
        echo ""
        echo -e "${GRAY}Fetching instances and K8s node data...${NC}"
        
        # Fetch all instances from OCI
        local bvr_instances_json
        bvr_instances_json=$(oci compute instance list \
            --compartment-id "$compartment_id" \
            --region "$region" \
            --all \
            --output json 2>/dev/null)
        
        if [[ -z "$bvr_instances_json" ]] || ! echo "$bvr_instances_json" | jq -e '.data' &>/dev/null; then
            echo -e "${RED}Failed to fetch instances from OCI${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
        
        # Fetch K8s nodes
        local bvr_k8s_nodes_json
        bvr_k8s_nodes_json=$(kubectl get nodes -o json 2>/dev/null)
        
        if [[ -z "$bvr_k8s_nodes_json" ]] || ! echo "$bvr_k8s_nodes_json" | jq -e '.items[0]' &>/dev/null; then
            echo -e "${RED}Failed to fetch K8s nodes - ensure kubectl is configured${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
        
        # Build K8s lookup: providerID → node_name|ready_status|kubelet_version|unschedulable|newNodeTaint
        local bvr_k8s_lookup
        bvr_k8s_lookup=$(echo "$bvr_k8s_nodes_json" | jq -r '
            .items[] |
            (.spec.taints // [] | map(select(.key == "newNode")) | if length > 0 then .[0].effect else "N/A" end) as $newNodeTaint |
            (.spec.unschedulable // false) as $unschedulable |
            "\(.spec.providerID // "")|\(.metadata.name)|\(.status.conditions[] | select(.type=="Ready") | .status)|\(.status.nodeInfo.kubeletVersion // "N/A")|\($unschedulable)|\($newNodeTaint)"
        ' 2>/dev/null)
        
        # Fetch pods per node for pod count
        local bvr_pods_per_node
        bvr_pods_per_node=$(kubectl get pods --all-namespaces --field-selector=status.phase=Running -o json 2>/dev/null | \
            jq -r '.items[] | .spec.nodeName' 2>/dev/null | sort | uniq -c | awk '{print $2"|"$1}')
        
        local bvr_idx=0
        
        echo ""
        printf "  ${BOLD}%-4s %-50s %-10s %-8s %-8s %-22s %-14s %-12s %-5s %-10s${NC}\n" \
            "#" "Display Name" "State" "K8s" "Cordon" "Shape" "Boot Vol (GB)" "K8s Version" "Pods" "AD"
        print_separator 155
        
        # Loop through OCI instances, only show those in K8s
        while IFS='|' read -r bvr_inst_id bvr_inst_name bvr_inst_state bvr_inst_shape bvr_inst_ad bvr_inst_image_id; do
            [[ -z "$bvr_inst_id" ]] && continue
            [[ "$bvr_inst_state" == "TERMINATED" ]] && continue
            
            # Check if this instance is a K8s node
            local bvr_k8s_match
            bvr_k8s_match=$(echo "$bvr_k8s_lookup" | grep "$bvr_inst_id" 2>/dev/null)
            [[ -z "$bvr_k8s_match" ]] && continue
            
            # Extract K8s data
            local bvr_k8s_node_name bvr_k8s_ready bvr_kubelet_version bvr_k8s_unschedulable bvr_k8s_taint
            bvr_k8s_node_name=$(echo "$bvr_k8s_match" | cut -d'|' -f2)
            bvr_k8s_ready=$(echo "$bvr_k8s_match" | cut -d'|' -f3)
            bvr_kubelet_version=$(echo "$bvr_k8s_match" | cut -d'|' -f4)
            bvr_k8s_unschedulable=$(echo "$bvr_k8s_match" | cut -d'|' -f5)
            bvr_k8s_taint=$(echo "$bvr_k8s_match" | cut -d'|' -f6)
            
            ((bvr_idx++))
            BVR_NODE_NAMES+=("$bvr_k8s_node_name")
            BVR_NODE_OCIDS+=("$bvr_inst_id")
            BVR_NODE_IMAGE_IDS+=("${bvr_inst_image_id:-}")
            BVR_NODE_VERSIONS+=("$bvr_kubelet_version")
            
            # Get boot volume size
            local bvr_inst_bv_size="N/A"
            local bvr_bv_attach_json=""
            bvr_bv_attach_json=$(oci compute boot-volume-attachment list \
                --compartment-id "$compartment_id" \
                --availability-domain "$bvr_inst_ad" \
                --instance-id "$bvr_inst_id" \
                --output json 2>/dev/null)
            local bvr_bv_id=""
            bvr_bv_id=$(echo "$bvr_bv_attach_json" | jq -r '.data[0]["boot-volume-id"] // empty' 2>/dev/null)
            if [[ -n "$bvr_bv_id" && "$bvr_bv_id" != "null" ]]; then
                bvr_inst_bv_size=$(oci bv boot-volume get --boot-volume-id "$bvr_bv_id" \
                    --query 'data."size-in-gbs"' --raw-output 2>/dev/null || echo "N/A")
            fi
            BVR_NODE_BV_SIZES+=("${bvr_inst_bv_size:-N/A}")
            
            # Color state
            local bvr_state_color="$GREEN"
            case "$bvr_inst_state" in
                RUNNING) bvr_state_color="$GREEN" ;;
                STOPPED) bvr_state_color="$RED" ;;
                STARTING|STOPPING) bvr_state_color="$YELLOW" ;;
                *) bvr_state_color="$WHITE" ;;
            esac
            
            # K8s ready color
            local bvr_ready_color="$GREEN"
            local bvr_ready_display="Ready"
            if [[ "$bvr_k8s_ready" != "True" ]]; then
                bvr_ready_color="$RED"
                bvr_ready_display="NotRdy"
            fi
            
            # Cordon status
            local bvr_cordon_status="-"
            local bvr_cordon_color="$GRAY"
            if [[ "$bvr_k8s_unschedulable" == "true" ]]; then
                bvr_cordon_status="Yes"
                bvr_cordon_color="$YELLOW"
            fi
            
            # Pod count
            local bvr_pod_count="-"
            local bvr_pod_color="$GRAY"
            local bvr_node_pods
            bvr_node_pods=$(echo "$bvr_pods_per_node" | grep "^${bvr_k8s_node_name}|" | cut -d'|' -f2)
            if [[ -n "$bvr_node_pods" ]]; then
                bvr_pod_count="$bvr_node_pods"
                bvr_pod_color="$CYAN"
            fi
            
            local bvr_ad_short="${bvr_inst_ad##*:}"
            
            printf "  ${YELLOW}%-4s${NC} %-50s ${bvr_state_color}%-10s${NC} ${bvr_ready_color}%-8s${NC} ${bvr_cordon_color}%-8s${NC} %-22s %-14s %-12s ${bvr_pod_color}%-5s${NC} %-10s\n" \
                "$bvr_idx" "$bvr_inst_name" "$bvr_inst_state" "$bvr_ready_display" "$bvr_cordon_status" \
                "${bvr_inst_shape:0:22}" "$bvr_inst_bv_size" "$bvr_kubelet_version" "$bvr_pod_count" "$bvr_ad_short"
                
        done < <(echo "$bvr_instances_json" | jq -r '
            .data[] |
            "\(.id)|\(.["display-name"] // "Unnamed")|\(.["lifecycle-state"])|\(.shape // "N/A")|\(.["availability-domain"] // "N/A")|\(.["image-id"] // "")"
        ' 2>/dev/null | sort -t'|' -k2,2)
        
        echo ""
        
        if [[ $bvr_idx -eq 0 ]]; then
            echo -e "${RED}No K8s nodes found with valid instance OCIDs in this compartment${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
        
        #======================================================================
        # Step 2: Select nodes
        #======================================================================
        echo -e "${BOLD}${WHITE}─── Select Nodes ───${NC}"
        echo -e "${GRAY}Enter node numbers: 1,3,5  or  1-5  or  all${NC}"
        echo ""
        echo -n -e "${CYAN}Select nodes: ${NC}"
        read -r node_selection
        
        if [[ -z "$node_selection" ]]; then
            echo -e "${YELLOW}No nodes selected - cancelled${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
        
        # Parse selection into indices
        if [[ "$node_selection" == "all" || "$node_selection" == "ALL" ]]; then
            for ((si=1; si<=bvr_idx; si++)); do
                selected_indices+=("$si")
            done
        else
            # Handle comma-separated and range notation
            IFS=',' read -ra parts <<< "$node_selection"
            for part in "${parts[@]}"; do
                part=$(echo "$part" | tr -d ' ')
                if [[ "$part" =~ ^([0-9]+)-([0-9]+)$ ]]; then
                    local range_start="${BASH_REMATCH[1]}"
                    local range_end="${BASH_REMATCH[2]}"
                    for ((ri=range_start; ri<=range_end; ri++)); do
                        [[ $ri -ge 1 && $ri -le $bvr_idx ]] && selected_indices+=("$ri")
                    done
                elif [[ "$part" =~ ^[0-9]+$ ]]; then
                    [[ $part -ge 1 && $part -le $bvr_idx ]] && selected_indices+=("$part")
                fi
            done
        fi
        
        if [[ ${#selected_indices[@]} -eq 0 ]]; then
            echo -e "${RED}No valid nodes selected${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
        
        # Build the K8S_NODE_NAME string
        echo ""
        echo -e "${BOLD}${WHITE}Selected nodes:${NC}"
        for si in "${selected_indices[@]}"; do
            local idx=$((si - 1))
            local nname="${BVR_NODE_NAMES[$idx]}"
            echo -e "  ${GREEN}•${NC} ${WHITE}$nname${NC}"
            if [[ -n "$K8S_NODE_NAME" ]]; then
                K8S_NODE_NAME+=" $nname"
            else
                K8S_NODE_NAME="$nname"
                first_image_id="${BVR_NODE_IMAGE_IDS[$idx]}"
                first_bv_size="${BVR_NODE_BV_SIZES[$idx]}"
            fi
        done
        echo ""
    fi
    
    #==========================================================================
    # Step 3: Compartment
    #==========================================================================
    local comp_name
    comp_name=$(resolve_compartment_name "$compartment_id")
    echo -e "${CYAN}Compartment:${NC} ${WHITE}$comp_name${NC} ${GRAY}($compartment_id)${NC}"
    echo -n -e "${CYAN}Use this compartment? (Y/n): ${NC}"
    read -r comp_confirm
    if [[ "$comp_confirm" == "n" || "$comp_confirm" == "N" ]]; then
        echo -n -e "${CYAN}Enter compartment OCID: ${NC}"
        read -r compartment_id
        if [[ -z "$compartment_id" ]]; then
            echo -e "${RED}No compartment provided - cancelled${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
    fi
    echo ""
    
    #==========================================================================
    # Step 4: Region
    #==========================================================================
    echo -e "${CYAN}Region:${NC} ${WHITE}$region${NC}"
    echo -n -e "${CYAN}Use this region? (Y/n): ${NC}"
    read -r region_confirm
    if [[ "$region_confirm" == "n" || "$region_confirm" == "N" ]]; then
        echo -n -e "${CYAN}Enter region (e.g., us-ashburn-1): ${NC}"
        read -r region
        if [[ -z "$region" ]]; then
            echo -e "${RED}No region provided - cancelled${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
    fi
    echo ""
    
    #==========================================================================
    # Step 5: Select custom image
    #==========================================================================
    echo -e "${BOLD}${WHITE}─── Select Image ───${NC}"
    echo -e "${GRAY}Fetching custom images from compartment...${NC}"
    
    # Get current image name for display
    local current_image_name="N/A"
    if [[ -n "$first_image_id" && "$first_image_id" != "null" ]]; then
        current_image_name=$(oci compute image get --image-id "$first_image_id" --region "$region" \
            --query 'data."display-name"' --raw-output 2>/dev/null || echo "N/A")
    fi
    
    # Fetch all images in the compartment
    local images_json
    images_json=$(oci compute image list --compartment-id "$compartment_id" --region "$region" --all --output json 2>/dev/null)
    
    local custom_images_json='{\"data\":[]}'
    if [[ -n "$images_json" ]] && echo "$images_json" | jq -e '.data' &>/dev/null; then
        custom_images_json=$(echo "$images_json" | jq --arg comp "$compartment_id" \
            '{data: [.data[] | select(.["compartment-id"] == $comp and .["lifecycle-state"] == "AVAILABLE")]}' 2>/dev/null)
    fi
    
    local img_count=0
    img_count=$(echo "$custom_images_json" | jq '.data | length' 2>/dev/null || echo "0")
    
    declare -A BVR_IMAGE_MAP=()
    local img_idx=0
    
    echo ""
    if [[ "$img_count" -gt 0 ]]; then
        printf "  ${BOLD}%-4s %-80s %-25s${NC}\n" "#" "Image Name" "OS"
        print_separator 120
        
        while IFS='|' read -r img_id img_name img_os; do
            [[ -z "$img_id" ]] && continue
            ((img_idx++))
            BVR_IMAGE_MAP[$img_idx]="$img_id"
            
            # Mark the current image
            local marker=""
            if [[ "$img_id" == "$first_image_id" ]]; then
                marker=" ${YELLOW}← current${NC}"
            fi
            
            printf "  ${YELLOW}%-4s${NC} %-80s %-25s%b\n" \
                "$img_idx" "$img_name" "$img_os" "$marker"
        done < <(echo "$custom_images_json" | jq -r '.data[] | "\(.id)|\(.["display-name"] // "Unnamed")|\(.["operating-system"] // "N/A")"' 2>/dev/null)
    fi
    
    echo ""
    if [[ -n "$first_image_id" && "$first_image_id" != "null" ]]; then
        echo -e "${GRAY}Current image: ${WHITE}$current_image_name${NC} ${YELLOW}($first_image_id)${NC}"
    fi
    echo -e "${GRAY}Press Enter to keep current image, or enter a number or paste an image OCID${NC}"
    echo -n -e "${CYAN}Select image [keep current]: ${NC}"
    read -r img_choice
    
    local selected_image_id="$first_image_id"
    local selected_image_name="$current_image_name"
    if [[ -n "$img_choice" ]]; then
        if [[ "$img_choice" =~ ^[0-9]+$ && -n "${BVR_IMAGE_MAP[$img_choice]}" ]]; then
            selected_image_id="${BVR_IMAGE_MAP[$img_choice]}"
            selected_image_name=$(echo "$custom_images_json" | jq -r --arg id "$selected_image_id" \
                '.data[] | select(.id == $id) | .["display-name"] // "N/A"' 2>/dev/null)
        elif [[ "$img_choice" =~ ^ocid1\.image\. ]]; then
            selected_image_id="$img_choice"
            selected_image_name=$(oci compute image get --image-id "$selected_image_id" --region "$region" \
                --query 'data."display-name"' --raw-output 2>/dev/null || echo "Custom OCID")
        else
            echo -e "${RED}Invalid selection - using current image${NC}"
        fi
    fi
    
    if [[ -z "$selected_image_id" || "$selected_image_id" == "null" ]]; then
        echo -e "${RED}No image selected and no current image found - cannot proceed${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    echo ""
    
    #==========================================================================
    # Step 6: Boot volume size
    #==========================================================================
    echo -e "${BOLD}${WHITE}─── Boot Volume Size ───${NC}"
    echo -e "${CYAN}Current boot volume size:${NC} ${WHITE}${first_bv_size:-N/A} GB${NC}"
    echo -n -e "${CYAN}Change boot volume size? (y/N): ${NC}"
    read -r change_bv
    
    local bv_size_param=""
    if [[ "$change_bv" == "y" || "$change_bv" == "Y" ]]; then
        echo -n -e "${CYAN}Enter new boot volume size in GB: ${NC}"
        read -r new_bv_size
        if [[ -n "$new_bv_size" && "$new_bv_size" =~ ^[0-9]+$ ]]; then
            bv_size_param="--bv-size $new_bv_size"
        else
            echo -e "${YELLOW}Invalid size - keeping current boot volume size${NC}"
        fi
    fi
    echo ""
    
    #==========================================================================
    # Step 7: Desired K8s version
    #==========================================================================
    echo -e "${BOLD}${WHITE}─── K8s Version ───${NC}"
    
    # Get current cluster version and available versions
    local cluster_ocid=""
    cluster_ocid=$(get_oke_env_value "OKE_CLUSTER_ID" 2>/dev/null)
    local current_k8s_version=""
    
    declare -a available_versions=()
    if [[ -n "$cluster_ocid" && "$cluster_ocid" != "N/A" ]]; then
        current_k8s_version=$(oci ce cluster get --cluster-id "$cluster_ocid" --region "$region" \
            --query 'data."kubernetes-version"' --raw-output 2>/dev/null || echo "")
        
        # Get available versions from cluster-options
        local options_json
        options_json=$(oci ce cluster-options get --cluster-option-id all --output json 2>/dev/null)
        if [[ -n "$options_json" ]]; then
            while read -r ver; do
                [[ -n "$ver" ]] && available_versions+=("$ver")
            done < <(echo "$options_json" | jq -r '(.data["kubernetes-versions"] // [])[]' 2>/dev/null | sort -V)
        fi
    fi
    
    echo -e "${CYAN}Current cluster version:${NC} ${WHITE}${current_k8s_version:-N/A}${NC}"
    echo -e "${CYAN}Node kubelet versions:${NC}  ${WHITE}${BVR_NODE_VERSIONS[0]:-N/A}${NC}"
    
    local k8s_version_param=""
    if [[ ${#available_versions[@]} -gt 0 ]]; then
        echo ""
        echo -e "${GRAY}Available K8s versions:${NC}"
        local ver_idx=0
        declare -A BVR_VER_MAP=()
        for ver in "${available_versions[@]}"; do
            ((ver_idx++))
            BVR_VER_MAP[$ver_idx]="$ver"
            local ver_marker=""
            [[ "$ver" == "$current_k8s_version" ]] && ver_marker=" ${YELLOW}← cluster${NC}"
            printf "  ${YELLOW}%-3s${NC}) ${WHITE}%-15s${NC}%b\n" "$ver_idx" "$ver" "$ver_marker"
        done
        echo ""
        echo -e "${GRAY}Press Enter to skip (no version change), or select a version number${NC}"
        echo -n -e "${CYAN}Desired K8s version [skip]: ${NC}"
        read -r ver_choice
        
        if [[ -n "$ver_choice" ]]; then
            local chosen_ver=""
            if [[ "$ver_choice" =~ ^[0-9]+$ && -n "${BVR_VER_MAP[$ver_choice]}" ]]; then
                chosen_ver="${BVR_VER_MAP[$ver_choice]}"
            elif [[ "$ver_choice" =~ ^v?[0-9]+\.[0-9]+ ]]; then
                chosen_ver="$ver_choice"
            fi
            if [[ -n "$chosen_ver" ]]; then
                # Ensure it starts with v
                [[ "$chosen_ver" != v* ]] && chosen_ver="v$chosen_ver"
                k8s_version_param="--desired-k8s-version $chosen_ver"
                echo -e "  ${GREEN}✓${NC} Will upgrade nodes to ${WHITE}$chosen_ver${NC}"
            fi
        fi
    else
        echo -e "${GRAY}Could not fetch available versions - you can enter manually${NC}"
        echo -n -e "${CYAN}Desired K8s version (e.g., v1.33.1) [skip]: ${NC}"
        read -r manual_ver
        if [[ -n "$manual_ver" ]]; then
            [[ "$manual_ver" != v* ]] && manual_ver="v$manual_ver"
            k8s_version_param="--desired-k8s-version $manual_ver"
        fi
    fi
    echo ""
    
    #==========================================================================
    # Step 8: Previous boot volume removal preference
    #==========================================================================
    echo -e "${BOLD}${WHITE}─── Post-Replacement Cleanup ───${NC}"
    echo -n -e "${CYAN}Remove previous boot volume after replacement? (y/N): ${NC}"
    read -r remove_bv_pref
    local remove_old_bv=false
    [[ "$remove_bv_pref" == "y" || "$remove_bv_pref" == "Y" ]] && remove_old_bv=true
    echo ""
    
    #==========================================================================
    # Step 9: Build and confirm command
    #==========================================================================
    local cmd="uv run ${bvr_script}"
    cmd+=" -c $compartment_id"
    cmd+=" --auth instance_principal"
    cmd+=" --image-ocid $selected_image_id"
    cmd+=" --region $region"
    [[ -n "$bv_size_param" ]] && cmd+=" $bv_size_param"
    [[ -n "$k8s_version_param" ]] && cmd+=" $k8s_version_param"
    cmd+=" --timeout-seconds 1200"
    cmd+=" $K8S_NODE_NAME"
    
    echo -e "${BOLD}${WHITE}═══════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${WHITE}                         CONFIRM BOOT VOLUME REPLACEMENT                        ${NC}"
    echo -e "${BOLD}${WHITE}═══════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "  ${CYAN}Nodes:${NC}          ${WHITE}$K8S_NODE_NAME${NC}"
    echo -e "  ${CYAN}Compartment:${NC}    ${WHITE}$(resolve_compartment_name "$compartment_id")${NC}"
    echo -e "  ${CYAN}Region:${NC}         ${WHITE}$region${NC}"
    echo -e "  ${CYAN}Image:${NC}          ${WHITE}$selected_image_name${NC}"
    echo -e "                  ${YELLOW}($selected_image_id)${NC}"
    if [[ -n "$bv_size_param" ]]; then
        echo -e "  ${CYAN}Boot Vol Size:${NC}  ${WHITE}${bv_size_param##* } GB${NC} ${YELLOW}(changed)${NC}"
    else
        echo -e "  ${CYAN}Boot Vol Size:${NC}  ${WHITE}${first_bv_size:-N/A} GB${NC} ${GRAY}(unchanged)${NC}"
    fi
    if [[ -n "$k8s_version_param" ]]; then
        echo -e "  ${CYAN}K8s Version:${NC}    ${WHITE}${k8s_version_param##* }${NC} ${YELLOW}(upgrade)${NC}"
    else
        echo -e "  ${CYAN}K8s Version:${NC}    ${GRAY}(no change)${NC}"
    fi
    echo -e "  ${CYAN}Remove Old BV:${NC}  ${WHITE}$remove_old_bv${NC}"
    echo ""
    echo -e "${BOLD}${WHITE}Command to execute:${NC}"
    echo -e "${GRAY}$cmd${NC}"
    echo ""
    echo -n -e "${BOLD}${YELLOW}⚠ This will replace boot volumes on ${#selected_indices[@]} node(s). Proceed? (y/N): ${NC}"
    read -r final_confirm
    
    if [[ "$final_confirm" != "y" && "$final_confirm" != "Y" ]]; then
        echo -e "${YELLOW}BVR cancelled${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    #==========================================================================
    # Step 10: Execute BVR
    #==========================================================================
    echo ""
    echo -e "${BOLD}${WHITE}═══ Executing Boot Volume Replacement ═══${NC}"
    echo ""
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: $cmd" >> "$log_file"
    echo -e "${WHITE}$ ${cmd}${NC}"
    echo ""
    
    # Run BVR with live elapsed timer
    run_with_elapsed_timer "$cmd" "$log_file"
    local bvr_exit_code=$?
    
    echo ""
    if [[ $bvr_exit_code -eq 0 ]]; then
        echo -e "${GREEN}═══ Boot Volume Replacement Completed Successfully ═══${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: BVR completed for nodes: $K8S_NODE_NAME" >> "$log_file"
        
        #==================================================================
        # Post-execution: Handle old boot volumes
        #==================================================================
        echo ""
        echo -e "${BOLD}${YELLOW}⚠ NOTE: The previous boot volume(s) from the replaced node(s) still exist.${NC}"
        echo -e "${GRAY}These boot volumes are detached but not deleted. They will continue to incur storage costs.${NC}"
        echo ""
        
        if [[ "$remove_old_bv" == "true" ]]; then
            echo -e "${YELLOW}You opted to remove old boot volumes.${NC}"
            echo -e "${GRAY}Searching for detached boot volumes...${NC}"
            echo ""
            
            # For each selected node, find any AVAILABLE (detached) boot volumes
            for si in "${selected_indices[@]}"; do
                local nidx=$((si - 1))
                local nname="${BVR_NODE_NAMES[$nidx]}"
                local nocid="${BVR_NODE_OCIDS[$nidx]}"
                
                # List boot volumes that might be from this instance (AVAILABLE = detached)
                local old_bvs
                old_bvs=$(oci bv boot-volume list --compartment-id "$compartment_id" --all --output json 2>/dev/null | \
                    jq -r --arg name "$nname" '.data[] | select(.["lifecycle-state"] == "AVAILABLE") | select(.["display-name"] | contains($name)) | "\(.id)|\(.["display-name"])|\(.["size-in-gbs"])"' 2>/dev/null)
                
                if [[ -n "$old_bvs" ]]; then
                    echo -e "${WHITE}Node: ${NC}${CYAN}$nname${NC}"
                    while IFS='|' read -r old_bv_id old_bv_name old_bv_gb; do
                        [[ -z "$old_bv_id" ]] && continue
                        echo -e "  ${GRAY}Found: ${WHITE}$old_bv_name${NC} (${old_bv_gb} GB) ${YELLOW}$old_bv_id${NC}"
                        echo -n -e "  ${RED}Delete this boot volume? (y/N): ${NC}"
                        read -r del_confirm
                        if [[ "$del_confirm" == "y" || "$del_confirm" == "Y" ]]; then
                            local del_cmd="oci bv boot-volume delete --boot-volume-id $old_bv_id --force"
                            echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: $del_cmd" >> "$log_file"
                            echo -e "  ${WHITE}$ ${del_cmd}${NC}"
                            eval "$del_cmd" 2>&1
                            if [[ $? -eq 0 ]]; then
                                echo -e "  ${GREEN}✓ Boot volume deleted${NC}"
                                echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted old boot volume $old_bv_id" >> "$log_file"
                            else
                                echo -e "  ${RED}✗ Failed to delete boot volume${NC}"
                                echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Delete boot volume $old_bv_id" >> "$log_file"
                            fi
                        else
                            echo -e "  ${GRAY}Skipped${NC}"
                        fi
                    done <<< "$old_bvs"
                    echo ""
                fi
            done
        else
            echo -e "${GRAY}To clean up old boot volumes later, use:${NC}"
            echo -e "${GRAY}  oci bv boot-volume list --compartment-id $compartment_id --lifecycle-state AVAILABLE${NC}"
            echo -e "${GRAY}  oci bv boot-volume delete --boot-volume-id <ocid> --force${NC}"
        fi
    else
        echo -e "${RED}═══ Boot Volume Replacement Failed (exit code: $bvr_exit_code) ═══${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: BVR exit code $bvr_exit_code for nodes: $K8S_NODE_NAME" >> "$log_file"
    fi
    
    echo ""
    echo -e "${GRAY}Log: $log_file${NC}"
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Display all instances with OCI properties in consolidated view
# Shows: Name, State, Shape config, Boot Vol, Image, Oracle-Tags, Cloud-Init
# Uses parallel fetching and caching for boot volumes and images
#--------------------------------------------------------------------------------
display_instances_properties_view() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    local max_parallel=10  # Max parallel API calls
    
    echo ""
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${GREEN}                                                                                    INSTANCE PROPERTIES VIEW                                                                                          ${NC}"
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    _display_cache_info \
        "${BOOT_VOLUME_CACHE}|Boot Volumes" \
        "${IMAGE_CACHE}|Images"
    echo ""
    local cache_max_age=3600
    local bv_cache_valid=false
    local img_cache_valid=false
    
    if [[ -f "$BOOT_VOLUME_CACHE" ]]; then
        local cache_age=$(($(date +%s) - $(stat -c %Y "$BOOT_VOLUME_CACHE" 2>/dev/null || echo 0)))
        [[ $cache_age -lt $cache_max_age ]] && bv_cache_valid=true
    fi
    if [[ -f "$IMAGE_CACHE" ]]; then
        local cache_age=$(($(date +%s) - $(stat -c %Y "$IMAGE_CACHE" 2>/dev/null || echo 0)))
        [[ $cache_age -lt $cache_max_age ]] && img_cache_valid=true
    fi
    
    echo -e "${YELLOW}Fetching instances...${NC}"
    
    # Fetch all instances with full details
    local instances_json
    instances_json=$(oci compute instance list \
        --compartment-id "$compartment_id" \
        --region "$region" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$instances_json" ]] || ! echo "$instances_json" | jq -e '.data[]' > /dev/null 2>&1; then
        echo -e "${RED}No instances found${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # Count instances
    local total_count
    total_count=$(echo "$instances_json" | jq '[.data[] | select(.["lifecycle-state"] != "TERMINATED")] | length')
    echo -e "${GREEN}Found ${total_count} instances${NC}"
    
    # Extract unique image IDs and instance OCIDs for parallel fetching
    local unique_images unique_instances
    unique_images=$(echo "$instances_json" | jq -r '.data[] | select(.["lifecycle-state"] != "TERMINATED") | .["image-id"] // empty' | sort -u | grep -v '^$')
    unique_instances=$(echo "$instances_json" | jq -r '.data[] | select(.["lifecycle-state"] != "TERMINATED") | "\(.id)|\(.["availability-domain"])"')
    
    # ========== PARALLEL BOOT VOLUME FETCHING ==========
    if [[ "$bv_cache_valid" == "true" ]]; then
        echo -e "${CYAN}Using cached boot volume data (< 1 hour old)${NC}"
    else
        echo -e "${YELLOW}Fetching boot volumes in parallel...${NC}"
        
        # Create temp directory for parallel results
        local tmp_bv_dir="${TEMP_DIR}/bv_fetch_$$"
        mkdir -p "$tmp_bv_dir"
        
        local bv_count=0
        local bv_total
        bv_total=$(echo "$unique_instances" | grep -c . 2>/dev/null) || bv_total=0
        [[ ! "$bv_total" =~ ^[0-9]+$ ]] && bv_total=0
        
        # Fetch boot volume attachments and details in parallel
        while IFS='|' read -r inst_ocid inst_ad; do
            [[ -z "$inst_ocid" ]] && continue
            
            # Run in background
            (
                # Get boot volume attachment - try with instance's compartment first
                local bv_attach_json
                bv_attach_json=$(oci compute boot-volume-attachment list \
                    --compartment-id "$compartment_id" \
                    --availability-domain "$inst_ad" \
                    --instance-id "$inst_ocid" \
                    --output json 2>/dev/null)
                
                local bv_id
                bv_id=$(echo "$bv_attach_json" | jq -r '.data[0]["boot-volume-id"] // empty' 2>/dev/null)
                
                if [[ -n "$bv_id" && "$bv_id" != "null" && "$bv_id" != "None" && "$bv_id" != "" ]]; then
                    # Get boot volume details using size-in-gbs and vpus-per-gb
                    local bv_json
                    bv_json=$(oci bv boot-volume get --boot-volume-id "$bv_id" --output json 2>/dev/null)
                    
                    if [[ -n "$bv_json" ]]; then
                        local bv_size bv_vpus
                        bv_size=$(echo "$bv_json" | jq -r '.data["size-in-gbs"] // empty' 2>/dev/null)
                        bv_vpus=$(echo "$bv_json" | jq -r '.data["vpus-per-gb"] // empty' 2>/dev/null)
                        
                        # Only write if we got values
                        if [[ -n "$bv_size" && "$bv_size" != "null" ]]; then
                            [[ -z "$bv_vpus" || "$bv_vpus" == "null" ]] && bv_vpus="-"
                            echo "${inst_ocid}|${bv_size}|${bv_vpus}" > "${tmp_bv_dir}/${inst_ocid##*.}"
                        fi
                    fi
                fi
            ) &
            
            ((bv_count++))
            
            # Limit parallel jobs
            if (( bv_count % max_parallel == 0 )); then
                wait
                printf "\r${GRAY}  Boot volumes: %d/%d${NC}          " "$bv_count" "$bv_total"
            fi
        done <<< "$unique_instances"
        
        # Wait for remaining jobs
        wait
        printf "\r${GRAY}  Boot volumes: %d/%d - Done${NC}          \n" "$bv_total" "$bv_total"
        
        # Consolidate results into cache
        if [[ -d "$tmp_bv_dir" ]] && ls "${tmp_bv_dir}"/* >/dev/null 2>&1; then
            cat "${tmp_bv_dir}"/* > "$BOOT_VOLUME_CACHE" 2>/dev/null
            local cached_count
            cached_count=$(wc -l < "$BOOT_VOLUME_CACHE" 2>/dev/null || echo 0)
            echo -e "${GREEN}  Cached ${cached_count} boot volumes${NC}"
        else
            echo -e "${YELLOW}  No boot volume data retrieved${NC}"
        fi
        rm -rf "$tmp_bv_dir"
    fi
    
    # ========== PARALLEL IMAGE FETCHING ==========
    if [[ "$img_cache_valid" == "true" ]]; then
        echo -e "${CYAN}Using cached image data (< 1 hour old)${NC}"
    else
        echo -e "${YELLOW}Fetching images in parallel...${NC}"
        
        local tmp_img_dir="${TEMP_DIR}/img_fetch_$$"
        mkdir -p "$tmp_img_dir"
        
        local img_count=0
        local img_total
        img_total=$(echo "$unique_images" | wc -l)
        
        while read -r image_id; do
            [[ -z "$image_id" ]] && continue
            
            # Check if already in cache
            if grep -q "^${image_id}|" "$IMAGE_CACHE" 2>/dev/null; then
                ((img_count++))
                continue
            fi
            
            # Run in background
            (
                local img_name
                img_name=$(oci compute image get --image-id "$image_id" \
                    --query 'data."display-name"' --raw-output 2>/dev/null) || img_name="-"
                echo "${image_id}|${img_name}" > "${tmp_img_dir}/${image_id##*.}"
            ) &
            
            ((img_count++))
            
            # Limit parallel jobs
            if (( img_count % max_parallel == 0 )); then
                wait
                printf "\r${GRAY}  Images: %d/%d${NC}          " "$img_count" "$img_total"
            fi
        done <<< "$unique_images"
        
        # Wait for remaining jobs
        wait
        printf "\r${GRAY}  Images: %d/%d - Done${NC}          \n" "$img_total" "$img_total"
        
        # Consolidate results into cache (append new entries)
        if [[ -d "$tmp_img_dir" ]]; then
            cat "${tmp_img_dir}"/* >> "$IMAGE_CACHE" 2>/dev/null
            rm -rf "$tmp_img_dir"
        fi
    fi
    
    # ========== BUILD DISPLAY DATA ==========
    echo -e "${YELLOW}Building display...${NC}"
    
    local tmp_data="${TEMP_DIR}/instance_props_$$"
    rm -f "$tmp_data"
    
    # Load caches into associative arrays for fast lookup
    declare -A BV_CACHE_MAP
    declare -A IMG_CACHE_MAP
    
    if [[ -f "$BOOT_VOLUME_CACHE" && -s "$BOOT_VOLUME_CACHE" ]]; then
        local bv_loaded=0
        while IFS='|' read -r inst_id bv_sz bv_vp; do
            if [[ -n "$inst_id" && -n "$bv_sz" ]]; then
                BV_CACHE_MAP["$inst_id"]="${bv_sz}|${bv_vp}"
                ((bv_loaded++))
            fi
        done < "$BOOT_VOLUME_CACHE"
        echo -e "${GRAY}  Loaded ${bv_loaded} boot volume entries from cache${NC}"
    else
        echo -e "${YELLOW}  No boot volume cache available${NC}"
    fi
    
    if [[ -f "$IMAGE_CACHE" && -s "$IMAGE_CACHE" ]]; then
        local img_loaded=0
        while IFS='|' read -r img_id img_nm; do
            if [[ -n "$img_id" ]]; then
                IMG_CACHE_MAP["$img_id"]="$img_nm"
                ((img_loaded++))
            fi
        done < "$IMAGE_CACHE"
        echo -e "${GRAY}  Loaded ${img_loaded} image entries from cache${NC}"
    fi
    
    # Process each instance using cached data
    while IFS='|' read -r ocid name state shape ocpus memory gpus net_bw max_vnics ad image_id launch_mode user_data created_by created_on; do
        [[ -z "$ocid" ]] && continue
        
        # Get boot volume from cache - use size-in-gbs and vpus-per-gb values
        local bv_size="-" bv_vpus="-"
        if [[ -n "${BV_CACHE_MAP[$ocid]:-}" ]]; then
            IFS='|' read -r bv_size bv_vpus <<< "${BV_CACHE_MAP[$ocid]}"
            # Ensure we have valid values
            [[ -z "$bv_size" || "$bv_size" == "null" ]] && bv_size="-"
            [[ -z "$bv_vpus" || "$bv_vpus" == "null" ]] && bv_vpus="-"
        fi
        
        # Get image name from cache
        local image_name="-"
        if [[ -n "$image_id" && "$image_id" != "null" && -n "${IMG_CACHE_MAP[$image_id]:-}" ]]; then
            image_name="${IMG_CACHE_MAP[$image_id]}"
        fi
        
        # Cloud-init fingerprint (last 7 chars)
        local ci_fp="-"
        if [[ -n "$user_data" && "$user_data" != "null" && "$user_data" != "" ]]; then
            ci_fp="${user_data: -7}"
        fi
        
        # Handle null values
        [[ "$gpus" == "null" || -z "$gpus" ]] && gpus="0"
        [[ "$net_bw" == "null" || -z "$net_bw" ]] && net_bw="-"
        [[ "$max_vnics" == "null" || -z "$max_vnics" ]] && max_vnics="-"
        [[ "$launch_mode" == "null" || -z "$launch_mode" ]] && launch_mode="-"
        [[ "$created_by" == "null" || -z "$created_by" ]] && created_by="-"
        [[ "$created_on" == "null" || -z "$created_on" ]] && created_on="-"
        
        # Format created_on date
        [[ "$created_on" != "-" ]] && created_on="${created_on:0:10}"
        
        # Store data
        echo "${name}|${state}|${shape}|${ocpus}|${memory}|${gpus}|${net_bw}|${max_vnics}|${bv_size}|${bv_vpus}|${image_name}|${launch_mode}|${created_by}|${created_on}|${ci_fp}" >> "$tmp_data"
        
    done < <(echo "$instances_json" | jq -r '
        .data[] | 
        select(.["lifecycle-state"] != "TERMINATED") |
        "\(.id)|\(.["display-name"])|\(.["lifecycle-state"])|\(.shape)|\(.["shape-config"]["ocpus"] // "")|\(.["shape-config"]["memory-in-gbs"] // "")|\(.["shape-config"]["gpus"] // "0")|\(.["shape-config"]["networking-bandwidth-in-gbps"] // "")|\(.["shape-config"]["max-vnic-attachments"] // "")|\(.["availability-domain"])|\(.["image-id"] // "")|\(.["launch-mode"] // "")|\(.metadata.user_data // "")|\(.["defined-tags"]["Oracle-Tags"]["CreatedBy"] // "")|\(.["defined-tags"]["Oracle-Tags"]["CreatedOn"] // "")"
    ' 2>/dev/null)
    
    if [[ ! -f "$tmp_data" ]]; then
        echo -e "${RED}No instance data collected${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # Build nodepool name cache: resolve unique ocid1.nodepool OCIDs from CreatedBy
    declare -A NODEPOOL_NAME_CACHE=()
    local np_ocids
    np_ocids=$(awk -F'|' '{print $13}' "$tmp_data" | grep '^ocid1.nodepool\.' | sort -u)
    if [[ -n "$np_ocids" ]]; then
        local np_count
        np_count=$(echo "$np_ocids" | wc -l)
        echo -e "${GRAY}Resolving ${np_count} nodepool name(s)...${NC}"
        while read -r np_ocid; do
            [[ -z "$np_ocid" ]] && continue
            local np_name
            np_name=$(oci ce node-pool get --node-pool-id "$np_ocid" --region "$region" --query 'data.name' --raw-output 2>/dev/null)
            if [[ -n "$np_name" && "$np_name" != "null" ]]; then
                NODEPOOL_NAME_CACHE["$np_ocid"]="$np_name"
            fi
        done <<< "$np_ocids"
    fi
    
    # Display header
    echo ""
    printf "${BOLD}%-35s %-8s %-22s %5s %6s %3s %6s %4s %5s %4s %-105s %-18s %-50s %-10s %-7s${NC}\n" \
        "Display Name" "State" "Shape" "OCPUs" "Mem" "GPU" "NetBW" "VNIC" "BV GB" "VPUs" "Image Name" "LaunchMode" "CreatedBy" "CreatedOn" "CI"
    print_separator 325
    
    # Display data sorted by name
    sort -t'|' -k1,1 "$tmp_data" | while IFS='|' read -r name state shape ocpus memory gpus net_bw max_vnics bv_size bv_vpus image_name launch_mode created_by created_on ci_fp; do
        # Color state
        local state_color="$GREEN"
        case "$state" in
            RUNNING) state_color="$GREEN" ;;
            STOPPED) state_color="$RED" ;;
            STARTING|STOPPING) state_color="$YELLOW" ;;
            PROVISIONING) state_color="$CYAN" ;;
            *) state_color="$WHITE" ;;
        esac
        
        # GPU display
        local gpu_disp="$gpus"
        [[ "$gpus" == "0" ]] && gpu_disp="-"
        
        # Truncate fields
        local name_t="${name:0:35}"
        local shape_t="${shape:0:22}"
        
        # Resolve CreatedBy: if ocid1.instance, look up display name from instances_json
        # If ocid1.nodepool, look up display name from nodepool cache
        local created_by_display="$created_by"
        if [[ "$created_by" == ocid1.instance.* ]]; then
            local resolved_name
            resolved_name=$(echo "$instances_json" | jq -r --arg id "$created_by" '.data[] | select(.id == $id) | .["display-name"] // empty' 2>/dev/null)
            if [[ -n "$resolved_name" ]]; then
                created_by_display="$resolved_name"
            fi
        elif [[ "$created_by" == ocid1.nodepool.* ]]; then
            if [[ -n "${NODEPOOL_NAME_CACHE[$created_by]:-}" ]]; then
                created_by_display="${NODEPOOL_NAME_CACHE[$created_by]}"
            fi
        fi
        
        printf "%-35s ${state_color}%-8s${NC} ${CYAN}%-22s${NC} %5s %6s ${GREEN}%3s${NC} %6s %4s %5s %4s %-105s %-18s ${BLUE}%-50s${NC} ${GRAY}%-10s${NC} ${MAGENTA}%-7s${NC}\n" \
            "$name_t" "$state" "$shape_t" "$ocpus" "$memory" "$gpu_disp" "$net_bw" "$max_vnics" "$bv_size" "$bv_vpus" "$image_name" "$launch_mode" "$created_by_display" "$created_on" "$ci_fp"
    done
    
    rm -f "$tmp_data"
    
    echo ""
    print_separator 325
    echo ""
    
    echo -e "${BOLD}${WHITE}Options:${NC}"
    echo -e "  ${CYAN}legend${NC}  - Show column legend"
    echo -e "  ${MAGENTA}r${NC}       - Clear cache and re-fetch all data"
    echo -e "  ${CYAN}Enter${NC}   - Return to menu"
    echo ""
    echo -n -e "${CYAN}Action [legend/r/Enter]: ${NC}"
    
    local action
    read -r action
    
    case "$action" in
        legend|LEGEND|l|L)
            echo ""
            echo -e "${BOLD}${WHITE}Column Legend:${NC}"
            echo -e "  ${WHITE}OCPUs${NC}      - Number of OCPUs (shape-config.ocpus)"
            echo -e "  ${WHITE}Mem${NC}        - Memory in GB (shape-config.memory-in-gbs)"
            echo -e "  ${WHITE}GPU${NC}        - Number of GPUs (shape-config.gpus)"
            echo -e "  ${WHITE}NetBW${NC}      - Network bandwidth in Gbps (shape-config.networking-bandwidth-in-gbps)"
            echo -e "  ${WHITE}VNIC${NC}       - Max VNIC attachments (shape-config.max-vnic-attachments)"
            echo -e "  ${WHITE}BV GB${NC}      - Boot Volume size in GB (boot-volume.size-in-gbs)"
            echo -e "  ${WHITE}VPUs${NC}       - Boot Volume VPUs/GB (boot-volume.vpus-per-gb) [10=Balanced, 20=Higher, 30+=Ultra]"
            echo -e "  ${WHITE}LaunchMode${NC} - NATIVE, EMULATED, PARAVIRTUALIZED, or CUSTOM (instance.launch-mode)"
            echo -e "  ${BLUE}CreatedBy${NC}  - Oracle-Tags CreatedBy (defined-tags.Oracle-Tags.CreatedBy)"
            echo -e "  ${GRAY}CreatedOn${NC}  - Oracle-Tags CreatedOn date (defined-tags.Oracle-Tags.CreatedOn)"
            echo -e "  ${WHITE}CI${NC}         - Cloud-Init fingerprint (last 7 chars of metadata.user_data)"
            echo ""
            echo -e "${GRAY}Instances with matching CI fingerprints have identical cloud-init configurations${NC}"
            echo ""
            echo -e "Press Enter to return..."
            read -r
            ;;
        refresh|REFRESH|r|R)
            echo -e "${YELLOW}Clearing cache...${NC}"
            rm -f "$BOOT_VOLUME_CACHE" "$IMAGE_CACHE"
            echo -e "${GREEN}Cache cleared. Re-running...${NC}"
            sleep 1
            display_instances_properties_view
            ;;
        *)
            return
            ;;
    esac
}

#--------------------------------------------------------------------------------
# Instance Actions Menu - Reboot, Terminate, etc.
#--------------------------------------------------------------------------------
instance_actions_menu() {
    local instance_ocid="$1"
    
    # Get instance name for display
    local instance_name
    instance_name=$(oci compute instance get --instance-id "$instance_ocid" --query 'data."display-name"' --raw-output 2>/dev/null) || instance_name="Unknown"
    
    # Get current state
    local instance_state
    instance_state=$(oci compute instance get --instance-id "$instance_ocid" --query 'data."lifecycle-state"' --raw-output 2>/dev/null) || instance_state="Unknown"
    
    # Check if in K8s
    local k8s_node_name=""
    k8s_node_name=$(kubectl get nodes -o json 2>/dev/null | jq -r --arg ocid "$instance_ocid" '.items[] | select(.spec.providerID | contains($ocid)) | .metadata.name' 2>/dev/null)
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Instance Actions ═══${NC}"
    echo -e "  Instance: ${GREEN}$instance_name${NC}"
    echo -e "  State:    ${CYAN}$instance_state${NC}"
    if [[ -n "$k8s_node_name" ]]; then
        echo -e "  K8s Node: ${GREEN}$k8s_node_name${NC}"
    else
        echo -e "  K8s Node: ${YELLOW}Not in cluster${NC}"
    fi
    echo ""
    echo -e "  ${RED}1${NC}) ${WHITE}Reboot Instance${NC}        - Graceful reboot (ACPI shutdown + start)"
    echo -e "  ${RED}2${NC}) ${WHITE}Force Reboot Instance${NC}  - Hard reset (immediate power cycle)"
    echo -e "  ${RED}3${NC}) ${WHITE}Stop Instance${NC}          - Graceful shutdown"
    echo -e "  ${GREEN}4${NC}) ${WHITE}Start Instance${NC}         - Power on (if stopped)"
    if [[ -n "$k8s_node_name" ]]; then
        echo -e "  ${YELLOW}6${NC}) ${WHITE}Drain K8s Node${NC}         - Safely evict pods before maintenance"
        echo -e "  ${YELLOW}7${NC}) ${WHITE}Cordon K8s Node${NC}        - Mark node as unschedulable"
        echo -e "  ${YELLOW}8${NC}) ${WHITE}Uncordon K8s Node${NC}      - Mark node as schedulable"
        echo -e "  ${YELLOW}10${NC}) ${WHITE}Cordon & Drain${NC}        - Cordon then drain (combo)"
    fi
    echo -e "  ${RED}5${NC}) ${WHITE}Terminate Instance${NC}     - ${RED}PERMANENTLY DELETE${NC} instance"
    echo ""
    echo -e "  ${CYAN}9${NC}) ${WHITE}View Console History${NC}   - Boot logs (debug cloud-init issues)"
    echo ""
    echo -e "  ${CYAN}Enter${NC}) Return to instance list"
    echo ""
    
    local prompt_range="1-5,9"
    [[ -n "$k8s_node_name" ]] && prompt_range="1-9"
    echo -n -e "${BOLD}${CYAN}Select action [${prompt_range}/Enter]: ${NC}"
    
    local action
    read -r action
    
    case "$action" in
        1)
            # Reboot (soft)
            echo ""
            echo -e "${YELLOW}Rebooting instance ${GREEN}$instance_name${NC}${YELLOW}...${NC}"
            echo -n -e "${CYAN}Confirm reboot? (yes/no): ${NC}"
            read -r confirm
            if [[ "$confirm" == "yes" ]]; then
                if oci compute instance action --instance-id "$instance_ocid" --action SOFTRESET 2>/dev/null; then
                    echo -e "${GREEN}✓ Reboot initiated successfully${NC}"
                else
                    echo -e "${RED}✗ Failed to reboot instance${NC}"
                fi
            else
                echo -e "${YELLOW}Reboot cancelled${NC}"
            fi
            echo ""
            echo -e "Press Enter to continue..."
            read -r
            ;;
        2)
            # Force Reboot (hard reset)
            echo ""
            echo -e "${YELLOW}Force rebooting instance ${GREEN}$instance_name${NC}${YELLOW}...${NC}"
            echo -e "${RED}WARNING: This is a hard reset and may cause data loss!${NC}"
            echo -n -e "${CYAN}Confirm force reboot? (yes/no): ${NC}"
            read -r confirm
            if [[ "$confirm" == "yes" ]]; then
                if oci compute instance action --instance-id "$instance_ocid" --action RESET 2>/dev/null; then
                    echo -e "${GREEN}✓ Force reboot initiated successfully${NC}"
                else
                    echo -e "${RED}✗ Failed to force reboot instance${NC}"
                fi
            else
                echo -e "${YELLOW}Force reboot cancelled${NC}"
            fi
            echo ""
            echo -e "Press Enter to continue..."
            read -r
            ;;
        3)
            # Stop instance
            echo ""
            echo -e "${YELLOW}Stopping instance ${GREEN}$instance_name${NC}${YELLOW}...${NC}"
            echo -n -e "${CYAN}Confirm stop? (yes/no): ${NC}"
            read -r confirm
            if [[ "$confirm" == "yes" ]]; then
                if oci compute instance action --instance-id "$instance_ocid" --action SOFTSTOP 2>/dev/null; then
                    echo -e "${GREEN}✓ Stop initiated successfully${NC}"
                else
                    echo -e "${RED}✗ Failed to stop instance${NC}"
                fi
            else
                echo -e "${YELLOW}Stop cancelled${NC}"
            fi
            echo ""
            echo -e "Press Enter to continue..."
            read -r
            ;;
        4)
            # Start instance
            echo ""
            echo -e "${YELLOW}Starting instance ${GREEN}$instance_name${NC}${YELLOW}...${NC}"
            echo -n -e "${CYAN}Confirm start? (yes/no): ${NC}"
            read -r confirm
            if [[ "$confirm" == "yes" ]]; then
                if oci compute instance action --instance-id "$instance_ocid" --action START 2>/dev/null; then
                    echo -e "${GREEN}✓ Start initiated successfully${NC}"
                else
                    echo -e "${RED}✗ Failed to start instance${NC}"
                fi
            else
                echo -e "${YELLOW}Start cancelled${NC}"
            fi
            echo ""
            echo -e "Press Enter to continue..."
            read -r
            ;;
        5)
            # Terminate instance
            echo ""
            echo -e "${RED}╔════════════════════════════════════════════════════════════════╗${NC}"
            echo -e "${RED}║                    ⚠️  WARNING: TERMINATE  ⚠️                   ║${NC}"
            echo -e "${RED}╚════════════════════════════════════════════════════════════════╝${NC}"
            echo ""
            echo -e "${RED}This will PERMANENTLY DELETE the instance:${NC}"
            echo -e "  Name: ${GREEN}$instance_name${NC}"
            echo -e "  OCID: ${YELLOW}$instance_ocid${NC}"
            echo ""
            echo -e "${RED}This action cannot be undone!${NC}"
            echo ""
            
            # Check if in K8s
            if [[ -n "$k8s_node_name" ]]; then
                echo -e "${YELLOW}⚠️  This instance is a Kubernetes node: ${CYAN}$k8s_node_name${NC}"
                echo -e "${YELLOW}   Consider draining the node first (option 6)${NC}"
                echo ""
            fi
            
            echo -n -e "${RED}Type 'TERMINATE' to confirm deletion: ${NC}"
            read -r confirm
            if [[ "$confirm" == "TERMINATE" ]]; then
                echo ""
                echo -e "${YELLOW}Terminating instance...${NC}"
                if oci compute instance terminate --instance-id "$instance_ocid" --preserve-boot-volume false --force 2>/dev/null; then
                    echo -e "${GREEN}✓ Terminate initiated successfully${NC}"
                    echo -e "${YELLOW}Instance will be deleted. Boot volume will also be deleted.${NC}"
                else
                    echo -e "${RED}✗ Failed to terminate instance${NC}"
                fi
            else
                echo -e "${YELLOW}Termination cancelled${NC}"
            fi
            echo ""
            echo -e "Press Enter to continue..."
            read -r
            ;;
        6)
            # Drain K8s node
            if [[ -z "$k8s_node_name" ]]; then
                echo -e "${RED}This instance is not a Kubernetes node${NC}"
                sleep 1
            else
                echo ""
                echo -e "${YELLOW}Draining Kubernetes node ${GREEN}$k8s_node_name${NC}${YELLOW}...${NC}"
                echo -e "${WHITE}This will evict all pods (except DaemonSets) from the node.${NC}"
                echo ""
                echo -n -e "${CYAN}Confirm drain? (yes/no): ${NC}"
                read -r confirm
                if [[ "$confirm" == "yes" ]]; then
                    echo ""
                    echo -e "${YELLOW}Running: kubectl drain $k8s_node_name --ignore-daemonsets --delete-emptydir-data${NC}"
                    if kubectl drain "$k8s_node_name" --ignore-daemonsets --delete-emptydir-data 2>&1; then
                        echo -e "${GREEN}✓ Node drained successfully${NC}"
                    else
                        echo -e "${RED}✗ Failed to drain node (some pods may not be evictable)${NC}"
                    fi
                else
                    echo -e "${YELLOW}Drain cancelled${NC}"
                fi
                echo ""
                echo -e "Press Enter to continue..."
                read -r
            fi
            ;;
        7)
            # Cordon K8s node
            if [[ -z "$k8s_node_name" ]]; then
                echo -e "${RED}This instance is not a Kubernetes node${NC}"
                sleep 1
            else
                echo ""
                echo -e "${YELLOW}Cordoning Kubernetes node ${GREEN}$k8s_node_name${NC}${YELLOW}...${NC}"
                echo -e "${WHITE}This marks the node as unschedulable (existing pods continue running).${NC}"
                echo ""
                echo -n -e "${CYAN}Confirm cordon? (yes/no): ${NC}"
                read -r confirm
                if [[ "$confirm" == "yes" ]]; then
                    if kubectl cordon "$k8s_node_name" 2>&1; then
                        echo -e "${GREEN}✓ Node cordoned successfully${NC}"
                    else
                        echo -e "${RED}✗ Failed to cordon node${NC}"
                    fi
                else
                    echo -e "${YELLOW}Cordon cancelled${NC}"
                fi
                echo ""
                echo -e "Press Enter to continue..."
                read -r
            fi
            ;;
        8)
            # Uncordon K8s node
            if [[ -z "$k8s_node_name" ]]; then
                echo -e "${RED}This instance is not a Kubernetes node${NC}"
                sleep 1
            else
                echo ""
                echo -e "${YELLOW}Uncordoning Kubernetes node ${GREEN}$k8s_node_name${NC}${YELLOW}...${NC}"
                echo -e "${WHITE}This marks the node as schedulable again.${NC}"
                echo ""
                echo -n -e "${CYAN}Confirm uncordon? (yes/no): ${NC}"
                read -r confirm
                if [[ "$confirm" == "yes" ]]; then
                    if kubectl uncordon "$k8s_node_name" 2>&1; then
                        echo -e "${GREEN}✓ Node uncordoned successfully${NC}"
                    else
                        echo -e "${RED}✗ Failed to uncordon node${NC}"
                    fi
                else
                    echo -e "${YELLOW}Uncordon cancelled${NC}"
                fi
                echo ""
                echo -e "Press Enter to continue..."
                read -r
            fi
            ;;
        9)
            # View Console History
            echo ""
            echo -e "${CYAN}Fetching console history for ${GREEN}$instance_name${NC}${CYAN}...${NC}"
            get_console_history "$instance_ocid"
            echo ""
            echo -e "Press Enter to continue..."
            read -r
            ;;
        10)
            # Cordon & Drain K8s node (combo)
            if [[ -z "$k8s_node_name" ]]; then
                echo -e "${RED}This instance is not a Kubernetes node${NC}"
                sleep 1
            else
                echo ""
                echo -e "${YELLOW}Cordon & Drain Kubernetes node ${GREEN}$k8s_node_name${NC}${YELLOW}...${NC}"
                echo -e "${WHITE}Step 1: Cordon (mark unschedulable)${NC}"
                echo -e "${WHITE}Step 2: Drain (evict all pods except DaemonSets)${NC}"
                echo ""
                echo -e "${RED}⚠️  This will evict all pods from the node!${NC}"
                echo ""
                echo -n -e "${CYAN}Confirm cordon & drain? (yes/no): ${NC}"
                read -r confirm
                if [[ "$confirm" == "yes" ]]; then
                    echo ""
                    echo -e "${YELLOW}Step 1: Cordoning...${NC}"
                    echo -e "${GRAY}$ kubectl cordon $k8s_node_name${NC}"
                    if kubectl cordon "$k8s_node_name" 2>&1; then
                        echo -e "${GREEN}✓ Node cordoned${NC}"
                        echo ""
                        echo -e "${YELLOW}Step 2: Draining...${NC}"
                        echo -e "${GRAY}$ kubectl drain $k8s_node_name --ignore-daemonsets --delete-emptydir-data${NC}"
                        if kubectl drain "$k8s_node_name" --ignore-daemonsets --delete-emptydir-data 2>&1; then
                            echo -e "${GREEN}✓ Node drained successfully${NC}"
                        else
                            echo -e "${RED}✗ Failed to drain node (node remains cordoned)${NC}"
                        fi
                    else
                        echo -e "${RED}✗ Failed to cordon node - skipping drain${NC}"
                    fi
                else
                    echo -e "${YELLOW}Cordon & drain cancelled${NC}"
                fi
                echo ""
                echo -e "Press Enter to continue..."
                read -r
            fi
            ;;
        *)
            # Return to list
            ;;
    esac
}

#--------------------------------------------------------------------------------
# Display detailed instance information
#--------------------------------------------------------------------------------
display_instance_details() {
    local instance_ocid="$1"
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    echo ""
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${CYAN}                                           INSTANCE DETAILS                                                     ${NC}"
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    
    # Fetch instance details
    local instance_json
    instance_json=$(oci compute instance get --instance-id "$instance_ocid" --output json 2>/dev/null)
    
    if [[ -z "$instance_json" ]] || ! echo "$instance_json" | jq -e '.data' > /dev/null 2>&1; then
        echo -e "${RED}Failed to fetch instance details${NC}"
        return 1
    fi
    
    # ========== CACHE VNIC AND VOLUME DATA (fetch once) ==========
    echo -ne "${GRAY}Loading instance data...${NC}"
    
    # Cache VNIC attachments
    local cached_vnic_attachments
    cached_vnic_attachments=$(oci compute vnic-attachment list \
        --compartment-id "$compartment_id" \
        --instance-id "$instance_ocid" \
        --output json 2>/dev/null)
    
    # Get availability domain for boot volume query
    local ad_for_query
    ad_for_query=$(echo "$instance_json" | jq -r '.data["availability-domain"] // "N/A"')
    
    # Cache boot volume attachments
    local cached_boot_vol_attachments
    cached_boot_vol_attachments=$(oci compute boot-volume-attachment list \
        --compartment-id "$compartment_id" \
        --availability-domain "$ad_for_query" \
        --instance-id "$instance_ocid" \
        --output json 2>/dev/null)
    
    # Cache block volume attachments
    local cached_block_vol_attachments
    cached_block_vol_attachments=$(oci compute volume-attachment list \
        --compartment-id "$compartment_id" \
        --instance-id "$instance_ocid" \
        --output json 2>/dev/null)
    
    # Pre-fetch all individual VNIC details and build lookup JSON
    local cached_vnic_details="{}"
    local cached_subnet_names="{}"
    local cached_nsg_names="{}"
    local all_subnet_ids=""
    local all_nsg_ids=""
    
    if [[ -n "$cached_vnic_attachments" ]]; then
        local vnic_ids
        vnic_ids=$(echo "$cached_vnic_attachments" | jq -r '.data[]["vnic-id"] // empty' 2>/dev/null)
        for vnic_id in $vnic_ids; do
            [[ -z "$vnic_id" ]] && continue
            local vnic_data
            vnic_data=$(oci network vnic get --vnic-id "$vnic_id" --output json 2>/dev/null)
            if [[ -n "$vnic_data" ]]; then
                cached_vnic_details=$(echo "$cached_vnic_details" | jq --arg id "$vnic_id" --argjson data "$vnic_data" '. + {($id): $data}' 2>/dev/null)
                # Collect subnet and NSG IDs for batch lookup
                local subnet_id nsg_list
                subnet_id=$(echo "$vnic_data" | jq -r '.data["subnet-id"] // empty' 2>/dev/null)
                [[ -n "$subnet_id" ]] && all_subnet_ids="$all_subnet_ids $subnet_id"
                nsg_list=$(echo "$vnic_data" | jq -r '.data["nsg-ids"] // [] | .[]' 2>/dev/null)
                [[ -n "$nsg_list" ]] && all_nsg_ids="$all_nsg_ids $nsg_list"
            fi
        done
    fi
    echo -ne "\r${GRAY}Loading instance data.. ${NC}"
    
    # Pre-fetch subnet names and route tables
    for subnet_id in $(echo "$all_subnet_ids" | tr ' ' '\n' | sort -u); do
        [[ -z "$subnet_id" ]] && continue
        local subnet_json subnet_name rt_id rt_name
        subnet_json=$(oci network subnet get --subnet-id "$subnet_id" --output json 2>/dev/null)
        if [[ -n "$subnet_json" ]]; then
            subnet_name=$(echo "$subnet_json" | jq -r '.data["display-name"] // "-"')
            rt_id=$(echo "$subnet_json" | jq -r '.data["route-table-id"] // empty')
            rt_name="-"
            if [[ -n "$rt_id" ]]; then
                rt_name=$(oci network route-table get --rt-id "$rt_id" --query 'data."display-name"' --raw-output 2>/dev/null) || rt_name="-"
            fi
            cached_subnet_names=$(echo "$cached_subnet_names" | jq --arg id "$subnet_id" --arg name "$subnet_name" --arg rt "$rt_name" '. + {($id): {"name": $name, "rt": $rt}}' 2>/dev/null)
        fi
    done
    
    # Pre-fetch NSG names
    for nsg_id in $(echo "$all_nsg_ids" | tr ' ' '\n' | sort -u); do
        [[ -z "$nsg_id" ]] && continue
        local nsg_name
        nsg_name=$(oci network nsg get --nsg-id "$nsg_id" --query 'data."display-name"' --raw-output 2>/dev/null) || nsg_name="N/A"
        cached_nsg_names=$(echo "$cached_nsg_names" | jq --arg id "$nsg_id" --arg name "$nsg_name" '. + {($id): $name}' 2>/dev/null)
    done
    echo -ne "\r${GRAY}Loading instance data...${NC}"
    
    # Pre-fetch all individual boot volume details and build lookup JSON
    local cached_boot_vol_details="{}"
    local cached_backup_policies="{}"
    
    if [[ -n "$cached_boot_vol_attachments" ]]; then
        local bv_ids
        bv_ids=$(echo "$cached_boot_vol_attachments" | jq -r '.data[]["boot-volume-id"] // empty' 2>/dev/null)
        for bv_id in $bv_ids; do
            [[ -z "$bv_id" ]] && continue
            local bv_data
            bv_data=$(oci bv boot-volume get --boot-volume-id "$bv_id" --output json 2>/dev/null)
            if [[ -n "$bv_data" ]]; then
                cached_boot_vol_details=$(echo "$cached_boot_vol_details" | jq --arg id "$bv_id" --argjson data "$bv_data" '. + {($id): $data}' 2>/dev/null)
            fi
            # Get backup policy
            local backup_assign backup_policy="None"
            backup_assign=$(oci bv volume-backup-policy-assignment get-volume-backup-policy-asset-assignment \
                --asset-id "$bv_id" --query 'data[0]."policy-id"' --raw-output 2>/dev/null)
            if [[ -n "$backup_assign" && "$backup_assign" != "null" ]]; then
                backup_policy=$(oci bv volume-backup-policy get --policy-id "$backup_assign" --query 'data."display-name"' --raw-output 2>/dev/null) || backup_policy="Custom"
            fi
            cached_backup_policies=$(echo "$cached_backup_policies" | jq --arg id "$bv_id" --arg policy "$backup_policy" '. + {($id): $policy}' 2>/dev/null)
        done
    fi
    echo -ne "\r${GRAY}Loading instance data....${NC}"
    
    # Pre-fetch all individual block volume details and build lookup JSON
    local cached_block_vol_details="{}"
    if [[ -n "$cached_block_vol_attachments" ]]; then
        local vol_ids
        vol_ids=$(echo "$cached_block_vol_attachments" | jq -r '.data[]["volume-id"] // empty' 2>/dev/null)
        for vol_id in $vol_ids; do
            [[ -z "$vol_id" ]] && continue
            local vol_data
            vol_data=$(oci bv volume get --volume-id "$vol_id" --output json 2>/dev/null)
            if [[ -n "$vol_data" ]]; then
                cached_block_vol_details=$(echo "$cached_block_vol_details" | jq --arg id "$vol_id" --argjson data "$vol_data" '. + {($id): $data}' 2>/dev/null)
            fi
            # Get backup policy
            local backup_assign backup_policy="None"
            backup_assign=$(oci bv volume-backup-policy-assignment get-volume-backup-policy-asset-assignment \
                --asset-id "$vol_id" --query 'data[0]."policy-id"' --raw-output 2>/dev/null)
            if [[ -n "$backup_assign" && "$backup_assign" != "null" ]]; then
                backup_policy=$(oci bv volume-backup-policy get --policy-id "$backup_assign" --query 'data."display-name"' --raw-output 2>/dev/null) || backup_policy="Custom"
            fi
            cached_backup_policies=$(echo "$cached_backup_policies" | jq --arg id "$vol_id" --arg policy "$backup_policy" '. + {($id): $policy}' 2>/dev/null)
        done
    fi
    
    # Clear loading message
    echo -ne "\r\033[K"
    
    # Extract basic info
    local display_name state shape ad fd time_created launch_mode image_id
    display_name=$(echo "$instance_json" | jq -r '.data["display-name"] // "N/A"')
    state=$(echo "$instance_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    shape=$(echo "$instance_json" | jq -r '.data.shape // "N/A"')
    ad=$(echo "$instance_json" | jq -r '.data["availability-domain"] // "N/A"')
    fd=$(echo "$instance_json" | jq -r '.data["fault-domain"] // "N/A"')
    time_created=$(echo "$instance_json" | jq -r '.data["time-created"] // "N/A"')
    launch_mode=$(echo "$instance_json" | jq -r '.data["launch-mode"] // "N/A"')
    image_id=$(echo "$instance_json" | jq -r '.data["image-id"] // empty')
    
    # Extract shape config
    local shape_ocpus shape_memory_gb shape_gpus shape_gpu_desc shape_nvmes shape_network_bw shape_max_nics
    shape_ocpus=$(echo "$instance_json" | jq -r '.data["shape-config"]["ocpus"] // "N/A"')
    shape_memory_gb=$(echo "$instance_json" | jq -r '.data["shape-config"]["memory-in-gbs"] // "N/A"')
    shape_gpus=$(echo "$instance_json" | jq -r '.data["shape-config"]["gpus"] // "0"')
    shape_gpu_desc=$(echo "$instance_json" | jq -r '.data["shape-config"]["gpu-description"] // empty')
    shape_nvmes=$(echo "$instance_json" | jq -r '.data["shape-config"]["local-disks"] // "0"')
    shape_network_bw=$(echo "$instance_json" | jq -r '.data["shape-config"]["networking-bandwidth-in-gbps"] // "N/A"')
    shape_max_nics=$(echo "$instance_json" | jq -r '.data["shape-config"]["max-vnic-attachments"] // "N/A"')
    
    # Extract GPU memory cluster tag
    local gpu_mem_cluster
    gpu_mem_cluster=$(echo "$instance_json" | jq -r '.data["freeform-tags"]["oci:compute:gpumemorycluster"] // empty')
    
    # Extract compute cluster ID
    local compute_cluster_id
    compute_cluster_id=$(echo "$instance_json" | jq -r '.data["compute-cluster-id"] // empty')
    
    # Check for OKE-related tags (created by)
    local oke_cluster_id oke_nodepool_id
    oke_cluster_id=$(echo "$instance_json" | jq -r '.data["defined-tags"]["oke-apisystem"]["ClusterId"] // empty')
    oke_nodepool_id=$(echo "$instance_json" | jq -r '.data["defined-tags"]["oke-apisystem"]["NodePoolId"] // empty')
    [[ -z "$oke_cluster_id" ]] && oke_cluster_id=$(echo "$instance_json" | jq -r '.data["freeform-tags"]["oke-clusterId"] // empty')
    [[ -z "$oke_nodepool_id" ]] && oke_nodepool_id=$(echo "$instance_json" | jq -r '.data["freeform-tags"]["oke-nodePoolId"] // empty')
    
    # Check for instance pool / instance configuration
    local instance_pool_id instance_config_id
    instance_pool_id=$(echo "$instance_json" | jq -r '.data["metadata"]["oci:compute:instancepool:id"] // empty')
    instance_config_id=$(echo "$instance_json" | jq -r '.data["metadata"]["oci:compute:instanceconfiguration:id"] // empty')
    
    # Extract Oracle-Tags
    local oracle_created_by oracle_created_on
    oracle_created_by=$(echo "$instance_json" | jq -r '.data["defined-tags"]["Oracle-Tags"]["CreatedBy"] // empty')
    oracle_created_on=$(echo "$instance_json" | jq -r '.data["defined-tags"]["Oracle-Tags"]["CreatedOn"] // empty')
    
    # Color state
    local state_color="$GREEN"
    case "$state" in
        RUNNING) state_color="$GREEN" ;;
        STOPPED) state_color="$RED" ;;
        STARTING|STOPPING) state_color="$YELLOW" ;;
        PROVISIONING) state_color="$CYAN" ;;
        *) state_color="$WHITE" ;;
    esac
    
    # ========== BASIC INFO (Compact) ==========
    echo ""
    echo -e "${BOLD}${WHITE}─── Basic Info ────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
    printf "${WHITE}%-10s${NC}${GREEN}%-50s${NC}\n" "Name:" "${display_name:0:50}"
    printf "${WHITE}%-10s${NC}${YELLOW}%s${NC}\n" "OCID:" "$instance_ocid"
    printf "${WHITE}%-10s${NC}${state_color}%-12s${NC}  ${WHITE}%-10s${NC}%-22s  ${WHITE}%-8s${NC}%s\n" "State:" "$state" "Created:" "${time_created:0:19}" "Launch:" "$launch_mode"
    printf "${WHITE}%-10s${NC}%-12s  ${WHITE}%-10s${NC}%s\n" "AD:" "${ad##*:}" "FD:" "${fd##*-}"
    
    # ========== SHAPE & COMPUTE (Compact) ==========
    echo ""
    echo -e "${BOLD}${WHITE}─── Shape & Resources ─────────────────────────────────────────────────────────────────────────────────────────${NC}"
    printf "${WHITE}%-10s${NC}${CYAN}%-30s${NC}  ${WHITE}%-8s${NC}%-8s  ${WHITE}%-8s${NC}%-10s\n" "Shape:" "$shape" "OCPUs:" "$shape_ocpus" "Memory:" "${shape_memory_gb} GB"
    
    local gpu_info="N/A"
    if [[ "$shape_gpus" != "0" && "$shape_gpus" != "N/A" ]]; then
        gpu_info="${shape_gpus}x ${shape_gpu_desc:-GPU}"
    fi
    printf "${WHITE}%-10s${NC}${GREEN}%-30s${NC}  ${WHITE}%-8s${NC}%-8s  ${WHITE}%-8s${NC}%-10s\n" "GPUs:" "$gpu_info" "NetBW:" "${shape_network_bw}Gb" "VNICs:" "$shape_max_nics"
    
    # ========== IMAGE (Full Details) ==========
    echo ""
    echo -e "${BOLD}${WHITE}─── Image ─────────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
    if [[ -n "$image_id" ]]; then
        local image_name image_os image_os_version
        local image_json
        image_json=$(oci compute image get --image-id "$image_id" --output json 2>/dev/null)
        if [[ -n "$image_json" ]]; then
            image_name=$(echo "$image_json" | jq -r '.data["display-name"] // "N/A"')
            image_os=$(echo "$image_json" | jq -r '.data["operating-system"] // "N/A"')
            image_os_version=$(echo "$image_json" | jq -r '.data["operating-system-version"] // "N/A"')
            echo -e "${WHITE}Name:${NC} ${GREEN}$image_name${NC}"
            echo -e "${WHITE}OS:${NC}   $image_os $image_os_version"
            echo -e "${WHITE}OCID:${NC} ${YELLOW}$image_id${NC}"
        fi
    else
        echo -e "${GRAY}Image information not available${NC}"
    fi
    
    # ========== CLUSTER/OKE ASSOCIATIONS (Compact) ==========
    if [[ -n "$gpu_mem_cluster" || -n "$compute_cluster_id" || -n "$oke_cluster_id" || -n "$instance_config_id" ]]; then
        echo ""
        echo -e "${BOLD}${WHITE}─── Associations ──────────────────────────────────────────────────────────────────────────────────────────────${NC}"
        
        if [[ -n "$gpu_mem_cluster" ]]; then
            local cluster_name
            cluster_name=$(lookup_cache "$CLUSTER_CACHE" "$gpu_mem_cluster" 2 2>/dev/null || echo "N/A")
            printf "${WHITE}%-18s${NC}${GREEN}%s${NC}\n" "GPU Mem Cluster:" "$cluster_name"
            printf "${WHITE}%-18s${NC}${YELLOW}%s${NC}\n" "" "$gpu_mem_cluster"
        fi
        if [[ -n "$compute_cluster_id" ]]; then
            local cc_name
            cc_name=$(get_compute_cluster_name "$compute_cluster_id")
            printf "${WHITE}%-18s${NC}${GREEN}%s${NC}\n" "Compute Cluster:" "$cc_name"
            printf "${WHITE}%-18s${NC}${YELLOW}%s${NC}\n" "" "$compute_cluster_id"
        fi
        if [[ -n "$oke_cluster_id" ]]; then
            printf "${WHITE}%-18s${NC}${YELLOW}%s${NC}\n" "OKE Cluster:" "$oke_cluster_id"
        fi
        if [[ -n "$oke_nodepool_id" ]]; then
            printf "${WHITE}%-18s${NC}${YELLOW}%s${NC}\n" "OKE Node Pool:" "$oke_nodepool_id"
        fi
        if [[ -n "$instance_config_id" ]]; then
            local ic_name
            ic_name=$(get_instance_config_name "$instance_config_id")
            printf "${WHITE}%-18s${NC}${GREEN}%s${NC}\n" "Instance Config:" "$ic_name"
            printf "${WHITE}%-18s${NC}${YELLOW}%s${NC}\n" "" "$instance_config_id"
        fi
    fi
    
    # ========== KUBERNETES STATUS (Compact) ==========
    echo ""
    echo -e "${BOLD}${WHITE}─── Kubernetes ────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
    
    local k8s_node_info
    k8s_node_info=$(kubectl get nodes -o json 2>/dev/null | jq -r --arg ocid "$instance_ocid" '
        .items[] | select(.spec.providerID | contains($ocid)) | 
        "\(.metadata.name)|\(.status.conditions[] | select(.type=="Ready") | .status)|\(.metadata.labels["nvidia.com/gpu.clique"] // "N/A")|\(.metadata.labels["nvidia.com/gpu.present"] // "false")|\(.spec.unschedulable // false)|\((.spec.taints // []) | map(select(.key == "newNode")) | if length > 0 then .[0].effect else "N/A" end)"
    ' 2>/dev/null)
    
    if [[ -n "$k8s_node_info" ]]; then
        local k8s_node_name k8s_ready k8s_clique k8s_gpu_present k8s_unschedulable k8s_new_node_taint
        IFS='|' read -r k8s_node_name k8s_ready k8s_clique k8s_gpu_present k8s_unschedulable k8s_new_node_taint <<< "$k8s_node_info"
        
        local ready_color="$GREEN"
        [[ "$k8s_ready" != "True" ]] && ready_color="$RED"
        
        # Get pod count on this node
        local k8s_pod_count k8s_ds_pod_count
        k8s_pod_count=$(kubectl get pods --all-namespaces --field-selector=spec.nodeName="$k8s_node_name",status.phase=Running -o json 2>/dev/null | jq '.items | length' 2>/dev/null)
        [[ -z "$k8s_pod_count" ]] && k8s_pod_count="0"
        k8s_ds_pod_count=$(kubectl get pods --all-namespaces --field-selector=spec.nodeName="$k8s_node_name",status.phase=Running -o json 2>/dev/null | \
            jq '[.items[] | select(.metadata.ownerReferences[]?.kind == "DaemonSet")] | length' 2>/dev/null)
        [[ -z "$k8s_ds_pod_count" ]] && k8s_ds_pod_count="0"
        
        # Determine scheduling status
        local sched_status="Schedulable"
        local sched_color="$GREEN"
        if [[ "$k8s_unschedulable" == "true" ]]; then
            local non_ds_pods=$((k8s_pod_count - k8s_ds_pod_count))
            if [[ $non_ds_pods -le 0 ]]; then
                sched_status="Drained"
                sched_color="$RED"
            else
                sched_status="Cordoned"
                sched_color="$YELLOW"
            fi
        fi
        
        # Check for newNode taint
        local taint_info=""
        local taint_color="$GRAY"
        if [[ "$k8s_new_node_taint" != "N/A" && -n "$k8s_new_node_taint" ]]; then
            taint_info="newNode:${k8s_new_node_taint}"
            taint_color="$YELLOW"
        fi
        
        printf "${WHITE}%-10s${NC}${GREEN}%-14s${NC}  ${WHITE}%-8s${NC}${GREEN}%-22s${NC}  ${WHITE}%-8s${NC}${ready_color}%-8s${NC}  ${WHITE}%-10s${NC}${sched_color}%-12s${NC}  ${WHITE}%-6s${NC}${CYAN}%-5s${NC}\n" \
            "Status:" "In Cluster" "Node:" "$k8s_node_name" "Ready:" "$k8s_ready" "Schedule:" "$sched_status" "Pods:" "$k8s_pod_count"
        
        # Second line with GPU and taint info
        if [[ "$k8s_gpu_present" == "true" ]]; then
            local clique_info="N/A"
            [[ "$k8s_clique" != "N/A" ]] && clique_info="$k8s_clique"
            if [[ -n "$taint_info" ]]; then
                printf "${WHITE}%-10s${NC}${GREEN}%-14s${NC}  ${WHITE}%-8s${NC}${CYAN}%-22s${NC}  ${WHITE}%-8s${NC}${taint_color}%-20s${NC}\n" "GPU:" "Present" "Clique:" "$clique_info" "Taint:" "$taint_info"
            else
                printf "${WHITE}%-10s${NC}${GREEN}%-14s${NC}  ${WHITE}%-8s${NC}${CYAN}%-22s${NC}\n" "GPU:" "Present" "Clique:" "$clique_info"
            fi
        elif [[ -n "$taint_info" ]]; then
            printf "${WHITE}%-10s${NC}${taint_color}%-30s${NC}\n" "Taint:" "$taint_info"
        fi
    else
        printf "${WHITE}%-10s${NC}${YELLOW}%-50s${NC}\n" "Status:" "Not in cluster (not joined or not found)"
    fi
    
    # ========== NETWORK / VNIC INFORMATION (Single Line per VNIC) ==========
    echo ""
    echo -e "${BOLD}${WHITE}─── Network (VNICs) ───────────────────────────────────────────────────────────────────────────────────────────${NC}"
    
    if [[ -n "$cached_vnic_attachments" ]] && echo "$cached_vnic_attachments" | jq -e '.data[]' > /dev/null 2>&1; then
        # Print header
        printf "${GRAY}%-3s %-30s %-15s %-15s %-22s %-22s %-6s %-55s %s${NC}\n" "NIC" "Name" "Private IP" "Public IP" "Subnet" "Route Table" "VLAN" "NSG" "OCID"
        
        echo "$cached_vnic_attachments" | jq -r '.data[] | "\(.["vnic-id"])|\(.["display-name"] // "N/A")|\(.["nic-index"] // 0)|\(.["vlan-tag"] // "")"' 2>/dev/null | \
        while IFS='|' read -r vnic_id vnic_attach_name nic_index vlan_tag; do
            [[ -z "$vnic_id" ]] && continue
            
            # Get VNIC details from cache
            local vnic_json
            vnic_json=$(echo "$cached_vnic_details" | jq --arg id "$vnic_id" '.[$id]' 2>/dev/null)
            
            if [[ -n "$vnic_json" && "$vnic_json" != "null" ]] && echo "$vnic_json" | jq -e '.data' > /dev/null 2>&1; then
                local vnic_name private_ip public_ip subnet_id mac_addr is_primary
                vnic_name=$(echo "$vnic_json" | jq -r '.data["display-name"] // "N/A"')
                private_ip=$(echo "$vnic_json" | jq -r '.data["private-ip"] // "N/A"')
                public_ip=$(echo "$vnic_json" | jq -r '.data["public-ip"] // empty')
                subnet_id=$(echo "$vnic_json" | jq -r '.data["subnet-id"] // "N/A"')
                mac_addr=$(echo "$vnic_json" | jq -r '.data["mac-address"] // "N/A"')
                is_primary=$(echo "$vnic_json" | jq -r '.data["is-primary"] // false')
                
                # Get NSG names from cache
                local nsg_ids nsg_names=""
                nsg_ids=$(echo "$vnic_json" | jq -r '.data["nsg-ids"] // [] | .[]' 2>/dev/null)
                if [[ -n "$nsg_ids" ]]; then
                    while read -r nsg_id; do
                        [[ -z "$nsg_id" ]] && continue
                        local nsg_name
                        nsg_name=$(echo "$cached_nsg_names" | jq -r --arg id "$nsg_id" '.[$id] // "N/A"' 2>/dev/null)
                        [[ "$nsg_name" == "null" ]] && nsg_name="N/A"
                        if [[ -n "$nsg_names" ]]; then
                            nsg_names="${nsg_names}, ${nsg_name}"
                        else
                            nsg_names="$nsg_name"
                        fi
                    done <<< "$nsg_ids"
                fi
                [[ -z "$nsg_names" ]] && nsg_names="-"
                
                # Get subnet name from cache
                local subnet_name="-"
                local route_table_name="-"
                if [[ "$subnet_id" != "N/A" && -n "$subnet_id" ]]; then
                    subnet_name=$(echo "$cached_subnet_names" | jq -r --arg id "$subnet_id" '.[$id].name // "-"' 2>/dev/null)
                    route_table_name=$(echo "$cached_subnet_names" | jq -r --arg id "$subnet_id" '.[$id].rt // "-"' 2>/dev/null)
                    [[ "$subnet_name" == "null" ]] && subnet_name="-"
                    [[ "$route_table_name" == "null" ]] && route_table_name="-"
                fi
                
                local nic_display="$nic_index"
                [[ "$is_primary" == "true" ]] && nic_display="${nic_index}*"
                
                # Format public IP and VLAN display
                local pub_ip_display="-"
                [[ -n "$public_ip" && "$public_ip" != "null" ]] && pub_ip_display="$public_ip"
                local vlan_display="-"
                [[ -n "$vlan_tag" ]] && vlan_display="$vlan_tag"
                
                # Single line with all info - NSG fully expanded near end
                printf "%-3s ${GREEN}%-30s${NC} ${CYAN}%-15s${NC} ${CYAN}%-15s${NC} %-22s %-22s %-6s %-55s ${YELLOW}%s${NC}\n" \
                    "$nic_display" "$vnic_name" "$private_ip" "$pub_ip_display" "$subnet_name" "$route_table_name" "$vlan_display" "$nsg_names" "$vnic_id"
            fi
        done
    else
        echo -e "${YELLOW}No VNICs found${NC}"
    fi
    
    # ========== BOOT VOLUME (with extended details) ==========
    echo ""
    echo -e "${BOLD}${WHITE}─── Boot Volume ───────────────────────────────────────────────────────────────────────────────────────────────${NC}"
    
    if [[ -n "$cached_boot_vol_attachments" ]] && echo "$cached_boot_vol_attachments" | jq -e '.data[]' > /dev/null 2>&1; then
        # Print header (aligned with block volumes)
        printf "${GRAY}%-40s %-9s %-5s %-3s %-5s %-6s %-8s %-4s %-4s %-4s %-6s %s${NC}\n" "Name" "State" "Size" "VPU" "Type" "Backup" "BkupMgd" "Repl" "VGrp" "Hydr" "EncKey" "OCID"
        
        echo "$cached_boot_vol_attachments" | jq -r '.data[] | "\(.["boot-volume-id"])|\(.["lifecycle-state"])"' 2>/dev/null | \
        while IFS='|' read -r bv_id bv_attach_state; do
            [[ -z "$bv_id" ]] && continue
            
            # Get boot volume details from cache
            local bv_json
            bv_json=$(echo "$cached_boot_vol_details" | jq --arg id "$bv_id" '.[$id]' 2>/dev/null)
            
            if [[ -n "$bv_json" && "$bv_json" != "null" ]] && echo "$bv_json" | jq -e '.data' > /dev/null 2>&1; then
                local bv_name bv_state bv_size_gb bv_vpus
                bv_name=$(echo "$bv_json" | jq -r '.data["display-name"] // "N/A"')
                bv_state=$(echo "$bv_json" | jq -r '.data["lifecycle-state"] // "N/A"')
                bv_size_gb=$(echo "$bv_json" | jq -r '.data["size-in-gbs"] // "N/A"')
                bv_vpus=$(echo "$bv_json" | jq -r '.data["vpus-per-gb"] // "N/A"')
                
                # Get additional fields
                local kms_key_id volume_group_id is_hydrated
                kms_key_id=$(echo "$bv_json" | jq -r '.data["kms-key-id"] // empty')
                volume_group_id=$(echo "$bv_json" | jq -r '.data["volume-group-id"] // empty')
                is_hydrated=$(echo "$bv_json" | jq -r '.data["is-hydrated"] // "N/A"')
                
                # Get backup policy from cache
                local backup_policy="None"
                local cached_policy
                cached_policy=$(echo "$cached_backup_policies" | jq -r --arg id "$bv_id" '.[$id] // "None"' 2>/dev/null)
                [[ -n "$cached_policy" && "$cached_policy" != "null" ]] && backup_policy="$cached_policy"
                
                # Backup managed by: Volume (direct) or VolGroup (if in volume group)
                local backup_managed="Volume"
                [[ -n "$volume_group_id" ]] && backup_managed="VolGroup"
                
                # Check cross-region replication
                local repl_status="-"
                local replicas
                replicas=$(echo "$bv_json" | jq -r '.data["boot-volume-replicas"] // [] | length' 2>/dev/null)
                [[ "$replicas" -gt 0 ]] && repl_status="Yes"
                
                # Format displays
                local bv_state_color="$GREEN"
                [[ "$bv_state" != "AVAILABLE" ]] && bv_state_color="$YELLOW"
                
                # Encryption: Oracle managed (no kms-key-id) or Customer (has kms-key-id/Vault)
                local enc_display="Oracle"
                [[ -n "$kms_key_id" ]] && enc_display="Cust"
                
                local vg_display="-"
                [[ -n "$volume_group_id" ]] && vg_display="Yes"
                
                local hydr_display="-"
                [[ "$is_hydrated" == "true" ]] && hydr_display="Yes"
                [[ "$is_hydrated" == "false" ]] && hydr_display="No"
                
                printf "${GREEN}%-40s${NC} ${bv_state_color}%-9s${NC} %-5s %-3s %-5s %-6s %-8s %-4s %-4s %-4s %-6s ${YELLOW}%s${NC}\n" \
                    "$bv_name" "$bv_state" "${bv_size_gb}GB" "$bv_vpus" "boot" "${backup_policy:0:6}" "$backup_managed" "$repl_status" "$vg_display" "$hydr_display" "$enc_display" "$bv_id"
            fi
        done
    else
        echo -e "${YELLOW}No boot volume found${NC}"
    fi
    
    # ========== BLOCK VOLUMES (with extended details) ==========
    echo ""
    echo -e "${BOLD}${WHITE}─── Block Volumes ─────────────────────────────────────────────────────────────────────────────────────────────${NC}"
    
    local vol_count=0
    if [[ -n "$cached_block_vol_attachments" ]] && echo "$cached_block_vol_attachments" | jq -e '.data[]' > /dev/null 2>&1; then
        # Print header (aligned with boot volume)
        printf "${GRAY}%-40s %-9s %-5s %-3s %-5s %-6s %-8s %-4s %-4s %-4s %-6s %s${NC}\n" "Name" "State" "Size" "VPU" "Type" "Backup" "BkupMgd" "Repl" "VGrp" "Hydr" "EncKey" "OCID"
        
        while IFS='|' read -r vol_id attach_state attach_type device is_readonly; do
            [[ -z "$vol_id" ]] && continue
            ((vol_count++))
            
            # Get block volume details from cache
            local vol_json
            vol_json=$(echo "$cached_block_vol_details" | jq --arg id "$vol_id" '.[$id]' 2>/dev/null)
            
            if [[ -n "$vol_json" && "$vol_json" != "null" ]] && echo "$vol_json" | jq -e '.data' > /dev/null 2>&1; then
                local vol_name vol_state vol_size_gb vol_vpus is_hydrated
                vol_name=$(echo "$vol_json" | jq -r '.data["display-name"] // "N/A"')
                vol_state=$(echo "$vol_json" | jq -r '.data["lifecycle-state"] // "N/A"')
                vol_size_gb=$(echo "$vol_json" | jq -r '.data["size-in-gbs"] // "N/A"')
                vol_vpus=$(echo "$vol_json" | jq -r '.data["vpus-per-gb"] // "N/A"')
                is_hydrated=$(echo "$vol_json" | jq -r '.data["is-hydrated"] // "N/A"')
                
                # Get additional fields
                local kms_key_id volume_group_id
                kms_key_id=$(echo "$vol_json" | jq -r '.data["kms-key-id"] // empty')
                volume_group_id=$(echo "$vol_json" | jq -r '.data["volume-group-id"] // empty')
                
                # Get backup policy from cache
                local backup_policy="None"
                local cached_policy
                cached_policy=$(echo "$cached_backup_policies" | jq -r --arg id "$vol_id" '.[$id] // "None"' 2>/dev/null)
                [[ -n "$cached_policy" && "$cached_policy" != "null" ]] && backup_policy="$cached_policy"
                
                # Backup managed by: Volume (direct) or VolGroup (if in volume group)
                local backup_managed="Volume"
                [[ -n "$volume_group_id" ]] && backup_managed="VolGroup"
                
                # Check cross-region replication
                local repl_status="-"
                local replicas
                replicas=$(echo "$vol_json" | jq -r '.data["block-volume-replicas"] // [] | length' 2>/dev/null)
                [[ "$replicas" -gt 0 ]] && repl_status="Yes"
                
                # Format displays
                local vol_state_color="$GREEN"
                [[ "$vol_state" != "AVAILABLE" ]] && vol_state_color="$YELLOW"
                
                local name_display="$vol_name"
                [[ "$is_readonly" == "true" ]] && name_display="${vol_name}*RO"
                
                # Encryption: Oracle managed (no kms-key-id) or Customer (has kms-key-id/Vault)
                local enc_display="Oracle"
                [[ -n "$kms_key_id" ]] && enc_display="Cust"
                
                local vg_display="-"
                [[ -n "$volume_group_id" ]] && vg_display="Yes"
                
                local hydr_display="-"
                [[ "$is_hydrated" == "true" ]] && hydr_display="Yes"
                [[ "$is_hydrated" == "false" ]] && hydr_display="No"
                
                printf "${GREEN}%-40s${NC} ${vol_state_color}%-9s${NC} %-5s %-3s %-5s %-6s %-8s %-4s %-4s %-4s %-6s ${YELLOW}%s${NC}\n" \
                    "$name_display" "$vol_state" "${vol_size_gb}GB" "$vol_vpus" "$attach_type" "${backup_policy:0:6}" "$backup_managed" "$repl_status" "$vg_display" "$hydr_display" "$enc_display" "$vol_id"
            fi
        done < <(echo "$cached_block_vol_attachments" | jq -r '.data[] | "\(.["volume-id"])|\(.["lifecycle-state"])|\(.["attachment-type"])|\(.device // "N/A")|\(.["is-read-only"] // false)"' 2>/dev/null)
    fi
    
    [[ $vol_count -eq 0 ]] && echo -e "${GRAY}No block volumes attached${NC}"
    
    # ========== TAGS ==========
    echo ""
    echo -e "${BOLD}${WHITE}─── Tags ──────────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
    
    # Defined Tags
    local defined_tags
    defined_tags=$(echo "$instance_json" | jq -r '.data["defined-tags"] // {}')
    
    local has_defined_tags="false"
    if [[ -n "$defined_tags" && "$defined_tags" != "{}" ]]; then
        has_defined_tags="true"
        echo -e "${CYAN}Defined Tags:${NC}"
        echo "$defined_tags" | jq -r 'to_entries[] | .key as $ns | .value | to_entries[] | "  \($ns).\(.key) = \(.value)"' 2>/dev/null | while read -r tag_line; do
            # Highlight unhealthy tags
            if [[ "$tag_line" == *"ComputeInstanceHostActions"* ]]; then
                echo -e "  ${RED}★ ${tag_line}${NC}"
            else
                echo -e "  ${GRAY}${tag_line}${NC}"
            fi
        done
    fi
    
    # Freeform Tags
    local freeform_tags
    freeform_tags=$(echo "$instance_json" | jq -r '.data["freeform-tags"] // {}')
    
    local has_freeform_tags="false"
    if [[ -n "$freeform_tags" && "$freeform_tags" != "{}" ]]; then
        has_freeform_tags="true"
        [[ "$has_defined_tags" == "true" ]] && echo ""
        echo -e "${CYAN}Freeform Tags:${NC}"
        echo "$freeform_tags" | jq -r 'to_entries[] | "  \(.key) = \(.value)"' 2>/dev/null | while read -r tag_line; do
            # Highlight GPU/cluster related tags
            if [[ "$tag_line" == *"gpumemorycluster"* || "$tag_line" == *"oke-"* ]]; then
                echo -e "  ${GREEN}${tag_line}${NC}"
            else
                echo -e "  ${GRAY}${tag_line}${NC}"
            fi
        done
    fi
    
    [[ "$has_defined_tags" == "false" && "$has_freeform_tags" == "false" ]] && echo -e "${GRAY}No tags${NC}"
    
    # Check for user_data (cloud-init)
    local user_data_b64
    user_data_b64=$(echo "$instance_json" | jq -r '.data.metadata.user_data // empty')
    
    local has_cloud_init="false"
    if [[ -n "$user_data_b64" ]]; then
        has_cloud_init="true"
        local ud_decoded_size
        ud_decoded_size=$(echo "$user_data_b64" | base64 -d 2>/dev/null | wc -c)
        echo ""
        echo -e "${BOLD}${WHITE}─── Cloud-Init ────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
        local gzip_indicator=""
        is_user_data_gzip "$user_data_b64" && gzip_indicator=" (gzip)"
        printf "${WHITE}%-10s${NC}${GREEN}%-15s${NC}  ${WHITE}%-8s${NC}%-15s\n" "Status:" "Present${gzip_indicator}" "Size:" "~${ud_decoded_size} bytes"
    fi
    
    # Check if in K8s (do once, before loop)
    local k8s_node_name=""
    k8s_node_name=$(kubectl get nodes -o json 2>/dev/null | jq -r --arg ocid "$instance_ocid" '.items[] | select(.spec.providerID | contains($ocid)) | .metadata.name' 2>/dev/null)
    
    # ========== ACTIONS LOOP ==========
    while true; do
        # Show actions menu
        echo ""
        echo -e "${BOLD}${WHITE}─── Actions ───────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
        
        # Line 0: Refresh/view details
        echo -e "  ${MAGENTA}r${NC}) Refresh instance details"
        
        # Line 1: Cloud-init + Console history
        if [[ "$has_cloud_init" == "true" ]]; then
            echo -e "  ${CYAN}1${NC}) View cloud-init    ${CYAN}2${NC}) Save cloud-init    ${CYAN}3${NC}) Compare cloud-init    ${CYAN}4${NC}) Console history"
        else
            echo -e "  ${GRAY}1) View cloud-init    2) Save cloud-init    3) Compare cloud-init${NC}    ${CYAN}4${NC}) Console history"
        fi
        
        # Line 2: Instance lifecycle actions
        echo -e "  ${RED}5${NC}) Reboot             ${RED}6${NC}) Force reboot       ${RED}7${NC}) Stop instance         ${GREEN}8${NC}) Start instance     ${RED}9${NC}) ${RED}TERMINATE${NC}"
        
        # Line 3: Unhealthy tagging options
        echo -e "  ${YELLOW}t${NC}) Tag unhealthy (keep running)     ${GREEN}rt${NC}) Remove unhealthy tag     ${RED}x${NC}) ${RED}Tag unhealthy + TERMINATE${NC}"
        
        # Line 4: K8s node actions (only if in K8s)
        if [[ -n "$k8s_node_name" ]]; then
            echo -e "  ${ORANGE}d${NC}) Drain K8s node     ${ORANGE}c${NC}) Cordon node        ${ORANGE}u${NC}) Uncordon node      ${ORANGE}cd${NC}) Cordon & Drain"
            echo -e "  ${GREEN}bvr${NC}) Boot Volume Replacement (upgrade node image/K8s version)"
        fi
        
        echo ""
        echo -e "  ${CYAN}Enter${NC}) Return to list"
        echo ""
        echo -n -e "${CYAN}Select [r/1-9/t/rt/x/d/c/u/cd/bvr/Enter]: ${NC}"
        
        local action
        read -r action
        
        case "$action" in
        r|R|refresh|REFRESH|details|DETAILS)
            # Re-display instance details by calling self recursively (but without re-fetching)
            # Actually, just break and let the caller loop handle it by re-calling display_instance_details
            echo ""
            echo -e "${YELLOW}Refreshing instance details...${NC}"
            # Return special code to indicate refresh
            return 2
            ;;
        1|cloud-init|cloudinit|ci|view|VIEW)
            if [[ "$has_cloud_init" == "true" ]]; then
                echo ""
                echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
                echo -e "${BOLD}${MAGENTA}                                    CLOUD-INIT USER-DATA                                                       ${NC}"
                echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
                echo -e "${GRAY}Instance: ${WHITE}$display_name${NC}"
                echo -e "${GRAY}OCID:     ${YELLOW}$instance_ocid${NC}"
                echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
                echo ""
                
                # Check if gzip compressed and show message
                if is_user_data_gzip "$user_data_b64"; then
                    echo -e "${GRAY}(gzip compressed - decompressing)${NC}"
                    echo ""
                fi
                
                # Decode and display (handles gzip)
                decode_user_data "$user_data_b64"
                
                echo ""
                echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
                echo ""
                echo -n -e "${CYAN}Press Enter to continue...${NC}"
                read -r
            else
                echo -e "${YELLOW}No cloud-init user-data found for this instance${NC}"
                sleep 1
            fi
            ;;
        2|save|SAVE|s|S)
            if [[ "$has_cloud_init" == "true" ]]; then
                local safe_name
                safe_name=$(echo "$display_name" | tr ' ' '_' | tr -cd '[:alnum:]_-')
                local filename="${safe_name}_cloud-init.yml"
                
                echo ""
                echo -n -e "${CYAN}Save as [${filename}]: ${NC}"
                local custom_filename
                read -r custom_filename
                [[ -n "$custom_filename" ]] && filename="$custom_filename"
                
                local gzip_msg=""
                if is_user_data_gzip "$user_data_b64"; then
                    gzip_msg=" ${GRAY}(decompressed from gzip)${NC}"
                fi
                
                if decode_user_data_to_file "$user_data_b64" "$filename"; then
                    echo -e "${GREEN}✓ Cloud-init saved to: ${WHITE}$(pwd)/${filename}${NC}${gzip_msg}"
                else
                    echo -e "${RED}Failed to save cloud-init${NC}"
                fi
                echo ""
                echo -n -e "${CYAN}Press Enter to continue...${NC}"
                read -r
            else
                echo -e "${YELLOW}No cloud-init user-data found for this instance${NC}"
                sleep 1
            fi
            ;;
        3|compare|COMPARE)
            if [[ "$has_cloud_init" == "true" ]]; then
                compare_instance_cloud_init "$instance_ocid" "$display_name" "$user_data_b64"
            else
                echo -e "${YELLOW}No cloud-init user-data found for this instance${NC}"
                sleep 1
            fi
            ;;
        4|console|CONSOLE|con|CON|history|HISTORY)
            capture_console_history "$instance_ocid" "$display_name"
            ;;
        5|reboot|REBOOT)
            echo ""
            echo -e "${YELLOW}Rebooting instance ${GREEN}$display_name${NC}${YELLOW}...${NC}"
            echo -n -e "${CYAN}Confirm reboot? (yes/no): ${NC}"
            local confirm
            read -r confirm
            if [[ "$confirm" == "yes" ]]; then
                log_action "REBOOT" "oci compute instance action --instance-id $instance_ocid --action SOFTRESET"
                if oci compute instance action --instance-id "$instance_ocid" --action SOFTRESET 2>/dev/null; then
                    echo -e "${GREEN}✓ Reboot initiated successfully${NC}"
                    log_action_result "SUCCESS" "Instance $display_name reboot initiated"
                else
                    echo -e "${RED}✗ Failed to reboot instance${NC}"
                    log_action_result "FAILED" "Instance $display_name reboot failed"
                fi
            else
                echo -e "${YELLOW}Reboot cancelled${NC}"
            fi
            echo ""
            echo -n -e "${CYAN}Press Enter to continue...${NC}"
            read -r
            ;;
        6|force|FORCE)
            echo ""
            echo -e "${YELLOW}Force rebooting instance ${GREEN}$display_name${NC}${YELLOW}...${NC}"
            echo -e "${RED}WARNING: This is a hard reset and may cause data loss!${NC}"
            echo -n -e "${CYAN}Confirm force reboot? (yes/no): ${NC}"
            local confirm
            read -r confirm
            if [[ "$confirm" == "yes" ]]; then
                log_action "FORCE_REBOOT" "oci compute instance action --instance-id $instance_ocid --action RESET"
                if oci compute instance action --instance-id "$instance_ocid" --action RESET 2>/dev/null; then
                    echo -e "${GREEN}✓ Force reboot initiated successfully${NC}"
                    log_action_result "SUCCESS" "Instance $display_name force reboot initiated"
                else
                    echo -e "${RED}✗ Failed to force reboot instance${NC}"
                    log_action_result "FAILED" "Instance $display_name force reboot failed"
                fi
            else
                echo -e "${YELLOW}Force reboot cancelled${NC}"
            fi
            echo ""
            echo -n -e "${CYAN}Press Enter to continue...${NC}"
            read -r
            ;;
        7|stop|STOP)
            echo ""
            echo -e "${YELLOW}Stopping instance ${GREEN}$display_name${NC}${YELLOW}...${NC}"
            echo -n -e "${CYAN}Confirm stop? (yes/no): ${NC}"
            local confirm
            read -r confirm
            if [[ "$confirm" == "yes" ]]; then
                log_action "STOP" "oci compute instance action --instance-id $instance_ocid --action SOFTSTOP"
                if oci compute instance action --instance-id "$instance_ocid" --action SOFTSTOP 2>/dev/null; then
                    echo -e "${GREEN}✓ Stop initiated successfully${NC}"
                    log_action_result "SUCCESS" "Instance $display_name stop initiated"
                else
                    echo -e "${RED}✗ Failed to stop instance${NC}"
                    log_action_result "FAILED" "Instance $display_name stop failed"
                fi
            else
                echo -e "${YELLOW}Stop cancelled${NC}"
            fi
            echo ""
            echo -n -e "${CYAN}Press Enter to continue...${NC}"
            read -r
            ;;
        8|start|START)
            echo ""
            echo -e "${YELLOW}Starting instance ${GREEN}$display_name${NC}${YELLOW}...${NC}"
            echo -n -e "${CYAN}Confirm start? (yes/no): ${NC}"
            local confirm
            read -r confirm
            if [[ "$confirm" == "yes" ]]; then
                log_action "START" "oci compute instance action --instance-id $instance_ocid --action START"
                if oci compute instance action --instance-id "$instance_ocid" --action START 2>/dev/null; then
                    echo -e "${GREEN}✓ Start initiated successfully${NC}"
                    log_action_result "SUCCESS" "Instance $display_name start initiated"
                else
                    echo -e "${RED}✗ Failed to start instance${NC}"
                    log_action_result "FAILED" "Instance $display_name start failed"
                fi
            else
                echo -e "${YELLOW}Start cancelled${NC}"
            fi
            echo ""
            echo -n -e "${CYAN}Press Enter to continue...${NC}"
            read -r
            ;;
        9|terminate|TERMINATE)
            echo ""
            echo -e "${RED}╔════════════════════════════════════════════════════════════════╗${NC}"
            echo -e "${RED}║                    ⚠️  WARNING: TERMINATE  ⚠️                   ║${NC}"
            echo -e "${RED}╚════════════════════════════════════════════════════════════════╝${NC}"
            echo ""
            echo -e "${RED}This will PERMANENTLY DELETE the instance:${NC}"
            echo -e "  Name: ${GREEN}$display_name${NC}"
            echo -e "  OCID: ${YELLOW}$instance_ocid${NC}"
            echo ""
            echo -e "${RED}This action cannot be undone!${NC}"
            echo ""
            
            if [[ -n "$k8s_node_name" ]]; then
                echo -e "${YELLOW}⚠️  This instance is a Kubernetes node: ${CYAN}$k8s_node_name${NC}"
                echo -e "${YELLOW}   Consider draining the node first (option d)${NC}"
                echo ""
            fi
            
            echo -n -e "${RED}Type 'TERMINATE' to confirm deletion: ${NC}"
            local confirm
            read -r confirm
            if [[ "$confirm" == "TERMINATE" ]]; then
                echo ""
                echo -e "${YELLOW}Terminating instance...${NC}"
                log_action "TERMINATE" "oci compute instance terminate --instance-id $instance_ocid --preserve-boot-volume false --force"
                if oci compute instance terminate --instance-id "$instance_ocid" --preserve-boot-volume false --force 2>/dev/null; then
                    echo -e "${GREEN}✓ Terminate initiated successfully${NC}"
                    echo -e "${YELLOW}Instance will be deleted. Boot volume will also be deleted.${NC}"
                    log_action_result "SUCCESS" "Instance $display_name terminate initiated"
                else
                    echo -e "${RED}✗ Failed to terminate instance${NC}"
                    log_action_result "FAILED" "Instance $display_name terminate failed"
                fi
            else
                echo -e "${YELLOW}Termination cancelled${NC}"
            fi
            echo ""
            echo -n -e "${CYAN}Press Enter to continue...${NC}"
            read -r
            ;;
        d|D|drain|DRAIN)
            if [[ -z "$k8s_node_name" ]]; then
                echo -e "${RED}This instance is not a Kubernetes node${NC}"
                sleep 1
            else
                echo ""
                echo -e "${YELLOW}Draining Kubernetes node ${GREEN}$k8s_node_name${NC}${YELLOW}...${NC}"
                echo -e "${WHITE}This will evict all pods (except DaemonSets) from the node.${NC}"
                echo ""
                echo -n -e "${CYAN}Confirm drain? (yes/no): ${NC}"
                local confirm
                read -r confirm
                if [[ "$confirm" == "yes" ]]; then
                    echo ""
                    log_action "K8S_DRAIN" "kubectl drain $k8s_node_name --ignore-daemonsets --delete-emptydir-data"
                    if kubectl drain "$k8s_node_name" --ignore-daemonsets --delete-emptydir-data 2>&1; then
                        echo -e "${GREEN}✓ Node drained successfully${NC}"
                        log_action_result "SUCCESS" "Node $k8s_node_name drained"
                    else
                        echo -e "${RED}✗ Failed to drain node (some pods may not be evictable)${NC}"
                        log_action_result "FAILED" "Node $k8s_node_name drain failed"
                    fi
                else
                    echo -e "${YELLOW}Drain cancelled${NC}"
                fi
                echo ""
                echo -n -e "${CYAN}Press Enter to continue...${NC}"
                read -r
            fi
            ;;
        cd|CD|cordon-drain|CORDON-DRAIN)
            if [[ -z "$k8s_node_name" ]]; then
                echo -e "${RED}This instance is not a Kubernetes node${NC}"
                sleep 1
            else
                echo ""
                echo -e "${YELLOW}Cordon & Drain Kubernetes node ${GREEN}$k8s_node_name${NC}${YELLOW}...${NC}"
                echo -e "${WHITE}Step 1: Cordon (mark unschedulable)${NC}"
                echo -e "${WHITE}Step 2: Drain (evict all pods except DaemonSets)${NC}"
                echo ""
                echo -e "${RED}⚠️  This will evict all pods from the node!${NC}"
                echo ""
                echo -n -e "${CYAN}Confirm cordon & drain? (yes/no): ${NC}"
                local confirm
                read -r confirm
                if [[ "$confirm" == "yes" ]]; then
                    echo ""
                    echo -e "${YELLOW}Step 1: Cordoning...${NC}"
                    echo -e "${GRAY}$ kubectl cordon $k8s_node_name${NC}"
                    log_action "K8S_CORDON" "kubectl cordon $k8s_node_name"
                    if kubectl cordon "$k8s_node_name" 2>&1; then
                        echo -e "${GREEN}✓ Node cordoned${NC}"
                        log_action_result "SUCCESS" "Node $k8s_node_name cordoned"
                        echo ""
                        echo -e "${YELLOW}Step 2: Draining...${NC}"
                        echo -e "${GRAY}$ kubectl drain $k8s_node_name --ignore-daemonsets --delete-emptydir-data${NC}"
                        log_action "K8S_DRAIN" "kubectl drain $k8s_node_name --ignore-daemonsets --delete-emptydir-data"
                        if kubectl drain "$k8s_node_name" --ignore-daemonsets --delete-emptydir-data 2>&1; then
                            echo -e "${GREEN}✓ Node drained successfully${NC}"
                            log_action_result "SUCCESS" "Node $k8s_node_name drained"
                        else
                            echo -e "${RED}✗ Failed to drain node (node remains cordoned)${NC}"
                            log_action_result "FAILED" "Node $k8s_node_name drain failed (remains cordoned)"
                        fi
                    else
                        echo -e "${RED}✗ Failed to cordon node - skipping drain${NC}"
                        log_action_result "FAILED" "Node $k8s_node_name cordon failed - skipping drain"
                    fi
                else
                    echo -e "${YELLOW}Cordon & drain cancelled${NC}"
                fi
                echo ""
                echo -n -e "${CYAN}Press Enter to continue...${NC}"
                read -r
            fi
            ;;
        c|C|cordon|CORDON)
            if [[ -z "$k8s_node_name" ]]; then
                echo -e "${RED}This instance is not a Kubernetes node${NC}"
                sleep 1
            else
                echo ""
                echo -e "${YELLOW}Cordoning Kubernetes node ${GREEN}$k8s_node_name${NC}${YELLOW}...${NC}"
                echo -e "${WHITE}This marks the node as unschedulable (existing pods continue running).${NC}"
                echo ""
                echo -n -e "${CYAN}Confirm cordon? (yes/no): ${NC}"
                local confirm
                read -r confirm
                if [[ "$confirm" == "yes" ]]; then
                    log_action "K8S_CORDON" "kubectl cordon $k8s_node_name"
                    if kubectl cordon "$k8s_node_name" 2>&1; then
                        echo -e "${GREEN}✓ Node cordoned successfully${NC}"
                        log_action_result "SUCCESS" "Node $k8s_node_name cordoned"
                    else
                        echo -e "${RED}✗ Failed to cordon node${NC}"
                        log_action_result "FAILED" "Node $k8s_node_name cordon failed"
                    fi
                else
                    echo -e "${YELLOW}Cordon cancelled${NC}"
                fi
                echo ""
                echo -n -e "${CYAN}Press Enter to continue...${NC}"
                read -r
            fi
            ;;
        u|U|uncordon|UNCORDON)
            if [[ -z "$k8s_node_name" ]]; then
                echo -e "${RED}This instance is not a Kubernetes node${NC}"
                sleep 1
            else
                echo ""
                echo -e "${YELLOW}Uncordoning Kubernetes node ${GREEN}$k8s_node_name${NC}${YELLOW}...${NC}"
                echo -e "${WHITE}This marks the node as schedulable again.${NC}"
                echo ""
                echo -n -e "${CYAN}Confirm uncordon? (yes/no): ${NC}"
                local confirm
                read -r confirm
                if [[ "$confirm" == "yes" ]]; then
                    log_action "K8S_UNCORDON" "kubectl uncordon $k8s_node_name"
                    if kubectl uncordon "$k8s_node_name" 2>&1; then
                        echo -e "${GREEN}✓ Node uncordoned successfully${NC}"
                        log_action_result "SUCCESS" "Node $k8s_node_name uncordoned"
                    else
                        echo -e "${RED}✗ Failed to uncordon node${NC}"
                        log_action_result "FAILED" "Node $k8s_node_name uncordon failed"
                    fi
                else
                    echo -e "${YELLOW}Uncordon cancelled${NC}"
                fi
                echo ""
                echo -n -e "${CYAN}Press Enter to continue...${NC}"
                read -r
            fi
            ;;
        bvr|BVR)
            if [[ -z "$k8s_node_name" ]]; then
                echo -e "${RED}This instance is not a Kubernetes node - BVR requires a K8s node${NC}"
                sleep 1
            else
                compute_boot_volume_replacement "$instance_ocid"
            fi
            ;;
        t|T|tag|TAG)
            # Tag instance as unhealthy (no terminate)
            tag_instance_unhealthy "$instance_ocid" "$display_name" "false"
            ;;
        rt|RT|removetag|REMOVETAG)
            # Remove unhealthy tag from instance
            remove_instance_unhealthy_tag "$instance_ocid" "$display_name"
            ;;
        x|X)
            # Tag instance as unhealthy AND terminate
            tag_instance_unhealthy "$instance_ocid" "$display_name" "true"
            ;;
        *)
            # Return to instance list (exit the actions loop)
            break
            ;;
    esac
    done  # End of actions loop
}

#--------------------------------------------------------------------------------
# Tag instance as unhealthy with optional terminate
# Args: $1 = instance OCID, $2 = display name, $3 = terminate (true/false)
#--------------------------------------------------------------------------------
tag_instance_unhealthy() {
    local instance_ocid="$1"
    local display_name="$2"
    local do_terminate="${3:-false}"
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    # Oracle defined tag namespace and key for host actions
    local tag_namespace="ComputeInstanceHostActions"
    local tag_key="CustomerReportedHostStatus"
    local tag_value="unhealthy"
    
    echo ""
    if [[ "$do_terminate" == "true" ]]; then
        echo -e "${RED}╔════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${RED}║              ⚠️  TAG UNHEALTHY + TERMINATE INSTANCE  ⚠️                         ║${NC}"
        echo -e "${RED}╚════════════════════════════════════════════════════════════════════════════════╝${NC}"
    else
        echo -e "${YELLOW}╔════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${YELLOW}║                         TAG INSTANCE AS UNHEALTHY                              ║${NC}"
        echo -e "${YELLOW}╚════════════════════════════════════════════════════════════════════════════════╝${NC}"
    fi
    echo ""
    echo -e "${WHITE}Instance:${NC}  ${GREEN}$display_name${NC}"
    echo -e "${WHITE}OCID:${NC}      ${YELLOW}$instance_ocid${NC}"
    echo ""
    echo -e "${WHITE}Defined tag to apply:${NC}"
    echo -e "  ${CYAN}Namespace:${NC} ${MAGENTA}$tag_namespace${NC}"
    echo -e "  ${CYAN}Key:${NC}       ${MAGENTA}$tag_key${NC}"
    echo -e "  ${CYAN}Value:${NC}     ${MAGENTA}$tag_value${NC}"
    echo ""
    
    if [[ "$do_terminate" == "true" ]]; then
        echo -e "${RED}⚠️  This will TAG the instance as unhealthy AND TERMINATE it!${NC}"
        echo ""
        echo -n -e "${RED}Type 'yes' to confirm TAG + TERMINATE: ${NC}"
    else
        echo -e "${YELLOW}This will TAG the instance as unhealthy (instance will continue running).${NC}"
        echo ""
        echo -n -e "${CYAN}Confirm tag? (yes/no): ${NC}"
    fi
    
    local confirm
    read -r confirm
    
    if [[ "$confirm" != "yes" ]]; then
        echo -e "${YELLOW}Operation cancelled${NC}"
        echo ""
        echo -n -e "${CYAN}Press Enter to continue...${NC}"
        read -r
        return
    fi
    
    # Get current defined tags
    echo ""
    echo -e "${YELLOW}Fetching current instance tags...${NC}"
    
    local instance_json
    instance_json=$(oci compute instance get \
        --instance-id "$instance_ocid" \
        --region "$region" \
        --output json 2>&1)
    
    if [[ $? -ne 0 ]]; then
        echo -e "${RED}Failed to fetch instance details:${NC}"
        echo "$instance_json"
        echo ""
        echo -n -e "${CYAN}Press Enter to continue...${NC}"
        read -r
        return 1
    fi
    
    # Extract current defined-tags
    local current_defined_tags
    current_defined_tags=$(echo "$instance_json" | jq -r '.data["defined-tags"] // {}')
    
    # Show current tags
    echo ""
    echo -e "${WHITE}Current defined tags:${NC}"
    if [[ -n "$current_defined_tags" && "$current_defined_tags" != "{}" ]]; then
        echo "$current_defined_tags" | jq -r 'to_entries[] | .key as $ns | .value | to_entries[] | "  \($ns).\(.key) = \(.value)"' 2>/dev/null
    else
        echo -e "  ${GRAY}(none)${NC}"
    fi
    echo ""
    
    # Merge in our new tag (preserving all existing tags)
    local updated_defined_tags
    updated_defined_tags=$(echo "$current_defined_tags" | jq --arg ns "$tag_namespace" --arg key "$tag_key" --arg val "$tag_value" '
        .[$ns] = ((.[$ns] // {}) + {($key): $val})
    ')
    
    # Format the JSON for display (compact for command, pretty for log)
    local updated_tags_compact
    updated_tags_compact=$(echo "$updated_defined_tags" | jq -c '.')
    
    # Build the update command for display
    local update_cmd="oci compute instance update --instance-id \"$instance_ocid\" --region \"$region\" --defined-tags '${updated_tags_compact}' --force"
    
    echo -e "${WHITE}Command to execute:${NC}"
    echo -e "${GRAY}oci compute instance update \\${NC}"
    echo -e "${GRAY}  --instance-id \"$instance_ocid\" \\${NC}"
    echo -e "${GRAY}  --region \"$region\" \\${NC}"
    echo -e "${GRAY}  --defined-tags '${NC}"
    echo "$updated_defined_tags" | jq '.' | while IFS= read -r line; do
        echo -e "${GRAY}$line${NC}"
    done
    echo -e "${GRAY}' --force${NC}"
    echo ""
    
    # Log the action
    log_action "TAG_UNHEALTHY" "$update_cmd"
    
    # Apply the tag
    echo -e "${YELLOW}Applying defined tag...${NC}"
    
    local tag_result
    tag_result=$(oci compute instance update \
        --instance-id "$instance_ocid" \
        --region "$region" \
        --defined-tags "$updated_defined_tags" \
        --force \
        --output json 2>&1)
    
    local tag_exit_code=$?
    
    if [[ $tag_exit_code -eq 0 ]]; then
        echo -e "${GREEN}✓ Instance tagged as unhealthy successfully${NC}"
        log_action_result "SUCCESS" "Instance $display_name tagged with $tag_namespace.$tag_key=$tag_value"
        
        # Verify the tag was applied
        local applied_tag
        applied_tag=$(echo "$tag_result" | jq -r --arg ns "$tag_namespace" --arg key "$tag_key" '.data["defined-tags"][$ns][$key] // "NOT_SET"')
        echo -e "  ${CYAN}Verified:${NC} ${MAGENTA}$tag_namespace.$tag_key${NC} = ${GREEN}$applied_tag${NC}"
        
        # If terminate requested, show instance details with the tag first
        if [[ "$do_terminate" == "true" ]]; then
            echo ""
            echo -e "${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
            echo -e "${YELLOW}                           INSTANCE DETAILS WITH APPLIED TAG                                                    ${NC}"
            echo -e "${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
            echo ""
            
            # Re-fetch instance to show updated tags
            local updated_instance_json
            updated_instance_json=$(oci compute instance get \
                --instance-id "$instance_ocid" \
                --region "$region" \
                --output json 2>/dev/null)
            
            if [[ -n "$updated_instance_json" ]]; then
                # Display key instance info
                local inst_state inst_shape inst_ad inst_created
                inst_state=$(echo "$updated_instance_json" | jq -r '.data["lifecycle-state"] // "N/A"')
                inst_shape=$(echo "$updated_instance_json" | jq -r '.data.shape // "N/A"')
                inst_ad=$(echo "$updated_instance_json" | jq -r '.data["availability-domain"] // "N/A"')
                inst_created=$(echo "$updated_instance_json" | jq -r '.data["time-created"] // "N/A"')
                
                echo -e "${WHITE}Instance:${NC}       ${GREEN}$display_name${NC}"
                echo -e "${WHITE}OCID:${NC}           ${YELLOW}$instance_ocid${NC}"
                echo -e "${WHITE}State:${NC}          ${CYAN}$inst_state${NC}"
                echo -e "${WHITE}Shape:${NC}          ${CYAN}$inst_shape${NC}"
                echo -e "${WHITE}AD:${NC}             ${CYAN}${inst_ad##*:}${NC}"
                echo -e "${WHITE}Created:${NC}        ${GRAY}${inst_created:0:19}${NC}"
                echo ""
                
                # Display defined tags (highlighting the unhealthy tag)
                echo -e "${WHITE}─── Defined Tags ───${NC}"
                local defined_tags
                defined_tags=$(echo "$updated_instance_json" | jq -r '.data["defined-tags"] // {}')
                
                if [[ -n "$defined_tags" && "$defined_tags" != "{}" ]]; then
                    echo "$defined_tags" | jq -r 'to_entries[] | .key as $ns | .value | to_entries[] | "\($ns).\(.key)=\(.value)"' 2>/dev/null | while read -r tag_line; do
                        if [[ "$tag_line" == *"$tag_namespace.$tag_key"* ]]; then
                            # Highlight the unhealthy tag
                            echo -e "  ${RED}★ $tag_line${NC}  ${RED}← UNHEALTHY TAG APPLIED${NC}"
                        else
                            echo -e "  ${GRAY}$tag_line${NC}"
                        fi
                    done
                else
                    echo -e "  ${GRAY}(none)${NC}"
                fi
                
                # Display freeform tags if any
                local freeform_tags
                freeform_tags=$(echo "$updated_instance_json" | jq -r '.data["freeform-tags"] // {}')
                if [[ -n "$freeform_tags" && "$freeform_tags" != "{}" ]]; then
                    echo ""
                    echo -e "${WHITE}─── Freeform Tags ───${NC}"
                    echo "$freeform_tags" | jq -r 'to_entries[] | "  \(.key)=\(.value)"' 2>/dev/null
                fi
            fi
            
            echo ""
            echo -e "${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        fi
    else
        echo -e "${RED}✗ Failed to tag instance:${NC}"
        echo "$tag_result"
        log_action_result "FAILED" "Failed to tag instance $display_name"
        
        # Check if it's a tag namespace issue
        if echo "$tag_result" | grep -qi "TagDefinition\|TagNamespace\|does not exist"; then
            echo ""
            echo -e "${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
            echo -e "${YELLOW}NOTE: The tag namespace '$tag_namespace' or key '$tag_key' may not exist in your tenancy.${NC}"
            echo -e "${YELLOW}You may need to create it first or use a different tag.${NC}"
            echo ""
            echo -e "${WHITE}To create the tag namespace and key, use:${NC}"
            echo -e "${GRAY}  oci iam tag-namespace create --compartment-id <root-compartment> --name \"$tag_namespace\" --description \"Host action tags\"${NC}"
            echo -e "${GRAY}  oci iam tag create --tag-namespace-id <namespace-ocid> --name \"$tag_key\" --description \"Customer reported host status\"${NC}"
            echo -e "${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        fi
        
        echo ""
        echo -n -e "${CYAN}Press Enter to continue...${NC}"
        read -r
        return 1
    fi
    
    # If terminate requested, do it now
    if [[ "$do_terminate" == "true" ]]; then
        echo ""
        echo -e "${RED}╔════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${RED}║                    ⚠️  FINAL CONFIRMATION TO TERMINATE  ⚠️                       ║${NC}"
        echo -e "${RED}╚════════════════════════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "${WHITE}Instance ${GREEN}$display_name${NC}${WHITE} has been tagged as unhealthy.${NC}"
        echo -e "${RED}Are you sure you want to TERMINATE this instance?${NC}"
        echo ""
        echo -n -e "${RED}Type 'TERMINATE' to proceed (or anything else to cancel): ${NC}"
        
        local final_confirm
        read -r final_confirm
        
        if [[ "$final_confirm" != "TERMINATE" ]]; then
            echo -e "${YELLOW}Termination cancelled. Instance remains tagged as unhealthy.${NC}"
            echo ""
            echo -n -e "${CYAN}Press Enter to continue...${NC}"
            read -r
            return 0
        fi
        
        echo ""
        echo -e "${RED}Proceeding with instance termination...${NC}"
        
        local terminate_cmd="oci compute instance terminate --instance-id \"$instance_ocid\" --region \"$region\" --preserve-boot-volume false --force"
        
        echo ""
        echo -e "${WHITE}Command to execute:${NC}"
        echo -e "${GRAY}$terminate_cmd${NC}"
        echo ""
        
        log_action "TERMINATE" "$terminate_cmd"
        
        local terminate_result
        terminate_result=$(oci compute instance terminate \
            --instance-id "$instance_ocid" \
            --region "$region" \
            --preserve-boot-volume false \
            --force 2>&1)
        
        if [[ $? -eq 0 ]]; then
            echo -e "${GREEN}✓ Instance termination initiated${NC}"
            log_action_result "SUCCESS" "Instance $display_name termination initiated"
        else
            echo -e "${RED}✗ Failed to terminate instance:${NC}"
            echo "$terminate_result"
            log_action_result "FAILED" "Failed to terminate instance $display_name"
        fi
    fi
    
    echo ""
    echo -n -e "${CYAN}Press Enter to continue...${NC}"
    read -r
}

#--------------------------------------------------------------------------------
# Remove unhealthy tag from instance
# Args: $1 = instance OCID, $2 = display name
#--------------------------------------------------------------------------------
remove_instance_unhealthy_tag() {
    local instance_ocid="$1"
    local display_name="$2"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    # Oracle defined tag namespace and key for host actions
    local tag_namespace="ComputeInstanceHostActions"
    local tag_key="CustomerReportedHostStatus"
    
    echo ""
    echo -e "${GREEN}╔════════════════════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${GREEN}║                       REMOVE UNHEALTHY TAG FROM INSTANCE                       ║${NC}"
    echo -e "${GREEN}╚════════════════════════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "${WHITE}Instance:${NC}  ${GREEN}$display_name${NC}"
    echo -e "${WHITE}OCID:${NC}      ${YELLOW}$instance_ocid${NC}"
    echo ""
    
    # Get current defined tags
    echo -e "${YELLOW}Fetching current instance tags...${NC}"
    
    local instance_json
    instance_json=$(oci compute instance get \
        --instance-id "$instance_ocid" \
        --region "$region" \
        --output json 2>&1)
    
    if [[ $? -ne 0 ]]; then
        echo -e "${RED}Failed to fetch instance details:${NC}"
        echo "$instance_json"
        echo ""
        echo -n -e "${CYAN}Press Enter to continue...${NC}"
        read -r
        return 1
    fi
    
    # Extract current defined-tags
    local current_defined_tags
    current_defined_tags=$(echo "$instance_json" | jq -r '.data["defined-tags"] // {}')
    
    # Check if the tag exists
    local current_tag_value
    current_tag_value=$(echo "$current_defined_tags" | jq -r --arg ns "$tag_namespace" --arg key "$tag_key" '.[$ns][$key] // empty')
    
    if [[ -z "$current_tag_value" ]]; then
        echo ""
        echo -e "${YELLOW}The unhealthy tag is not set on this instance.${NC}"
        echo -e "  ${CYAN}$tag_namespace.$tag_key${NC} = ${GRAY}(not set)${NC}"
        echo ""
        echo -n -e "${CYAN}Press Enter to continue...${NC}"
        read -r
        return 0
    fi
    
    echo ""
    echo -e "${WHITE}Current tag to remove:${NC}"
    echo -e "  ${CYAN}Namespace:${NC} ${MAGENTA}$tag_namespace${NC}"
    echo -e "  ${CYAN}Key:${NC}       ${MAGENTA}$tag_key${NC}"
    echo -e "  ${CYAN}Value:${NC}     ${RED}$current_tag_value${NC}"
    echo ""
    
    # Show all current tags
    echo -e "${WHITE}All current defined tags:${NC}"
    if [[ -n "$current_defined_tags" && "$current_defined_tags" != "{}" ]]; then
        echo "$current_defined_tags" | jq -r 'to_entries[] | .key as $ns | .value | to_entries[] | "\($ns).\(.key) = \(.value)"' 2>/dev/null | while read -r tag_line; do
            if [[ "$tag_line" == *"$tag_namespace.$tag_key"* ]]; then
                echo -e "  ${RED}★ $tag_line${NC}  ${RED}← TO BE REMOVED${NC}"
            else
                echo -e "  ${GRAY}$tag_line${NC}"
            fi
        done
    fi
    echo ""
    
    echo -e "${GREEN}This will REMOVE the unhealthy tag from the instance.${NC}"
    echo ""
    echo -n -e "${CYAN}Confirm removal? (yes/no): ${NC}"
    
    local confirm
    read -r confirm
    
    if [[ "$confirm" != "yes" ]]; then
        echo -e "${YELLOW}Operation cancelled${NC}"
        echo ""
        echo -n -e "${CYAN}Press Enter to continue...${NC}"
        read -r
        return
    fi
    
    # Remove the tag by deleting the key from the namespace
    local updated_defined_tags
    updated_defined_tags=$(echo "$current_defined_tags" | jq --arg ns "$tag_namespace" --arg key "$tag_key" '
        if .[$ns] then
            .[$ns] |= del(.[$key]) |
            if .[$ns] == {} then del(.[$ns]) else . end
        else
            .
        end
    ')
    
    # Format the JSON for display
    local updated_tags_compact
    updated_tags_compact=$(echo "$updated_defined_tags" | jq -c '.')
    
    # Build the update command for display
    local update_cmd="oci compute instance update --instance-id \"$instance_ocid\" --region \"$region\" --defined-tags '${updated_tags_compact}' --force"
    
    echo ""
    echo -e "${WHITE}Command to execute:${NC}"
    echo -e "${GRAY}oci compute instance update \\${NC}"
    echo -e "${GRAY}  --instance-id \"$instance_ocid\" \\${NC}"
    echo -e "${GRAY}  --region \"$region\" \\${NC}"
    echo -e "${GRAY}  --defined-tags '${NC}"
    echo "$updated_defined_tags" | jq '.' | while IFS= read -r line; do
        echo -e "${GRAY}$line${NC}"
    done
    echo -e "${GRAY}' --force${NC}"
    echo ""
    
    # Log the action
    log_action "REMOVE_UNHEALTHY_TAG" "$update_cmd"
    
    # Apply the update
    echo -e "${YELLOW}Removing unhealthy tag...${NC}"
    
    local tag_result
    tag_result=$(oci compute instance update \
        --instance-id "$instance_ocid" \
        --region "$region" \
        --defined-tags "$updated_defined_tags" \
        --force \
        --output json 2>&1)
    
    local tag_exit_code=$?
    
    if [[ $tag_exit_code -eq 0 ]]; then
        echo -e "${GREEN}✓ Unhealthy tag removed successfully${NC}"
        log_action_result "SUCCESS" "Instance $display_name - removed $tag_namespace.$tag_key tag"
        
        # Verify the tag was removed
        local verified_tag
        verified_tag=$(echo "$tag_result" | jq -r --arg ns "$tag_namespace" --arg key "$tag_key" '.data["defined-tags"][$ns][$key] // "REMOVED"')
        if [[ "$verified_tag" == "REMOVED" || -z "$verified_tag" ]]; then
            echo -e "  ${CYAN}Verified:${NC} ${MAGENTA}$tag_namespace.$tag_key${NC} = ${GREEN}(removed)${NC}"
        else
            echo -e "  ${YELLOW}Warning:${NC} Tag may still exist: ${MAGENTA}$tag_namespace.$tag_key${NC} = ${RED}$verified_tag${NC}"
        fi
        
        # Show updated tags
        echo ""
        echo -e "${WHITE}─── Updated Defined Tags ───${NC}"
        local final_tags
        final_tags=$(echo "$tag_result" | jq -r '.data["defined-tags"] // {}')
        if [[ -n "$final_tags" && "$final_tags" != "{}" ]]; then
            echo "$final_tags" | jq -r 'to_entries[] | .key as $ns | .value | to_entries[] | "  \($ns).\(.key) = \(.value)"' 2>/dev/null
        else
            echo -e "  ${GRAY}(no defined tags)${NC}"
        fi
    else
        echo -e "${RED}✗ Failed to remove tag:${NC}"
        echo "$tag_result"
        log_action_result "FAILED" "Failed to remove unhealthy tag from instance $display_name"
    fi
    
    echo ""
    echo -n -e "${CYAN}Press Enter to continue...${NC}"
    read -r
}

#--------------------------------------------------------------------------------
# Interactive console history - entry point from instance details menu
# Args: $1 = instance OCID, $2 = instance display name
#--------------------------------------------------------------------------------
capture_console_history() {
    local instance_ocid="$1"
    local instance_name="$2"
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    echo ""
    echo -e "${BOLD}${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${YELLOW}                                         CONSOLE HISTORY                                                        ${NC}"
    echo -e "${BOLD}${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${WHITE}Instance:${NC} ${GREEN}$instance_name${NC}"
    echo -e "${WHITE}OCID:${NC}     ${YELLOW}$instance_ocid${NC}"
    echo ""
    
    # Check for existing console history captures
    echo -e "${YELLOW}Checking for existing console history captures...${NC}"
    
    local existing_history
    existing_history=$(oci --region "$region" compute console-history list \
        --compartment-id "$compartment_id" \
        --instance-id "$instance_ocid" \
        --lifecycle-state "SUCCEEDED" \
        --sort-by "TIMECREATED" \
        --sort-order "DESC" \
        --limit 5 \
        --output json 2>/dev/null)
    
    local history_count=0
    [[ -n "$existing_history" ]] && history_count=$(echo "$existing_history" | jq -r '.data | length' 2>/dev/null) || history_count=0
    [[ ! "$history_count" =~ ^[0-9]+$ ]] && history_count=0
    
    if [[ $history_count -gt 0 ]]; then
        echo ""
        echo -e "${WHITE}Recent console history captures:${NC}"
        echo ""
        
        declare -a HISTORY_LIST=()
        local idx=0
        
        printf "  ${GRAY}%-4s %-25s %-20s${NC}\n" "#" "Time Created" "State"
        echo -e "  ${GRAY}────────────────────────────────────────────────────────────${NC}"
        
        while IFS='|' read -r hist_id hist_time hist_state; do
            [[ -z "$hist_id" ]] && continue
            ((idx++))
            HISTORY_LIST+=("$hist_id")
            printf "  ${YELLOW}%-4s${NC} ${WHITE}%-25s${NC} ${GREEN}%-20s${NC}\n" "${idx})" "${hist_time:0:19}" "$hist_state"
        done < <(echo "$existing_history" | jq -r '.data[] | "\(.id)|\(.["time-created"])|\(.["lifecycle-state"])"' 2>/dev/null)
        
        echo ""
        echo -e "  ${CYAN}n${NC}) Capture new console history"
        echo -e "  ${CYAN}b${NC}) Back"
        echo ""
        echo -n -e "${CYAN}Select existing capture [1-${idx}] or 'n' for new: ${NC}"
        local choice
        read -r choice
        
        if [[ "$choice" == "n" || "$choice" == "N" ]]; then
            # Capture new using unified function (auto_cleanup=true, interactive=true)
            fetch_and_display_console_history "$instance_ocid" "$region" "$instance_name" "true" "true"
            echo ""
            echo -n -e "${CYAN}Press Enter to continue...${NC}"
            read -r
        elif [[ "$choice" == "b" || "$choice" == "B" || -z "$choice" ]]; then
            return
        elif [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le ${#HISTORY_LIST[@]} ]]; then
            local selected_id="${HISTORY_LIST[$((choice-1))]}"
            # Display existing history content
            _display_existing_console_history "$selected_id" "$instance_name" "$region"
            echo ""
            echo -n -e "${CYAN}Press Enter to continue...${NC}"
            read -r
        else
            echo -e "${RED}Invalid selection${NC}"
            sleep 1
        fi
    else
        echo ""
        echo -e "${GRAY}No existing console history captures found.${NC}"
        echo ""
        # Automatically capture new console history using unified function
        fetch_and_display_console_history "$instance_ocid" "$region" "$instance_name" "true" "true"
        echo ""
        echo -n -e "${CYAN}Press Enter to continue...${NC}"
        read -r
    fi
}

#--------------------------------------------------------------------------------
# Display existing console history content (for viewing previously captured history)
# Args: $1 = console history OCID, $2 = instance display name, $3 = region
#--------------------------------------------------------------------------------
_display_existing_console_history() {
    local history_id="$1"
    local instance_name="$2"
    local region="${3:-${EFFECTIVE_REGION:-$REGION}}"
    
    echo ""
    echo -e "${YELLOW}Fetching console output...${NC}"
    
    # Build the command (for display)
    local cmd="oci --region \"$region\" compute console-history get-content --instance-console-history-id \"$history_id\" --length 10000000 --file -"
    echo -e "${GRAY}Command: ${cmd}${NC}"
    echo ""
    
    # Use temp file for reliability
    local temp_output temp_error
    temp_output=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    temp_error=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    
    # Capture raw output for display if empty
    local raw_output
    raw_output=$(oci --region "$region" compute console-history get-content \
        --instance-console-history-id "$history_id" \
        --length 10000000 \
        --file "$temp_output" 2>&1)
    local exit_code=$?
    
    echo -e "${BOLD}${CYAN}─── Console Output ───────────────────────────────────────────────────────────────${NC}"
    echo ""
    
    if [[ $exit_code -eq 0 ]]; then
        if [[ -s "$temp_output" ]]; then
            cat "$temp_output"
            echo ""
            echo -e "${BOLD}${CYAN}─── End of Console Output ────────────────────────────────────────────────────────${NC}"
            echo ""
            
            # Option to save
            echo -n -e "${CYAN}Save to file? [y/N]: ${NC}"
            local save_choice
            read -r save_choice
            
            if [[ "$save_choice" =~ ^[Yy] ]]; then
                local safe_name
                safe_name=$(echo "$instance_name" | tr ' ' '_' | tr -cd '[:alnum:]_-')
                local filename="${safe_name}_console_$(date +%Y%m%d_%H%M%S).log"
                
                echo -n -e "${CYAN}Filename [${filename}]: ${NC}"
                local custom_filename
                read -r custom_filename
                [[ -n "$custom_filename" ]] && filename="$custom_filename"
                
                if cp "$temp_output" "$filename" 2>/dev/null; then
                    echo -e "${GREEN}✓ Console output saved to: ${WHITE}$(pwd)/${filename}${NC}"
                else
                    echo -e "${RED}Failed to save console output${NC}"
                fi
            fi
        else
            echo -e "${YELLOW}(Console history is empty - no serial console output captured)${NC}"
            echo ""
            echo -e "${WHITE}OCI CLI raw output:${NC}"
            if [[ -n "$raw_output" ]]; then
                echo -e "${GRAY}${raw_output}${NC}"
            else
                echo -e "${GRAY}(no output returned)${NC}"
            fi
            echo ""
            echo -e "${WHITE}Note: This can happen if:${NC}"
            echo -e "${GRAY}  - The instance has not produced any serial console output${NC}"
            echo -e "${GRAY}  - Serial console logging is not enabled on the instance${NC}"
            echo -e "${GRAY}  - The instance was recently created/rebooted${NC}"
            echo ""
            echo -e "${BOLD}${CYAN}─── End of Console Output ────────────────────────────────────────────────────────${NC}"
        fi
    else
        echo -e "${RED}Failed to fetch console history content${NC}"
        echo -e "${GRAY}Exit code: ${exit_code}${NC}"
        echo -e "${WHITE}OCI CLI output:${NC}"
        echo -e "${GRAY}${raw_output}${NC}"
        if [[ -s "$temp_error" ]]; then
            echo -e "${WHITE}Stderr:${NC}"
            cat "$temp_error"
        fi
        echo ""
        echo -e "${BOLD}${CYAN}─── End of Console Output ────────────────────────────────────────────────────────${NC}"
    fi
    
    # Cleanup temp files
    rm -f "$temp_output" "$temp_error"
}

#--------------------------------------------------------------------------------
# Compare instance cloud-init - offers choice of another instance or instance config
# Args: $1 = instance OCID, $2 = instance display name, $3 = instance user_data base64
#--------------------------------------------------------------------------------
compare_instance_cloud_init() {
    local instance_ocid="$1"
    local instance_name="$2"
    local instance_ud_b64="$3"
    
    echo ""
    echo -e "${BOLD}${BLUE}═══ Compare Cloud-Init ═══${NC}"
    echo ""
    echo -e "${WHITE}Current Instance:${NC} ${GREEN}$instance_name${NC}"
    echo ""
    echo -e "${BOLD}${WHITE}Compare against:${NC}"
    echo -e "  ${YELLOW}1${NC}) Another Compute Instance"
    echo -e "  ${YELLOW}2${NC}) An Instance Configuration"
    echo -e "  ${CYAN}q${NC}) Cancel"
    echo ""
    echo -n -e "${CYAN}Select option [1/2/q]: ${NC}"
    
    local choice
    read -r choice
    
    case "$choice" in
        1)
            compare_instance_to_instance "$instance_ocid" "$instance_name" "$instance_ud_b64"
            ;;
        2)
            compare_instance_to_config "$instance_ocid" "$instance_name" "$instance_ud_b64"
            ;;
        *)
            return
            ;;
    esac
}

#--------------------------------------------------------------------------------
# Compare instance cloud-init to another instance
# Args: $1 = instance OCID, $2 = instance display name, $3 = instance user_data base64
#--------------------------------------------------------------------------------
compare_instance_to_instance() {
    local instance_ocid="$1"
    local instance_name="$2"
    local instance_ud_b64="$3"
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    
    echo ""
    echo -e "${BOLD}${BLUE}═══ Compare to Another Instance ═══${NC}"
    echo ""
    echo -e "${YELLOW}Fetching compute instances...${NC}"
    
    # Get list of instances
    local instances_json
    instances_json=$(oci compute instance list \
        --compartment-id "$compartment_id" \
        --lifecycle-state RUNNING \
        --output json 2>/dev/null)
    
    if [[ -z "$instances_json" ]] || ! echo "$instances_json" | jq -e '.data[]' > /dev/null 2>&1; then
        echo -e "${RED}No running instances found${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # List instances (excluding current one)
    local inst_idx=0
    declare -A COMPARE_INST_MAP=()
    
    printf "${BOLD}%-4s %-50s %-25s${NC}\n" "#" "Instance Name" "Shape"
    print_separator 90
    
    while IFS='|' read -r inst_ocid inst_name inst_shape; do
        [[ -z "$inst_ocid" ]] && continue
        [[ "$inst_ocid" == "$instance_ocid" ]] && continue  # Skip current instance
        
        ((inst_idx++))
        COMPARE_INST_MAP[$inst_idx]="$inst_ocid|$inst_name"
        printf "${YELLOW}%-4s${NC} ${WHITE}%-50s${NC} ${CYAN}%-25s${NC}\n" "$inst_idx" "${inst_name:0:50}" "$inst_shape"
    done < <(echo "$instances_json" | jq -r '.data[] | "\(.id)|\(.["display-name"])|\(.shape)"' 2>/dev/null)
    
    if [[ $inst_idx -eq 0 ]]; then
        echo -e "${GRAY}No other instances found to compare${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Select instance to compare against (1-${inst_idx}): ${NC}"
    local select_choice
    read -r select_choice
    
    if [[ -z "${COMPARE_INST_MAP[$select_choice]:-}" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    local other_ocid other_name
    IFS='|' read -r other_ocid other_name <<< "${COMPARE_INST_MAP[$select_choice]}"
    
    echo ""
    echo -e "${YELLOW}Fetching instance details...${NC}"
    
    # Get the other instance's user_data (fetch full JSON, extract with jq)
    local other_json other_ud_b64
    other_json=$(oci compute instance get \
        --instance-id "$other_ocid" \
        --output json 2>/dev/null)
    
    if [[ -n "$other_json" ]] && echo "$other_json" | jq -e '.data' > /dev/null 2>&1; then
        other_ud_b64=$(echo "$other_json" | jq -r '.data.metadata.user_data // empty' 2>/dev/null)
    fi
    
    if [[ -z "$other_ud_b64" || "$other_ud_b64" == "null" ]]; then
        echo -e "${YELLOW}The selected instance has no cloud-init user_data${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # Create temp files for diff
    local tmp1 tmp2
    tmp1=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    tmp2=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    
    # Decode user_data (handles gzip compression)
    decode_user_data_to_file "$instance_ud_b64" "$tmp1"
    decode_user_data_to_file "$other_ud_b64" "$tmp2"
    
    echo ""
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${MAGENTA}                                           INSTANCE CLOUD-INIT COMPARISON                                                                              ${NC}"
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${WHITE}Comparing:${NC}"
    echo -e "  ${RED}- Instance A:${NC} ${GREEN}$instance_name${NC}"
    echo -e "  ${GREEN}+ Instance B:${NC} ${BLUE}$other_name${NC}"
    echo ""
    
    if diff -q "$tmp1" "$tmp2" > /dev/null 2>&1; then
        echo -e "${GREEN}╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${GREEN}║                                                 ✓ CLOUD-INIT IS IDENTICAL                                                                              ║${NC}"
        echo -e "${GREEN}╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝${NC}"
    else
        echo -e "${RED}╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${RED}║                                                 ✗ CLOUD-INIT DIFFERS                                                                                    ║${NC}"
        echo -e "${RED}╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "${BOLD}${WHITE}Differences:${NC}"
        echo ""
        
        local diff_output
        diff_output=$(diff -u "$tmp1" "$tmp2" 2>/dev/null | tail -n +4)
        
        while IFS= read -r line; do
            if [[ "$line" =~ ^@@ ]]; then
                echo -e "${YELLOW}${line}${NC}"
            elif [[ "$line" =~ ^- ]]; then
                echo -e "${RED}${line}${NC}  ${GRAY}← $instance_name${NC}"
            elif [[ "$line" =~ ^\+ ]]; then
                echo -e "${GREEN}${line}${NC}  ${GRAY}← $other_name${NC}"
            elif [[ "$line" =~ ^[[:space:]] ]]; then
                echo -e "${GRAY}${line}${NC}"
            fi
        done <<< "$diff_output"
    fi
    
    rm -f "$tmp1" "$tmp2"
    
    echo ""
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "Press Enter to return..."
    read -r
}

#--------------------------------------------------------------------------------
# Compare instance cloud-init against an instance configuration
# Args: $1 = instance OCID, $2 = instance display name, $3 = instance user_data base64
#--------------------------------------------------------------------------------
compare_instance_to_config() {
    local instance_ocid="$1"
    local instance_name="$2"
    local instance_ud_b64="$3"
    
    echo ""
    echo -e "${BOLD}${BLUE}═══ Compare Instance Cloud-Init to Instance Configuration ═══${NC}"
    echo ""
    echo -e "${WHITE}Instance:${NC} ${GREEN}$instance_name${NC}"
    echo ""
    
    # Refresh instance config cache
    fetch_instance_configurations > /dev/null 2>&1
    
    if [[ ! -f "$INSTANCE_CONFIG_CACHE" ]]; then
        echo -e "${RED}No instance configurations found${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # List configs
    local ic_idx=0
    declare -A COMPARE_IC_MAP=()
    
    printf "${BOLD}%-4s %-70s${NC}\n" "#" "Instance Configuration Name"
    print_separator 90
    
    while IFS='|' read -r ic_ocid ic_name _; do
        [[ "$ic_ocid" =~ ^#.*$ ]] && continue
        [[ -z "$ic_ocid" ]] && continue
        
        ((ic_idx++))
        COMPARE_IC_MAP[$ic_idx]="$ic_ocid|$ic_name"
        printf "${YELLOW}%-4s${NC} ${WHITE}%-70s${NC}\n" "$ic_idx" "$ic_name"
    done < <(grep -v '^#' "$INSTANCE_CONFIG_CACHE" 2>/dev/null)
    
    if [[ $ic_idx -eq 0 ]]; then
        echo -e "${GRAY}No instance configurations found${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Select instance configuration to compare against (1-${ic_idx}): ${NC}"
    local choice
    read -r choice
    
    if [[ -z "${COMPARE_IC_MAP[$choice]:-}" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    local ic_ocid ic_name
    IFS='|' read -r ic_ocid ic_name <<< "${COMPARE_IC_MAP[$choice]}"
    
    echo ""
    echo -e "${YELLOW}Fetching instance configuration...${NC}"
    
    # Get instance config user_data (fetch full JSON, extract with jq - same as detail view)
    local ic_json ic_ud_b64
    ic_json=$(oci compute-management instance-configuration get \
        --instance-configuration-id "$ic_ocid" \
        --output json 2>/dev/null)
    
    if [[ -n "$ic_json" ]] && echo "$ic_json" | jq -e '.data' > /dev/null 2>&1; then
        ic_ud_b64=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["metadata"]["user_data"] // empty' 2>/dev/null)
    fi
    
    if [[ -z "$ic_ud_b64" || "$ic_ud_b64" == "null" ]]; then
        echo -e "${YELLOW}Instance configuration has no user_data${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # Create temp files for diff
    local tmp_instance tmp_ic
    tmp_instance=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    tmp_ic=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    
    # Decode user_data (handles gzip compression)
    decode_user_data_to_file "$instance_ud_b64" "$tmp_instance"
    decode_user_data_to_file "$ic_ud_b64" "$tmp_ic"
    
    echo ""
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${MAGENTA}                                              CLOUD-INIT COMPARISON                                                                                    ${NC}"
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${WHITE}Comparing:${NC}"
    echo -e "  ${RED}- (Instance):${NC}        ${GREEN}$instance_name${NC}"
    echo -e "  ${GREEN}+ (Instance Config):${NC} ${BLUE}$ic_name${NC}"
    echo ""
    
    if diff -q "$tmp_instance" "$tmp_ic" > /dev/null 2>&1; then
        echo -e "${GREEN}╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${GREEN}║                                           ✓ CLOUD-INIT IS IDENTICAL - NO DRIFT DETECTED                                                               ║${NC}"
        echo -e "${GREEN}╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝${NC}"
    else
        echo -e "${RED}╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${RED}║                                           ✗ DRIFT DETECTED - CLOUD-INIT DIFFERS                                                                        ║${NC}"
        echo -e "${RED}╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "${BOLD}${WHITE}Differences:${NC}"
        echo ""
        
        # Show annotated diff
        local diff_output
        diff_output=$(diff -u "$tmp_instance" "$tmp_ic" 2>/dev/null | tail -n +4)
        
        while IFS= read -r line; do
            if [[ "$line" =~ ^@@ ]]; then
                echo -e "${YELLOW}${line}${NC}"
            elif [[ "$line" =~ ^- ]]; then
                echo -e "${RED}${line}${NC}  ${GRAY}← Instance (current)${NC}"
            elif [[ "$line" =~ ^\+ ]]; then
                echo -e "${GREEN}${line}${NC}  ${GRAY}← Instance Config (expected)${NC}"
            elif [[ "$line" =~ ^[[:space:]] ]]; then
                echo -e "${GRAY}${line}${NC}"
            fi
        done <<< "$diff_output"
    fi
    
    # Cleanup
    rm -f "$tmp_instance" "$tmp_ic"
    
    echo ""
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "Press Enter to return..."
    read -r
}

#===============================================================================
# INSTANCE CONFIGURATION MANAGEMENT
#===============================================================================

manage_instance_configurations() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    # Build instance config index map
    declare -A LOCAL_IC_INDEX_MAP=()
    
    while true; do
        echo ""
        echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${GREEN}                                                    INSTANCE CONFIGURATION MANAGEMENT                                                                    ${NC}"
        echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        _display_cache_info \
            "${INSTANCE_CONFIG_CACHE}|Instance Configs"
        echo ""
        
        echo -e "${BOLD}${WHITE}Environment:${NC}"
        echo -e "  ${CYAN}Region:${NC}      ${WHITE}${region}${NC}"
        echo -e "  ${CYAN}Compartment:${NC} ${WHITE}$(resolve_compartment_name "${compartment_id}")${NC} ${GRAY}(${compartment_id})${NC}"
        echo ""
        
        # Fetch and display instance configurations
        fetch_instance_configurations > /dev/null 2>&1
        
        echo -e "${BOLD}${WHITE}═══ Instance Configurations ═══${NC}"
        echo ""
        printf "${BOLD}%-5s %-55s %-20s %s${NC}\n" "ID" "Name" "Created" "OCID"
        print_separator 160
        
        local ic_idx=0
        LOCAL_IC_INDEX_MAP=()
        
        if [[ -f "$INSTANCE_CONFIG_CACHE" ]]; then
            # Read from cache (now includes time-created)
            while IFS='|' read -r ic_ocid ic_name ic_time_created; do
                [[ "$ic_ocid" =~ ^#.*$ ]] && continue
                [[ -z "$ic_ocid" ]] && continue
                
                ((ic_idx++))
                local iid="i${ic_idx}"
                LOCAL_IC_INDEX_MAP[$iid]="$ic_ocid"
                IC_INDEX_MAP[$iid]="$ic_ocid"
                
                # Format time_created from cache
                local time_display="N/A"
                if [[ -n "$ic_time_created" && "$ic_time_created" != "N/A" ]]; then
                    time_display="${ic_time_created:0:16}"
                    time_display="${time_display/T/ }"
                fi
                
                printf "${YELLOW}%-5s${NC} ${WHITE}%-55s${NC} ${GRAY}%-20s${NC} ${YELLOW}%s${NC}\n" \
                    "$iid" "${ic_name:0:55}" "$time_display" "$ic_ocid"
            done < <(grep -v '^#' "$INSTANCE_CONFIG_CACHE" 2>/dev/null)
        fi
        
        if [[ $ic_idx -eq 0 ]]; then
            echo -e "  ${GRAY}No instance configurations found${NC}"
        fi
        
        echo ""
        echo -e "${GRAY}Total: ${ic_idx} instance configurations${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
        echo -e "  ${YELLOW}i#${NC}          - View instance configuration details and user-data (e.g., 'i1', 'i2')"
        echo -e "  ${GREEN}c${NC}           - Create a new Instance Configuration"
        echo -e "  ${YELLOW}re${NC}          - Rename an Instance Configuration (with recommended name)"
        echo -e "  ${RED}d${NC}           - Delete Instance Configuration(s) (d i1, d i1,i3, d all)"
        echo -e "  ${CYAN}comp${NC}        - Compare full configuration between two instance configurations"
        echo -e "  ${CYAN}diff${NC}        - Quick cloud-init diff (config vs config, or config vs local file)"
        echo -e "  ${MAGENTA}r${NC}           - Refresh data from OCI"
        echo -e "  ${CYAN}back${NC}        - Return to main menu"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Instance Configs] Enter selection [i#/c/re/d/comp/diff/r/back]: ${NC}"
        
        local input
        read -r input
        
        # Empty input goes back
        if [[ -z "$input" ]]; then
            return
        fi
        
        case "$input" in
            c|C|create|CREATE)
                create_instance_configuration_interactive
                ;;
            re|RE|rename|RENAME)
                rename_instance_configuration_interactive
                ;;
            d|D|delete|DELETE)
                delete_instance_configuration_interactive
                ;;
            d\ *|D\ *|delete\ *|DELETE\ *)
                local delete_args="${input#* }"
                delete_instance_configuration_interactive "$delete_args"
                ;;
            ua|UA|update-all|UPDATE-ALL)
                update_all_clusters_instance_config
                ;;
            comp|COMP|compare|COMPARE)
                compare_instance_configurations
                ;;
            diff|DIFF)
                diff_instance_config_cloudinit
                ;;
            r|R|refresh|REFRESH)
                echo -e "${YELLOW}Refreshing cache...${NC}"
                rm -f "$INSTANCE_CONFIG_CACHE"
                ;;
            quit|QUIT|q|Q|exit|EXIT|back|BACK|b|B)
                return
                ;;
            i[0-9]*)
                view_instance_configuration_detail "$input"
                ;;
            *)
                echo -e "${RED}Unknown command: $input${NC}"
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# View Instance Configuration Detail with user-data decoding
#--------------------------------------------------------------------------------
view_instance_configuration_detail() {
    local ic_id="$1"
    local ic_ocid="${IC_INDEX_MAP[$ic_id]:-}"
    
    if [[ -z "$ic_ocid" ]]; then
        echo -e "${RED}Invalid instance config ID: $ic_id${NC}"
        return 1
    fi
    
    echo ""
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${GREEN}                       INSTANCE CONFIGURATION DETAILS                          ${NC}"
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════${NC}"
    
    local ic_json
    ic_json=$(oci compute-management instance-configuration get \
        --instance-configuration-id "$ic_ocid" \
        --output json 2>/dev/null)
    
    if [[ -z "$ic_json" ]]; then
        echo -e "${RED}Failed to fetch instance configuration details${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return 1
    fi
    
    local ic_name ic_time_created ic_compartment
    ic_name=$(echo "$ic_json" | jq -r '.data["display-name"] // "N/A"')
    ic_time_created=$(echo "$ic_json" | jq -r '.data["time-created"] // "N/A"')
    ic_compartment=$(echo "$ic_json" | jq -r '.data["compartment-id"] // "N/A"')
    
    echo ""
    echo -e "${WHITE}Name:${NC}         ${GREEN}$ic_name${NC}"
    echo -e "${WHITE}OCID:${NC}         ${YELLOW}$ic_ocid${NC}"
    echo -e "${WHITE}Time Created:${NC} $ic_time_created"
    echo -e "${WHITE}Compartment:${NC}  ${WHITE}$(resolve_compartment_name "$ic_compartment")${NC} ${GRAY}($ic_compartment)${NC}"
    
    # Show instance details from the configuration
    echo ""
    echo -e "${BOLD}${CYAN}Instance Details:${NC}"
    local shape ad boot_size boot_vpus image_id subnet_id
    shape=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["shape"] // "N/A"')
    ad=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["availability-domain"] // "N/A"')
    boot_size=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["source-details"] | (.["boot-volume-size-in-gbs"] // .bootVolumeSizeInGBs // .["bootVolumeSizeInGBs"] // "N/A")')
    boot_vpus=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["source-details"] | (.["boot-volume-vpus-per-gb"] // .bootVolumeVpusPerGB // .["bootVolumeVpusPerGB"] // "N/A")')
    image_id=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["source-details"]["image-id"] // .data["instance-details"]["launch-details"]["source-details"]["imageId"] // "N/A"')
    subnet_id=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["create-vnic-details"]["subnet-id"] // "N/A"')
    local max_pods
    max_pods=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["metadata"]["oke-max-pods"] // "N/A"')
    
    echo -e "  ${WHITE}Shape:${NC}              $shape"
    echo -e "  ${WHITE}Availability Domain:${NC} $ad"
    echo -e "  ${WHITE}Boot Volume Size:${NC}   ${boot_size} GB"
    echo -e "  ${WHITE}Boot Volume VPUs:${NC}   ${boot_vpus} VPUs/GB"
    echo -e "  ${WHITE}Max Pods:${NC}           $max_pods"
    
    # Fetch and display image details
    if [[ -n "$image_id" && "$image_id" != "N/A" ]]; then
        local img_json img_name img_os
        img_json=$(oci compute image get --image-id "$image_id" --output json 2>/dev/null)
        if [[ -n "$img_json" ]] && echo "$img_json" | jq -e '.data' > /dev/null 2>&1; then
            img_name=$(echo "$img_json" | jq -r '.data["display-name"] // "Unknown"')
            img_os=$(echo "$img_json" | jq -r '.data["operating-system"] // ""')
            echo -e "  ${WHITE}Image Name:${NC}         ${WHITE}$img_name${NC}"
            [[ -n "$img_os" && "$img_os" != "null" ]] && echo -e "  ${WHITE}Image OS:${NC}           ${WHITE}$img_os${NC}"
        fi
        echo -e "  ${WHITE}Image OCID:${NC}         ${YELLOW}$image_id${NC}"
    else
        echo -e "  ${WHITE}Image:${NC}              ${GRAY}N/A${NC}"
    fi
    
    # Fetch and display subnet details
    if [[ -n "$subnet_id" && "$subnet_id" != "N/A" ]]; then
        local subnet_json subnet_name
        subnet_json=$(oci network subnet get --subnet-id "$subnet_id" --output json 2>/dev/null)
        if [[ -n "$subnet_json" ]] && echo "$subnet_json" | jq -e '.data' > /dev/null 2>&1; then
            subnet_name=$(echo "$subnet_json" | jq -r '.data["display-name"] // "Unknown"')
            echo -e "  ${WHITE}Subnet Name:${NC}        ${WHITE}$subnet_name${NC}"
        fi
        echo -e "  ${WHITE}Subnet OCID:${NC}        ${YELLOW}$subnet_id${NC}"
    else
        echo -e "  ${WHITE}Subnet:${NC}             ${GRAY}N/A${NC}"
    fi
    
    # Check for user_data
    local user_data_b64
    user_data_b64=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["metadata"]["user_data"] // empty' 2>/dev/null)
    
    local has_user_data="false"
    [[ -n "$user_data_b64" ]] && has_user_data="true"
    
    # Check for SSH keys
    local ssh_keys
    ssh_keys=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["metadata"]["ssh_authorized_keys"] // empty' 2>/dev/null)
    
    if [[ -n "$ssh_keys" ]]; then
        echo ""
        echo -e "${BOLD}${CYAN}SSH Keys:${NC}"
        echo -e "  ${GREEN}✓ SSH authorized keys are configured${NC}"
    fi
    
    if [[ "$has_user_data" == "true" ]]; then
        echo ""
        echo -e "${BOLD}${CYAN}User Data:${NC}"
        echo -e "  ${GREEN}✓ Cloud-init user-data is configured ($(echo "$user_data_b64" | wc -c) bytes encoded)${NC}"
    fi
    
    # Show actions
    echo ""
    echo -e "${BOLD}${WHITE}Actions:${NC}"
    if [[ "$has_user_data" == "true" ]]; then
        echo -e "  ${MAGENTA}view${NC}     - View decoded cloud-init user-data"
        echo -e "  ${MAGENTA}save${NC}     - Save user-data to file"
    fi
    echo -e "  ${GREEN}json${NC}     - Output raw JSON of instance configuration"
    echo -e "  ${YELLOW}rename${NC}   - Rename this instance configuration"
    echo -e "  ${RED}delete${NC}   - Delete this instance configuration"
    echo -e "  ${CYAN}Enter${NC}    - Return to menu"
    echo ""
    echo -n -e "${CYAN}Action [view/save/json/rename/delete/Enter]: ${NC}"
    
    local action
    read -r action
    
    case "$action" in
        view|VIEW|v|V)
            if [[ "$has_user_data" == "true" ]]; then
                echo ""
                echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════${NC}"
                echo -e "${BOLD}${MAGENTA}                         DECODED CLOUD-INIT USER-DATA                          ${NC}"
                echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════${NC}"
                echo ""
                
                # Check if gzip compressed and decompress
                if is_user_data_gzip "$user_data_b64"; then
                    echo -e "${GRAY}(gzip compressed - decompressing)${NC}"
                    echo ""
                fi
                decode_user_data "$user_data_b64"
                
                echo ""
                echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════${NC}"
                echo ""
                echo -n -e "${CYAN}Press Enter to continue...${NC}"
                read -r
            else
                echo -e "${YELLOW}No user-data found${NC}"
            fi
            ;;
        save|SAVE|s|S)
            if [[ "$has_user_data" == "true" ]]; then
                local safe_name
                safe_name=$(echo "$ic_name" | tr ' ' '_' | tr -cd '[:alnum:]_-')
                local filename="${safe_name}_cloud-init.yml"
                
                echo ""
                echo -n -e "${CYAN}Save as [${filename}]: ${NC}"
                local custom_filename
                read -r custom_filename
                [[ -n "$custom_filename" ]] && filename="$custom_filename"
                
                local gzip_msg=""
                if is_user_data_gzip "$user_data_b64"; then
                    gzip_msg=" ${GRAY}(decompressed from gzip)${NC}"
                fi
                
                if decode_user_data_to_file "$user_data_b64" "$filename"; then
                    echo -e "${GREEN}✓ User-data saved to: ${WHITE}$(pwd)/${filename}${NC}${gzip_msg}"
                else
                    echo -e "${RED}Failed to save user-data${NC}"
                fi
                echo ""
                echo -n -e "${CYAN}Press Enter to continue...${NC}"
                read -r
            else
                echo -e "${YELLOW}No user-data found${NC}"
            fi
            ;;
        rename|RENAME|r|R)
            rename_single_instance_configuration "$ic_ocid" "$ic_name" "$ic_json"
            ;;
        json|JSON|j|J)
            echo ""
            echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════${NC}"
            echo -e "${BOLD}${GREEN}                    INSTANCE CONFIGURATION JSON                               ${NC}"
            echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════${NC}"
            echo ""
            echo "$ic_json" | jq '.'
            echo ""
            echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════${NC}"
            echo ""
            
            # Offer to save
            local safe_json_name
            safe_json_name=$(echo "$ic_name" | tr ' ' '_' | tr -cd '[:alnum:]_-')
            local json_filename="${safe_json_name}.json"
            echo -n -e "${CYAN}Save to file? [y/N]: ${NC}"
            local save_json
            read -r save_json
            if [[ "$save_json" == "y" || "$save_json" == "Y" ]]; then
                echo -n -e "${CYAN}Save as [${json_filename}]: ${NC}"
                local custom_json_name
                read -r custom_json_name
                [[ -n "$custom_json_name" ]] && json_filename="$custom_json_name"
                if echo "$ic_json" | jq '.' > "$json_filename" 2>/dev/null; then
                    echo -e "${GREEN}✓ JSON saved to: ${WHITE}$(pwd)/${json_filename}${NC}"
                else
                    echo -e "${RED}Failed to save JSON${NC}"
                fi
            fi
            echo ""
            echo -n -e "${CYAN}Press Enter to continue...${NC}"
            read -r
            ;;
        delete|DELETE|d|D)
            delete_single_instance_configuration "$ic_ocid" "$ic_name"
            ;;
        *)
            # Return to menu
            ;;
    esac
}

#--------------------------------------------------------------------------------
# Compare two Instance Configurations
#--------------------------------------------------------------------------------
compare_instance_configurations() {
    echo ""
    echo -e "${BOLD}${MAGENTA}═══ Compare Instance Configurations ═══${NC}"
    echo ""
    
    # Refresh cache
    fetch_instance_configurations > /dev/null 2>&1
    
    if [[ ! -f "$INSTANCE_CONFIG_CACHE" ]]; then
        echo -e "${RED}No instance configurations found${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # List configs
    local ic_idx=0
    declare -A COMPARE_IC_MAP=()
    
    printf "${BOLD}%-4s %-60s${NC}\n" "#" "Name"
    print_separator 80
    
    while IFS='|' read -r ic_ocid ic_name _; do
        [[ "$ic_ocid" =~ ^#.*$ ]] && continue
        [[ -z "$ic_ocid" ]] && continue
        
        ((ic_idx++))
        COMPARE_IC_MAP[$ic_idx]="$ic_ocid|$ic_name"
        printf "${YELLOW}%-4s${NC} ${WHITE}%-60s${NC}\n" "$ic_idx" "$ic_name"
    done < <(grep -v '^#' "$INSTANCE_CONFIG_CACHE" 2>/dev/null)
    
    if [[ $ic_idx -lt 2 ]]; then
        echo ""
        echo -e "${YELLOW}Need at least 2 instance configurations to compare${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Select first configuration (1-${ic_idx}): ${NC}"
    local choice1
    read -r choice1
    
    if [[ -z "${COMPARE_IC_MAP[$choice1]:-}" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return
    fi
    
    echo -n -e "${CYAN}Select second configuration (1-${ic_idx}): ${NC}"
    local choice2
    read -r choice2
    
    if [[ -z "${COMPARE_IC_MAP[$choice2]:-}" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return
    fi
    
    local ocid1 name1 ocid2 name2
    IFS='|' read -r ocid1 name1 <<< "${COMPARE_IC_MAP[$choice1]}"
    IFS='|' read -r ocid2 name2 <<< "${COMPARE_IC_MAP[$choice2]}"
    
    echo ""
    echo -e "${BOLD}Comparing:${NC}"
    echo -e "  ${GREEN}A:${NC} $name1"
    echo -e "  ${BLUE}B:${NC} $name2"
    echo ""
    echo -e "${YELLOW}Fetching full configuration details...${NC}"
    
    # Get FULL instance configuration JSON for both
    local json1 json2
    json1=$(oci compute-management instance-configuration get \
        --instance-configuration-id "$ocid1" \
        --output json 2>/dev/null)
    
    json2=$(oci compute-management instance-configuration get \
        --instance-configuration-id "$ocid2" \
        --output json 2>/dev/null)
    
    if [[ -z "$json1" || -z "$json2" ]]; then
        echo -e "${RED}Failed to fetch configuration details${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # Extract launch-details for comparison
    local launch1 launch2
    launch1=$(echo "$json1" | jq '.data["instance-details"]["launch-details"]')
    launch2=$(echo "$json2" | jq '.data["instance-details"]["launch-details"]')
    
    echo ""
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${MAGENTA}                                                    CONFIGURATION COMPARISON                                                                            ${NC}"
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    
    # Compare key fields individually
    local has_diff=false
    
    # Shape
    local shape1 shape2
    shape1=$(echo "$launch1" | jq -r '.shape // "N/A"')
    shape2=$(echo "$launch2" | jq -r '.shape // "N/A"')
    echo ""
    echo -e "${BOLD}${WHITE}Shape:${NC}"
    if [[ "$shape1" == "$shape2" ]]; then
        echo -e "  ${GREEN}✓ Same:${NC} $shape1"
    else
        echo -e "  ${RED}✗ Different:${NC}"
        echo -e "    ${GREEN}$name1:${NC} $shape1"
        echo -e "    ${BLUE}$name2:${NC} $shape2"
        has_diff=true
    fi
    
    # Shape Config (for flex shapes)
    local sc1_ocpus sc1_mem sc2_ocpus sc2_mem
    sc1_ocpus=$(echo "$launch1" | jq -r '.["shape-config"].ocpus // empty')
    sc1_mem=$(echo "$launch1" | jq -r '.["shape-config"]["memory-in-gbs"] // empty')
    sc2_ocpus=$(echo "$launch2" | jq -r '.["shape-config"].ocpus // empty')
    sc2_mem=$(echo "$launch2" | jq -r '.["shape-config"]["memory-in-gbs"] // empty')
    
    if [[ -n "$sc1_ocpus" || -n "$sc2_ocpus" ]]; then
        echo ""
        echo -e "${BOLD}${WHITE}Shape Config (OCPUs):${NC}"
        if [[ "$sc1_ocpus" == "$sc2_ocpus" ]]; then
            echo -e "  ${GREEN}✓ Same:${NC} ${sc1_ocpus:-N/A}"
        else
            echo -e "  ${RED}✗ Different:${NC}"
            echo -e "    ${GREEN}$name1:${NC} ${sc1_ocpus:-N/A}"
            echo -e "    ${BLUE}$name2:${NC} ${sc2_ocpus:-N/A}"
            has_diff=true
        fi
        
        echo ""
        echo -e "${BOLD}${WHITE}Shape Config (Memory GB):${NC}"
        if [[ "$sc1_mem" == "$sc2_mem" ]]; then
            echo -e "  ${GREEN}✓ Same:${NC} ${sc1_mem:-N/A}"
        else
            echo -e "  ${RED}✗ Different:${NC}"
            echo -e "    ${GREEN}$name1:${NC} ${sc1_mem:-N/A}"
            echo -e "    ${BLUE}$name2:${NC} ${sc2_mem:-N/A}"
            has_diff=true
        fi
    fi
    
    # Availability Domain
    local ad1 ad2
    ad1=$(echo "$launch1" | jq -r '.["availability-domain"] // "N/A"')
    ad2=$(echo "$launch2" | jq -r '.["availability-domain"] // "N/A"')
    echo ""
    echo -e "${BOLD}${WHITE}Availability Domain:${NC}"
    if [[ "$ad1" == "$ad2" ]]; then
        echo -e "  ${GREEN}✓ Same:${NC} $ad1"
    else
        echo -e "  ${RED}✗ Different:${NC}"
        echo -e "    ${GREEN}$name1:${NC} $ad1"
        echo -e "    ${BLUE}$name2:${NC} $ad2"
        has_diff=true
    fi
    
    # Boot Volume Size
    local bvsize1 bvsize2
    bvsize1=$(echo "$launch1" | jq -r '.["source-details"]["boot-volume-size-in-gbs"] // "N/A"')
    bvsize2=$(echo "$launch2" | jq -r '.["source-details"]["boot-volume-size-in-gbs"] // "N/A"')
    echo ""
    echo -e "${BOLD}${WHITE}Boot Volume Size (GB):${NC}"
    if [[ "$bvsize1" == "$bvsize2" ]]; then
        echo -e "  ${GREEN}✓ Same:${NC} $bvsize1"
    else
        echo -e "  ${RED}✗ Different:${NC}"
        echo -e "    ${GREEN}$name1:${NC} $bvsize1"
        echo -e "    ${BLUE}$name2:${NC} $bvsize2"
        has_diff=true
    fi
    
    # Boot Volume VPUs
    local bvvpus1 bvvpus2
    bvvpus1=$(echo "$launch1" | jq -r '.["source-details"]["boot-volume-vpus-per-gb"] // "N/A"')
    bvvpus2=$(echo "$launch2" | jq -r '.["source-details"]["boot-volume-vpus-per-gb"] // "N/A"')
    echo ""
    echo -e "${BOLD}${WHITE}Boot Volume VPUs/GB:${NC}"
    if [[ "$bvvpus1" == "$bvvpus2" ]]; then
        echo -e "  ${GREEN}✓ Same:${NC} $bvvpus1"
    else
        echo -e "  ${RED}✗ Different:${NC}"
        echo -e "    ${GREEN}$name1:${NC} $bvvpus1"
        echo -e "    ${BLUE}$name2:${NC} $bvvpus2"
        has_diff=true
    fi
    
    # Image ID - show full OCID with name
    local img1 img2
    img1=$(echo "$launch1" | jq -r '.["source-details"]["image-id"] // "N/A"')
    img2=$(echo "$launch2" | jq -r '.["source-details"]["image-id"] // "N/A"')
    
    # Fetch image names
    local img1_name="(fetching...)" img2_name="(fetching...)"
    if [[ -n "$img1" && "$img1" != "N/A" ]]; then
        img1_name=$(oci compute image get --image-id "$img1" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
    fi
    if [[ -n "$img2" && "$img2" != "N/A" ]]; then
        img2_name=$(oci compute image get --image-id "$img2" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}Image:${NC}"
    if [[ "$img1" == "$img2" ]]; then
        echo -e "  ${GREEN}✓ Same:${NC} ${WHITE}$img1_name${NC} (${YELLOW}$img1${NC})"
    else
        echo -e "  ${RED}✗ Different:${NC}"
        echo -e "    ${GREEN}$name1:${NC} ${WHITE}$img1_name${NC}"
        echo -e "      ${YELLOW}$img1${NC}"
        echo -e "    ${BLUE}$name2:${NC} ${WHITE}$img2_name${NC}"
        echo -e "      ${YELLOW}$img2${NC}"
        has_diff=true
    fi
    
    # Subnet ID - show full OCID with name
    local subnet1 subnet2 subnet1_name subnet2_name
    subnet1=$(echo "$launch1" | jq -r '.["create-vnic-details"]["subnet-id"] // "N/A"')
    subnet2=$(echo "$launch2" | jq -r '.["create-vnic-details"]["subnet-id"] // "N/A"')
    subnet1_name=""
    subnet2_name=""
    [[ -n "$subnet1" && "$subnet1" != "N/A" ]] && subnet1_name=$(oci network subnet get --subnet-id "$subnet1" --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
    [[ -n "$subnet2" && "$subnet2" != "N/A" ]] && subnet2_name=$(oci network subnet get --subnet-id "$subnet2" --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
    echo ""
    echo -e "${BOLD}${WHITE}Subnet:${NC}"
    if [[ "$subnet1" == "$subnet2" ]]; then
        echo -e "  ${GREEN}✓ Same:${NC} ${WHITE}${subnet1_name:-N/A}${NC} (${YELLOW}$subnet1${NC})"
    else
        echo -e "  ${RED}✗ Different:${NC}"
        echo -e "    ${GREEN}$name1:${NC} ${WHITE}${subnet1_name:-N/A}${NC} (${YELLOW}$subnet1${NC})"
        echo -e "    ${BLUE}$name2:${NC} ${WHITE}${subnet2_name:-N/A}${NC} (${YELLOW}$subnet2${NC})"
        has_diff=true
    fi
    
    # NSG IDs - show full OCIDs
    local nsg1 nsg2
    nsg1=$(echo "$launch1" | jq -r '.["create-vnic-details"]["nsg-ids"] // []' | jq -r '.[]' 2>/dev/null | sort)
    nsg2=$(echo "$launch2" | jq -r '.["create-vnic-details"]["nsg-ids"] // []' | jq -r '.[]' 2>/dev/null | sort)
    echo ""
    echo -e "${BOLD}${WHITE}NSG IDs:${NC}"
    if [[ "$nsg1" == "$nsg2" ]]; then
        if [[ -n "$nsg1" ]]; then
            echo -e "  ${GREEN}✓ Same:${NC}"
            echo "$nsg1" | while read -r nsg; do
                echo -e "    $nsg"
            done
        else
            echo -e "  ${GREEN}✓ Same:${NC} (none)"
        fi
    else
        echo -e "  ${RED}✗ Different:${NC}"
        echo -e "    ${GREEN}$name1:${NC}"
        if [[ -n "$nsg1" ]]; then
            echo "$nsg1" | while read -r nsg; do
                echo -e "      $nsg"
            done
        else
            echo -e "      (none)"
        fi
        echo -e "    ${BLUE}$name2:${NC}"
        if [[ -n "$nsg2" ]]; then
            echo "$nsg2" | while read -r nsg; do
                echo -e "      $nsg"
            done
        else
            echo -e "      (none)"
        fi
        has_diff=true
    fi
    
    # Agent Config comparison
    echo ""
    echo -e "${BOLD}${WHITE}Agent Config:${NC}"
    local agent1 agent2
    agent1=$(echo "$launch1" | jq -c '.["agent-config"]["plugins-config"] // []' 2>/dev/null | jq -c 'sort_by(.name)' 2>/dev/null)
    agent2=$(echo "$launch2" | jq -c '.["agent-config"]["plugins-config"] // []' 2>/dev/null | jq -c 'sort_by(.name)' 2>/dev/null)
    
    if [[ "$agent1" == "$agent2" ]]; then
        echo -e "  ${GREEN}✓ Same agent plugin configuration${NC}"
    else
        echo -e "  ${RED}✗ Different agent plugin configuration:${NC}"
        # Show per-plugin differences
        local all_plugins
        all_plugins=$(echo -e "${agent1}\n${agent2}" | jq -r '.[].name' 2>/dev/null | sort -u)
        while read -r plugin; do
            [[ -z "$plugin" ]] && continue
            local state1 state2
            state1=$(echo "$agent1" | jq -r --arg p "$plugin" '.[] | select(.name == $p) | .["desired-state"] // "(not set)"' 2>/dev/null)
            state2=$(echo "$agent2" | jq -r --arg p "$plugin" '.[] | select(.name == $p) | .["desired-state"] // "(not set)"' 2>/dev/null)
            [[ -z "$state1" ]] && state1="(not set)"
            [[ -z "$state2" ]] && state2="(not set)"
            if [[ "$state1" == "$state2" ]]; then
                echo -e "    ${GREEN}✓${NC} %-45s ${GRAY}%s${NC}\n" "$plugin" "$state1" | xargs -0 printf 2>/dev/null || \
                echo -e "    ${GREEN}✓${NC} ${WHITE}$plugin:${NC} $state1"
            else
                echo -e "    ${RED}✗${NC} ${WHITE}$plugin:${NC}"
                echo -e "        ${GREEN}$name1:${NC} $state1"
                echo -e "        ${BLUE}$name2:${NC} $state2"
            fi
        done <<< "$all_plugins"
        has_diff=true
    fi
    
    # Metadata fields (excluding user_data which we'll handle separately)
    echo ""
    echo -e "${BOLD}${WHITE}Metadata Fields:${NC}"
    local meta1_keys meta2_keys
    meta1_keys=$(echo "$launch1" | jq -r '.metadata // {} | keys[]' 2>/dev/null | grep -v '^user_data$' | sort)
    meta2_keys=$(echo "$launch2" | jq -r '.metadata // {} | keys[]' 2>/dev/null | grep -v '^user_data$' | sort)
    
    # Find all unique keys
    local all_meta_keys
    all_meta_keys=$(echo -e "${meta1_keys}\n${meta2_keys}" | sort -u | grep -v '^$')
    
    if [[ -z "$all_meta_keys" ]]; then
        echo -e "  ${GRAY}(no metadata fields other than user_data)${NC}"
    else
        while read -r key; do
            [[ -z "$key" ]] && continue
            local val1 val2
            val1=$(echo "$launch1" | jq -r ".metadata[\"$key\"] // \"(not set)\"")
            val2=$(echo "$launch2" | jq -r ".metadata[\"$key\"] // \"(not set)\"")
            
            if [[ "$val1" == "$val2" ]]; then
                echo -e "  ${GREEN}✓${NC} ${WHITE}$key:${NC} $val1"
            else
                echo -e "  ${RED}✗${NC} ${WHITE}$key:${NC}"
                echo -e "      ${GREEN}$name1:${NC} $val1"
                echo -e "      ${BLUE}$name2:${NC} $val2"
                has_diff=true
            fi
        done <<< "$all_meta_keys"
    fi
    
    # User Data comparison - improved display
    echo ""
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${MAGENTA}                                                  CLOUD-INIT USER-DATA COMPARISON                                                                       ${NC}"
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${WHITE}Legend:${NC}"
    echo -e "  ${RED}- Lines only in:${NC} ${GREEN}$name1${NC}"
    echo -e "  ${GREEN}+ Lines only in:${NC} ${BLUE}$name2${NC}"
    echo ""
    
    local ud1 ud2
    ud1=$(echo "$launch1" | jq -r '.metadata.user_data // empty')
    ud2=$(echo "$launch2" | jq -r '.metadata.user_data // empty')
    
    # Create temp files for diff
    local tmp1 tmp2
    tmp1=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    tmp2=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    
    if [[ -n "$ud1" ]]; then
        decode_user_data_to_file "$ud1" "$tmp1" || echo "# Failed to decode user_data" > "$tmp1"
    else
        echo "# No user_data" > "$tmp1"
    fi
    
    if [[ -n "$ud2" ]]; then
        decode_user_data_to_file "$ud2" "$tmp2" || echo "# Failed to decode user_data" > "$tmp2"
    else
        echo "# No user_data" > "$tmp2"
    fi
    
    local lines1 lines2
    lines1=$(wc -l < "$tmp1" 2>/dev/null || echo "0")
    lines2=$(wc -l < "$tmp2" 2>/dev/null || echo "0")
    echo -e "${GRAY}  A: ${lines1} lines  |  B: ${lines2} lines${NC}"
    echo ""
    
    if diff -q "$tmp1" "$tmp2" > /dev/null 2>&1; then
        echo -e "${GREEN}✓ Cloud-init user-data is identical${NC}"
    else
        echo -e "${RED}✗ Cloud-init user-data is DIFFERENT${NC}"
        echo ""
        
        # Show side-by-side differences with context
        echo -e "${BOLD}${WHITE}Differences found:${NC}"
        echo ""
        
        # Use diff to find changed lines and display them more clearly
        local diff_output
        diff_output=$(diff -u "$tmp1" "$tmp2" 2>/dev/null | tail -n +4)  # Skip header lines
        
        local in_change=false
        local line_num=0
        while IFS= read -r line; do
            ((line_num++))
            
            if [[ "$line" =~ ^@@ ]]; then
                # Context marker - show section
                echo ""
                echo -e "${YELLOW}${line}${NC}"
                in_change=true
            elif [[ "$line" =~ ^- ]]; then
                # Line removed (in config 1 only)
                echo -e "${RED}${line}${NC}  ${GRAY}← ${name1}${NC}"
            elif [[ "$line" =~ ^\+ ]]; then
                # Line added (in config 2 only)
                echo -e "${GREEN}${line}${NC}  ${GRAY}← ${name2}${NC}"
            elif [[ "$line" =~ ^[[:space:]] ]] && [[ "$in_change" == "true" ]]; then
                # Context line
                echo -e "${GRAY}${line}${NC}"
            fi
        done <<< "$diff_output"
        
        has_diff=true
    fi
    
    # Summary
    echo ""
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    if [[ "$has_diff" == "true" ]]; then
        echo -e "${RED}✗ Configurations have differences${NC}"
    else
        echo -e "${GREEN}✓ Configurations are identical${NC}"
    fi
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    
    # Post-compare actions menu
    echo ""
    echo -e "${BOLD}${WHITE}═══ Post-Compare Actions ═══${NC}"
    echo -e "  ${YELLOW}view-a${NC}   - View full cloud-init for: ${GREEN}$name1${NC}"
    echo -e "  ${YELLOW}view-b${NC}   - View full cloud-init for: ${BLUE}$name2${NC}"
    echo -e "  ${GREEN}save-a${NC}   - Save cloud-init A to file"
    echo -e "  ${GREEN}save-b${NC}   - Save cloud-init B to file"
    echo -e "  ${CYAN}save${NC}     - Save both cloud-init files"
    echo -e "  ${WHITE}Enter${NC}    - Return"
    echo ""
    
    while true; do
        echo -n -e "${CYAN}Action [Enter to return]: ${NC}"
        local post_action
        read -r post_action
        
        case "$post_action" in
            view-a|VIEW-A)
                echo ""
                echo -e "${BOLD}${GREEN}═══ Cloud-Init: $name1 ═══${NC}"
                echo -e "${GRAY}$(printf '━%.0s' $(seq 1 120))${NC}"
                cat "$tmp1"
                echo -e "${GRAY}$(printf '━%.0s' $(seq 1 120))${NC}"
                echo ""
                ;;
            view-b|VIEW-B)
                echo ""
                echo -e "${BOLD}${BLUE}═══ Cloud-Init: $name2 ═══${NC}"
                echo -e "${GRAY}$(printf '━%.0s' $(seq 1 120))${NC}"
                cat "$tmp2"
                echo -e "${GRAY}$(printf '━%.0s' $(seq 1 120))${NC}"
                echo ""
                ;;
            save-a|SAVE-A)
                local safe_name1
                safe_name1=$(echo "$name1" | tr ' /' '_-')
                local save_file1="cloud-init-${safe_name1}-$(date +%Y%m%d_%H%M%S).yml"
                cp "$tmp1" "$save_file1"
                echo -e "${GREEN}✓ Saved: ${WHITE}${save_file1}${NC}"
                ;;
            save-b|SAVE-B)
                local safe_name2
                safe_name2=$(echo "$name2" | tr ' /' '_-')
                local save_file2="cloud-init-${safe_name2}-$(date +%Y%m%d_%H%M%S).yml"
                cp "$tmp2" "$save_file2"
                echo -e "${GREEN}✓ Saved: ${WHITE}${save_file2}${NC}"
                ;;
            save|SAVE)
                local timestamp_save
                timestamp_save=$(date +%Y%m%d_%H%M%S)
                local safe_n1 safe_n2
                safe_n1=$(echo "$name1" | tr ' /' '_-')
                safe_n2=$(echo "$name2" | tr ' /' '_-')
                local sf1="cloud-init-${safe_n1}-${timestamp_save}.yml"
                local sf2="cloud-init-${safe_n2}-${timestamp_save}.yml"
                cp "$tmp1" "$sf1"
                cp "$tmp2" "$sf2"
                echo -e "${GREEN}✓ Saved: ${WHITE}${sf1}${NC}"
                echo -e "${GREEN}✓ Saved: ${WHITE}${sf2}${NC}"
                ;;
            "")
                break
                ;;
            *)
                echo -e "${GRAY}Unknown action. Press Enter to return.${NC}"
                ;;
        esac
    done
    
    # Cleanup
    rm -f "$tmp1" "$tmp2"
}

#--------------------------------------------------------------------------------
# Quick cloud-init diff between two instance configs or against a local file
#--------------------------------------------------------------------------------
diff_instance_config_cloudinit() {
    echo ""
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${MAGENTA}                                              CLOUD-INIT DIFF                                                                                            ${NC}"
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    echo -e "${WHITE}Compare cloud-init user-data between:${NC}"
    echo -e "  ${YELLOW}1${NC}) Two Instance Configurations"
    echo -e "  ${YELLOW}2${NC}) Instance Configuration vs Local File"
    echo -e "  ${CYAN}q${NC}) Cancel"
    echo ""
    echo -n -e "${CYAN}Select mode [1/2/q]: ${NC}"
    local mode_choice
    read -r mode_choice
    
    case "$mode_choice" in
        1)
            _diff_config_vs_config
            ;;
        2)
            _diff_config_vs_file
            ;;
        *)
            return
            ;;
    esac
}

#--------------------------------------------------------------------------------
# Internal: Diff cloud-init between two instance configurations
#--------------------------------------------------------------------------------
_diff_config_vs_config() {
    # Refresh cache
    fetch_instance_configurations > /dev/null 2>&1
    
    if [[ ! -f "$INSTANCE_CONFIG_CACHE" ]]; then
        echo -e "${RED}No instance configurations found${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # List configs
    local ic_idx=0
    declare -A DIFF_IC_MAP=()
    
    echo ""
    printf "${BOLD}%-4s %-60s${NC}\n" "#" "Name"
    print_separator 80
    
    while IFS='|' read -r ic_ocid ic_name _; do
        [[ "$ic_ocid" =~ ^#.*$ ]] && continue
        [[ -z "$ic_ocid" ]] && continue
        
        ((ic_idx++))
        DIFF_IC_MAP[$ic_idx]="$ic_ocid|$ic_name"
        printf "${YELLOW}%-4s${NC} ${WHITE}%-60s${NC}\n" "$ic_idx" "$ic_name"
    done < <(grep -v '^#' "$INSTANCE_CONFIG_CACHE" 2>/dev/null)
    
    if [[ $ic_idx -lt 2 ]]; then
        echo ""
        echo -e "${YELLOW}Need at least 2 instance configurations to compare${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Select first configuration (1-${ic_idx}): ${NC}"
    local choice1
    read -r choice1
    
    if [[ -z "${DIFF_IC_MAP[$choice1]:-}" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return
    fi
    
    echo -n -e "${CYAN}Select second configuration (1-${ic_idx}): ${NC}"
    local choice2
    read -r choice2
    
    if [[ -z "${DIFF_IC_MAP[$choice2]:-}" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return
    fi
    
    local ocid1 name1 ocid2 name2
    IFS='|' read -r ocid1 name1 <<< "${DIFF_IC_MAP[$choice1]}"
    IFS='|' read -r ocid2 name2 <<< "${DIFF_IC_MAP[$choice2]}"
    
    echo ""
    echo -e "${YELLOW}Fetching cloud-init from both configurations...${NC}"
    
    # Fetch full JSON first then extract with jq (same method as detail view)
    local ic_json1 ic_json2 ud1 ud2
    
    ic_json1=$(oci compute-management instance-configuration get \
        --instance-configuration-id "$ocid1" \
        --output json 2>/dev/null)
    if [[ -n "$ic_json1" ]] && echo "$ic_json1" | jq -e '.data' > /dev/null 2>&1; then
        ud1=$(echo "$ic_json1" | jq -r '.data["instance-details"]["launch-details"]["metadata"]["user_data"] // empty' 2>/dev/null)
    fi
    
    ic_json2=$(oci compute-management instance-configuration get \
        --instance-configuration-id "$ocid2" \
        --output json 2>/dev/null)
    if [[ -n "$ic_json2" ]] && echo "$ic_json2" | jq -e '.data' > /dev/null 2>&1; then
        ud2=$(echo "$ic_json2" | jq -r '.data["instance-details"]["launch-details"]["metadata"]["user_data"] // empty' 2>/dev/null)
    fi
    
    # Create temp files
    local tmp1 tmp2
    tmp1=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    tmp2=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    
    if [[ -n "$ud1" && "$ud1" != "null" ]]; then
        decode_user_data_to_file "$ud1" "$tmp1" || echo "# Failed to decode" > "$tmp1"
    else
        echo "# No user_data" > "$tmp1"
    fi
    
    if [[ -n "$ud2" && "$ud2" != "null" ]]; then
        decode_user_data_to_file "$ud2" "$tmp2" || echo "# Failed to decode" > "$tmp2"
    else
        echo "# No user_data" > "$tmp2"
    fi
    
    # Display the diff
    _display_cloudinit_diff "$tmp1" "$name1" "$tmp2" "$name2"
    
    # Cleanup happens in _display_cloudinit_diff
}

#--------------------------------------------------------------------------------
# Internal: Diff instance config cloud-init vs a local file
#--------------------------------------------------------------------------------
_diff_config_vs_file() {
    # Refresh cache
    fetch_instance_configurations > /dev/null 2>&1
    
    if [[ ! -f "$INSTANCE_CONFIG_CACHE" ]]; then
        echo -e "${RED}No instance configurations found${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # List configs
    local ic_idx=0
    declare -A DIFF_IC_MAP=()
    
    echo ""
    printf "${BOLD}%-4s %-60s${NC}\n" "#" "Name"
    print_separator 80
    
    while IFS='|' read -r ic_ocid ic_name _; do
        [[ "$ic_ocid" =~ ^#.*$ ]] && continue
        [[ -z "$ic_ocid" ]] && continue
        
        ((ic_idx++))
        DIFF_IC_MAP[$ic_idx]="$ic_ocid|$ic_name"
        printf "${YELLOW}%-4s${NC} ${WHITE}%-60s${NC}\n" "$ic_idx" "$ic_name"
    done < <(grep -v '^#' "$INSTANCE_CONFIG_CACHE" 2>/dev/null)
    
    if [[ $ic_idx -eq 0 ]]; then
        echo -e "${GRAY}No instance configurations found${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Select instance configuration (1-${ic_idx}): ${NC}"
    local choice
    read -r choice
    
    if [[ -z "${DIFF_IC_MAP[$choice]:-}" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return
    fi
    
    local ic_ocid ic_name
    IFS='|' read -r ic_ocid ic_name <<< "${DIFF_IC_MAP[$choice]}"
    
    echo ""
    
    # Search for cloud-init*.yml files in current directory
    local ci_files=()
    local ci_idx=0
    while IFS= read -r -d '' ci_file; do
        ((ci_idx++))
        ci_files[$ci_idx]="$ci_file"
    done < <(find . -maxdepth 1 \( -name 'cloud-init*.yml' -o -name 'cloud-init*.yaml' \) -print0 2>/dev/null | sort -z)
    
    local local_file=""
    if [[ $ci_idx -gt 0 ]]; then
        echo -e "${BOLD}${WHITE}Cloud-init files in current directory:${NC}"
        for fi in $(seq 1 $ci_idx); do
            printf "  ${YELLOW}%-3s${NC} %s\n" "$fi" "${ci_files[$fi]}"
        done
        echo ""
        echo -n -e "${CYAN}Select file # or enter path manually: ${NC}"
        local file_choice
        read -r file_choice
        
        if [[ "$file_choice" =~ ^[0-9]+$ ]] && [[ -n "${ci_files[$file_choice]:-}" ]]; then
            local_file="${ci_files[$file_choice]}"
        else
            local_file="$file_choice"
        fi
    else
        echo -n -e "${CYAN}Enter path to local cloud-init file: ${NC}"
        read -r local_file
    fi
    
    # Expand ~ to home directory
    local_file="${local_file/#\~/$HOME}"
    
    if [[ ! -f "$local_file" ]]; then
        echo -e "${RED}File not found: ${local_file}${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    echo ""
    echo -e "${YELLOW}Fetching cloud-init from instance configuration...${NC}"
    
    # Fetch full JSON first (same method as instance config detail view)
    local ic_json
    ic_json=$(oci compute-management instance-configuration get \
        --instance-configuration-id "$ic_ocid" \
        --output json 2>/dev/null)
    
    local ud_b64=""
    if [[ -n "$ic_json" ]] && echo "$ic_json" | jq -e '.data' > /dev/null 2>&1; then
        ud_b64=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["metadata"]["user_data"] // empty' 2>/dev/null)
    fi
    
    # Create temp file for decoded config cloud-init
    local tmp_config
    tmp_config=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    
    if [[ -n "$ud_b64" && "$ud_b64" != "null" ]]; then
        decode_user_data_to_file "$ud_b64" "$tmp_config" || echo "# Failed to decode" > "$tmp_config"
    else
        echo "# No user_data" > "$tmp_config"
    fi
    
    local local_basename
    local_basename=$(basename "$local_file")
    
    # Display the diff
    _display_cloudinit_diff "$tmp_config" "$ic_name" "$local_file" "$local_basename (local)"
    
    # Only cleanup the temp file, not the local file
    rm -f "$tmp_config"
}

#--------------------------------------------------------------------------------
# Internal: Display cloud-init diff with interactive actions
# Args: $1=file_a, $2=name_a, $3=file_b, $4=name_b
#--------------------------------------------------------------------------------
_display_cloudinit_diff() {
    local file_a="$1"
    local name_a="$2"
    local file_b="$3"
    local name_b="$4"
    
    local lines_a lines_b
    lines_a=$(wc -l < "$file_a" 2>/dev/null || echo "0")
    lines_b=$(wc -l < "$file_b" 2>/dev/null || echo "0")
    
    echo ""
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${MAGENTA}                                              CLOUD-INIT DIFF                                                                                            ${NC}"
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${WHITE}Comparing:${NC}"
    echo -e "  ${RED}- A:${NC} ${GREEN}$name_a${NC} ${GRAY}(${lines_a} lines)${NC}"
    echo -e "  ${GREEN}+ B:${NC} ${BLUE}$name_b${NC} ${GRAY}(${lines_b} lines)${NC}"
    echo ""
    
    if diff -q "$file_a" "$file_b" > /dev/null 2>&1; then
        echo -e "${GREEN}╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${GREEN}║                                                 ✓ CLOUD-INIT IS IDENTICAL                                                                              ║${NC}"
        echo -e "${GREEN}╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝${NC}"
    else
        echo -e "${RED}╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${RED}║                                                 ✗ CLOUD-INIT DIFFERS                                                                                    ║${NC}"
        echo -e "${RED}╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        
        # Count changed lines
        local added removed
        added=$(diff -u "$file_a" "$file_b" 2>/dev/null | grep -c '^+[^+]' || true)
        removed=$(diff -u "$file_a" "$file_b" 2>/dev/null | grep -c '^-[^-]' || true)
        echo -e "${GRAY}  Changes: ${RED}-${removed} lines removed${NC}  ${GREEN}+${added} lines added${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}Unified Diff:${NC}"
        echo ""
        
        local diff_output
        diff_output=$(diff -u "$file_a" "$file_b" 2>/dev/null | tail -n +4)
        
        while IFS= read -r line; do
            if [[ "$line" =~ ^@@ ]]; then
                echo ""
                echo -e "${YELLOW}${line}${NC}"
            elif [[ "$line" =~ ^- ]]; then
                echo -e "${RED}${line}${NC}"
            elif [[ "$line" =~ ^\+ ]]; then
                echo -e "${GREEN}${line}${NC}"
            elif [[ "$line" =~ ^[[:space:]] ]]; then
                echo -e "${GRAY}${line}${NC}"
            fi
        done <<< "$diff_output"
    fi
    
    echo ""
    echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Interactive post-diff actions
    echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
    echo -e "  ${CYAN}view-a${NC}   - View full cloud-init: ${GREEN}$name_a${NC}"
    echo -e "  ${CYAN}view-b${NC}   - View full cloud-init: ${BLUE}$name_b${NC}"
    echo -e "  ${CYAN}save-a${NC}   - Save cloud-init A to file"
    echo -e "  ${CYAN}save-b${NC}   - Save cloud-init B to file"
    echo -e "  ${CYAN}save${NC}     - Save both cloud-init files"
    echo -e "  ${CYAN}Enter${NC}    - Return"
    echo ""
    
    while true; do
        echo -n -e "${CYAN}Action [Enter to return]: ${NC}"
        local action
        read -r action
        
        case "$action" in
            view-a|VIEW-A)
                echo ""
                echo -e "${BOLD}${GREEN}═══ Cloud-Init: $name_a (${lines_a} lines) ═══${NC}"
                echo -e "${GRAY}$(printf '━%.0s' $(seq 1 120))${NC}"
                nl -ba "$file_a"
                echo -e "${GRAY}$(printf '━%.0s' $(seq 1 120))${NC}"
                echo ""
                ;;
            view-b|VIEW-B)
                echo ""
                echo -e "${BOLD}${BLUE}═══ Cloud-Init: $name_b (${lines_b} lines) ═══${NC}"
                echo -e "${GRAY}$(printf '━%.0s' $(seq 1 120))${NC}"
                nl -ba "$file_b"
                echo -e "${GRAY}$(printf '━%.0s' $(seq 1 120))${NC}"
                echo ""
                ;;
            save-a|SAVE-A)
                local safe_a
                safe_a=$(echo "$name_a" | tr ' /()' '_---')
                local out_a="cloud-init-${safe_a}-$(date +%Y%m%d_%H%M%S).yml"
                cp "$file_a" "$out_a"
                echo -e "${GREEN}✓ Saved: ${WHITE}${out_a}${NC}"
                ;;
            save-b|SAVE-B)
                local safe_b
                safe_b=$(echo "$name_b" | tr ' /()' '_---')
                local out_b="cloud-init-${safe_b}-$(date +%Y%m%d_%H%M%S).yml"
                cp "$file_b" "$out_b"
                echo -e "${GREEN}✓ Saved: ${WHITE}${out_b}${NC}"
                ;;
            save|SAVE)
                local ts_save
                ts_save=$(date +%Y%m%d_%H%M%S)
                local sa sb
                sa=$(echo "$name_a" | tr ' /()' '_---')
                sb=$(echo "$name_b" | tr ' /()' '_---')
                local oa="cloud-init-${sa}-${ts_save}.yml"
                local ob="cloud-init-${sb}-${ts_save}.yml"
                cp "$file_a" "$oa"
                cp "$file_b" "$ob"
                echo -e "${GREEN}✓ Saved: ${WHITE}${oa}${NC}"
                echo -e "${GREEN}✓ Saved: ${WHITE}${ob}${NC}"
                ;;
            "")
                break
                ;;
            *)
                echo -e "${GRAY}Unknown action. Press Enter to return.${NC}"
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# Rename Instance Configuration interactively
#--------------------------------------------------------------------------------
rename_instance_configuration_interactive() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    echo ""
    echo -e "${BOLD}${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${YELLOW}                                    RENAME INSTANCE CONFIGURATION                                               ${NC}"
    echo -e "${BOLD}${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Refresh cache
    fetch_instance_configurations > /dev/null 2>&1
    
    if [[ ! -f "$INSTANCE_CONFIG_CACHE" ]]; then
        echo -e "${RED}No instance configurations found${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # List configs
    local ic_idx=0
    declare -A RENAME_IC_MAP=()
    
    printf "${BOLD}%-4s %-70s${NC}\n" "#" "Current Name"
    print_separator 100
    
    while IFS='|' read -r ic_ocid ic_name _; do
        [[ "$ic_ocid" =~ ^#.*$ ]] && continue
        [[ -z "$ic_ocid" ]] && continue
        
        ((ic_idx++))
        RENAME_IC_MAP[$ic_idx]="$ic_ocid|$ic_name"
        printf "${YELLOW}%-4s${NC} ${WHITE}%-70s${NC}\n" "$ic_idx" "$ic_name"
    done < <(grep -v '^#' "$INSTANCE_CONFIG_CACHE" 2>/dev/null)
    
    if [[ $ic_idx -eq 0 ]]; then
        echo -e "${GRAY}No instance configurations found${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Select instance configuration to rename (1-${ic_idx}): ${NC}"
    local choice
    read -r choice
    
    if [[ -z "${RENAME_IC_MAP[$choice]:-}" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    local ic_ocid ic_current_name
    IFS='|' read -r ic_ocid ic_current_name <<< "${RENAME_IC_MAP[$choice]}"
    
    echo ""
    echo -e "${BOLD}${WHITE}Selected:${NC} ${CYAN}$ic_current_name${NC}"
    echo -e "${GRAY}OCID: $ic_ocid${NC}"
    echo ""
    
    # Fetch full details to generate recommended name
    echo -e "${YELLOW}Fetching configuration details...${NC}"
    local ic_json
    ic_json=$(oci compute-management instance-configuration get \
        --instance-configuration-id "$ic_ocid" \
        --output json 2>/dev/null)
    
    if [[ -z "$ic_json" ]]; then
        echo -e "${RED}Failed to fetch instance configuration details${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # Extract details for recommended name
    local shape network_type oke_version
    shape=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["shape"] // "unknown"')
    
    # Determine network type from metadata
    local native_networking
    native_networking=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["metadata"]["oke-native-pod-networking"] // "false"')
    if [[ "$native_networking" == "true" ]]; then
        network_type="native"
    else
        network_type="flannel"
    fi
    
    # Try to extract kubernetes version from user_data
    local user_data_b64
    user_data_b64=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["metadata"]["user_data"] // empty')
    oke_version="unknown"
    if [[ -n "$user_data_b64" ]]; then
        local decoded_ud
        decoded_ud=$(echo "$user_data_b64" | base64 -d 2>/dev/null)
        # Look for kubernetes version in the apt source or package name
        # e.g., kubernetes-1.33 or oci-oke-node-all-1.33.1
        local extracted_version
        extracted_version=$(echo "$decoded_ud" | grep -oP 'kubernetes-\K[0-9]+\.[0-9]+' | head -1)
        if [[ -z "$extracted_version" ]]; then
            extracted_version=$(echo "$decoded_ud" | grep -oP 'oci-oke-node-all-\K[0-9]+\.[0-9]+' | head -1)
        fi
        if [[ -n "$extracted_version" ]]; then
            oke_version="$extracted_version"
        fi
    fi
    
    # Count existing configs with similar pattern to determine next number
    local base_pattern="${shape}-ic-oke-${oke_version}-${network_type}"
    local existing_count=0
    if [[ -f "$INSTANCE_CONFIG_CACHE" ]]; then
        existing_count=$(grep -c "${base_pattern}" "$INSTANCE_CONFIG_CACHE" 2>/dev/null) || existing_count=0
        [[ ! "$existing_count" =~ ^[0-9]+$ ]] && existing_count=0
    fi
    local next_num=$((existing_count + 1))
    
    # Generate recommended name
    local recommended_name="${shape}-ic-oke-${oke_version}-${network_type}-${next_num}"
    
    echo ""
    echo -e "${BOLD}${WHITE}Detected Configuration:${NC}"
    echo -e "  ${CYAN}Shape:${NC}        $shape"
    echo -e "  ${CYAN}Network Type:${NC} $network_type"
    echo -e "  ${CYAN}OKE Version:${NC}  $oke_version"
    echo ""
    
    echo -e "${BOLD}${WHITE}Naming Convention:${NC} ${GRAY}<shape>-ic-oke-<version>-<network_type>-<#>${NC}"
    echo ""
    echo -e "${BOLD}${GREEN}Recommended Name:${NC} ${WHITE}$recommended_name${NC}"
    echo ""
    
    echo -n -e "${CYAN}Enter new name [${recommended_name}]: ${NC}"
    local new_name
    read -r new_name
    
    # Use recommended name if empty
    [[ -z "$new_name" ]] && new_name="$recommended_name"
    
    # Don't rename if same name
    if [[ "$new_name" == "$ic_current_name" ]]; then
        echo -e "${YELLOW}New name is the same as current name. No changes made.${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}Rename Summary:${NC}"
    echo -e "  ${RED}Current:${NC} $ic_current_name"
    echo -e "  ${GREEN}New:${NC}     $new_name"
    echo ""
    
    # Show command to be executed
    echo -e "${BOLD}${YELLOW}─── Command to Execute ───${NC}"
    echo ""
    printf "%s\n" "oci compute-management instance-configuration update \\"
    printf "%s\n" "  --instance-configuration-id \"$ic_ocid\" \\"
    printf "%s\n" "  --display-name \"$new_name\""
    echo ""
    
    # Log file for the action
    local log_file="${LOGS_DIR}/instance_config_rename_$(date +%Y%m%d_%H%M%S).log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    
    echo -e "${BOLD}${YELLOW}═══ CONFIRM RENAME ═══${NC}"
    echo ""
    echo -e "${WHITE}Log file: ${CYAN}${log_file}${NC}"
    echo ""
    echo -n -e "${CYAN}Type 'RENAME' to confirm: ${NC}"
    local confirm
    read -r confirm
    
    if [[ "$confirm" != "RENAME" ]]; then
        echo -e "${YELLOW}Cancelled.${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # Log the command
    {
        echo "=========================================="
        echo "Instance Configuration Rename"
        echo "Timestamp: $(date)"
        echo "=========================================="
        echo ""
        echo "OCID: $ic_ocid"
        echo "Current Name: $ic_current_name"
        echo "New Name: $new_name"
        echo ""
        echo "Command:"
        echo "oci compute-management instance-configuration update \\"
        echo "  --instance-configuration-id \"$ic_ocid\" \\"
        echo "  --display-name \"$new_name\""
        echo ""
        echo "=========================================="
        echo "Execution Output:"
        echo "=========================================="
    } > "$log_file"
    
    # Execute the rename
    echo ""
    echo -e "${YELLOW}Renaming instance configuration...${NC}"
    
    local result
    result=$(oci compute-management instance-configuration update \
        --instance-configuration-id "$ic_ocid" \
        --display-name "$new_name" 2>&1)
    local exit_code=$?
    
    # Log the result
    echo "$result" >> "$log_file"
    
    if [[ $exit_code -eq 0 ]]; then
        echo ""
        echo -e "${GREEN}╔════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${GREEN}║                 INSTANCE CONFIGURATION RENAMED SUCCESSFULLY                ║${NC}"
        echo -e "${GREEN}╚════════════════════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "${WHITE}Old Name:${NC} ${RED}$ic_current_name${NC}"
        echo -e "${WHITE}New Name:${NC} ${GREEN}$new_name${NC}"
        echo -e "${WHITE}Log:${NC}      ${WHITE}$log_file${NC}"
        echo ""
        
        # Invalidate cache
        rm -f "$INSTANCE_CONFIG_CACHE"
        
        echo -e "${GREEN}✓ Rename complete!${NC}"
    else
        echo ""
        echo -e "${RED}╔════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${RED}║                    FAILED TO RENAME INSTANCE CONFIGURATION                 ║${NC}"
        echo -e "${RED}╚════════════════════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "${RED}Error:${NC}"
        echo "$result"
        echo ""
        echo -e "${WHITE}Log file: ${CYAN}$log_file${NC}"
    fi
    
    echo ""
    echo -e "Press Enter to return..."
    read -r
}

#--------------------------------------------------------------------------------
# Rename a single Instance Configuration (called from detail view)
# Args: $1 = OCID, $2 = current name, $3 = JSON (optional, will fetch if not provided)
#--------------------------------------------------------------------------------
rename_single_instance_configuration() {
    local ic_ocid="$1"
    local ic_current_name="$2"
    local ic_json="${3:-}"
    
    echo ""
    echo -e "${BOLD}${YELLOW}─── Rename Instance Configuration ───${NC}"
    echo ""
    
    # Fetch JSON if not provided
    if [[ -z "$ic_json" ]]; then
        echo -e "${YELLOW}Fetching configuration details...${NC}"
        ic_json=$(oci compute-management instance-configuration get \
            --instance-configuration-id "$ic_ocid" \
            --output json 2>/dev/null)
        
        if [[ -z "$ic_json" ]]; then
            echo -e "${RED}Failed to fetch instance configuration details${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
    fi
    
    # Extract details for recommended name
    local shape network_type oke_version
    shape=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["shape"] // "unknown"')
    
    # Determine network type from metadata
    local native_networking
    native_networking=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["metadata"]["oke-native-pod-networking"] // "false"')
    if [[ "$native_networking" == "true" ]]; then
        network_type="native"
    else
        network_type="flannel"
    fi
    
    # Try to extract kubernetes version from user_data
    local user_data_b64
    user_data_b64=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["metadata"]["user_data"] // empty')
    oke_version="unknown"
    if [[ -n "$user_data_b64" ]]; then
        local decoded_ud
        decoded_ud=$(echo "$user_data_b64" | base64 -d 2>/dev/null)
        local extracted_version
        extracted_version=$(echo "$decoded_ud" | grep -oP 'kubernetes-\K[0-9]+\.[0-9]+' | head -1)
        if [[ -z "$extracted_version" ]]; then
            extracted_version=$(echo "$decoded_ud" | grep -oP 'oci-oke-node-all-\K[0-9]+\.[0-9]+' | head -1)
        fi
        if [[ -n "$extracted_version" ]]; then
            oke_version="$extracted_version"
        fi
    fi
    
    # Count existing configs with similar pattern
    local base_pattern="${shape}-ic-oke-${oke_version}-${network_type}"
    local existing_count=0
    if [[ -f "$INSTANCE_CONFIG_CACHE" ]]; then
        existing_count=$(grep -c "${base_pattern}" "$INSTANCE_CONFIG_CACHE" 2>/dev/null) || existing_count=0
        [[ ! "$existing_count" =~ ^[0-9]+$ ]] && existing_count=0
    fi
    local next_num=$((existing_count + 1))
    
    # Generate recommended name
    local recommended_name="${shape}-ic-oke-${oke_version}-${network_type}-${next_num}"
    
    echo -e "${WHITE}Current Name:${NC}     ${CYAN}$ic_current_name${NC}"
    echo -e "${WHITE}Shape:${NC}            $shape"
    echo -e "${WHITE}Network Type:${NC}     $network_type"
    echo -e "${WHITE}OKE Version:${NC}      $oke_version"
    echo ""
    echo -e "${BOLD}${GREEN}Recommended:${NC}      ${WHITE}$recommended_name${NC}"
    echo ""
    
    echo -n -e "${CYAN}Enter new name [${recommended_name}]: ${NC}"
    local new_name
    read -r new_name
    
    [[ -z "$new_name" ]] && new_name="$recommended_name"
    
    if [[ "$new_name" == "$ic_current_name" ]]; then
        echo -e "${YELLOW}New name is the same as current name. No changes made.${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Show command
    echo ""
    echo -e "${BOLD}${YELLOW}Command:${NC}"
    echo -e "oci compute-management instance-configuration update \\"
    echo -e "  --instance-configuration-id \"$ic_ocid\" \\"
    echo -e "  --display-name \"$new_name\""
    echo ""
    
    echo -n -e "${CYAN}Type 'RENAME' to confirm: ${NC}"
    local confirm
    read -r confirm
    
    if [[ "$confirm" != "RENAME" ]]; then
        echo -e "${YELLOW}Cancelled.${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Log file
    local log_file="${LOGS_DIR}/instance_config_rename_$(date +%Y%m%d_%H%M%S).log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    
    {
        echo "=========================================="
        echo "Instance Configuration Rename"
        echo "Timestamp: $(date)"
        echo "=========================================="
        echo "OCID: $ic_ocid"
        echo "Current Name: $ic_current_name"
        echo "New Name: $new_name"
        echo ""
        echo "Command:"
        echo "oci compute-management instance-configuration update \\"
        echo "  --instance-configuration-id \"$ic_ocid\" \\"
        echo "  --display-name \"$new_name\""
        echo ""
        echo "=========================================="
        echo "Execution Output:"
        echo "=========================================="
    } > "$log_file"
    
    echo ""
    echo -e "${YELLOW}Renaming...${NC}"
    
    local result
    result=$(oci compute-management instance-configuration update \
        --instance-configuration-id "$ic_ocid" \
        --display-name "$new_name" 2>&1)
    local exit_code=$?
    
    echo "$result" >> "$log_file"
    
    if [[ $exit_code -eq 0 ]]; then
        echo -e "${GREEN}✓ Renamed successfully!${NC}"
        echo -e "  ${RED}Old:${NC} $ic_current_name"
        echo -e "  ${GREEN}New:${NC} $new_name"
        rm -f "$INSTANCE_CONFIG_CACHE"
    else
        echo -e "${RED}✗ Failed to rename${NC}"
        echo "$result"
    fi
    
    echo -e "${WHITE}Log: $log_file${NC}"
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#===============================================================================
# GPU MEMORY FABRIC & CLUSTER MANAGEMENT
#===============================================================================

interactive_gpu_management() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    while true; do
        display_gpu_management_menu
        
        echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
        echo -e "  ${YELLOW}f#/g#/i#/c#${NC} - View resource details (e.g., 'f1', 'g2', 'i3', 'c1')"
        echo -e "  ${GREEN}create${NC}      - Create a new GPU Memory Cluster on a Fabric"
        echo -e "  ${GREEN}update${NC}      - Update an existing GPU Memory Cluster (size/instance config)"
        echo -e "  ${MAGENTA}r${NC}           - Refresh data from OCI"
        echo -e "  ${CYAN}back${NC}        - Return to main menu"
        echo ""
        echo -n -e "${BOLD}${CYAN}[GPU Fabrics] Enter # or command [f#/g#/i#/c#/create/update/r/back]: ${NC}"
        
        local input
        read -r input
        
        # Empty input goes back
        if [[ -z "$input" ]]; then
            return
        fi
        
        case "$input" in
            create|CREATE)
                create_gpu_memory_cluster_interactive
                ;;
            update|UPDATE)
                update_gpu_memory_cluster_interactive
                ;;
            r|R|refresh|REFRESH)
                echo -e "${YELLOW}Refreshing cache...${NC}"
                rm -f "$FABRIC_CACHE" "$CLUSTER_CACHE" "$INSTANCE_CLUSTER_MAP_CACHE" "$INSTANCE_CONFIG_CACHE" "$COMPUTE_CLUSTER_CACHE"
                ;;
            quit|QUIT|q|Q|exit|EXIT|back|BACK|b|B)
                return
                ;;
            f[0-9]*|g[0-9]*|i[0-9]*|c[0-9]*)
                view_gpu_resource "$input"
                ;;
            *)
                echo -e "${RED}Unknown command: $input${NC}"
                ;;
        esac
    done
}

# View details of a fabric or cluster
view_gpu_resource() {
    local resource_id="$1"
    
    case "$resource_id" in
        f[0-9]*)
            local fabric_ocid="${FABRIC_INDEX_MAP[$resource_id]:-}"
            if [[ -z "$fabric_ocid" ]]; then
                echo -e "${RED}Invalid fabric ID: $resource_id${NC}"
                return 1
            fi
            
            echo ""
            echo -e "${BOLD}${ORANGE}=== GPU Memory Fabric Details ===${NC}"
            
            # Fetch full details
            local fabric_json
            fabric_json=$(oci compute compute-gpu-memory-fabric get \
                --compute-gpu-memory-fabric-id "$fabric_ocid" \
                --output json 2>/dev/null)
            
            if [[ -n "$fabric_json" ]]; then
                local fabric_name
                fabric_name=$(echo "$fabric_json" | jq -r '.data["display-name"] // "N/A"')
                echo -e "${WHITE}Name:${NC} ${ORANGE}$fabric_name${NC}"
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$fabric_ocid${NC}"
                echo ""
                echo "$fabric_json" | jq -r '
                    .data | 
                    "State:             \(.["lifecycle-state"] // "N/A")",
                    "Healthy Hosts:     \(.["healthy-host-count"] // 0)",
                    "Available Hosts:   \(.["available-host-count"] // 0)",
                    "Total Hosts:       \(.["total-host-count"] // 0)",
                    "Current Firmware:  \(.["current-firmware-bundle-id"] // "N/A")",
                    "Target Firmware:   \(.["target-firmware-bundle-id"] // "N/A")",
                    "Firmware State:    \(.["firmware-update-state"] // "N/A")",
                    "Time Created:      \(.["time-created"] // "N/A")"
                '
            else
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$fabric_ocid${NC}"
                echo ""
                echo -e "${RED}Failed to fetch fabric details${NC}"
            fi
            ;;
            
        g[0-9]*)
            local cluster_ocid="${CLUSTER_INDEX_MAP[$resource_id]:-}"
            if [[ -z "$cluster_ocid" ]]; then
                echo -e "${RED}Invalid cluster ID: $resource_id${NC}"
                return 1
            fi
            
            echo ""
            echo -e "${BOLD}${MAGENTA}=== GPU Memory Cluster Details ===${NC}"
            
            # Fetch full details
            local cluster_json
            cluster_json=$(oci compute compute-gpu-memory-cluster get \
                --compute-gpu-memory-cluster-id "$cluster_ocid" \
                --output json 2>/dev/null)
            
            if [[ -n "$cluster_json" ]]; then
                local cluster_name
                cluster_name=$(echo "$cluster_json" | jq -r '.data["display-name"] // "N/A"')
                echo -e "${WHITE}Name:${NC} ${MAGENTA}$cluster_name${NC}"
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$cluster_ocid${NC}"
                echo ""
                
                local ic_id cc_id fabric_id
                ic_id=$(echo "$cluster_json" | jq -r '.data["instance-configuration-id"] // "N/A"')
                cc_id=$(echo "$cluster_json" | jq -r '.data["compute-cluster-id"] // "N/A"')
                fabric_id=$(echo "$cluster_json" | jq -r '.data["gpu-memory-fabric-id"] // "N/A"')
                
                local ic_name cc_name
                ic_name=$(get_instance_config_name "$ic_id")
                cc_name=$(get_compute_cluster_name "$cc_id")
                
                echo "$cluster_json" | jq -r '
                    .data | 
                    "State:                  \(.["lifecycle-state"] // "N/A")",
                    "Size:                   \(.["size"] // 0)",
                    "Availability Domain:    \(.["availability-domain"] // "N/A")",
                    "Time Created:           \(.["time-created"] // "N/A")"
                '
                echo -e "Instance Configuration: ${GREEN}$ic_name${NC} ${YELLOW}($ic_id)${NC}"
                echo -e "Compute Cluster:        ${GREEN}$cc_name${NC} ${YELLOW}($cc_id)${NC}"
                
                # Resolve fabric name
                local fabric_name="N/A"
                if [[ "$fabric_id" != "N/A" && -n "$fabric_id" ]]; then
                    fabric_name=$(oci compute compute-gpu-memory-fabric get --compute-gpu-memory-fabric-id "$fabric_id" --query 'data."display-name"' --raw-output 2>/dev/null) || fabric_name="N/A"
                fi
                echo -e "GPU Memory Fabric:      ${GREEN}$fabric_name${NC} ${YELLOW}($fabric_id)${NC}"
            else
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$cluster_ocid${NC}"
                echo ""
                echo -e "${RED}Failed to fetch cluster details${NC}"
            fi
            ;;
            
        i[0-9]*)
            local ic_ocid="${IC_INDEX_MAP[$resource_id]:-}"
            if [[ -z "$ic_ocid" ]]; then
                echo -e "${RED}Invalid instance config ID: $resource_id${NC}"
                return 1
            fi
            
            echo ""
            echo -e "${BOLD}${GREEN}=== Instance Configuration Details ===${NC}"
            
            local ic_json
            ic_json=$(oci compute-management instance-configuration get \
                --instance-configuration-id "$ic_ocid" \
                --output json 2>/dev/null)
            
            if [[ -n "$ic_json" ]]; then
                local ic_name ic_time_created ic_compartment
                ic_name=$(echo "$ic_json" | jq -r '.data["display-name"] // "N/A"')
                ic_time_created=$(echo "$ic_json" | jq -r '.data["time-created"] // "N/A"')
                ic_compartment=$(echo "$ic_json" | jq -r '.data["compartment-id"] // "N/A"')
                
                echo -e "${WHITE}Name:${NC}         ${GREEN}$ic_name${NC}"
                echo -e "${WHITE}OCID:${NC}         ${YELLOW}$ic_ocid${NC}"
                echo -e "${WHITE}Time Created:${NC} $ic_time_created"
                echo -e "${WHITE}Compartment:${NC}  ${WHITE}$(resolve_compartment_name "$ic_compartment")${NC} ${GRAY}($ic_compartment)${NC}"
                
                # Show instance details from the configuration
                echo ""
                echo -e "${BOLD}${CYAN}Instance Details:${NC}"
                echo "$ic_json" | jq -r '
                    .data["instance-details"]["launch-details"] // {} |
                    "  Shape:              \(.shape // "N/A")",
                    "  Availability Domain: \(.["availability-domain"] // "N/A")",
                    "  Compartment:        \(.["compartment-id"][-20:] // "N/A")"
                ' 2>/dev/null
                
                # Show source details
                local source_type
                source_type=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["source-details"]["source-type"] // "N/A"' 2>/dev/null)
                echo -e "  Source Type:        $source_type"
                
                if [[ "$source_type" == "image" ]]; then
                    local image_id
                    image_id=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["source-details"]["image-id"] // "N/A"' 2>/dev/null)
                    
                    # Fetch image details to get the display name
                    if [[ -n "$image_id" && "$image_id" != "N/A" ]]; then
                        echo -e "  ${BOLD}${CYAN}Image:${NC}"
                        local img_json img_name img_os img_os_version
                        img_json=$(oci compute image get --image-id "$image_id" --output json 2>/dev/null)
                        if [[ -n "$img_json" ]] && echo "$img_json" | jq -e '.data' > /dev/null 2>&1; then
                            img_name=$(echo "$img_json" | jq -r '.data["display-name"] // "Unknown"')
                            img_os=$(echo "$img_json" | jq -r '.data["operating-system"] // "N/A"')
                            img_os_version=$(echo "$img_json" | jq -r '.data["operating-system-version"] // ""')
                            echo -e "    Name:    ${WHITE}$img_name${NC}"
                            echo -e "    OS:      ${WHITE}$img_os $img_os_version${NC}"
                            echo -e "    OCID:    ${YELLOW}$image_id${NC}"
                        else
                            echo -e "    Name:    ${GRAY}(unable to fetch)${NC}"
                            echo -e "    OCID:    ${YELLOW}$image_id${NC}"
                        fi
                    else
                        echo -e "  Image ID:           ${GRAY}N/A${NC}"
                    fi
                fi
                
                # Check if user_data exists
                local has_user_data="false"
                local user_data_b64
                user_data_b64=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["metadata"]["user_data"] // empty' 2>/dev/null)
                [[ -n "$user_data_b64" ]] && has_user_data="true"
                
                # Check for other metadata
                local ssh_keys
                ssh_keys=$(echo "$ic_json" | jq -r '.data["instance-details"]["launch-details"]["metadata"]["ssh_authorized_keys"] // empty' 2>/dev/null)
                if [[ -n "$ssh_keys" ]]; then
                    echo ""
                    echo -e "${BOLD}${CYAN}SSH Keys:${NC}"
                    echo -e "  ${GRAY}(SSH authorized keys are configured)${NC}"
                fi
                
                if [[ "$has_user_data" == "true" ]]; then
                    echo ""
                    echo -e "${BOLD}${CYAN}User Data:${NC}"
                    echo -e "  ${GREEN}✓ Cloud-init user-data is configured${NC}"
                fi
                
                # Show action option
                echo ""
                echo -e "${BOLD}${WHITE}Actions:${NC}"
                if [[ "$has_user_data" == "true" ]]; then
                    echo -e "  ${MAGENTA}user-data${NC}  - View decoded cloud-init user-data"
                    echo -e "  ${MAGENTA}save${NC}       - Save user-data to file (cloud-init.yml)"
                fi
                echo -e "  ${RED}delete${NC}     - Delete this instance configuration"
                echo -e "  ${CYAN}Enter${NC}      - Return to menu"
                echo ""
                echo -n -e "${CYAN}Action [user-data/save/delete/Enter]: ${NC}"
                
                local action
                read -r action
                
                if [[ "$action" == "user-data" || "$action" == "userdata" || "$action" == "ud" ]]; then
                    if [[ "$has_user_data" == "true" ]]; then
                        echo ""
                        echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════${NC}"
                        echo -e "${BOLD}${MAGENTA}                         DECODED CLOUD-INIT USER-DATA                          ${NC}"
                        echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════${NC}"
                        echo ""
                        # Decode and display the user-data (handles gzip)
                        if is_user_data_gzip "$user_data_b64"; then
                            echo -e "${GRAY}(gzip compressed - decompressing)${NC}"
                            echo ""
                        fi
                        decode_user_data "$user_data_b64"
                        echo ""
                        echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════${NC}"
                        echo ""
                        echo -n -e "${CYAN}Press Enter to continue...${NC}"
                        read -r
                    else
                        echo -e "${YELLOW}No user-data found in this instance configuration${NC}"
                    fi
                elif [[ "$action" == "save" || "$action" == "SAVE" ]]; then
                    if [[ "$has_user_data" == "true" ]]; then
                        # Generate safe filename from instance config name
                        local safe_name
                        safe_name=$(echo "$ic_name" | tr ' ' '_' | tr -cd '[:alnum:]_-')
                        local filename="${safe_name}_cloud-init.yml"
                        
                        echo ""
                        echo -n -e "${CYAN}Save as [${filename}]: ${NC}"
                        local custom_filename
                        read -r custom_filename
                        [[ -n "$custom_filename" ]] && filename="$custom_filename"
                        
                        # Decode and save (handles gzip)
                        local gzip_msg=""
                        if is_user_data_gzip "$user_data_b64"; then
                            gzip_msg=" ${GRAY}(decompressed from gzip)${NC}"
                        fi
                        
                        if decode_user_data_to_file "$user_data_b64" "$filename"; then
                            echo -e "${GREEN}✓ User-data saved to: ${WHITE}$(pwd)/${filename}${NC}${gzip_msg}"
                        else
                            echo -e "${RED}Failed to save user-data${NC}"
                        fi
                        echo ""
                        echo -n -e "${CYAN}Press Enter to continue...${NC}"
                        read -r
                    else
                        echo -e "${YELLOW}No user-data found in this instance configuration${NC}"
                    fi
                elif [[ "$action" == "delete" || "$action" == "DELETE" ]]; then
                    # Store the ic_ocid for deletion
                    IC_INDEX_MAP["delete_target"]="$ic_ocid"
                    delete_single_instance_configuration "$ic_ocid" "$ic_name"
                fi
            else
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$ic_ocid${NC}"
                echo ""
                echo -e "${RED}Failed to fetch instance configuration details${NC}"
            fi
            ;;
            
        c[0-9]*)
            local cc_ocid="${CC_INDEX_MAP[$resource_id]:-}"
            if [[ -z "$cc_ocid" ]]; then
                echo -e "${RED}Invalid compute cluster ID: $resource_id${NC}"
                return 1
            fi
            
            echo ""
            echo -e "${BOLD}${BLUE}=== Compute Cluster Details ===${NC}"
            
            local cc_json
            cc_json=$(oci compute compute-cluster get \
                --compute-cluster-id "$cc_ocid" \
                --output json 2>/dev/null)
            
            if [[ -n "$cc_json" ]]; then
                local cc_name
                cc_name=$(echo "$cc_json" | jq -r '.data["display-name"] // "N/A"')
                echo -e "${WHITE}Name:${NC} ${BLUE}$cc_name${NC}"
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$cc_ocid${NC}"
                echo ""
                echo "$cc_json" | jq -r '
                    .data | 
                    "State:                \(.["lifecycle-state"] // "N/A")",
                    "Availability Domain:  \(.["availability-domain"] // "N/A")",
                    "Time Created:         \(.["time-created"] // "N/A")"
                '
            else
                echo -e "${WHITE}OCID:${NC} ${YELLOW}$cc_ocid${NC}"
                echo ""
                echo -e "${RED}Failed to fetch compute cluster details${NC}"
            fi
            ;;
            
        *)
            echo -e "${RED}Invalid resource ID format. Use f#, g#, i#, or c#${NC}"
            return 1
            ;;
    esac
}

# Create GPU Memory Cluster interactively
create_gpu_memory_cluster_interactive() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    echo ""
    echo -e "${BOLD}${GREEN}═══ Create GPU Memory Cluster ═══${NC}"
    echo ""
    
    # Refresh caches to get latest data
    echo -e "${YELLOW}Refreshing data from OCI...${NC}"
    rm -f "$FABRIC_CACHE" "$CLUSTER_CACHE" "$INSTANCE_CLUSTER_MAP_CACHE" "$INSTANCE_CONFIG_CACHE" "$COMPUTE_CLUSTER_CACHE"
    fetch_gpu_fabrics
    fetch_gpu_clusters
    fetch_instance_configurations
    fetch_compute_clusters
    
    # Rebuild index maps
    display_gpu_management_menu > /dev/null 2>&1
    
    echo -e "${GREEN}✓ Data refreshed${NC}"
    echo ""
    
    # Display available GPU Memory Fabrics (only those with capacity)
    echo -e "${WHITE}GPU Memory Fabrics with Available Capacity:${NC}"
    echo ""
    printf "${BOLD}%-6s %-45s %-12s %8s %6s %6s  %-90s${NC}\n" \
        "ID" "Fabric Name" "State" "Healthy" "Avail" "Total" "Fabric OCID"
    print_separator 180
    
    local has_available=false
    local fabric_output_temp
    fabric_output_temp=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    
    # Build map of fabric availability for later use
    declare -A FABRIC_AVAIL_MAP
    
    local fid
    for fid in "${!FABRIC_INDEX_MAP[@]}"; do
        local fabric_ocid="${FABRIC_INDEX_MAP[$fid]}"
        [[ -z "$fabric_ocid" ]] && continue
        
        # Get fabric info from cache
        local fabric_line
        fabric_line=$(grep "^[^#].*|${fabric_ocid}|" "$FABRIC_CACHE" 2>/dev/null | head -1)
        [[ -z "$fabric_line" ]] && fabric_line=$(grep "${fabric_ocid}" "$FABRIC_CACHE" 2>/dev/null | head -1)
        
        if [[ -n "$fabric_line" ]]; then
            local f_name f_suffix f_ocid f_state f_healthy f_avail f_total
            IFS='|' read -r f_name f_suffix f_ocid f_state f_healthy f_avail f_total _ _ _ <<< "$fabric_line"
            
            # Only include fabrics with available capacity
            if [[ "$f_avail" != "0" && "$f_avail" != "N/A" && -n "$f_avail" && "$f_avail" -gt 0 ]] 2>/dev/null; then
                has_available=true
                FABRIC_AVAIL_MAP[$fid]="$f_avail"
                
                # Store for sorting (numeric key|display data including OCID)
                local fid_num="${fid#f}"
                echo "${fid_num}|${fid}|${f_name}|${f_state}|${f_healthy}|${f_avail}|${f_total}|${fabric_ocid}" >> "$fabric_output_temp"
            fi
        fi
    done
    
    # Sort and display
    sort -t'|' -k1 -n "$fabric_output_temp" | while IFS='|' read -r _ fid f_name f_state f_healthy f_avail f_total f_ocid; do
        # State color
        local state_color="$GREEN"
        [[ "$f_state" != "AVAILABLE" && "$f_state" != "OCCUPIED" ]] && state_color="$RED"
        
        printf "${YELLOW}%-6s${NC} ${CYAN}%-45s${NC} ${state_color}%-12s${NC} %8s ${LIGHT_GREEN}%6s${NC} %6s  ${GRAY}%-90s${NC}\n" \
            "$fid" "$f_name" "$f_state" "$f_healthy" "$f_avail" "$f_total" "$f_ocid"
    done
    
    rm -f "$fabric_output_temp"
    
    echo ""
    
    if [[ "$has_available" != "true" ]]; then
        echo -e "${RED}No GPU Memory Fabrics have available capacity. Cannot create cluster.${NC}"
        return 1
    fi
    
    # Select Fabric
    echo -n -e "${CYAN}Select GPU Memory Fabric (f#): ${NC}"
    local fabric_input
    read -r fabric_input
    
    local fabric_ocid="${FABRIC_INDEX_MAP[$fabric_input]:-}"
    if [[ -z "$fabric_ocid" ]]; then
        echo -e "${RED}Invalid fabric selection: $fabric_input${NC}"
        return 1
    fi
    
    # Check fabric has availability
    local fabric_avail="${FABRIC_AVAIL_MAP[$fabric_input]:-0}"
    if [[ "$fabric_avail" -eq 0 ]] 2>/dev/null; then
        echo -e "${RED}Selected fabric has no available capacity${NC}"
        return 1
    fi
    
    # Get fabric suffix for display name
    local fabric_suffix="${fabric_ocid: -5}"
    local default_display_name="fabric-${fabric_suffix}"
    
    echo -e "${WHITE}Selected Fabric:${NC} ${YELLOW}$fabric_ocid${NC}"
    echo -e "${WHITE}Available Nodes:${NC} ${LIGHT_GREEN}$fabric_avail${NC}"
    echo ""
    
    # Display Compute Clusters
    echo -e "${WHITE}Available Compute Clusters:${NC}"
    echo ""
    printf "${BOLD}%-6s %-40s %-35s %-12s${NC}\n" \
        "ID" "Compute Cluster Name" "Availability Domain" "Status"
    print_separator 95
    
    local cc_output_temp
    cc_output_temp=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    
    local cid
    for cid in "${!CC_INDEX_MAP[@]}"; do
        local cc_ocid="${CC_INDEX_MAP[$cid]}"
        [[ -z "$cc_ocid" ]] && continue
        
        # Get compute cluster info from cache
        local cc_line cc_name cc_ad cc_state
        cc_line=$(grep "^${cc_ocid}|" "$COMPUTE_CLUSTER_CACHE" 2>/dev/null | head -1)
        if [[ -n "$cc_line" ]]; then
            IFS='|' read -r _ cc_name cc_ad cc_state <<< "$cc_line"
            # Default state if not present (old cache format)
            [[ -z "$cc_state" ]] && cc_state="UNKNOWN"
        else
            cc_name="N/A"
            cc_ad="N/A"
            cc_state="UNKNOWN"
        fi
        
        # Skip deleted clusters
        [[ "$cc_state" == "DELETED" ]] && continue
        
        local cid_num="${cid#c}"
        echo "${cid_num}|${cid}|${cc_name}|${cc_ad}|${cc_state}" >> "$cc_output_temp"
    done
    
    sort -t'|' -k1 -n "$cc_output_temp" | while IFS='|' read -r _ cid cc_name cc_ad cc_state; do
        # Color-code the status
        local state_color="$GREEN"
        case "$cc_state" in
            ACTIVE) state_color="$GREEN" ;;
            CREATING|UPDATING) state_color="$YELLOW" ;;
            DELETING) state_color="$RED" ;;
            *) state_color="$GRAY" ;;
        esac
        printf "${YELLOW}%-6s${NC} ${CYAN}%-40s${NC} ${MAGENTA}%-35s${NC} ${state_color}%-12s${NC}\n" \
            "$cid" "$cc_name" "$cc_ad" "$cc_state"
    done
    
    rm -f "$cc_output_temp"
    
    echo ""
    
    # Select Compute Cluster
    echo -n -e "${CYAN}Select Compute Cluster (c#): ${NC}"
    local cc_input
    read -r cc_input
    
    local cc_ocid="${CC_INDEX_MAP[$cc_input]:-}"
    if [[ -z "$cc_ocid" ]]; then
        echo -e "${RED}Invalid compute cluster selection: $cc_input${NC}"
        return 1
    fi
    
    # Get AD from compute cluster
    local cc_ad
    cc_ad=$(oci compute compute-cluster get \
        --compute-cluster-id "$cc_ocid" \
        --query 'data."availability-domain"' \
        --raw-output 2>/dev/null)
    
    echo -e "${WHITE}Selected Compute Cluster:${NC} ${YELLOW}$cc_ocid${NC}"
    echo -e "${WHITE}Availability Domain:${NC} ${MAGENTA}$cc_ad${NC}"
    echo ""
    
    # Display Instance Configurations
    echo -e "${WHITE}Available Instance Configurations:${NC}"
    echo ""
    printf "${BOLD}%-6s %-60s${NC}\n" \
        "ID" "Instance Configuration Name"
    print_separator 70
    
    local ic_output_temp
    ic_output_temp=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    
    local iid
    for iid in "${!IC_INDEX_MAP[@]}"; do
        local ic_ocid="${IC_INDEX_MAP[$iid]}"
        [[ -z "$ic_ocid" ]] && continue
        
        # Get instance config info from cache
        local ic_line ic_name
        ic_line=$(grep "^${ic_ocid}|" "$INSTANCE_CONFIG_CACHE" 2>/dev/null | head -1)
        if [[ -n "$ic_line" ]]; then
            IFS='|' read -r _ ic_name <<< "$ic_line"
        else
            ic_name="N/A"
        fi
        
        local iid_num="${iid#i}"
        echo "${iid_num}|${iid}|${ic_name}" >> "$ic_output_temp"
    done
    
    sort -t'|' -k1 -n "$ic_output_temp" | while IFS='|' read -r _ iid ic_name; do
        printf "${YELLOW}%-6s${NC} ${CYAN}%-60s${NC}\n" \
            "$iid" "$ic_name"
    done
    
    rm -f "$ic_output_temp"
    
    echo ""
    
    # Select Instance Configuration
    echo -n -e "${CYAN}Select Instance Configuration (i#): ${NC}"
    local ic_input
    read -r ic_input
    
    local ic_ocid="${IC_INDEX_MAP[$ic_input]:-}"
    if [[ -z "$ic_ocid" ]]; then
        echo -e "${RED}Invalid instance configuration selection: $ic_input${NC}"
        return 1
    fi
    
    echo -e "${WHITE}Selected Instance Config:${NC} ${YELLOW}$ic_ocid${NC}"
    echo ""
    
    # Enter Size (default 1, max = fabric availability)
    echo -n -e "${CYAN}Enter cluster size (1-${fabric_avail}) [1]: ${NC}"
    local cluster_size
    read -r cluster_size
    cluster_size="${cluster_size:-1}"
    
    if ! [[ "$cluster_size" =~ ^[0-9]+$ ]] || [[ "$cluster_size" -lt 1 ]]; then
        echo -e "${RED}Invalid size: must be a positive integer${NC}"
        return 1
    fi
    
    if [[ "$cluster_size" -gt "$fabric_avail" ]]; then
        echo -e "${RED}Invalid size: requested $cluster_size but only $fabric_avail nodes available${NC}"
        return 1
    fi
    
    # Enter Display Name
    echo -n -e "${CYAN}Enter display name [${default_display_name}]: ${NC}"
    local display_name
    read -r display_name
    display_name="${display_name:-$default_display_name}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Confirm Creation ═══${NC}"
    echo -e "  ${CYAN}Display Name:${NC}         ${WHITE}$display_name${NC}"
    echo -e "  ${CYAN}Availability Domain:${NC}  ${WHITE}$cc_ad${NC}"
    echo -e "  ${CYAN}Size:${NC}                 ${WHITE}$cluster_size${NC}"
    echo ""
    
    # Show compartment with name
    local comp_name_display
    comp_name_display=$(resolve_compartment_name "$compartment_id")
    echo -e "  ${CYAN}Compartment:${NC}"
    echo -e "    Name: ${WHITE}${comp_name_display}${NC}"
    echo -e "    OCID: ${YELLOW}${compartment_id}${NC}"
    
    # Show compute cluster with name
    local cc_name_display
    cc_name_display=$(oci compute compute-cluster get --compute-cluster-id "$cc_ocid" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
    echo -e "  ${CYAN}Compute Cluster:${NC}"
    echo -e "    Name: ${WHITE}${cc_name_display}${NC}"
    echo -e "    OCID: ${YELLOW}${cc_ocid}${NC}"
    
    # Show instance configuration with name
    local ic_name_display
    ic_name_display=$(oci compute-management instance-configuration get --instance-configuration-id "$ic_ocid" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
    echo -e "  ${CYAN}Instance Config:${NC}"
    echo -e "    Name: ${WHITE}${ic_name_display}${NC}"
    echo -e "    OCID: ${YELLOW}${ic_ocid}${NC}"
    
    # Show GPU memory fabric with name
    local fabric_name_display
    fabric_name_display=$(oci compute compute-gpu-memory-fabric get --compute-gpu-memory-fabric-id "$fabric_ocid" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
    echo -e "  ${CYAN}GPU Memory Fabric:${NC}"
    echo -e "    Name: ${WHITE}${fabric_name_display}${NC}"
    echo -e "    OCID: ${YELLOW}${fabric_ocid}${NC}"
    echo ""
    
    echo -e "${BOLD}${WHITE}Command to execute:${NC}"
    echo -e "${GRAY}oci compute compute-gpu-memory-cluster create \\
    --availability-domain \"$cc_ad\" \\
    --compartment-id \"$compartment_id\" \\
    --compute-cluster-id \"$cc_ocid\" \\
    --instance-configuration-id \"$ic_ocid\" \\
    --gpu-memory-fabric-id \"$fabric_ocid\" \\
    --size $cluster_size \\
    --display-name \"$display_name\"${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Proceed with creation? (yes/no): ${NC}"
    local confirm
    read -r confirm
    
    if [[ "$confirm" != "yes" ]]; then
        echo -e "${RED}Creation cancelled${NC}"
        return 0
    fi
    
    echo ""
    echo -e "${GREEN}Creating GPU Memory Cluster...${NC}"
    
    # Create the cluster
    local result
    result=$(oci compute compute-gpu-memory-cluster create \
        --availability-domain "$cc_ad" \
        --compartment-id "$compartment_id" \
        --compute-cluster-id "$cc_ocid" \
        --instance-configuration-id "$ic_ocid" \
        --gpu-memory-fabric-id "$fabric_ocid" \
        --size "$cluster_size" \
        --display-name "$display_name" \
        --output json 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}GPU Memory Cluster creation initiated successfully!${NC}"
        echo ""
        local new_cluster_id
        new_cluster_id=$(echo "$result" | jq -r '.data.id // "N/A"')
        local new_cluster_state
        new_cluster_state=$(echo "$result" | jq -r '.data["lifecycle-state"] // "N/A"')
        
        echo -e "${WHITE}New Cluster OCID:${NC}  ${YELLOW}$new_cluster_id${NC}"
        echo -e "${WHITE}Initial State:${NC}     ${CYAN}$new_cluster_state${NC}"
        
        # Invalidate cluster, fabric, and instance-cluster map caches
        rm -f "$CLUSTER_CACHE" "$FABRIC_CACHE" "$INSTANCE_CLUSTER_MAP_CACHE"
    else
        echo -e "${RED}Failed to create GPU Memory Cluster:${NC}"
        echo "$result"
        return 1
    fi
}

# Update GPU Memory Cluster interactively
update_gpu_memory_cluster_interactive() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    
    echo ""
    echo -e "${BOLD}${YELLOW}═══ Update GPU Memory Cluster(s) ═══${NC}"
    echo ""
    
    # Refresh caches to get latest data
    echo -e "${YELLOW}Refreshing data from OCI...${NC}"
    rm -f "$FABRIC_CACHE" "$CLUSTER_CACHE" "$INSTANCE_CLUSTER_MAP_CACHE" "$INSTANCE_CONFIG_CACHE" "$COMPUTE_CLUSTER_CACHE"
    fetch_gpu_fabrics
    fetch_gpu_clusters
    fetch_instance_configurations
    fetch_compute_clusters
    
    # Rebuild index maps
    display_gpu_management_menu > /dev/null 2>&1
    
    echo -e "${GREEN}✓ Data refreshed${NC}"
    echo ""
    
    # List available GPU Memory Clusters
    echo -e "${WHITE}Available GPU Memory Clusters:${NC}"
    echo ""
    printf "${BOLD}%-6s %-35s %-10s %6s  %-40s %8s %6s %6s${NC}\n" \
        "ID" "Cluster Name" "State" "Size" "Fabric" "Healthy" "Avail" "Total"
    print_separator 130
    
    # Collect cluster lines for sorting
    local cluster_lines_temp
    cluster_lines_temp=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    local has_clusters=false
    local max_gid_num=0
    
    for gid in "${!CLUSTER_INDEX_MAP[@]}"; do
        local cluster_ocid="${CLUSTER_INDEX_MAP[$gid]}"
        [[ -z "$cluster_ocid" ]] && continue
        
        has_clusters=true
        
        # Track max gid number
        local gid_num="${gid#g}"
        [[ "$gid_num" -gt "$max_gid_num" ]] && max_gid_num="$gid_num"
        
        # Get cluster info from cache
        local cluster_line
        cluster_line=$(grep "^${cluster_ocid}|" "$CLUSTER_CACHE" 2>/dev/null | head -1)
        
        if [[ -n "$cluster_line" ]]; then
            local c_name c_state c_fabric_suffix c_size
            IFS='|' read -r _ c_name c_state c_fabric_suffix _ _ c_size <<< "$cluster_line"
            
            # Get fabric info from suffix
            local fabric_name="N/A" f_healthy="N/A" f_avail="N/A" f_total="N/A"
            if [[ -n "$c_fabric_suffix" ]]; then
                local fabric_line
                fabric_line=$(grep -v '^#' "$FABRIC_CACHE" 2>/dev/null | grep "|${c_fabric_suffix}|" | head -1)
                if [[ -n "$fabric_line" ]]; then
                    IFS='|' read -r fabric_name _ _ _ f_healthy f_avail f_total _ _ _ <<< "$fabric_line"
                fi
            fi
            
            # Store for sorting: gid_num|gid|name|state|size|fabric|healthy|avail|total
            echo "${gid_num}|${gid}|${c_name}|${c_state}|${c_size}|${fabric_name}|${f_healthy}|${f_avail}|${f_total}" >> "$cluster_lines_temp"
        fi
    done
    
    # Sort and display
    sort -t'|' -k1 -n "$cluster_lines_temp" | while IFS='|' read -r _ gid c_name c_state c_size fabric_name f_healthy f_avail f_total; do
        # Color state
        local state_color
        case "$c_state" in
            ACTIVE) state_color="${GREEN}" ;;
            CREATING) state_color="${CYAN}" ;;
            UPDATING|SCALING) state_color="${YELLOW}" ;;
            INACTIVE|FAILED|DELETED|DELETING) state_color="${RED}" ;;
            *) state_color="${WHITE}" ;;
        esac
        
        # Color available - highlight if > 0
        local avail_color="${WHITE}"
        [[ "$f_avail" != "N/A" && "$f_avail" != "0" ]] && avail_color="${LIGHT_GREEN}"
        
        printf "${YELLOW}%-6s${NC} ${MAGENTA}%-35s${NC} ${state_color}%-10s${NC} %6s  ${CYAN}%-40s${NC} %8s ${avail_color}%6s${NC} %6s\n" \
            "$gid" "$c_name" "$c_state" "$c_size" "$fabric_name" "$f_healthy" "$f_avail" "$f_total"
    done
    
    rm -f "$cluster_lines_temp"
    
    if [[ "$has_clusters" != "true" ]]; then
        echo -e "  ${YELLOW}No GPU Memory Clusters available${NC}"
        return 1
    fi
    
    echo ""
    
    # ── Multi-select: g1, g1,g2,g3, g1-5, all ──
    echo -e "${WHITE}Select cluster(s) to update:${NC}"
    echo -e "  ${GRAY}Examples: ${WHITE}g1${GRAY}  |  ${WHITE}g1,g3,g5${GRAY}  |  ${WHITE}g1-5${GRAY}  |  ${WHITE}all${NC}"
    echo ""
    echo -n -e "${CYAN}Select GPU Memory Cluster(s): ${NC}"
    local cluster_input
    read -r cluster_input
    
    if [[ -z "$cluster_input" ]]; then
        echo -e "${RED}No cluster selected${NC}"
        return 1
    fi
    
    # ── Parse selection into array of g# IDs ──
    local selected_gids=()
    
    if [[ "${cluster_input,,}" == "all" ]]; then
        # All clusters
        for gid in "${!CLUSTER_INDEX_MAP[@]}"; do
            selected_gids+=("$gid")
        done
    elif [[ "$cluster_input" == *","* ]]; then
        # Comma-separated: g1,g2,g3 or g1, g2, g3
        IFS=',' read -ra parts <<< "$cluster_input"
        for part in "${parts[@]}"; do
            local trimmed="${part// /}"  # trim spaces
            # Ensure g prefix
            [[ "$trimmed" =~ ^[0-9]+$ ]] && trimmed="g${trimmed}"
            selected_gids+=("$trimmed")
        done
    elif [[ "$cluster_input" == *"-"* ]]; then
        # Range: g1-5 or 1-5
        local range_str="${cluster_input#g}"  # remove g prefix if present
        local range_start="${range_str%-*}"
        local range_end="${range_str#*-}"
        
        if [[ "$range_start" =~ ^[0-9]+$ ]] && [[ "$range_end" =~ ^[0-9]+$ ]]; then
            for ((i=range_start; i<=range_end; i++)); do
                selected_gids+=("g${i}")
            done
        else
            echo -e "${RED}Invalid range: $cluster_input${NC}"
            return 1
        fi
    else
        # Single: g1 or 1
        local trimmed="${cluster_input// /}"
        [[ "$trimmed" =~ ^[0-9]+$ ]] && trimmed="g${trimmed}"
        selected_gids+=("$trimmed")
    fi
    
    # ── Validate all selected gids exist ──
    local valid_gids=()
    local invalid_gids=()
    for gid in "${selected_gids[@]}"; do
        if [[ -n "${CLUSTER_INDEX_MAP[$gid]+x}" ]] && [[ -n "${CLUSTER_INDEX_MAP[$gid]}" ]]; then
            valid_gids+=("$gid")
        else
            invalid_gids+=("$gid")
        fi
    done
    
    if [[ ${#invalid_gids[@]} -gt 0 ]]; then
        echo -e "${YELLOW}Warning: Invalid cluster IDs skipped: ${RED}${invalid_gids[*]}${NC}"
    fi
    
    if [[ ${#valid_gids[@]} -eq 0 ]]; then
        echo -e "${RED}No valid clusters selected${NC}"
        return 1
    fi
    
    # Sort valid_gids numerically
    IFS=$'\n' valid_gids=($(for g in "${valid_gids[@]}"; do echo "$g"; done | sort -t'g' -k2 -n))
    unset IFS
    
    echo ""
    echo -e "${GREEN}✓ Selected ${WHITE}${#valid_gids[@]}${GREEN} cluster(s): ${YELLOW}${valid_gids[*]}${NC}"
    echo ""
    
    # ── Update type selection ──
    echo -e "${WHITE}What would you like to update?${NC}"
    echo -e "  ${GREEN}1${NC} - Size"
    echo -e "  ${GREEN}2${NC} - Instance Configuration"
    echo -e "  ${GREEN}3${NC} - Both Size and Instance Configuration"
    echo -e "  ${RED}0${NC} - Cancel"
    echo ""
    echo -n -e "${CYAN}Select option: ${NC}"
    local option
    read -r option
    
    [[ "$option" == "0" ]] && { echo -e "${RED}Update cancelled${NC}"; return 0; }
    [[ ! "$option" =~ ^[1-3]$ ]] && { echo -e "${RED}Invalid option${NC}"; return 1; }
    
    # ── Collect per-cluster details ──
    # For sizes, we need per-cluster input; for IC, one IC applies to all
    
    local new_ic=""
    declare -A cluster_new_sizes  # gid -> new_size
    
    # If size update is requested (option 1 or 3)
    if [[ "$option" == "1" || "$option" == "3" ]]; then
        echo ""
        echo -e "${BOLD}${WHITE}═══ Size Update ═══${NC}"
        echo ""
        
        # Show current sizes for reference
        printf "  ${BOLD}%-6s %-35s %10s  %-40s %6s${NC}\n" \
            "ID" "Cluster Name" "Curr Size" "Fabric" "Avail"
        printf "  ${WHITE}%-6s %-35s %10s  %-40s %6s${NC}\n" \
            "------" "-----------------------------------" "----------" "----------------------------------------" "------"
        
        for gid in "${valid_gids[@]}"; do
            local cluster_ocid="${CLUSTER_INDEX_MAP[$gid]}"
            local c_line
            c_line=$(grep "^${cluster_ocid}|" "$CLUSTER_CACHE" 2>/dev/null | head -1)
            local c_name="" c_size="" c_fabric_suffix=""
            IFS='|' read -r _ c_name _ c_fabric_suffix _ _ c_size <<< "$c_line"
            
            local f_avail="N/A"
            if [[ -n "$c_fabric_suffix" ]]; then
                local f_line
                f_line=$(grep -v '^#' "$FABRIC_CACHE" 2>/dev/null | grep "|${c_fabric_suffix}|" | head -1)
                [[ -n "$f_line" ]] && IFS='|' read -r _ _ _ _ _ f_avail _ <<< "$f_line"
            fi
            
            local fabric_name_short="N/A"
            [[ -n "$f_line" ]] && IFS='|' read -r fabric_name_short _ <<< "$f_line"
            
            printf "  ${YELLOW}%-6s${NC} ${MAGENTA}%-35s${NC} ${CYAN}%10s${NC}  ${GRAY}%-40s${NC} ${YELLOW}%6s${NC}\n" \
                "$gid" "${c_name:0:35}" "$c_size" "${fabric_name_short:0:40}" "$f_avail"
        done
        
        echo ""
        
        if [[ ${#valid_gids[@]} -eq 1 ]]; then
            # Single cluster - simple prompt
            echo -n -e "${CYAN}Enter new size for ${YELLOW}${valid_gids[0]}${CYAN}: ${NC}"
            local sz
            read -r sz
            if ! [[ "$sz" =~ ^[0-9]+$ ]] || [[ "$sz" -lt 1 ]]; then
                echo -e "${RED}Invalid size: must be a positive integer${NC}"
                return 1
            fi
            cluster_new_sizes["${valid_gids[0]}"]="$sz"
        else
            # Multiple clusters - offer same size or per-cluster
            echo -e "${WHITE}Size options:${NC}"
            echo -e "  ${GREEN}a${NC} - Apply ${WHITE}same size${NC} to all selected clusters"
            echo -e "  ${GREEN}p${NC} - Specify size ${WHITE}per cluster${NC} individually"
            echo ""
            echo -n -e "${CYAN}Choose [a/p]: ${NC}"
            local size_mode
            read -r size_mode
            
            if [[ "${size_mode,,}" == "a" ]]; then
                echo -n -e "${CYAN}Enter new size for all ${WHITE}${#valid_gids[@]}${CYAN} clusters: ${NC}"
                local sz
                read -r sz
                if ! [[ "$sz" =~ ^[0-9]+$ ]] || [[ "$sz" -lt 1 ]]; then
                    echo -e "${RED}Invalid size: must be a positive integer${NC}"
                    return 1
                fi
                for gid in "${valid_gids[@]}"; do
                    cluster_new_sizes["$gid"]="$sz"
                done
            else
                # Per-cluster sizing
                for gid in "${valid_gids[@]}"; do
                    local cluster_ocid="${CLUSTER_INDEX_MAP[$gid]}"
                    local c_line
                    c_line=$(grep "^${cluster_ocid}|" "$CLUSTER_CACHE" 2>/dev/null | head -1)
                    local c_name="" c_size=""
                    IFS='|' read -r _ c_name _ _ _ _ c_size <<< "$c_line"
                    
                    echo -n -e "${CYAN}New size for ${YELLOW}${gid}${CYAN} (${MAGENTA}${c_name}${CYAN}, current=${WHITE}${c_size}${CYAN}): ${NC}"
                    local sz
                    read -r sz
                    if ! [[ "$sz" =~ ^[0-9]+$ ]] || [[ "$sz" -lt 1 ]]; then
                        echo -e "${RED}Invalid size '${sz}' for ${gid} - must be a positive integer. Aborting.${NC}"
                        return 1
                    fi
                    cluster_new_sizes["$gid"]="$sz"
                done
            fi
        fi
    fi
    
    # If instance config update is requested (option 2 or 3)
    if [[ "$option" == "2" || "$option" == "3" ]]; then
        echo ""
        echo -e "${BOLD}${WHITE}═══ Instance Configuration Update ═══${NC}"
        echo ""
        echo -e "${WHITE}Available Instance Configurations:${NC}"
        echo ""
        printf "${BOLD}%-6s %-60s %-90s${NC}\n" \
            "ID" "Instance Configuration Name" "Instance Configuration OCID"
        print_separator 160
        
        local ic_output_temp
        ic_output_temp=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
        
        local iid
        for iid in "${!IC_INDEX_MAP[@]}"; do
            local ic_ocid="${IC_INDEX_MAP[$iid]}"
            [[ -z "$ic_ocid" ]] && continue
            
            local ic_line ic_name
            ic_line=$(grep "^${ic_ocid}|" "$INSTANCE_CONFIG_CACHE" 2>/dev/null | head -1)
            if [[ -n "$ic_line" ]]; then
                IFS='|' read -r _ ic_name <<< "$ic_line"
            else
                ic_name="N/A"
            fi
            
            local iid_num="${iid#i}"
            echo "${iid_num}|${iid}|${ic_name}|${ic_ocid}" >> "$ic_output_temp"
        done
        
        sort -t'|' -k1 -n "$ic_output_temp" | while IFS='|' read -r _ iid ic_name ic_ocid; do
            printf "${YELLOW}%-6s${NC} ${CYAN}%-60s${NC} ${GRAY}%-90s${NC}\n" \
                "$iid" "$ic_name" "$ic_ocid"
        done
        
        rm -f "$ic_output_temp"
        echo ""
        
        echo -n -e "${CYAN}Select Instance Configuration for all clusters (i#): ${NC}"
        local ic_input
        read -r ic_input
        new_ic="${IC_INDEX_MAP[$ic_input]:-}"
        if [[ -z "$new_ic" ]]; then
            echo -e "${RED}Invalid instance configuration selection: $ic_input${NC}"
            return 1
        fi
    fi
    
    # ── Confirmation Summary ──
    echo ""
    echo -e "${BOLD}${WHITE}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${WHITE}                     CONFIRM UPDATE                            ${NC}"
    echo -e "${BOLD}${WHITE}═══════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    local new_ic_name=""
    [[ -n "$new_ic" ]] && new_ic_name=$(get_instance_config_name "$new_ic")
    
    for gid in "${valid_gids[@]}"; do
        local cluster_ocid="${CLUSTER_INDEX_MAP[$gid]}"
        local c_line
        c_line=$(grep "^${cluster_ocid}|" "$CLUSTER_CACHE" 2>/dev/null | head -1)
        local c_name="" c_state="" c_size="" c_ic=""
        IFS='|' read -r _ c_name c_state _ _ _ c_size <<< "$c_line"
        
        # Get current IC
        local cur_ic_ocid=""
        cur_ic_ocid=$(oci compute compute-gpu-memory-cluster get \
            --compute-gpu-memory-cluster-id "$cluster_ocid" \
            --query 'data."instance-configuration-id"' --raw-output 2>/dev/null)
        local cur_ic_name=""
        [[ -n "$cur_ic_ocid" ]] && cur_ic_name=$(get_instance_config_name "$cur_ic_ocid")
        
        echo -e "  ${YELLOW}${gid}${NC} ${MAGENTA}${c_name}${NC}  ${GRAY}(${cluster_ocid})${NC}"
        
        if [[ -n "${cluster_new_sizes[$gid]:-}" ]]; then
            echo -e "      ${CYAN}Size:${NC}     ${WHITE}${c_size}${NC} → ${GREEN}${cluster_new_sizes[$gid]}${NC}"
        fi
        if [[ -n "$new_ic" ]]; then
            echo -e "      ${CYAN}IC:${NC}       ${WHITE}${cur_ic_name:-N/A}${NC} → ${GREEN}${new_ic_name}${NC}"
        fi
        echo ""
    done
    
    # Display commands that will be executed
    echo -e "${BOLD}${WHITE}Commands to execute:${NC}"
    echo ""
    for gid in "${valid_gids[@]}"; do
        local cluster_ocid="${CLUSTER_INDEX_MAP[$gid]}"
        local cmd_str="oci compute compute-gpu-memory-cluster update --compute-gpu-memory-cluster-id \"${cluster_ocid}\""
        [[ -n "${cluster_new_sizes[$gid]:-}" ]] && cmd_str+=" --size ${cluster_new_sizes[$gid]}"
        [[ -n "$new_ic" ]] && cmd_str+=" --instance-configuration-id \"${new_ic}\""
        echo -e "  ${GRAY}[${gid}] ${cmd_str}${NC}"
    done
    
    echo ""
    echo -n -e "${YELLOW}Proceed with update of ${WHITE}${#valid_gids[@]}${YELLOW} cluster(s)? (yes/no): ${NC}"
    local confirm
    read -r confirm
    
    if [[ "$confirm" != "yes" ]]; then
        echo -e "${RED}Update cancelled${NC}"
        return 0
    fi
    
    # ── Execute updates ──
    echo ""
    echo -e "${GREEN}Executing updates...${NC}"
    echo ""
    
    local success_count=0
    local fail_count=0
    local log_file="${LOG_DIR}/gpu_cluster_actions.log"
    mkdir -p "$LOG_DIR"
    
    for gid in "${valid_gids[@]}"; do
        local cluster_ocid="${CLUSTER_INDEX_MAP[$gid]}"
        local c_line
        c_line=$(grep "^${cluster_ocid}|" "$CLUSTER_CACHE" 2>/dev/null | head -1)
        local c_name=""
        IFS='|' read -r _ c_name _ <<< "$c_line"
        
        # Build command args
        local cmd_args="--compute-gpu-memory-cluster-id $cluster_ocid"
        local cmd_display="oci compute compute-gpu-memory-cluster update --compute-gpu-memory-cluster-id \"${cluster_ocid}\""
        
        [[ -n "${cluster_new_sizes[$gid]:-}" ]] && { cmd_args+=" --size ${cluster_new_sizes[$gid]}"; cmd_display+=" --size ${cluster_new_sizes[$gid]}"; }
        [[ -n "$new_ic" ]] && { cmd_args+=" --instance-configuration-id $new_ic"; cmd_display+=" --instance-configuration-id \"${new_ic}\""; }
        
        echo -e "  ${YELLOW}${gid}${NC} ${MAGENTA}${c_name}${NC} ..."
        
        # Log the command
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: ${cmd_display}" >> "$log_file"
        
        local result
        result=$(oci compute compute-gpu-memory-cluster update $cmd_args --output json 2>&1)
        local exit_code=$?
        
        if [[ $exit_code -eq 0 ]]; then
            local updated_state updated_size
            updated_state=$(echo "$result" | jq -r 'if .data then .data["lifecycle-state"] else .["lifecycle-state"] end // "N/A"' 2>/dev/null)
            updated_size=$(echo "$result" | jq -r 'if .data then .data["size"] else .["size"] end // "N/A"' 2>/dev/null)
            
            [[ -z "$updated_state" || "$updated_state" == "null" ]] && updated_state="N/A"
            [[ -z "$updated_size" || "$updated_size" == "null" ]] && updated_size="N/A"
            
            local state_color="${WHITE}"
            case "$updated_state" in
                ACTIVE) state_color="${GREEN}" ;;
                UPDATING|SCALING) state_color="${YELLOW}" ;;
                FAILED|INACTIVE) state_color="${RED}" ;;
                CREATING) state_color="${CYAN}" ;;
            esac
            
            echo -e "    ${GREEN}✓${NC} State: ${state_color}${updated_state}${NC}  Size: ${CYAN}${updated_size}${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: ${gid} ${c_name} -> state=${updated_state} size=${updated_size}" >> "$log_file"
            ((success_count++))
        else
            echo -e "    ${RED}✗ Failed${NC}"
            echo "$result" | head -3 | sed 's/^/      /'
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: ${gid} ${c_name} -> ${result}" >> "$log_file"
            ((fail_count++))
        fi
    done
    
    echo ""
    echo -e "${WHITE}Results: ${GREEN}${success_count} succeeded${NC}, ${RED}${fail_count} failed${NC}"
    echo -e "  ${GRAY}Logged to: ${log_file}${NC}"
    
    # Invalidate caches
    rm -f "$CLUSTER_CACHE" "$FABRIC_CACHE" "$INSTANCE_CLUSTER_MAP_CACHE"
}

#--------------------------------------------------------------------------------
# Update ALL GPU Memory Clusters with a selected Instance Configuration
#--------------------------------------------------------------------------------
update_all_clusters_instance_config() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    
    echo ""
    echo -e "${BOLD}${BLUE}═══ Update All GPU Memory Clusters - Instance Configuration ═══${NC}"
    echo ""
    
    # Refresh caches to get latest data
    echo -e "${YELLOW}Refreshing data from OCI...${NC}"
    rm -f "$FABRIC_CACHE" "$CLUSTER_CACHE" "$INSTANCE_CLUSTER_MAP_CACHE" "$INSTANCE_CONFIG_CACHE" "$COMPUTE_CLUSTER_CACHE"
    fetch_gpu_fabrics
    fetch_gpu_clusters
    fetch_instance_configurations
    fetch_compute_clusters
    
    # Rebuild index maps
    display_gpu_management_menu > /dev/null 2>&1
    
    echo -e "${GREEN}✓ Data refreshed${NC}"
    echo ""
    
    # Check if any instance configurations exist
    if [[ ${#IC_INDEX_MAP[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No Instance Configurations available${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return 0
    fi
    
    # Check if any clusters exist
    if [[ ${#CLUSTER_INDEX_MAP[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No GPU Memory Clusters available to update${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return 0
    fi
    
    # Display Instance Configurations
    echo -e "${WHITE}Available Instance Configurations:${NC}"
    echo ""
    printf "${BOLD}%-6s %-60s %-90s${NC}\n" \
        "ID" "Instance Configuration Name" "OCID"
    print_separator 160
    
    # Sort and display instance configs
    local ic_output_temp
    ic_output_temp=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    
    local iid
    for iid in "${!IC_INDEX_MAP[@]}"; do
        local ic_ocid="${IC_INDEX_MAP[$iid]}"
        [[ -z "$ic_ocid" ]] && continue
        
        local ic_line ic_name
        ic_line=$(grep "^${ic_ocid}|" "$INSTANCE_CONFIG_CACHE" 2>/dev/null | head -1)
        if [[ -n "$ic_line" ]]; then
            IFS='|' read -r _ ic_name <<< "$ic_line"
        else
            ic_name="N/A"
        fi
        
        local iid_num="${iid#i}"
        echo "${iid_num}|${iid}|${ic_name}|${ic_ocid}" >> "$ic_output_temp"
    done
    
    sort -t'|' -k1 -n "$ic_output_temp" | while IFS='|' read -r _ iid ic_name ic_ocid; do
        printf "${YELLOW}%-6s${NC} ${GREEN}%-60s${NC} ${GRAY}%-90s${NC}\n" \
            "$iid" "$ic_name" "$ic_ocid"
    done
    
    rm -f "$ic_output_temp"
    echo ""
    
    # Select Instance Configuration
    echo -n -e "${CYAN}Select Instance Configuration to apply to ALL clusters (i#) or 'cancel': ${NC}"
    local ic_input
    read -r ic_input
    
    # Check for cancel
    if [[ "$ic_input" == "cancel" || "$ic_input" == "c" || -z "$ic_input" ]]; then
        echo -e "${YELLOW}Update cancelled${NC}"
        return 0
    fi
    
    local selected_ic_ocid="${IC_INDEX_MAP[$ic_input]:-}"
    if [[ -z "$selected_ic_ocid" ]]; then
        echo -e "${RED}Invalid instance configuration selection: $ic_input${NC}"
        return 1
    fi
    
    # Get selected IC name
    local selected_ic_name
    selected_ic_name=$(get_instance_config_name "$selected_ic_ocid")
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ GPU Memory Clusters to Update ═══${NC}"
    echo ""
    
    # Collect clusters to update (only ACTIVE, UPDATING, SCALING states that don't already have the selected IC)
    local clusters_to_update=()
    local cluster_names=()
    local cluster_current_ics=()
    local skipped_count=0
    
    for gid in "${!CLUSTER_INDEX_MAP[@]}"; do
        local cluster_ocid="${CLUSTER_INDEX_MAP[$gid]}"
        [[ -z "$cluster_ocid" ]] && continue
        
        # Get cluster info from cache
        local cluster_line
        cluster_line=$(grep "^${cluster_ocid}|" "$CLUSTER_CACHE" 2>/dev/null | head -1)
        
        if [[ -n "$cluster_line" ]]; then
            local c_name c_state c_fabric_suffix c_ic_id c_size
            IFS='|' read -r _ c_name c_state c_fabric_suffix c_ic_id _ c_size <<< "$cluster_line"
            
            # Only include active-ish clusters
            if [[ "$c_state" == "ACTIVE" || "$c_state" == "UPDATING" || "$c_state" == "SCALING" ]]; then
                # Skip if already has the selected instance configuration
                if [[ "$c_ic_id" == "$selected_ic_ocid" ]]; then
                    ((skipped_count++))
                    continue
                fi
                
                clusters_to_update+=("$cluster_ocid")
                cluster_names+=("$c_name")
                
                # Get current IC name
                local current_ic_name="N/A"
                if [[ -n "$c_ic_id" && "$c_ic_id" != "N/A" ]]; then
                    current_ic_name=$(get_instance_config_name "$c_ic_id")
                fi
                cluster_current_ics+=("$current_ic_name")
            fi
        fi
    done
    
    # Show skipped count if any
    if [[ $skipped_count -gt 0 ]]; then
        echo -e "${GREEN}Skipped ${skipped_count} cluster(s) already using ${selected_ic_name}${NC}"
        echo ""
    fi
    
    if [[ ${#clusters_to_update[@]} -eq 0 ]]; then
        echo -e "${GREEN}All active GPU Memory Clusters already have the selected Instance Configuration${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return 0
    fi
    
    # Display clusters that will be updated
    printf "${BOLD}%-40s %-50s${NC}\n" "Cluster Name" "Current Instance Config"
    print_separator 95
    
    for i in "${!clusters_to_update[@]}"; do
        printf "%-40s ${GRAY}%-50s${NC}\n" "${cluster_names[$i]}" "${cluster_current_ics[$i]}"
    done
    
    echo ""
    echo -e "${WHITE}Total clusters to update:${NC} ${CYAN}${#clusters_to_update[@]}${NC}"
    echo -e "${WHITE}New Instance Configuration:${NC} ${GREEN}$selected_ic_name${NC}"
    echo ""
    
    # Show commands that will be executed
    echo -e "${BOLD}${WHITE}Commands to execute:${NC}"
    echo ""
    for i in "${!clusters_to_update[@]}"; do
        local cluster_ocid="${clusters_to_update[$i]}"
        echo -e "${GRAY}oci compute compute-gpu-memory-cluster update \\
    --compute-gpu-memory-cluster-id \"$cluster_ocid\" \\
    --instance-configuration-id \"$selected_ic_ocid\"${NC}"
        echo ""
    done
    
    # Confirm
    echo -e "${YELLOW}╔════════════════════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${YELLOW}║                    ⚠️  BULK UPDATE CONFIRMATION  ⚠️                              ║${NC}"
    echo -e "${YELLOW}╚════════════════════════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "${WHITE}This will update ${CYAN}${#clusters_to_update[@]}${NC}${WHITE} GPU Memory Cluster(s) to use:${NC}"
    echo -e "  ${GREEN}$selected_ic_name${NC}"
    echo -e "  ${GRAY}$selected_ic_ocid${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Type 'UPDATE ALL' to confirm: ${NC}"
    local confirm
    read -r confirm
    
    if [[ "$confirm" != "UPDATE ALL" ]]; then
        echo -e "${YELLOW}Update cancelled${NC}"
        return 0
    fi
    
    echo ""
    echo -e "${GREEN}Starting bulk update...${NC}"
    echo ""
    
    # Update each cluster
    local success_count=0
    local fail_count=0
    
    for i in "${!clusters_to_update[@]}"; do
        local cluster_ocid="${clusters_to_update[$i]}"
        local cluster_name="${cluster_names[$i]}"
        
        echo -n -e "  Updating ${CYAN}$cluster_name${NC}... "
        
        local result
        result=$(oci compute compute-gpu-memory-cluster update \
            --compute-gpu-memory-cluster-id "$cluster_ocid" \
            --instance-configuration-id "$selected_ic_ocid" \
            --output json 2>&1)
        local exit_code=$?
        
        if [[ $exit_code -eq 0 ]]; then
            echo -e "${GREEN}✓${NC}"
            ((success_count++))
        else
            echo -e "${RED}✗${NC}"
            echo -e "    ${RED}Error: $(echo "$result" | head -1)${NC}"
            ((fail_count++))
        fi
    done
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Update Summary ═══${NC}"
    echo -e "  ${GREEN}Successful:${NC} $success_count"
    echo -e "  ${RED}Failed:${NC}     $fail_count"
    echo ""
    
    # Invalidate caches
    rm -f "$CLUSTER_CACHE" "$FABRIC_CACHE" "$INSTANCE_CLUSTER_MAP_CACHE"
    
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Delete a single Instance Configuration by OCID (called from view details)
#--------------------------------------------------------------------------------
delete_single_instance_configuration() {
    local ic_ocid="$1"
    local ic_name="$2"
    
    echo ""
    echo -e "${RED}╔════════════════════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${RED}║                    ⚠️  WARNING: DELETE INSTANCE CONFIGURATION  ⚠️               ║${NC}"
    echo -e "${RED}╚════════════════════════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "${WHITE}Instance Configuration:${NC} ${GREEN}$ic_name${NC}"
    echo -e "${WHITE}OCID:${NC}                   ${YELLOW}$ic_ocid${NC}"
    echo ""
    
    # Check if in use
    local clusters_using_ic=""
    if [[ -f "$CLUSTER_CACHE" ]]; then
        while IFS='|' read -r cluster_ocid cluster_name cluster_state _ cluster_ic_id _; do
            [[ "$cluster_ocid" =~ ^#.*$ ]] && continue
            [[ -z "$cluster_ocid" ]] && continue
            [[ "$cluster_state" == "DELETED" ]] && continue
            
            if [[ "$cluster_ic_id" == "$ic_ocid" ]]; then
                clusters_using_ic="${clusters_using_ic}${cluster_name} (${cluster_state})\n"
            fi
        done < "$CLUSTER_CACHE"
    fi
    
    if [[ -n "$clusters_using_ic" ]]; then
        echo -e "${RED}⚠️  WARNING: This instance configuration is used by:${NC}"
        echo -e "${YELLOW}$(echo -e "$clusters_using_ic")${NC}"
        echo ""
    fi
    
    echo -e "${RED}This action cannot be undone!${NC}"
    echo ""
    
    echo -n -e "${RED}Type 'DELETE' to confirm: ${NC}"
    local confirm
    read -r confirm
    
    if [[ "$confirm" != "DELETE" ]]; then
        echo -e "${YELLOW}Delete cancelled${NC}"
        return 0
    fi
    
    echo ""
    echo -e "${YELLOW}Deleting Instance Configuration...${NC}"
    
    local result
    result=$(oci compute-management instance-configuration delete \
        --instance-configuration-id "$ic_ocid" \
        --force 2>&1)
    local exit_code=$?
    
    if [[ $exit_code -eq 0 ]]; then
        echo -e "${GREEN}✓ Instance Configuration deleted successfully${NC}"
        rm -f "$INSTANCE_CONFIG_CACHE"
    else
        echo -e "${RED}✗ Failed to delete:${NC}"
        echo "$result"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Manage Compute Clusters - Main menu for compute cluster operations
#--------------------------------------------------------------------------------
manage_compute_clusters() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    while true; do
        echo ""
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${CYAN}                                         COMPUTE CLUSTER MANAGEMENT                                              ${NC}"
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        _display_cache_info \
            "${COMPUTE_CLUSTER_CACHE}|Compute Clusters"
        echo ""
        
        echo -e "${BOLD}${WHITE}Environment:${NC}"
        echo -e "  ${CYAN}Region:${NC}      ${WHITE}${region}${NC}"
        echo -e "  ${CYAN}Compartment:${NC} ${WHITE}$(resolve_compartment_name "${compartment_id}")${NC} ${GRAY}(${compartment_id})${NC}"
        echo ""
        
        # ========== Show Existing Compute Clusters ==========
        echo -e "${BOLD}${MAGENTA}─── Existing Compute Clusters ───${NC}"
        echo ""
        
        # Refresh compute cluster cache
        fetch_compute_clusters "$compartment_id" "$region"
        
        # Build array for selection
        declare -a CC_LIST=()
        local cc_count=0
        
        if [[ -f "$COMPUTE_CLUSTER_CACHE" ]] && [[ -s "$COMPUTE_CLUSTER_CACHE" ]]; then
            printf "  ${GRAY}%-4s %-45s %-35s %-12s${NC}\n" "#" "Display Name" "Availability Domain" "Status"
            echo -e "  ${GRAY}──────────────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
            while IFS='|' read -r cc_ocid cc_name cc_ad cc_state; do
                [[ -z "$cc_ocid" || "$cc_ocid" == "#"* ]] && continue
                
                # Default state if not present (old cache format)
                [[ -z "$cc_state" ]] && cc_state="UNKNOWN"
                
                # Skip deleted clusters
                [[ "$cc_state" == "DELETED" ]] && continue
                ((cc_count++))
                CC_LIST+=("$cc_ocid|$cc_name|$cc_ad|$cc_state")
                
                # Color-code the status
                local state_color="$GREEN"
                case "$cc_state" in
                    ACTIVE) state_color="$GREEN" ;;
                    CREATING|UPDATING) state_color="$YELLOW" ;;
                    DELETING) state_color="$RED" ;;
                    *) state_color="$GRAY" ;;
                esac
                
                printf "  ${YELLOW}%-4s${NC} ${WHITE}%-45s${NC} ${CYAN}%-35s${NC} ${state_color}%-12s${NC}\n" "$cc_count)" "$cc_name" "$cc_ad" "$cc_state"
            done < <(grep -v '^#' "$COMPUTE_CLUSTER_CACHE" 2>/dev/null)
            
            if [[ $cc_count -eq 0 ]]; then
                echo -e "  ${GRAY}(No existing compute clusters found)${NC}"
            else
                echo ""
                echo -e "  ${WHITE}Total: ${GREEN}${cc_count}${WHITE} compute cluster(s)${NC}"
            fi
        else
            echo -e "  ${GRAY}(No existing compute clusters found)${NC}"
        fi
        echo ""
        
        # ========== Menu Options ==========
        echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
        echo ""
        echo -e "  ${GREEN}c${NC}) ${WHITE}Create${NC}  - Create a new compute cluster"
        if [[ $cc_count -gt 0 ]]; then
            echo -e "  ${RED}d${NC}) ${WHITE}Delete${NC}  - Delete an existing compute cluster"
            echo -e "  ${CYAN}v${NC}) ${WHITE}View${NC}    - View compute cluster details (enter number)"
        fi
        echo -e "  ${MAGENTA}r${NC}) ${WHITE}Refresh${NC} - Refresh compute cluster list"
        echo -e "  ${CYAN}b${NC}) ${WHITE}Back${NC}    - Return to main menu"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Compute Clusters] Enter selection [c/d/v/r/b] or cluster number: ${NC}"
        
        local choice
        read -r choice
        
        case "$choice" in
            c|C|create|CREATE)
                create_compute_cluster_interactive
                ;;
            d|D|delete|DELETE)
                if [[ $cc_count -eq 0 ]]; then
                    echo -e "${YELLOW}No compute clusters available to delete${NC}"
                    sleep 1
                else
                    delete_compute_cluster_interactive
                fi
                ;;
            v|V|view|VIEW)
                if [[ $cc_count -gt 0 ]]; then
                    echo -n -e "${CYAN}Enter cluster number to view [1-${cc_count}]: ${NC}"
                    local view_num
                    read -r view_num
                    if [[ "$view_num" =~ ^[0-9]+$ ]] && [[ $view_num -ge 1 ]] && [[ $view_num -le $cc_count ]]; then
                        local selected="${CC_LIST[$((view_num-1))]}"
                        local sel_ocid sel_name sel_ad sel_state
                        IFS='|' read -r sel_ocid sel_name sel_ad sel_state <<< "$selected"
                        view_compute_cluster_details "$sel_ocid" "$sel_name"
                    else
                        echo -e "${RED}Invalid selection${NC}"
                        sleep 1
                    fi
                else
                    echo -e "${YELLOW}No compute clusters available to view${NC}"
                    sleep 1
                fi
                ;;
            r|R|refresh|REFRESH)
                rm -f "$COMPUTE_CLUSTER_CACHE"
                echo -e "${GREEN}Cache cleared, refreshing...${NC}"
                sleep 1
                ;;
            b|B|back|BACK|"")
                return
                ;;
            [0-9]*)
                # Direct number selection for viewing
                if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le $cc_count ]]; then
                    local selected="${CC_LIST[$((choice-1))]}"
                    local sel_ocid sel_name sel_ad sel_state
                    IFS='|' read -r sel_ocid sel_name sel_ad sel_state <<< "$selected"
                    view_compute_cluster_details "$sel_ocid" "$sel_name"
                else
                    echo -e "${RED}Invalid selection${NC}"
                    sleep 1
                fi
                ;;
            *)
                echo -e "${RED}Invalid selection${NC}"
                sleep 1
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# View Compute Cluster details
#--------------------------------------------------------------------------------
view_compute_cluster_details() {
    local cc_ocid="$1"
    local cc_name="$2"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Compute Cluster Details ═══${NC}"
    echo ""
    echo -e "${YELLOW}Fetching details for: ${WHITE}${cc_name}${NC}"
    echo ""
    
    local cc_json
    cc_json=$(oci compute compute-cluster get --compute-cluster-id "$cc_ocid" 2>/dev/null)
    
    if [[ -z "$cc_json" ]]; then
        echo -e "${RED}Failed to fetch compute cluster details${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo "$cc_json" | jq -r '
        .data | 
        "  Display Name:        \(.["display-name"] // "N/A")",
        "  OCID:                \(.id)",
        "  Availability Domain: \(.["availability-domain"] // "N/A")",
        "  Lifecycle State:     \(.["lifecycle-state"] // "N/A")",
        "  Time Created:        \(.["time-created"] // "N/A")"
    '
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Delete Compute Cluster interactively
#--------------------------------------------------------------------------------
delete_compute_cluster_interactive() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    echo ""
    echo -e "${BOLD}${RED}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${RED}                                       DELETE COMPUTE CLUSTER                                                     ${NC}"
    echo -e "${BOLD}${RED}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Fetch and display compute clusters
    fetch_compute_clusters "$compartment_id" "$region"
    
    declare -a CC_LIST=()
    local cc_count=0
    
    if [[ -f "$COMPUTE_CLUSTER_CACHE" ]] && [[ -s "$COMPUTE_CLUSTER_CACHE" ]]; then
        printf "  ${GRAY}%-4s %-45s %-35s %-12s${NC}\n" "#" "Display Name" "Availability Domain" "Status"
        echo -e "  ${GRAY}──────────────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
        while IFS='|' read -r cc_ocid cc_name cc_ad cc_state; do
            [[ -z "$cc_ocid" || "$cc_ocid" == "#"* ]] && continue
            
            # Default state if not present (old cache format)
            [[ -z "$cc_state" ]] && cc_state="UNKNOWN"
            
            # Skip deleted clusters
            [[ "$cc_state" == "DELETED" ]] && continue
            ((cc_count++))
            CC_LIST+=("$cc_ocid|$cc_name|$cc_ad|$cc_state")
            
            # Color-code the status
            local state_color="$GREEN"
            case "$cc_state" in
                ACTIVE) state_color="$GREEN" ;;
                CREATING|UPDATING) state_color="$YELLOW" ;;
                DELETING) state_color="$RED" ;;
                *) state_color="$GRAY" ;;
            esac
            
            printf "  ${YELLOW}%-4s${NC} ${WHITE}%-45s${NC} ${CYAN}%-35s${NC} ${state_color}%-12s${NC}\n" "$cc_count)" "$cc_name" "$cc_ad" "$cc_state"
        done < <(grep -v '^#' "$COMPUTE_CLUSTER_CACHE" 2>/dev/null)
    fi
    
    if [[ $cc_count -eq 0 ]]; then
        echo -e "  ${GRAY}(No compute clusters found to delete)${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Enter cluster number to delete [1-${cc_count}] or 'b' to go back: ${NC}"
    local del_choice
    read -r del_choice
    
    if [[ "$del_choice" == "b" || "$del_choice" == "B" || -z "$del_choice" ]]; then
        return
    fi
    
    if ! [[ "$del_choice" =~ ^[0-9]+$ ]] || [[ $del_choice -lt 1 ]] || [[ $del_choice -gt $cc_count ]]; then
        echo -e "${RED}Invalid selection${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    local selected="${CC_LIST[$((del_choice-1))]}"
    local sel_ocid sel_name sel_ad sel_state
    IFS='|' read -r sel_ocid sel_name sel_ad sel_state <<< "$selected"
    
    echo ""
    echo -e "${BOLD}${WHITE}Selected Compute Cluster:${NC}"
    echo -e "  ${CYAN}Display Name:${NC}        ${WHITE}${sel_name}${NC}"
    echo -e "  ${CYAN}OCID:${NC}                ${YELLOW}${sel_ocid}${NC}"
    echo -e "  ${CYAN}Availability Domain:${NC} ${WHITE}${sel_ad}${NC}"
    echo -e "  ${CYAN}Status:${NC}              ${WHITE}${sel_state}${NC}"
    echo ""
    
    # Use global DEBUG_MODE
    local debug_flag=""
    if [[ "$DEBUG_MODE" == "true" ]]; then
        debug_flag="--debug"
    fi
    
    # ========== Show Command ==========
    echo -e "${BOLD}${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${YELLOW}                                          COMMAND TO EXECUTE                                                     ${NC}"
    echo -e "${BOLD}${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    local cmd="oci compute compute-cluster delete \\
    --compute-cluster-id \"${sel_ocid}\" \\
    --force"
    
    [[ -n "$debug_flag" ]] && cmd="${cmd} \\
    ${debug_flag}"
    
    echo -e "${WHITE}${cmd}${NC}"
    echo ""
    
    # Log file for the action
    local log_file="${LOGS_DIR}/compute_cluster_delete_$(date +%Y%m%d_%H%M%S).log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    
    echo -e "${BOLD}${RED}═══ CONFIRM DELETION ═══${NC}"
    echo ""
    echo -e "${RED}WARNING: This action cannot be undone!${NC}"
    echo -e "${WHITE}Log file: ${CYAN}${log_file}${NC}"
    echo ""
    echo -n -e "${CYAN}Type 'DELETE' to confirm, or anything else to cancel: ${NC}"
    local confirm
    read -r confirm
    
    if [[ "$confirm" != "DELETE" ]]; then
        echo -e "${YELLOW}Cancelled.${NC}"
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # ========== Execute the Command ==========
    echo ""
    echo -e "${YELLOW}Deleting Compute Cluster...${NC}"
    
    # Log the command
    {
        echo "=========================================="
        echo "Compute Cluster Deletion"
        echo "Timestamp: $(date)"
        echo "=========================================="
        echo ""
        echo "Display Name:        ${sel_name}"
        echo "OCID:                ${sel_ocid}"
        echo "Availability Domain: ${sel_ad}"
        echo "Debug Mode:          ${debug_flag:-disabled}"
        echo ""
        echo "Command:"
        echo "oci compute compute-cluster delete \\"
        echo "    --compute-cluster-id \"${sel_ocid}\" \\"
        echo "    --force ${debug_flag}"
        echo ""
        echo "=========================================="
        echo "Execution Output:"
        echo "=========================================="
    } > "$log_file"
    
    local result
    if [[ -n "$debug_flag" ]]; then
        result=$(oci compute compute-cluster delete \
            --compute-cluster-id "${sel_ocid}" \
            --force \
            --debug 2>&1)
    else
        result=$(oci compute compute-cluster delete \
            --compute-cluster-id "${sel_ocid}" \
            --force 2>&1)
    fi
    local exit_code=$?
    
    # Log the result
    echo "$result" >> "$log_file"
    
    if [[ $exit_code -eq 0 ]]; then
        echo ""
        echo -e "${GREEN}╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${GREEN}║                                        COMPUTE CLUSTER DELETED                                                   ║${NC}"
        echo -e "${GREEN}╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "  ${CYAN}Display Name:${NC} ${WHITE}${sel_name}${NC}"
        echo -e "  ${CYAN}OCID:${NC}         ${YELLOW}${sel_ocid}${NC}"
        echo ""
        echo -e "  ${WHITE}Log file: ${CYAN}${log_file}${NC}"
        echo ""
        
        # Invalidate compute cluster cache
        rm -f "$COMPUTE_CLUSTER_CACHE"
        echo -e "${GRAY}(Compute cluster cache cleared)${NC}"
        
        # Log success
        {
            echo ""
            echo "=========================================="
            echo "Result: SUCCESS"
            echo "=========================================="
        } >> "$log_file"
    else
        echo ""
        echo -e "${RED}╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${RED}║                                      COMPUTE CLUSTER DELETION FAILED                                            ║${NC}"
        echo -e "${RED}╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "${RED}Error:${NC}"
        echo "$result"
        echo ""
        echo -e "  ${WHITE}Log file: ${CYAN}${log_file}${NC}"
        
        # Log failure
        {
            echo ""
            echo "=========================================="
            echo "Result: FAILED"
            echo "Exit Code: ${exit_code}"
            echo "=========================================="
        } >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Create Compute Cluster interactively
#--------------------------------------------------------------------------------
create_compute_cluster_interactive() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    local selected_ad="${AD:-}"
    local shape_name="${SHAPE_NAME:-GPU}"
    
    echo ""
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${GREEN}                                       CREATE COMPUTE CLUSTER                                                    ${NC}"
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Validate required variables
    local missing_vars=""
    [[ -z "$compartment_id" ]] && missing_vars+="COMPARTMENT_ID "
    [[ -z "$selected_ad" ]] && missing_vars+="AD "
    
    if [[ -n "$missing_vars" ]]; then
        echo -e "${RED}Missing required variables in variables.sh:${NC}"
        echo -e "${YELLOW}  $missing_vars${NC}"
        echo ""
        echo -e "${WHITE}Please run ${CYAN}--setup${WHITE} or manually configure variables.sh${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return 1
    fi
    
    echo -e "${BOLD}${WHITE}Current Environment:${NC}"
    echo -e "  ${CYAN}Region:${NC}              ${WHITE}${region}${NC}"
    echo -e "  ${CYAN}Compartment:${NC}         ${WHITE}$(resolve_compartment_name "${compartment_id}")${NC} ${GRAY}(${compartment_id})${NC}"
    echo -e "  ${CYAN}Availability Domain:${NC} ${WHITE}${selected_ad}${NC}"
    echo -e "  ${CYAN}Shape:${NC}               ${WHITE}${shape_name}${NC}"
    [[ "$DEBUG_MODE" == "true" ]] && echo -e "  ${CYAN}Debug Mode:${NC}          ${YELLOW}ENABLED${NC}"
    echo ""
    
    # ========== Enter Display Name ==========
    echo -e "${BOLD}${MAGENTA}─── Compute Cluster Display Name ───${NC}"
    echo ""
    
    # Default name based on shape from variables.sh
    local default_name="${shape_name}-Compute-Cluster"
    echo -e "${WHITE}Common naming patterns:${NC}"
    echo -e "  ${GRAY}- <shape>-Compute-Cluster (e.g., BM.GPU.H100.8-Compute-Cluster)${NC}"
    echo -e "  ${GRAY}- <project>-cc-<ad> (e.g., ml-training-cc-ad1)${NC}"
    echo ""
    
    echo -n -e "${CYAN}Enter display name [${default_name}]: ${NC}"
    local display_name
    read -r display_name
    
    [[ -z "$display_name" ]] && display_name="$default_name"
    
    echo -e "${GREEN}✓ Display Name: ${WHITE}${display_name}${NC}"
    echo ""
    
    # Use global DEBUG_MODE (set via --debug command line flag)
    local debug_flag=""
    if [[ "$DEBUG_MODE" == "true" ]]; then
        debug_flag="--debug"
    fi
    
    # ========== Show Command and Confirm ==========
    echo -e "${BOLD}${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${YELLOW}                                          COMMAND TO EXECUTE                                                     ${NC}"
    echo -e "${BOLD}${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    local cmd="oci compute compute-cluster create \\
    --availability-domain \"${selected_ad}\" \\
    --compartment-id \"${compartment_id}\" \\
    --display-name \"${display_name}\""
    
    [[ -n "$debug_flag" ]] && cmd="${cmd} \\
    ${debug_flag}"
    
    echo -e "${WHITE}${cmd}${NC}"
    echo ""
    
    # Log file for the action
    local log_file="${LOGS_DIR}/compute_cluster_create_$(date +%Y%m%d_%H%M%S).log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    
    echo -e "${BOLD}${RED}═══ CONFIRM CREATION ═══${NC}"
    echo ""
    echo -e "${YELLOW}This will create a new Compute Cluster.${NC}"
    echo -e "${WHITE}Log file: ${CYAN}${log_file}${NC}"
    echo ""
    echo -n -e "${CYAN}Type 'CREATE' to confirm, or anything else to cancel: ${NC}"
    local confirm
    read -r confirm
    
    if [[ "$confirm" != "CREATE" ]]; then
        echo -e "${YELLOW}Cancelled.${NC}"
        echo -e "Press Enter to return..."
        read -r
        return 0
    fi
    
    # ========== Execute the Command ==========
    echo ""
    echo -e "${YELLOW}Creating Compute Cluster...${NC}"
    
    # Log the command
    {
        echo "=========================================="
        echo "Compute Cluster Creation"
        echo "Timestamp: $(date)"
        echo "=========================================="
        echo ""
        echo "Display Name:        ${display_name}"
        echo "Availability Domain: ${selected_ad}"
        echo "Compartment ID:      ${compartment_id}"
        echo "Region:              ${region}"
        echo "Debug Mode:          ${debug_flag:-disabled}"
        echo ""
        echo "Command:"
        echo "oci compute compute-cluster create \\"
        echo "    --availability-domain \"${selected_ad}\" \\"
        echo "    --compartment-id \"${compartment_id}\" \\"
        echo "    --display-name \"${display_name}\" ${debug_flag}"
        echo ""
        echo "=========================================="
        echo "Execution Output:"
        echo "=========================================="
    } > "$log_file"
    
    local result
    if [[ -n "$debug_flag" ]]; then
        result=$(oci compute compute-cluster create \
            --availability-domain "${selected_ad}" \
            --compartment-id "${compartment_id}" \
            --display-name "${display_name}" \
            --debug 2>&1)
    else
        result=$(oci compute compute-cluster create \
            --availability-domain "${selected_ad}" \
            --compartment-id "${compartment_id}" \
            --display-name "${display_name}" 2>&1)
    fi
    local exit_code=$?
    
    # Log the result
    echo "$result" >> "$log_file"
    
    if [[ $exit_code -eq 0 ]]; then
        local new_ocid
        new_ocid=$(echo "$result" | jq -r '.data.id // empty' 2>/dev/null)
        local new_state
        new_state=$(echo "$result" | jq -r '.data["lifecycle-state"] // "UNKNOWN"' 2>/dev/null)
        
        echo ""
        echo -e "${GREEN}╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${GREEN}║                                        COMPUTE CLUSTER CREATED                                                  ║${NC}"
        echo -e "${GREEN}╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "  ${CYAN}Display Name:${NC}        ${WHITE}${display_name}${NC}"
        echo -e "  ${CYAN}OCID:${NC}                ${YELLOW}${new_ocid}${NC}"
        echo -e "  ${CYAN}Availability Domain:${NC} ${WHITE}${selected_ad}${NC}"
        echo -e "  ${CYAN}State:${NC}               ${GREEN}${new_state}${NC}"
        echo ""
        echo -e "  ${WHITE}Log file: ${CYAN}${log_file}${NC}"
        echo ""
        
        # Invalidate compute cluster cache
        rm -f "$COMPUTE_CLUSTER_CACHE"
        echo -e "${GRAY}(Compute cluster cache cleared - will refresh on next access)${NC}"
        
        # Log success
        {
            echo ""
            echo "=========================================="
            echo "Result: SUCCESS"
            echo "New OCID: ${new_ocid}"
            echo "State: ${new_state}"
            echo "=========================================="
        } >> "$log_file"
    else
        echo ""
        echo -e "${RED}╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${RED}║                                      COMPUTE CLUSTER CREATION FAILED                                            ║${NC}"
        echo -e "${RED}╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "${RED}Error:${NC}"
        echo "$result"
        echo ""
        echo -e "  ${WHITE}Log file: ${CYAN}${log_file}${NC}"
        
        # Log failure
        {
            echo ""
            echo "=========================================="
            echo "Result: FAILED"
            echo "Exit Code: ${exit_code}"
            echo "=========================================="
        } >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#===============================================================================
# GPU INSTANCE TAGGING MANAGEMENT
#===============================================================================

# Default tag namespace and tag settings for GPU instance host actions
GPU_TAG_NAMESPACE="${GPU_TAG_NAMESPACE:-ComputeInstanceHostActions}"
GPU_TAG_NAMESPACE_DESCRIPTION="${GPU_TAG_NAMESPACE_DESCRIPTION:-Compute Instance Actions Tag Namespace}"
GPU_TAG_NAME="${GPU_TAG_NAME:-CustomerReportedHostStatus}"
GPU_TAG_NAME_DESCRIPTION="${GPU_TAG_NAME_DESCRIPTION:-host is unhealthy and needs manual intervention before returning to the previous pool post-recycle}"
GPU_TAG_VALUES="${GPU_TAG_VALUES:-unhealthy}"

#--------------------------------------------------------------------------------
# Get tenancy home region (required for IAM operations)
# OCI Command: oci iam region-subscription list --tenancy-id <TENANCY_ID>
#--------------------------------------------------------------------------------
get_home_region() {
    local tenancy_ocid="${TENANCY_ID:-$TENANCY_OCID}"
    
    if [[ -z "$tenancy_ocid" ]]; then
        echo ""
        return 1
    fi
    
    local home_region
    # Query home region from tenancy's region subscriptions
    home_region=$(oci iam region-subscription list \
        --tenancy-id "$tenancy_ocid" \
        --query "data[?\"is-home-region\"==\`true\`].\"region-name\" | [0]" \
        --raw-output 2>/dev/null)
    
    echo "$home_region"
}

#================================================================================
# RESOURCE MANAGER STACKS MANAGEMENT
#================================================================================

#--------------------------------------------------------------------------------
# Manage Resource Manager Stacks - Main menu
#--------------------------------------------------------------------------------
manage_resource_manager_stacks() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    
    # Show stacks with jobs - this function handles all interactions
    # When user presses 'b', it returns and we go back to main menu
    rm_list_stacks_with_jobs "$compartment_id"
}

#--------------------------------------------------------------------------------
# List All Resource Manager Stacks with their Jobs - Interactive
#--------------------------------------------------------------------------------
rm_list_stacks_with_jobs() {
    local compartment_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${WHITE}                                  ALL STACKS WITH JOB HISTORY                                                    ${NC}"
    echo -e "${BOLD}${WHITE}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    local list_cmd="oci resource-manager stack list --compartment-id \"$compartment_id\" --all --output json"
    echo -e "${GRAY}$list_cmd${NC}"
    echo ""
    
    local stacks_json
    stacks_json=$(oci resource-manager stack list \
        --compartment-id "$compartment_id" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$stacks_json" || "$stacks_json" == "null" ]]; then
        echo -e "${YELLOW}No stacks found or unable to list stacks${NC}"
        return 1
    fi
    
    local stack_count
    stack_count=$(echo "$stacks_json" | jq '.data | length' 2>/dev/null)
    
    if [[ "$stack_count" -eq 0 ]]; then
        echo -e "${YELLOW}No stacks found in this compartment${NC}"
        return 1
    fi
    
    echo -e "${GREEN}Found $stack_count stack(s)${NC}"
    echo ""
    
    # Clear and populate global maps
    declare -gA RM_STACK_MAP
    declare -gA RM_STACK_NAMES
    declare -gA RM_JOB_MAP  # Maps "stack_idx.job_idx" to job_id
    RM_STACK_MAP=()
    RM_STACK_NAMES=()
    RM_JOB_MAP=()
    
    local stack_idx=0
    
    # Process each stack
    while IFS='|' read -r stack_name state tf_version stack_id time_created; do
        [[ -z "$stack_name" ]] && continue
        ((stack_idx++))
        
        RM_STACK_MAP[$stack_idx]="$stack_id"
        RM_STACK_NAMES[$stack_idx]="$stack_name"
        
        # Color based on state
        local state_color="$GREEN"
        case "$state" in
            ACTIVE) state_color="$GREEN" ;;
            CREATING|UPDATING) state_color="$YELLOW" ;;
            DELETING|DELETED|FAILED) state_color="$RED" ;;
            *) state_color="$GRAY" ;;
        esac
        
        echo -e "${BOLD}${CYAN}┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
        echo -e "${BOLD}${CYAN}│ [s${stack_idx}] Stack: ${WHITE}${stack_name}${NC}"
        echo -e "${BOLD}${CYAN}├──────────────────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
        echo -e "│ ${CYAN}State:${NC}      ${state_color}${state}${NC}"
        echo -e "│ ${CYAN}TF Version:${NC} ${WHITE}${tf_version:-N/A}${NC}"
        echo -e "│ ${CYAN}Created:${NC}    ${WHITE}${time_created:0:19}${NC}"
        echo -e "│ ${CYAN}Stack OCID:${NC} ${YELLOW}${stack_id}${NC}"
        echo -e "${BOLD}${CYAN}│${NC}"
        
        # Fetch jobs for this stack
        local jobs_json
        jobs_json=$(oci resource-manager job list \
            --stack-id "$stack_id" \
            --all \
            --output json 2>/dev/null)
        
        local job_count=0
        if [[ -n "$jobs_json" && "$jobs_json" != "null" ]]; then
            job_count=$(echo "$jobs_json" | jq '.data | length' 2>/dev/null) || job_count=0
        fi
        
        if [[ "$job_count" -eq 0 ]]; then
            echo -e "│ ${GRAY}No jobs found for this stack${NC}"
        else
            echo -e "│ ${BOLD}${WHITE}Jobs (${job_count}):${NC}"
            echo -e "│"
            printf "│   ${BOLD}%-8s %-12s %-12s %-20s %-20s %s${NC}\n" "ID" "Operation" "State" "Created" "Finished" "Job OCID"
            echo -e "│   ────────────────────────────────────────────────────────────────────────────────────────────────────────"
            
            local job_idx=0
            while IFS='|' read -r operation job_state time_created time_finished job_id; do
                [[ -z "$operation" ]] && continue
                ((job_idx++))
                
                # Store job mapping
                RM_JOB_MAP["${stack_idx}.${job_idx}"]="$job_id"
                
                # Color based on state
                local job_state_color="$GREEN"
                case "$job_state" in
                    SUCCEEDED) job_state_color="$GREEN" ;;
                    IN_PROGRESS|ACCEPTED) job_state_color="$YELLOW" ;;
                    FAILED|CANCELED) job_state_color="$RED" ;;
                    *) job_state_color="$GRAY" ;;
                esac
                
                # Operation color
                local op_color="$WHITE"
                case "$operation" in
                    APPLY) op_color="$GREEN" ;;
                    PLAN) op_color="$CYAN" ;;
                    DESTROY) op_color="$RED" ;;
                    IMPORT_TF_STATE) op_color="$YELLOW" ;;
                esac
                
                # Format times
                local time_created_short="${time_created:0:19}"
                local time_finished_short="${time_finished:0:19}"
                [[ "$time_finished_short" == "null" || -z "$time_finished_short" ]] && time_finished_short="-"
                
                printf "│   ${YELLOW}[j%-5s]${NC} ${op_color}%-12s${NC} ${job_state_color}%-12s${NC} %-20s %-20s ${GRAY}%s${NC}\n" \
                    "${stack_idx}.${job_idx}" "$operation" "$job_state" "$time_created_short" "$time_finished_short" "$job_id"
                    
            done < <(echo "$jobs_json" | jq -r '.data | sort_by(.["time-created"]) | reverse | .[] | "\(.operation)|\(.["lifecycle-state"])|\(.["time-created"])|\(.["time-finished"] // "null")|\(.id)"' 2>/dev/null)
        fi
        
        echo -e "${BOLD}${CYAN}└──────────────────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
        echo ""
        
    done < <(echo "$stacks_json" | jq -r '.data | sort_by(.["display-name"]) | .[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["terraform-version"] // "N/A")|\(.id)|\(.["time-created"])"' 2>/dev/null)
    
    RM_STACK_COUNT=$stack_idx
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Summary ═══${NC}"
    echo -e "  Total Stacks: ${GREEN}$stack_count${NC}"
    echo ""
    
    # Interactive selection loop
    while true; do
        echo -e "${BOLD}${WHITE}─── Selection Options ───${NC}"
        echo -e "  ${YELLOW}s#${NC}       - View stack details (e.g., ${YELLOW}s1${NC})"
        echo -e "  ${YELLOW}s#o${NC}      - View stack outputs (e.g., ${YELLOW}s1o${NC})"
        echo -e "  ${YELLOW}s#r${NC}      - View stack resources (e.g., ${YELLOW}s1r${NC})"
        echo -e "  ${YELLOW}s#t${NC}      - View stack state file (e.g., ${YELLOW}s1t${NC})"
        echo -e "  ${YELLOW}j#.#${NC}     - View job details (e.g., ${YELLOW}j1.2${NC})"
        echo -e "  ${YELLOW}j#.#l${NC}    - View job logs (e.g., ${YELLOW}j1.2l${NC})"
        echo -e "  ${MAGENTA}r${NC}        - Reload stacks and jobs"
        echo -e "  ${CYAN}b${NC}        - Back to Resource Manager menu"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Resource Manager] Selection: ${NC}"
        read -r selection
        
        [[ -z "$selection" || "$selection" == "b" || "$selection" == "B" ]] && return 0
        
        # Refresh
        if [[ "$selection" == "r" || "$selection" == "R" || "$selection" == "refresh" ]]; then
            rm_list_stacks_with_jobs "$compartment_id"
            return $?
        fi
        
        # Stack details: s#
        if [[ "$selection" =~ ^s([0-9]+)$ ]]; then
            local sel_stack="${BASH_REMATCH[1]}"
            if [[ -n "${RM_STACK_MAP[$sel_stack]}" ]]; then
                rm_show_stack_detail "${RM_STACK_MAP[$sel_stack]}"
            else
                echo -e "${RED}Invalid stack number: s${sel_stack}${NC}"
            fi
            continue
        fi
        
        # Stack outputs: s#o
        if [[ "$selection" =~ ^s([0-9]+)o$ ]]; then
            local sel_stack="${BASH_REMATCH[1]}"
            if [[ -n "${RM_STACK_MAP[$sel_stack]}" ]]; then
                rm_show_stack_outputs_direct "${RM_STACK_MAP[$sel_stack]}" "${RM_STACK_NAMES[$sel_stack]}"
            else
                echo -e "${RED}Invalid stack number: s${sel_stack}${NC}"
            fi
            continue
        fi
        
        # Stack resources: s#r
        if [[ "$selection" =~ ^s([0-9]+)r$ ]]; then
            local sel_stack="${BASH_REMATCH[1]}"
            if [[ -n "${RM_STACK_MAP[$sel_stack]}" ]]; then
                rm_show_stack_resources_direct "${RM_STACK_MAP[$sel_stack]}" "${RM_STACK_NAMES[$sel_stack]}"
            else
                echo -e "${RED}Invalid stack number: s${sel_stack}${NC}"
            fi
            continue
        fi
        
        # Stack state: s#t
        if [[ "$selection" =~ ^s([0-9]+)t$ ]]; then
            local sel_stack="${BASH_REMATCH[1]}"
            if [[ -n "${RM_STACK_MAP[$sel_stack]}" ]]; then
                rm_show_stack_state_direct "${RM_STACK_MAP[$sel_stack]}" "${RM_STACK_NAMES[$sel_stack]}"
            else
                echo -e "${RED}Invalid stack number: s${sel_stack}${NC}"
            fi
            continue
        fi
        
        # Job details: j#.#
        if [[ "$selection" =~ ^j([0-9]+)\.([0-9]+)$ ]]; then
            local sel_key="${BASH_REMATCH[1]}.${BASH_REMATCH[2]}"
            if [[ -n "${RM_JOB_MAP[$sel_key]}" ]]; then
                rm_show_job_detail_direct "${RM_JOB_MAP[$sel_key]}"
            else
                echo -e "${RED}Invalid job reference: j${sel_key}${NC}"
            fi
            continue
        fi
        
        # Job logs: j#.#l
        if [[ "$selection" =~ ^j([0-9]+)\.([0-9]+)l$ ]]; then
            local sel_key="${BASH_REMATCH[1]}.${BASH_REMATCH[2]}"
            if [[ -n "${RM_JOB_MAP[$sel_key]}" ]]; then
                rm_show_job_logs_direct "${RM_JOB_MAP[$sel_key]}"
            else
                echo -e "${RED}Invalid job reference: j${sel_key}${NC}"
            fi
            continue
        fi
        
        echo -e "${RED}Invalid selection. Use s# for stacks, j#.# for jobs${NC}"
    done
    
    return 0
}

#--------------------------------------------------------------------------------
# Show stack outputs directly by stack ID
#--------------------------------------------------------------------------------
rm_show_stack_outputs_direct() {
    local stack_id="$1"
    local stack_name="$2"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Stack Outputs: ${CYAN}${stack_name}${NC} ${BOLD}${WHITE}═══${NC}"
    echo ""
    
    local get_cmd="oci resource-manager stack get --stack-id \"$stack_id\" --output json"
    echo -e "${GRAY}$get_cmd${NC}"
    echo ""
    
    local stack_json
    stack_json=$(oci resource-manager stack get --stack-id "$stack_id" --output json 2>/dev/null)
    
    if [[ -z "$stack_json" || "$stack_json" == "null" ]]; then
        echo -e "${RED}Failed to get stack details${NC}"
        return
    fi
    
    # Check for outputs in stack
    local outputs
    outputs=$(echo "$stack_json" | jq '.data.outputs // {}' 2>/dev/null)
    
    if [[ "$outputs" == "{}" || "$outputs" == "null" || -z "$outputs" ]]; then
        echo -e "${YELLOW}No outputs found for this stack${NC}"
        echo -e "${GRAY}Note: Outputs are populated after a successful apply job${NC}"
    else
        echo -e "${GREEN}Stack Outputs:${NC}"
        echo ""
        echo "$outputs" | jq -r 'to_entries[] | "  \(.key): \(.value)"' 2>/dev/null
    fi
    
    echo ""
}

#--------------------------------------------------------------------------------
# Show stack resources directly by stack ID
#--------------------------------------------------------------------------------
rm_show_stack_resources_direct() {
    local stack_id="$1"
    local stack_name="$2"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Stack Resources: ${CYAN}${stack_name}${NC} ${BOLD}${WHITE}═══${NC}"
    echo ""
    
    local list_cmd="oci resource-manager stack list-terraform-resources --stack-id \"$stack_id\" --output json"
    echo -e "${GRAY}$list_cmd${NC}"
    echo ""
    
    local resources_json
    resources_json=$(oci resource-manager stack list-terraform-resources \
        --stack-id "$stack_id" \
        --output json 2>/dev/null)
    
    if [[ -z "$resources_json" || "$resources_json" == "null" ]]; then
        echo -e "${YELLOW}No resources found or unable to list resources${NC}"
        return
    fi
    
    local resource_count
    resource_count=$(echo "$resources_json" | jq '.data | length' 2>/dev/null)
    
    if [[ "$resource_count" -eq 0 ]]; then
        echo -e "${YELLOW}No resources found for this stack${NC}"
        return
    fi
    
    echo -e "${GREEN}Found $resource_count resource(s)${NC}"
    echo ""
    
    # Print header
    printf "${BOLD}%-50s %-40s %s${NC}\n" "Resource Type" "Resource Name" "Resource OCID"
    print_separator 160
    
    echo "$resources_json" | jq -r '.data[] | "\(.["resource-type"] // "N/A")|\(.["resource-name"] // "N/A")|\(.["resource-id"] // "N/A")"' 2>/dev/null | while IFS='|' read -r res_type res_name res_id; do
        printf "%-50s %-40s ${GRAY}%s${NC}\n" "${res_type:0:48}" "${res_name:0:38}" "$res_id"
    done
    
    echo ""
}

#--------------------------------------------------------------------------------
# Show stack state directly by stack ID
#--------------------------------------------------------------------------------
rm_show_stack_state_direct() {
    local stack_id="$1"
    local stack_name="$2"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Stack State: ${CYAN}${stack_name}${NC} ${BOLD}${WHITE}═══${NC}"
    echo ""
    
    local get_cmd="oci resource-manager stack get-stack-tf-state --stack-id \"$stack_id\" --file -"
    echo -e "${GRAY}$get_cmd${NC}"
    echo ""
    
    local state_content
    state_content=$(oci resource-manager stack get-stack-tf-state \
        --stack-id "$stack_id" \
        --file - 2>/dev/null)
    
    if [[ -z "$state_content" ]]; then
        echo -e "${YELLOW}No state found or unable to get state${NC}"
        return
    fi
    
    # Parse and display state summary
    echo -e "${GREEN}Terraform State Summary:${NC}"
    echo ""
    
    local version serial
    version=$(echo "$state_content" | jq -r '.version // "N/A"' 2>/dev/null)
    serial=$(echo "$state_content" | jq -r '.serial // "N/A"' 2>/dev/null)
    
    echo -e "  ${CYAN}Version:${NC} $version"
    echo -e "  ${CYAN}Serial:${NC}  $serial"
    echo ""
    
    # Count resources
    local res_count
    res_count=$(echo "$state_content" | jq '.resources | length' 2>/dev/null) || res_count=0
    echo -e "  ${CYAN}Resources in state:${NC} $res_count"
    echo ""
    
    if [[ "$res_count" -gt 0 ]]; then
        echo -e "${WHITE}Resources:${NC}"
        echo ""
        printf "  ${BOLD}%-40s %-50s %s${NC}\n" "Type" "Name" "Provider"
        echo "  ────────────────────────────────────────────────────────────────────────────────────────────────────────"
        
        echo "$state_content" | jq -r '.resources[] | "\(.type // "N/A")|\(.name // "N/A")|\(.provider // "N/A")"' 2>/dev/null | while IFS='|' read -r res_type res_name res_provider; do
            printf "  %-40s %-50s ${GRAY}%s${NC}\n" "${res_type:0:38}" "${res_name:0:48}" "$res_provider"
        done
    fi
    
    echo ""
}

#--------------------------------------------------------------------------------
# Show job details directly by job ID
#--------------------------------------------------------------------------------
rm_show_job_detail_direct() {
    local job_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Job Details ═══${NC}"
    echo ""
    
    local get_cmd="oci resource-manager job get --job-id \"$job_id\" --output json"
    echo -e "${GRAY}$get_cmd${NC}"
    echo ""
    
    local job_json
    job_json=$(oci resource-manager job get --job-id "$job_id" --output json 2>/dev/null)
    
    if [[ -z "$job_json" || "$job_json" == "null" ]]; then
        echo -e "${RED}Failed to get job details${NC}"
        return
    fi
    
    # Extract fields
    local operation state stack_id time_created time_finished
    local resolved_plan_id apply_tf_state failure_details
    operation=$(echo "$job_json" | jq -r '.data.operation // "N/A"')
    state=$(echo "$job_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    stack_id=$(echo "$job_json" | jq -r '.data["stack-id"] // "N/A"')
    time_created=$(echo "$job_json" | jq -r '.data["time-created"] // "N/A"')
    time_finished=$(echo "$job_json" | jq -r '.data["time-finished"] // "N/A"')
    resolved_plan_id=$(echo "$job_json" | jq -r '.data["resolved-plan-job-id"] // "N/A"')
    
    # State color
    local state_color="$GREEN"
    case "$state" in
        SUCCEEDED) state_color="$GREEN" ;;
        IN_PROGRESS|ACCEPTED) state_color="$YELLOW" ;;
        FAILED|CANCELED) state_color="$RED" ;;
    esac
    
    # Operation color
    local op_color="$WHITE"
    case "$operation" in
        APPLY) op_color="$GREEN" ;;
        PLAN) op_color="$CYAN" ;;
        DESTROY) op_color="$RED" ;;
        IMPORT_TF_STATE) op_color="$YELLOW" ;;
    esac
    
    echo -e "  ${CYAN}Operation:${NC}    ${op_color}$operation${NC}"
    echo -e "  ${CYAN}State:${NC}        ${state_color}$state${NC}"
    echo -e "  ${CYAN}Created:${NC}      ${WHITE}$time_created${NC}"
    echo -e "  ${CYAN}Finished:${NC}     ${WHITE}$time_finished${NC}"
    echo -e "  ${CYAN}Stack OCID:${NC}   ${YELLOW}$stack_id${NC}"
    echo -e "  ${CYAN}Job OCID:${NC}     ${YELLOW}$job_id${NC}"
    
    if [[ "$resolved_plan_id" != "N/A" && "$resolved_plan_id" != "null" && -n "$resolved_plan_id" ]]; then
        echo -e "  ${CYAN}Plan Job:${NC}     ${YELLOW}$resolved_plan_id${NC}"
    fi
    
    # Check for failure details
    if [[ "$state" == "FAILED" ]]; then
        failure_details=$(echo "$job_json" | jq -r '.data["failure-details"] // "N/A"' 2>/dev/null)
        if [[ "$failure_details" != "N/A" && "$failure_details" != "null" && -n "$failure_details" ]]; then
            echo ""
            echo -e "  ${RED}Failure Details:${NC}"
            echo "$failure_details" | fold -s -w 100 | while IFS= read -r line; do
                echo -e "    ${RED}$line${NC}"
            done
        fi
    fi
    
    echo ""
}

#--------------------------------------------------------------------------------
# Show job logs directly by job ID
#--------------------------------------------------------------------------------
rm_show_job_logs_direct() {
    local job_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Job Logs ═══${NC}"
    echo ""
    
    local logs_cmd="oci resource-manager job get-job-logs --job-id \"$job_id\" --all --output json"
    echo -e "${GRAY}$logs_cmd${NC}"
    echo ""
    
    local logs_json
    logs_json=$(oci resource-manager job get-job-logs \
        --job-id "$job_id" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$logs_json" || "$logs_json" == "null" ]]; then
        echo -e "${YELLOW}No logs found or unable to get logs${NC}"
        return
    fi
    
    local log_count
    log_count=$(echo "$logs_json" | jq '.data | length' 2>/dev/null)
    
    if [[ "$log_count" -eq 0 ]]; then
        echo -e "${YELLOW}No log entries found${NC}"
        return
    fi
    
    echo -e "${GREEN}Found $log_count log entries${NC}"
    echo ""
    
    # Display logs
    echo "$logs_json" | jq -r '.data[] | "\(.timestamp // "N/A") [\(.level // "INFO")] \(.message // "")"' 2>/dev/null | while IFS= read -r log_line; do
        # Color based on log level
        if echo "$log_line" | grep -qE '\[ERROR\]|\[FATAL\]'; then
            echo -e "${RED}$log_line${NC}"
        elif echo "$log_line" | grep -qE '\[WARN\]|\[WARNING\]'; then
            echo -e "${YELLOW}$log_line${NC}"
        elif echo "$log_line" | grep -qE 'Apply complete|Creation complete|Destruction complete'; then
            echo -e "${GREEN}$log_line${NC}"
        else
            echo "$log_line"
        fi
    done
    
    echo ""
    echo -e "${GRAY}Press Enter to continue${NC}"
    read -r
}

#--------------------------------------------------------------------------------
# List Resource Manager Stacks
#--------------------------------------------------------------------------------
rm_list_stacks() {
    local compartment_id="$1"
    local interactive="${2:-true}"  # Whether to prompt for selection
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Resource Manager Stacks ═══${NC}"
    echo ""
    
    local list_cmd="oci resource-manager stack list --compartment-id \"$compartment_id\" --all --output json"
    echo -e "${GRAY}$list_cmd${NC}"
    echo ""
    
    local stacks_json
    stacks_json=$(oci resource-manager stack list \
        --compartment-id "$compartment_id" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$stacks_json" || "$stacks_json" == "null" ]]; then
        echo -e "${YELLOW}No stacks found or unable to list stacks${NC}"
        return 1
    fi
    
    local stack_count
    stack_count=$(echo "$stacks_json" | jq '.data | length' 2>/dev/null)
    
    if [[ "$stack_count" -eq 0 ]]; then
        echo -e "${YELLOW}No stacks found in this compartment${NC}"
        return 1
    fi
    
    echo -e "${GREEN}Found $stack_count stack(s)${NC}"
    echo ""
    
    # Print header
    printf "${BOLD}%-3s %-35s %-10s %-8s %s${NC}\n" "#" "Stack Name" "State" "TF Ver" "Stack OCID"
    print_separator 160
    
    local idx=0
    # Clear and populate global stack map
    declare -gA RM_STACK_MAP
    declare -gA RM_STACK_NAMES
    RM_STACK_MAP=()
    RM_STACK_NAMES=()
    
    while IFS='|' read -r stack_name state tf_version stack_id time_created; do
        [[ -z "$stack_name" ]] && continue
        ((idx++))
        
        RM_STACK_MAP[$idx]="$stack_id"
        RM_STACK_NAMES[$idx]="$stack_name"
        
        # Color based on state
        local state_color="$GREEN"
        case "$state" in
            ACTIVE) state_color="$GREEN" ;;
            CREATING|UPDATING) state_color="$YELLOW" ;;
            DELETING|DELETED|FAILED) state_color="$RED" ;;
            *) state_color="$GRAY" ;;
        esac
        
        # Truncate name if too long
        local name_trunc="${stack_name:0:33}"
        [[ ${#stack_name} -gt 33 ]] && name_trunc="${name_trunc}.."
        
        printf "${YELLOW}%-3s${NC} %-35s ${state_color}%-10s${NC} %-8s ${GRAY}%s${NC}\n" \
            "$idx" "$name_trunc" "$state" "${tf_version:-N/A}" "$stack_id"
            
    done < <(echo "$stacks_json" | jq -r '.data[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["terraform-version"] // "N/A")|\(.id)|\(.["time-created"])"' 2>/dev/null | sort)
    
    echo ""
    
    # Store count for other functions
    RM_STACK_COUNT=$idx
    
    if [[ "$interactive" == "true" ]]; then
        echo -e "${GRAY}Enter stack # to view details, or press Enter to continue${NC}"
        echo -n -e "${CYAN}Selection: ${NC}"
        read -r stack_selection
        
        if [[ -n "$stack_selection" && -n "${RM_STACK_MAP[$stack_selection]}" ]]; then
            rm_show_stack_detail "${RM_STACK_MAP[$stack_selection]}"
        fi
    fi
    
    return 0
}

#--------------------------------------------------------------------------------
# Show detailed stack information
#--------------------------------------------------------------------------------
rm_show_stack_detail() {
    local stack_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Stack Details ═══${NC}"
    echo ""
    
    local get_cmd="oci resource-manager stack get --stack-id \"$stack_id\" --output json"
    echo -e "${GRAY}$get_cmd${NC}"
    echo ""
    
    local stack_json
    stack_json=$(oci resource-manager stack get \
        --stack-id "$stack_id" \
        --output json 2>/dev/null)
    
    if [[ -z "$stack_json" || "$stack_json" == "null" ]]; then
        echo -e "${RED}Failed to get stack details${NC}"
        return
    fi
    
    # Extract fields
    local name state tf_version description time_created source_type working_dir
    name=$(echo "$stack_json" | jq -r '.data["display-name"] // "N/A"')
    state=$(echo "$stack_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    tf_version=$(echo "$stack_json" | jq -r '.data["terraform-version"] // "N/A"')
    description=$(echo "$stack_json" | jq -r '.data.description // "N/A"')
    time_created=$(echo "$stack_json" | jq -r '.data["time-created"] // "N/A"')
    source_type=$(echo "$stack_json" | jq -r '.data["config-source"].["config-source-type"] // "N/A"')
    working_dir=$(echo "$stack_json" | jq -r '.data["config-source"]["working-directory"] // "N/A"')
    
    # State color
    local state_color="$GREEN"
    case "$state" in
        ACTIVE) state_color="$GREEN" ;;
        CREATING|UPDATING) state_color="$YELLOW" ;;
        DELETING|DELETED|FAILED) state_color="$RED" ;;
    esac
    
    echo -e "  ${CYAN}Name:${NC}              ${WHITE}$name${NC}"
    echo -e "  ${CYAN}State:${NC}             ${state_color}$state${NC}"
    echo -e "  ${CYAN}Terraform Version:${NC} ${WHITE}$tf_version${NC}"
    echo -e "  ${CYAN}Description:${NC}       ${WHITE}$description${NC}"
    echo -e "  ${CYAN}Created:${NC}           ${WHITE}$time_created${NC}"
    echo -e "  ${CYAN}Source Type:${NC}       ${WHITE}$source_type${NC}"
    echo -e "  ${CYAN}Working Directory:${NC} ${WHITE}$working_dir${NC}"
    echo -e "  ${CYAN}Stack OCID:${NC}        ${YELLOW}$stack_id${NC}"
    echo ""
    
    # Show variables if any
    local variables
    variables=$(echo "$stack_json" | jq -r '.data.variables // {}')
    if [[ "$variables" != "{}" && "$variables" != "null" ]]; then
        echo -e "${BOLD}${WHITE}Variables:${NC}"
        echo "$variables" | jq -r 'to_entries[] | "  \(.key) = \(.value)"' 2>/dev/null | head -20
        local var_count
        var_count=$(echo "$variables" | jq 'keys | length' 2>/dev/null)
        [[ "$var_count" -gt 20 ]] && echo -e "  ${GRAY}... and $((var_count - 20)) more${NC}"
        echo ""
    fi
    
    # Show freeform tags
    local freeform_tags
    freeform_tags=$(echo "$stack_json" | jq -r '.data["freeform-tags"] // {}')
    if [[ "$freeform_tags" != "{}" && "$freeform_tags" != "null" ]]; then
        echo -e "${BOLD}${WHITE}Freeform Tags:${NC}"
        echo "$freeform_tags" | jq -r 'to_entries[] | "  \(.key) = \(.value)"' 2>/dev/null
        echo ""
    fi
    
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# View Stack Details (with selection from list)
#--------------------------------------------------------------------------------
rm_view_stack_details() {
    local compartment_id="$1"
    
    # List stacks without interactive prompt
    rm_list_stacks "$compartment_id" "false"
    
    if [[ ${RM_STACK_COUNT:-0} -eq 0 ]]; then
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Enter stack # to view details (or Enter to cancel): ${NC}"
    read -r stack_selection
    
    if [[ -n "$stack_selection" && -n "${RM_STACK_MAP[$stack_selection]}" ]]; then
        rm_show_stack_detail "${RM_STACK_MAP[$stack_selection]}"
    elif [[ -n "$stack_selection" ]]; then
        echo -e "${RED}Invalid selection${NC}"
    fi
}

#--------------------------------------------------------------------------------
# List Jobs for a Stack
#--------------------------------------------------------------------------------
rm_list_jobs() {
    local compartment_id="$1"
    
    # List stacks without interactive prompt
    rm_list_stacks "$compartment_id" "false"
    
    if [[ ${RM_STACK_COUNT:-0} -eq 0 ]]; then
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Enter stack # to view jobs (or Enter to cancel): ${NC}"
    read -r stack_selection
    
    if [[ -z "$stack_selection" ]]; then
        return
    fi
    
    if [[ -z "${RM_STACK_MAP[$stack_selection]}" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return
    fi
    
    local stack_id="${RM_STACK_MAP[$stack_selection]}"
    local stack_name="${RM_STACK_NAMES[$stack_selection]}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Jobs for Stack: ${CYAN}${stack_name}${NC} ${BOLD}${WHITE}═══${NC}"
    echo ""
    
    local list_cmd="oci resource-manager job list --stack-id \"$stack_id\" --all --output json"
    echo -e "${GRAY}$list_cmd${NC}"
    echo ""
    
    local jobs_json
    jobs_json=$(oci resource-manager job list \
        --stack-id "$stack_id" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$jobs_json" || "$jobs_json" == "null" ]]; then
        echo -e "${YELLOW}No jobs found or unable to list jobs${NC}"
        return
    fi
    
    local job_count
    job_count=$(echo "$jobs_json" | jq '.data | length' 2>/dev/null)
    
    if [[ "$job_count" -eq 0 ]]; then
        echo -e "${YELLOW}No jobs found for this stack${NC}"
        return
    fi
    
    echo -e "${GREEN}Found $job_count job(s)${NC}"
    echo ""
    
    # Print header
    printf "${BOLD}%-3s %-12s %-12s %-20s %s${NC}\n" "#" "Operation" "State" "Time Created" "Job OCID"
    print_separator 160
    
    local idx=0
    declare -gA RM_JOB_MAP
    RM_JOB_MAP=()
    
    while IFS='|' read -r operation state time_created job_id; do
        [[ -z "$operation" ]] && continue
        ((idx++))
        
        RM_JOB_MAP[$idx]="$job_id"
        
        # Color based on state
        local state_color="$GREEN"
        case "$state" in
            SUCCEEDED) state_color="$GREEN" ;;
            IN_PROGRESS|ACCEPTED) state_color="$YELLOW" ;;
            FAILED|CANCELED) state_color="$RED" ;;
            *) state_color="$GRAY" ;;
        esac
        
        # Operation color
        local op_color="$WHITE"
        case "$operation" in
            APPLY) op_color="$GREEN" ;;
            PLAN) op_color="$CYAN" ;;
            DESTROY) op_color="$RED" ;;
            IMPORT_TF_STATE) op_color="$YELLOW" ;;
        esac
        
        # Format time
        local time_short="${time_created:0:19}"
        
        printf "${YELLOW}%-3s${NC} ${op_color}%-12s${NC} ${state_color}%-12s${NC} %-20s ${GRAY}%s${NC}\n" \
            "$idx" "$operation" "$state" "$time_short" "$job_id"
            
    done < <(echo "$jobs_json" | jq -r '.data | sort_by(.["time-created"]) | reverse | .[] | "\(.operation)|\(.["lifecycle-state"])|\(.["time-created"])|\(.id)"' 2>/dev/null)
    
    # Store count
    RM_JOB_COUNT=$idx
    
    echo ""
    echo -e "${GRAY}Enter job # to view details, or press Enter to continue${NC}"
    echo -n -e "${CYAN}Selection: ${NC}"
    read -r job_selection
    
    if [[ -n "$job_selection" && -n "${RM_JOB_MAP[$job_selection]}" ]]; then
        rm_show_job_detail "${RM_JOB_MAP[$job_selection]}"
    fi
}

#--------------------------------------------------------------------------------
# Show Job Details
#--------------------------------------------------------------------------------
rm_show_job_detail() {
    local job_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Job Details ═══${NC}"
    echo ""
    
    local get_cmd="oci resource-manager job get --job-id \"$job_id\" --output json"
    echo -e "${GRAY}$get_cmd${NC}"
    echo ""
    
    local job_json
    job_json=$(oci resource-manager job get \
        --job-id "$job_id" \
        --output json 2>/dev/null)
    
    if [[ -z "$job_json" || "$job_json" == "null" ]]; then
        echo -e "${RED}Failed to get job details${NC}"
        return
    fi
    
    # Extract fields
    local operation state time_created time_finished stack_id
    local apply_job_plan_resolution failure_details
    operation=$(echo "$job_json" | jq -r '.data.operation // "N/A"')
    state=$(echo "$job_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    time_created=$(echo "$job_json" | jq -r '.data["time-created"] // "N/A"')
    time_finished=$(echo "$job_json" | jq -r '.data["time-finished"] // "N/A"')
    stack_id=$(echo "$job_json" | jq -r '.data["stack-id"] // "N/A"')
    apply_job_plan_resolution=$(echo "$job_json" | jq -r '.data["apply-job-plan-resolution"] // "N/A"')
    failure_details=$(echo "$job_json" | jq -r '.data["failure-details"] // empty')
    
    # State color
    local state_color="$GREEN"
    case "$state" in
        SUCCEEDED) state_color="$GREEN" ;;
        IN_PROGRESS|ACCEPTED) state_color="$YELLOW" ;;
        FAILED|CANCELED) state_color="$RED" ;;
    esac
    
    # Operation color
    local op_color="$WHITE"
    case "$operation" in
        APPLY) op_color="$GREEN" ;;
        PLAN) op_color="$CYAN" ;;
        DESTROY) op_color="$RED" ;;
    esac
    
    echo -e "  ${CYAN}Operation:${NC}         ${op_color}$operation${NC}"
    echo -e "  ${CYAN}State:${NC}             ${state_color}$state${NC}"
    echo -e "  ${CYAN}Created:${NC}           ${WHITE}$time_created${NC}"
    echo -e "  ${CYAN}Finished:${NC}          ${WHITE}$time_finished${NC}"
    echo -e "  ${CYAN}Plan Resolution:${NC}   ${WHITE}$apply_job_plan_resolution${NC}"
    echo -e "  ${CYAN}Stack OCID:${NC}        ${YELLOW}$stack_id${NC}"
    echo -e "  ${CYAN}Job OCID:${NC}          ${YELLOW}$job_id${NC}"
    
    # Show failure details if present
    if [[ -n "$failure_details" && "$failure_details" != "null" ]]; then
        echo ""
        echo -e "${RED}Failure Details:${NC}"
        echo "$failure_details" | jq '.' 2>/dev/null || echo "$failure_details"
    fi
    
    echo ""
    echo -e "${GRAY}Options: ${WHITE}logs${NC} = view logs, ${WHITE}Enter${NC} = continue${NC}"
    echo -n -e "${CYAN}Selection: ${NC}"
    read -r action
    
    if [[ "$action" == "logs" ]]; then
        rm_show_job_logs "$job_id"
    fi
}

#--------------------------------------------------------------------------------
# View Job Details (with selection from list)
#--------------------------------------------------------------------------------
rm_view_job_details() {
    local compartment_id="$1"
    
    # First select a stack
    rm_list_stacks "$compartment_id" "false"
    
    if [[ ${RM_STACK_COUNT:-0} -eq 0 ]]; then
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Enter stack # to view its jobs (or Enter to cancel): ${NC}"
    read -r stack_selection
    
    if [[ -z "$stack_selection" ]]; then
        return
    fi
    
    if [[ -z "${RM_STACK_MAP[$stack_selection]}" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return
    fi
    
    local stack_id="${RM_STACK_MAP[$stack_selection]}"
    local stack_name="${RM_STACK_NAMES[$stack_selection]}"
    
    # Now list jobs for that stack
    echo ""
    echo -e "${BOLD}${WHITE}═══ Jobs for Stack: ${CYAN}${stack_name}${NC} ${BOLD}${WHITE}═══${NC}"
    echo ""
    
    local jobs_json
    jobs_json=$(oci resource-manager job list \
        --stack-id "$stack_id" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$jobs_json" || "$jobs_json" == "null" ]]; then
        echo -e "${YELLOW}No jobs found${NC}"
        return
    fi
    
    local job_count
    job_count=$(echo "$jobs_json" | jq '.data | length' 2>/dev/null)
    
    if [[ "$job_count" -eq 0 ]]; then
        echo -e "${YELLOW}No jobs found for this stack${NC}"
        return
    fi
    
    echo -e "${GREEN}Found $job_count job(s)${NC}"
    echo ""
    
    printf "${BOLD}%-3s %-12s %-12s %-20s %s${NC}\n" "#" "Operation" "State" "Time Created" "Job OCID"
    print_separator 160
    
    local idx=0
    declare -gA RM_JOB_MAP
    RM_JOB_MAP=()
    
    while IFS='|' read -r operation state time_created job_id; do
        [[ -z "$operation" ]] && continue
        ((idx++))
        
        RM_JOB_MAP[$idx]="$job_id"
        
        local state_color="$GREEN"
        case "$state" in
            SUCCEEDED) state_color="$GREEN" ;;
            IN_PROGRESS|ACCEPTED) state_color="$YELLOW" ;;
            FAILED|CANCELED) state_color="$RED" ;;
            *) state_color="$GRAY" ;;
        esac
        
        local op_color="$WHITE"
        case "$operation" in
            APPLY) op_color="$GREEN" ;;
            PLAN) op_color="$CYAN" ;;
            DESTROY) op_color="$RED" ;;
            IMPORT_TF_STATE) op_color="$YELLOW" ;;
        esac
        
        local time_short="${time_created:0:19}"
        
        printf "${YELLOW}%-3s${NC} ${op_color}%-12s${NC} ${state_color}%-12s${NC} %-20s ${GRAY}%s${NC}\n" \
            "$idx" "$operation" "$state" "$time_short" "$job_id"
            
    done < <(echo "$jobs_json" | jq -r '.data | sort_by(.["time-created"]) | reverse | .[] | "\(.operation)|\(.["lifecycle-state"])|\(.["time-created"])|\(.id)"' 2>/dev/null)
    
    echo ""
    echo -n -e "${CYAN}Enter job # to view details (or Enter to cancel): ${NC}"
    read -r job_selection
    
    if [[ -n "$job_selection" && -n "${RM_JOB_MAP[$job_selection]}" ]]; then
        rm_show_job_detail "${RM_JOB_MAP[$job_selection]}"
    elif [[ -n "$job_selection" ]]; then
        echo -e "${RED}Invalid selection${NC}"
    fi
}

#--------------------------------------------------------------------------------
# View Job Logs (with selection)
#--------------------------------------------------------------------------------
rm_view_job_logs() {
    local compartment_id="$1"
    
    # First select a stack
    rm_list_stacks "$compartment_id" "false"
    
    if [[ ${RM_STACK_COUNT:-0} -eq 0 ]]; then
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Enter stack # to view its jobs (or Enter to cancel): ${NC}"
    read -r stack_selection
    
    if [[ -z "$stack_selection" ]]; then
        return
    fi
    
    if [[ -z "${RM_STACK_MAP[$stack_selection]}" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return
    fi
    
    local stack_id="${RM_STACK_MAP[$stack_selection]}"
    local stack_name="${RM_STACK_NAMES[$stack_selection]}"
    
    # List jobs
    echo ""
    echo -e "${BOLD}${WHITE}═══ Jobs for Stack: ${CYAN}${stack_name}${NC} ${BOLD}${WHITE}═══${NC}"
    echo ""
    
    local jobs_json
    jobs_json=$(oci resource-manager job list \
        --stack-id "$stack_id" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$jobs_json" || "$jobs_json" == "null" ]]; then
        echo -e "${YELLOW}No jobs found${NC}"
        return
    fi
    
    local job_count
    job_count=$(echo "$jobs_json" | jq '.data | length' 2>/dev/null)
    
    if [[ "$job_count" -eq 0 ]]; then
        echo -e "${YELLOW}No jobs found for this stack${NC}"
        return
    fi
    
    echo -e "${GREEN}Found $job_count job(s)${NC}"
    echo ""
    
    printf "${BOLD}%-3s %-12s %-12s %-20s %s${NC}\n" "#" "Operation" "State" "Time Created" "Job OCID"
    print_separator 160
    
    local idx=0
    declare -gA RM_JOB_MAP
    RM_JOB_MAP=()
    
    while IFS='|' read -r operation state time_created job_id; do
        [[ -z "$operation" ]] && continue
        ((idx++))
        
        RM_JOB_MAP[$idx]="$job_id"
        
        local state_color="$GREEN"
        case "$state" in
            SUCCEEDED) state_color="$GREEN" ;;
            IN_PROGRESS|ACCEPTED) state_color="$YELLOW" ;;
            FAILED|CANCELED) state_color="$RED" ;;
            *) state_color="$GRAY" ;;
        esac
        
        local op_color="$WHITE"
        case "$operation" in
            APPLY) op_color="$GREEN" ;;
            PLAN) op_color="$CYAN" ;;
            DESTROY) op_color="$RED" ;;
            IMPORT_TF_STATE) op_color="$YELLOW" ;;
        esac
        
        local time_short="${time_created:0:19}"
        
        printf "${YELLOW}%-3s${NC} ${op_color}%-12s${NC} ${state_color}%-12s${NC} %-20s ${GRAY}%s${NC}\n" \
            "$idx" "$operation" "$state" "$time_short" "$job_id"
            
    done < <(echo "$jobs_json" | jq -r '.data | sort_by(.["time-created"]) | reverse | .[] | "\(.operation)|\(.["lifecycle-state"])|\(.["time-created"])|\(.id)"' 2>/dev/null)
    
    echo ""
    echo -n -e "${CYAN}Enter job # to view logs (or Enter to cancel): ${NC}"
    read -r job_selection
    
    if [[ -n "$job_selection" && -n "${RM_JOB_MAP[$job_selection]}" ]]; then
        rm_show_job_logs "${RM_JOB_MAP[$job_selection]}"
    elif [[ -n "$job_selection" ]]; then
        echo -e "${RED}Invalid selection${NC}"
    fi
}

rm_show_job_logs() {
    local job_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Job Logs ═══${NC}"
    echo ""
    
    local logs_cmd="oci resource-manager job get-job-logs --job-id \"$job_id\" --all"
    echo -e "${GRAY}$logs_cmd${NC}"
    echo ""
    
    # Get logs
    local logs_json
    logs_json=$(oci resource-manager job get-job-logs \
        --job-id "$job_id" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$logs_json" || "$logs_json" == "null" ]]; then
        echo -e "${YELLOW}No logs found or unable to retrieve logs${NC}"
        return
    fi
    
    local log_count
    log_count=$(echo "$logs_json" | jq '.data | length' 2>/dev/null)
    
    echo -e "${GREEN}Retrieved $log_count log entries${NC}"
    echo ""
    
    # Display logs with timestamp and level
    echo "$logs_json" | jq -r '.data[] | "\(.timestamp) [\(.level)] \(.message)"' 2>/dev/null | while read -r line; do
        # Color based on level in the line
        if [[ "$line" == *"[ERROR]"* ]]; then
            echo -e "${RED}$line${NC}"
        elif [[ "$line" == *"[WARN]"* ]]; then
            echo -e "${YELLOW}$line${NC}"
        elif [[ "$line" == *"[INFO]"* ]]; then
            echo -e "${WHITE}$line${NC}"
        else
            echo "$line"
        fi
    done | less -R
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# View Stack Outputs
#--------------------------------------------------------------------------------
rm_view_stack_outputs() {
    local compartment_id="$1"
    
    # List stacks first
    rm_list_stacks "$compartment_id" "false"
    
    if [[ ${RM_STACK_COUNT:-0} -eq 0 ]]; then
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Enter stack # to view outputs (or Enter to cancel): ${NC}"
    read -r stack_selection
    
    if [[ -z "$stack_selection" ]]; then
        return
    fi
    
    if [[ -z "${RM_STACK_MAP[$stack_selection]}" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return
    fi
    
    local stack_id="${RM_STACK_MAP[$stack_selection]}"
    local stack_name="${RM_STACK_NAMES[$stack_selection]}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Stack Outputs: ${CYAN}${stack_name}${NC} ${BOLD}${WHITE}═══${NC}"
    echo ""
    
    local outputs_cmd="oci resource-manager stack list-terraform-outputs --stack-id \"$stack_id\" --all --output json"
    echo -e "${GRAY}$outputs_cmd${NC}"
    echo ""
    
    # Try the outputs endpoint
    local tf_outputs
    tf_outputs=$(oci resource-manager stack list-terraform-outputs \
        --stack-id "$stack_id" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -n "$tf_outputs" && "$tf_outputs" != "null" ]]; then
        local output_count
        output_count=$(echo "$tf_outputs" | jq '.data | length' 2>/dev/null)
        
        if [[ "$output_count" -gt 0 ]]; then
            echo -e "${GREEN}Found $output_count output(s)${NC}"
            echo ""
            
            printf "${BOLD}%-40s %-12s %s${NC}\n" "Output Name" "Sensitive" "Value"
            print_separator 100
            
            echo "$tf_outputs" | jq -r '.data[] | "\(.["output-name"])|\(.["is-sensitive"])|\(.["output-value"])"' 2>/dev/null | while IFS='|' read -r name sensitive value; do
                local name_trunc="${name:0:38}"
                local sens_color="$WHITE"
                local value_display
                if [[ "$sensitive" == "true" ]]; then
                    sens_color="$RED"
                    value_display="${RED}[SENSITIVE - hidden]${NC}"
                else
                    value_display="${value:0:80}"
                    [[ ${#value} -gt 80 ]] && value_display="${value_display}..."
                fi
                printf "%-40s ${sens_color}%-12s${NC} %s\n" "$name_trunc" "$sensitive" "$value_display"
            done
        else
            echo -e "${YELLOW}No outputs defined for this stack${NC}"
        fi
    else
        echo -e "${YELLOW}Unable to retrieve outputs. The stack may not have been applied yet.${NC}"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# View Stack State
#--------------------------------------------------------------------------------
rm_view_stack_state() {
    local compartment_id="$1"
    
    # List stacks first
    rm_list_stacks "$compartment_id" "false"
    
    if [[ ${RM_STACK_COUNT:-0} -eq 0 ]]; then
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Enter stack # to view state (or Enter to cancel): ${NC}"
    read -r stack_selection
    
    if [[ -z "$stack_selection" ]]; then
        return
    fi
    
    if [[ -z "${RM_STACK_MAP[$stack_selection]}" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return
    fi
    
    local stack_id="${RM_STACK_MAP[$stack_selection]}"
    local stack_name="${RM_STACK_NAMES[$stack_selection]}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Terraform State: ${CYAN}${stack_name}${NC} ${BOLD}${WHITE}═══${NC}"
    echo ""
    
    local state_cmd="oci resource-manager stack get-stack-tf-state --stack-id \"$stack_id\" --file -"
    echo -e "${GRAY}$state_cmd${NC}"
    echo ""
    
    echo -e "${YELLOW}Note: This retrieves the Terraform state file. It may contain sensitive information.${NC}"
    echo -n -e "${CYAN}Continue? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        return
    fi
    
    echo ""
    
    # Get state and pipe through jq for pretty printing, then to less
    oci resource-manager stack get-stack-tf-state \
        --stack-id "$stack_id" \
        --file - 2>/dev/null | jq '.' 2>/dev/null | less -R
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# List Stack Resources
#--------------------------------------------------------------------------------
rm_list_stack_resources() {
    local compartment_id="$1"
    
    # List stacks first
    rm_list_stacks "$compartment_id" "false"
    
    if [[ ${RM_STACK_COUNT:-0} -eq 0 ]]; then
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Enter stack # to list resources (or Enter to cancel): ${NC}"
    read -r stack_selection
    
    if [[ -z "$stack_selection" ]]; then
        return
    fi
    
    if [[ -z "${RM_STACK_MAP[$stack_selection]}" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return
    fi
    
    local stack_id="${RM_STACK_MAP[$stack_selection]}"
    local stack_name="${RM_STACK_NAMES[$stack_selection]}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Resources Managed by: ${CYAN}${stack_name}${NC} ${BOLD}${WHITE}═══${NC}"
    echo ""
    
    local resources_cmd="oci resource-manager associated-resource-summary list-stack-associated-resources --stack-id \"$stack_id\" --all --output json"
    echo -e "${GRAY}$resources_cmd${NC}"
    echo ""
    
    local resources_json
    resources_json=$(oci resource-manager associated-resource-summary list-stack-associated-resources \
        --stack-id "$stack_id" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$resources_json" || "$resources_json" == "null" ]]; then
        echo -e "${YELLOW}No resources found or unable to list resources${NC}"
        echo -e "${GRAY}Note: Resources are only tracked after a successful apply.${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local resource_count
    resource_count=$(echo "$resources_json" | jq '.data.items | length' 2>/dev/null)
    
    if [[ "$resource_count" -eq 0 || -z "$resource_count" ]]; then
        echo -e "${YELLOW}No resources found for this stack${NC}"
        echo -e "${GRAY}Note: Resources are only tracked after a successful apply.${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo -e "${GREEN}Found $resource_count resource(s)${NC}"
    echo ""
    
    # Print header
    printf "${BOLD}%-3s %-30s %-40s %s${NC}\n" "#" "Resource Type" "Resource Name" "Resource OCID"
    print_separator 180
    
    local idx=0
    echo "$resources_json" | jq -r '.data.items[] | "\(.["resource-type"])|\(.["resource-name"] // "N/A")|\(.["resource-id"])"' 2>/dev/null | while IFS='|' read -r res_type res_name res_id; do
        ((idx++))
        
        # Truncate for display
        local type_trunc="${res_type:0:28}"
        local name_trunc="${res_name:0:38}"
        [[ ${#res_name} -gt 38 ]] && name_trunc="${name_trunc}.."
        
        printf "${YELLOW}%-3s${NC} %-30s %-40s ${GRAY}%s${NC}\n" "$idx" "$type_trunc" "$name_trunc" "$res_id"
    done
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#================================================================================
# WORK REQUESTS MANAGEMENT
#================================================================================

#--------------------------------------------------------------------------------
# Manage Work Requests - Main menu
#--------------------------------------------------------------------------------
manage_work_requests() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local _wr_filter=""
    local _wr_filter_file="${TEMP_DIR}/.wr_next_filter_$$"
    
    # Loop: re-display with current filter until user exits
    while true; do
        # Write current filter to file so the function can update it
        echo "$_wr_filter" > "$_wr_filter_file"
        
        wr_list_work_requests_interactive "$compartment_id" "$_wr_filter" "$_wr_filter_file"
        local _wr_rc=$?
        
        # Check return: 0=back, 2=re-filter (new filter in temp file)
        if [[ $_wr_rc -eq 2 ]]; then
            _wr_filter=$(cat "$_wr_filter_file" 2>/dev/null)
            continue
        else
            rm -f "$_wr_filter_file"
            return 0
        fi
    done
}

#--------------------------------------------------------------------------------
# List Work Requests with Interactive Selection
#--------------------------------------------------------------------------------
wr_list_work_requests_interactive() {
    local compartment_id="$1"
    local status_filter="${2:-}"
    local filter_file="${3:-}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${WHITE}                                          WORK REQUESTS                                                          ${NC}"
    echo -e "${BOLD}${WHITE}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    local list_cmd="oci work-requests work-request list --compartment-id \"$compartment_id\" --all --output json"
    local query_filter=""
    if [[ -n "$status_filter" ]]; then
        query_filter="--query \"data[?status=='${status_filter}']\""
        list_cmd="oci work-requests work-request list --compartment-id \"$compartment_id\" --all $query_filter --output json"
    fi
    echo -e "${GRAY}$list_cmd${NC}"
    echo ""
    
    local wr_json
    if [[ -n "$status_filter" ]]; then
        wr_json=$(oci work-requests work-request list \
            --compartment-id "$compartment_id" \
            --all \
            --query "data[?status=='${status_filter}']" \
            --output json 2>/dev/null)
    else
        wr_json=$(oci work-requests work-request list \
            --compartment-id "$compartment_id" \
            --all \
            --output json 2>/dev/null)
    fi
    
    if [[ -z "$wr_json" || "$wr_json" == "null" ]]; then
        echo -e "${YELLOW}No work requests found or unable to list work requests${NC}"
        echo ""
        echo -e "${GRAY}Press Enter to go back...${NC}"
        read -r
        return 0
    fi
    
    local wr_count
    # Handle both formats - with and without .data wrapper
    if echo "$wr_json" | jq -e '.data' &>/dev/null; then
        wr_count=$(echo "$wr_json" | jq '.data | length' 2>/dev/null)
    else
        wr_count=$(echo "$wr_json" | jq 'length' 2>/dev/null)
    fi
    
    if [[ "$wr_count" -eq 0 || -z "$wr_count" ]]; then
        echo -e "${YELLOW}No work requests found${NC}"
        [[ -n "$status_filter" ]] && echo -e "${CYAN}Filter: ${WHITE}$status_filter${NC}"
        echo ""
        if [[ -n "$status_filter" ]]; then
            echo -e "${GRAY}Press Enter to clear filter, or 'b' to go back...${NC}"
            local _empty_choice
            read -r _empty_choice
            if [[ "$_empty_choice" == "b" || "$_empty_choice" == "B" ]]; then
                return 0
            fi
            [[ -n "$filter_file" ]] && echo "" > "$filter_file"
            return 2
        fi
        echo -e "${GRAY}Press Enter to go back...${NC}"
        read -r
        return 0
    fi
    
    echo -e "${GREEN}Found $wr_count work request(s)${NC}"
    [[ -n "$status_filter" ]] && echo -e "${CYAN}Filtered by status: ${WHITE}$status_filter${NC}"
    echo ""
    
    # Print header
    printf "${BOLD}%-6s %-40s %-15s %-6s %-20s %s${NC}\n" "ID" "Operation Type" "Status" "%" "Time Started" "Work Request OCID"
    print_separator 180
    
    local idx=0
    # Clear and populate global work request map
    declare -gA WR_MAP
    WR_MAP=()
    
    # Handle both formats - with and without .data wrapper
    local jq_path=".data"
    if ! echo "$wr_json" | jq -e '.data' &>/dev/null; then
        jq_path="."
    fi
    
    while IFS='|' read -r operation_type status percent_complete time_started wr_id; do
        [[ -z "$operation_type" ]] && continue
        ((idx++))
        
        WR_MAP[$idx]="$wr_id"
        
        # Color based on status
        local status_color="$GREEN"
        case "$status" in
            SUCCEEDED|COMPLETED) status_color="$GREEN" ;;
            IN_PROGRESS|ACCEPTED) status_color="$YELLOW" ;;
            FAILED|CANCELED|CANCELING) status_color="$RED" ;;
            *) status_color="$GRAY" ;;
        esac
        
        # Truncate operation type if needed
        local op_trunc="${operation_type:0:38}"
        [[ ${#operation_type} -gt 38 ]] && op_trunc="${op_trunc}.."
        
        # Format time
        local time_short="${time_started:0:19}"
        
        # Format percentage
        local pct_display="${percent_complete:-0}"
        
        printf "${YELLOW}[w%-3s]${NC} %-40s ${status_color}%-15s${NC} %-6s %-20s ${GRAY}%s${NC}\n" \
            "$idx" "$op_trunc" "$status" "${pct_display}%" "$time_short" "$wr_id"
            
    done < <(echo "$wr_json" | jq -r "${jq_path} | sort_by(.[\"time-started\"]) | reverse | .[] | \"\(.[\"operation-type\"])|\(.status)|\(.[\"percent-complete\"])|\(.[\"time-started\"])|\(.id)\"" 2>/dev/null)
    
    echo ""
    
    # Store count
    WR_COUNT=$idx
    
    # Interactive selection loop
    while true; do
        echo -e "${BOLD}${WHITE}─── Selection Options ───${NC}"
        echo -e "  ${YELLOW}w#${NC}        - View work request details (e.g., ${YELLOW}w1${NC})"
        echo -e "  ${YELLOW}w#e${NC}       - View work request errors (e.g., ${YELLOW}w1e${NC})"
        echo -e "  ${YELLOW}w#l${NC}       - View work request logs (e.g., ${YELLOW}w1l${NC})"
        echo -e "  ${YELLOW}w#r${NC}       - View affected resources (e.g., ${YELLOW}w1r${NC})"
        echo -e "  ${CYAN}filter${NC}    - Filter by status: ${RED}f${NC}=FAILED  ${YELLOW}p${NC}=IN_PROGRESS  ${GREEN}s${NC}=SUCCEEDED  ${WHITE}a${NC}=ALL"
        echo -e "  ${MAGENTA}r${NC}         - Reload work requests"
        echo -e "  ${CYAN}b${NC}         - Back to main menu"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Work Requests] Selection: ${NC}"
        read -r selection
        
        [[ -z "$selection" || "$selection" == "b" || "$selection" == "B" ]] && return 0
        
        # Refresh (with current filter)
        if [[ "$selection" == "r" || "$selection" == "R" || "$selection" == "refresh" ]]; then
            [[ -n "$filter_file" ]] && echo "$status_filter" > "$filter_file"
            return 2
        fi
        
        # Filter commands (abbreviations and full names) - always re-query full list with new filter
        if [[ "$selection" == "f" || "$selection" == "F" || "$selection" == "failed" ]]; then
            [[ -n "$filter_file" ]] && echo "FAILED" > "$filter_file"
            return 2
        fi
        if [[ "$selection" == "p" || "$selection" == "P" || "$selection" == "progress" ]]; then
            [[ -n "$filter_file" ]] && echo "IN_PROGRESS" > "$filter_file"
            return 2
        fi
        if [[ "$selection" == "s" || "$selection" == "S" || "$selection" == "succeeded" ]]; then
            [[ -n "$filter_file" ]] && echo "SUCCEEDED" > "$filter_file"
            return 2
        fi
        if [[ "$selection" == "a" || "$selection" == "A" || "$selection" == "all" ]]; then
            [[ -n "$filter_file" ]] && echo "" > "$filter_file"
            return 2
        fi
        
        # Work request details: w#
        if [[ "$selection" =~ ^w([0-9]+)$ ]]; then
            local sel_wr="${BASH_REMATCH[1]}"
            if [[ -n "${WR_MAP[$sel_wr]}" ]]; then
                wr_show_work_request_detail "${WR_MAP[$sel_wr]}"
            else
                echo -e "${RED}Invalid work request number: w${sel_wr}${NC}"
            fi
            continue
        fi
        
        # Work request errors: w#e
        if [[ "$selection" =~ ^w([0-9]+)e$ ]]; then
            local sel_wr="${BASH_REMATCH[1]}"
            if [[ -n "${WR_MAP[$sel_wr]}" ]]; then
                wr_show_work_request_errors "${WR_MAP[$sel_wr]}"
            else
                echo -e "${RED}Invalid work request number: w${sel_wr}${NC}"
            fi
            continue
        fi
        
        # Work request logs: w#l
        if [[ "$selection" =~ ^w([0-9]+)l$ ]]; then
            local sel_wr="${BASH_REMATCH[1]}"
            if [[ -n "${WR_MAP[$sel_wr]}" ]]; then
                wr_show_work_request_logs "${WR_MAP[$sel_wr]}"
            else
                echo -e "${RED}Invalid work request number: w${sel_wr}${NC}"
            fi
            continue
        fi
        
        # Work request resources: w#r
        if [[ "$selection" =~ ^w([0-9]+)r$ ]]; then
            local sel_wr="${BASH_REMATCH[1]}"
            if [[ -n "${WR_MAP[$sel_wr]}" ]]; then
                wr_show_work_request_resources "${WR_MAP[$sel_wr]}"
            else
                echo -e "${RED}Invalid work request number: w${sel_wr}${NC}"
            fi
            continue
        fi
        
        echo -e "${RED}Invalid selection. Use w# for work requests${NC}"
    done
    
    return 0
}

#--------------------------------------------------------------------------------
# Show Work Request Resources
#--------------------------------------------------------------------------------
wr_show_work_request_resources() {
    local wr_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Work Request Affected Resources ═══${NC}"
    echo ""
    
    local get_cmd="oci work-requests work-request get --work-request-id \"$wr_id\" --output json"
    echo -e "${GRAY}$get_cmd${NC}"
    echo ""
    
    local wr_json
    wr_json=$(oci work-requests work-request get --work-request-id "$wr_id" --output json 2>/dev/null)
    
    if [[ -z "$wr_json" || "$wr_json" == "null" ]]; then
        echo -e "${RED}Failed to get work request details${NC}"
        return
    fi
    
    # Get resources
    local resources
    resources=$(echo "$wr_json" | jq -r '.data.resources // []' 2>/dev/null)
    
    local res_count
    res_count=$(echo "$resources" | jq 'length' 2>/dev/null) || res_count=0
    
    if [[ "$res_count" -eq 0 ]]; then
        echo -e "${YELLOW}No affected resources found${NC}"
        return
    fi
    
    echo -e "${GREEN}Found $res_count affected resource(s)${NC}"
    echo ""
    
    printf "${BOLD}%-20s %-20s %s${NC}\n" "Action Type" "Entity Type" "Resource OCID"
    print_separator 140
    
    echo "$resources" | jq -r '.[] | "\(.["action-type"] // "N/A")|\(.["entity-type"] // "N/A")|\(.identifier // "N/A")"' 2>/dev/null | while IFS='|' read -r action_type entity_type identifier; do
        # Color based on action type
        local action_color="$WHITE"
        case "$action_type" in
            CREATED) action_color="$GREEN" ;;
            UPDATED) action_color="$YELLOW" ;;
            DELETED) action_color="$RED" ;;
            IN_PROGRESS) action_color="$CYAN" ;;
        esac
        
        printf "${action_color}%-20s${NC} %-20s ${GRAY}%s${NC}\n" "$action_type" "$entity_type" "$identifier"
    done
    
    echo ""
}

#--------------------------------------------------------------------------------
# List Work Requests
#--------------------------------------------------------------------------------
wr_list_work_requests() {
    local compartment_id="$1"
    local status_filter="${2:-}"
    local action_on_select="${3:-none}"  # none, details, errors, logs
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Work Requests ═══${NC}"
    echo ""
    
    local list_cmd="oci work-requests work-request list --compartment-id \"$compartment_id\" --all --output json"
    [[ -n "$status_filter" ]] && list_cmd="oci work-requests work-request list --compartment-id \"$compartment_id\" --status \"$status_filter\" --all --output json"
    echo -e "${GRAY}$list_cmd${NC}"
    echo ""
    
    local wr_json
    if [[ -n "$status_filter" ]]; then
        wr_json=$(oci work-requests work-request list \
            --compartment-id "$compartment_id" \
            --status "$status_filter" \
            --all \
            --output json 2>/dev/null)
    else
        wr_json=$(oci work-requests work-request list \
            --compartment-id "$compartment_id" \
            --all \
            --output json 2>/dev/null)
    fi
    
    if [[ -z "$wr_json" || "$wr_json" == "null" ]]; then
        echo -e "${YELLOW}No work requests found or unable to list work requests${NC}"
        return 1
    fi
    
    local wr_count
    wr_count=$(echo "$wr_json" | jq '.data | length' 2>/dev/null)
    
    if [[ "$wr_count" -eq 0 ]]; then
        echo -e "${YELLOW}No work requests found${NC}"
        return 1
    fi
    
    echo -e "${GREEN}Found $wr_count work request(s)${NC}"
    [[ -n "$status_filter" ]] && echo -e "${CYAN}Filtered by status: ${WHITE}$status_filter${NC}"
    echo ""
    
    # Print header
    printf "${BOLD}%-3s %-40s %-15s %-6s %-20s %s${NC}\n" "#" "Operation Type" "Status" "%" "Time Started" "Work Request OCID"
    print_separator 180
    
    local idx=0
    # Clear and populate global work request map
    declare -gA WR_MAP
    WR_MAP=()
    
    while IFS='|' read -r operation_type status percent_complete time_started wr_id; do
        [[ -z "$operation_type" ]] && continue
        ((idx++))
        
        WR_MAP[$idx]="$wr_id"
        
        # Color based on status
        local status_color="$GREEN"
        case "$status" in
            SUCCEEDED|COMPLETED) status_color="$GREEN" ;;
            IN_PROGRESS|ACCEPTED) status_color="$YELLOW" ;;
            FAILED|CANCELED|CANCELING) status_color="$RED" ;;
            *) status_color="$GRAY" ;;
        esac
        
        # Truncate operation type if needed
        local op_trunc="${operation_type:0:38}"
        [[ ${#operation_type} -gt 38 ]] && op_trunc="${op_trunc}.."
        
        # Format time
        local time_short="${time_started:0:19}"
        
        # Format percentage
        local pct_display="${percent_complete:-0}"
        
        printf "${YELLOW}%-3s${NC} %-40s ${status_color}%-15s${NC} %-6s %-20s ${GRAY}%s${NC}\n" \
            "$idx" "$op_trunc" "$status" "${pct_display}%" "$time_short" "$wr_id"
            
    done < <(echo "$wr_json" | jq -r '.data | sort_by(.["time-started"]) | reverse | .[] | "\(.["operation-type"])|\(.status)|\(.["percent-complete"])|\(.["time-started"])|\(.id)"' 2>/dev/null)
    
    echo ""
    
    # Store count
    WR_COUNT=$idx
    
    # Handle selection based on action type
    case "$action_on_select" in
        none)
            echo -e "Press Enter to continue..."
            read -r
            ;;
        details)
            echo -n -e "${CYAN}Enter work request # to view details (or Enter to cancel): ${NC}"
            read -r wr_selection
            if [[ -n "$wr_selection" && -n "${WR_MAP[$wr_selection]}" ]]; then
                wr_show_work_request_detail "${WR_MAP[$wr_selection]}"
            elif [[ -n "$wr_selection" ]]; then
                echo -e "${RED}Invalid selection${NC}"
            fi
            ;;
        errors)
            echo -n -e "${CYAN}Enter work request # to view errors (or Enter to cancel): ${NC}"
            read -r wr_selection
            if [[ -n "$wr_selection" && -n "${WR_MAP[$wr_selection]}" ]]; then
                wr_show_work_request_errors "${WR_MAP[$wr_selection]}"
            elif [[ -n "$wr_selection" ]]; then
                echo -e "${RED}Invalid selection${NC}"
            fi
            ;;
        logs)
            echo -n -e "${CYAN}Enter work request # to view logs (or Enter to cancel): ${NC}"
            read -r wr_selection
            if [[ -n "$wr_selection" && -n "${WR_MAP[$wr_selection]}" ]]; then
                wr_show_work_request_logs "${WR_MAP[$wr_selection]}"
            elif [[ -n "$wr_selection" ]]; then
                echo -e "${RED}Invalid selection${NC}"
            fi
            ;;
    esac
    
    return 0
}

#--------------------------------------------------------------------------------
# Show Work Request Details
#--------------------------------------------------------------------------------
wr_show_work_request_detail() {
    local wr_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Work Request Details ═══${NC}"
    echo ""
    
    local get_cmd="oci work-requests work-request get --work-request-id \"$wr_id\" --output json"
    echo -e "${GRAY}$get_cmd${NC}"
    echo ""
    
    local wr_json
    wr_json=$(oci work-requests work-request get \
        --work-request-id "$wr_id" \
        --output json 2>/dev/null)
    
    if [[ -z "$wr_json" || "$wr_json" == "null" ]]; then
        echo -e "${RED}Failed to get work request details${NC}"
        return
    fi
    
    # Extract fields
    local operation_type status percent_complete time_accepted time_started time_finished
    operation_type=$(echo "$wr_json" | jq -r '.data["operation-type"] // "N/A"')
    status=$(echo "$wr_json" | jq -r '.data.status // "N/A"')
    percent_complete=$(echo "$wr_json" | jq -r '.data["percent-complete"] // "0"')
    time_accepted=$(echo "$wr_json" | jq -r '.data["time-accepted"] // "N/A"')
    time_started=$(echo "$wr_json" | jq -r '.data["time-started"] // "N/A"')
    time_finished=$(echo "$wr_json" | jq -r '.data["time-finished"] // "N/A"')
    
    # Status color
    local status_color="$GREEN"
    case "$status" in
        SUCCEEDED|COMPLETED) status_color="$GREEN" ;;
        IN_PROGRESS|ACCEPTED) status_color="$YELLOW" ;;
        FAILED|CANCELED|CANCELING) status_color="$RED" ;;
    esac
    
    echo -e "  ${CYAN}Operation Type:${NC}    ${WHITE}$operation_type${NC}"
    echo -e "  ${CYAN}Status:${NC}            ${status_color}$status${NC}"
    echo -e "  ${CYAN}Progress:${NC}          ${WHITE}${percent_complete}%${NC}"
    echo -e "  ${CYAN}Time Accepted:${NC}     ${WHITE}$time_accepted${NC}"
    echo -e "  ${CYAN}Time Started:${NC}      ${WHITE}$time_started${NC}"
    echo -e "  ${CYAN}Time Finished:${NC}     ${WHITE}$time_finished${NC}"
    echo -e "  ${CYAN}Work Request OCID:${NC} ${YELLOW}$wr_id${NC}"
    echo ""
    
    # Show resources affected
    local resources
    resources=$(echo "$wr_json" | jq -r '.data.resources // []')
    if [[ "$resources" != "[]" && "$resources" != "null" ]]; then
        echo -e "${BOLD}${WHITE}Resources Affected:${NC}"
        echo ""
        printf "  ${BOLD}%-20s %-15s %s${NC}\n" "Entity Type" "Action" "Resource OCID"
        print_separator 140
        echo "$wr_json" | jq -r '.data.resources[] | "\(.["entity-type"])|\(.["action-type"])|\(.identifier)"' 2>/dev/null | while IFS='|' read -r entity_type action_type identifier; do
            local action_color="$WHITE"
            case "$action_type" in
                CREATED) action_color="$GREEN" ;;
                UPDATED|IN_PROGRESS) action_color="$YELLOW" ;;
                DELETED) action_color="$RED" ;;
            esac
            printf "  %-20s ${action_color}%-15s${NC} ${GRAY}%s${NC}\n" "$entity_type" "$action_type" "$identifier"
        done
        echo ""
    fi
    
    echo -e "${GRAY}Options: ${WHITE}errors${NC} = view errors, ${WHITE}logs${NC} = view logs, ${WHITE}Enter${NC} = continue${NC}"
    echo -n -e "${CYAN}Selection: ${NC}"
    read -r action
    
    case "$action" in
        errors|ERRORS|e|E)
            wr_show_work_request_errors "$wr_id"
            ;;
        logs|LOGS|l|L)
            wr_show_work_request_logs "$wr_id"
            ;;
    esac
}

#--------------------------------------------------------------------------------
# View Work Request Errors (called directly from show_detail)
#--------------------------------------------------------------------------------

wr_show_work_request_errors() {
    local wr_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Work Request Errors ═══${NC}"
    echo ""
    
    local errors_cmd="oci work-requests work-request-error list --work-request-id \"$wr_id\" --all --output json"
    echo -e "${GRAY}$errors_cmd${NC}"
    echo ""
    
    local errors_json
    errors_json=$(oci work-requests work-request-error list \
        --work-request-id "$wr_id" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$errors_json" || "$errors_json" == "null" ]]; then
        echo -e "${YELLOW}No errors found or unable to retrieve errors${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local error_count
    error_count=$(echo "$errors_json" | jq '.data | length' 2>/dev/null)
    
    if [[ "$error_count" -eq 0 ]]; then
        echo -e "${GREEN}No errors found for this work request${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo -e "${RED}Found $error_count error(s)${NC}"
    echo ""
    
    # Display errors
    echo "$errors_json" | jq -r '.data[] | "\(.timestamp) [\(.code)] \(.message)"' 2>/dev/null | while read -r line; do
        echo -e "${RED}$line${NC}"
    done
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Show Work Request Logs (called directly from show_detail or menu)
#--------------------------------------------------------------------------------
wr_show_work_request_logs() {
    local wr_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Work Request Logs ═══${NC}"
    echo ""
    
    local logs_cmd="oci work-requests work-request-log-entry list --work-request-id \"$wr_id\" --all --output json"
    echo -e "${GRAY}$logs_cmd${NC}"
    echo ""
    
    local logs_json
    logs_json=$(oci work-requests work-request-log-entry list \
        --work-request-id "$wr_id" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$logs_json" || "$logs_json" == "null" ]]; then
        echo -e "${YELLOW}No logs found or unable to retrieve logs${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local log_count
    log_count=$(echo "$logs_json" | jq '.data | length' 2>/dev/null)
    
    if [[ "$log_count" -eq 0 ]]; then
        echo -e "${YELLOW}No log entries found for this work request${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo -e "${GREEN}Found $log_count log entries${NC}"
    echo ""
    
    # Display logs with timestamp
    echo "$logs_json" | jq -r '.data | sort_by(.timestamp) | .[] | "\(.timestamp) | \(.message)"' 2>/dev/null | while read -r line; do
        # Color based on content
        if [[ "$line" == *"error"* || "$line" == *"Error"* || "$line" == *"ERROR"* || "$line" == *"failed"* || "$line" == *"Failed"* ]]; then
            echo -e "${RED}$line${NC}"
        elif [[ "$line" == *"warn"* || "$line" == *"Warn"* || "$line" == *"WARN"* ]]; then
            echo -e "${YELLOW}$line${NC}"
        elif [[ "$line" == *"success"* || "$line" == *"Success"* || "$line" == *"completed"* || "$line" == *"Completed"* ]]; then
            echo -e "${GREEN}$line${NC}"
        else
            echo "$line"
        fi
    done | less -R
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Filter Work Requests by Status
#--------------------------------------------------------------------------------
wr_filter_by_status() {
    local compartment_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Filter Work Requests by Status ═══${NC}"
    echo ""
    echo -e "  ${GREEN}1${NC}) ${WHITE}ACCEPTED${NC}      - Work request accepted but not started"
    echo -e "  ${GREEN}2${NC}) ${WHITE}IN_PROGRESS${NC}   - Work request currently running"
    echo -e "  ${GREEN}3${NC}) ${WHITE}SUCCEEDED${NC}     - Work request completed successfully"
    echo -e "  ${GREEN}4${NC}) ${WHITE}FAILED${NC}        - Work request failed"
    echo -e "  ${GREEN}5${NC}) ${WHITE}CANCELING${NC}     - Work request being canceled"
    echo -e "  ${GREEN}6${NC}) ${WHITE}CANCELED${NC}      - Work request was canceled"
    echo ""
    echo -n -e "${CYAN}Enter status # (or Enter to cancel): ${NC}"
    read -r status_selection
    
    local status_filter=""
    case "$status_selection" in
        1) status_filter="ACCEPTED" ;;
        2) status_filter="IN_PROGRESS" ;;
        3) status_filter="SUCCEEDED" ;;
        4) status_filter="FAILED" ;;
        5) status_filter="CANCELING" ;;
        6) status_filter="CANCELED" ;;
        "") return ;;
        *)
            echo -e "${RED}Invalid selection${NC}"
            return
            ;;
    esac
    
    wr_list_work_requests "$compartment_id" "$status_filter" "details"
}

#--------------------------------------------------------------------------------
# Search Work Requests by Resource OCID
#--------------------------------------------------------------------------------
wr_search_by_resource() {
    local compartment_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Search Work Requests by Resource OCID ═══${NC}"
    echo ""
    echo -n -e "${CYAN}Enter Resource OCID to search: ${NC}"
    read -r resource_ocid
    
    if [[ -z "$resource_ocid" ]]; then
        echo -e "${YELLOW}No resource OCID provided${NC}"
        return
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Work Requests for Resource ═══${NC}"
    echo ""
    
    local search_cmd="oci work-requests work-request list --compartment-id \"$compartment_id\" --resource-id \"$resource_ocid\" --all --output json"
    echo -e "${GRAY}$search_cmd${NC}"
    echo ""
    
    local wr_json
    wr_json=$(oci work-requests work-request list \
        --compartment-id "$compartment_id" \
        --resource-id "$resource_ocid" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$wr_json" || "$wr_json" == "null" ]]; then
        echo -e "${YELLOW}No work requests found for this resource${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local wr_count
    wr_count=$(echo "$wr_json" | jq '.data | length' 2>/dev/null)
    
    if [[ "$wr_count" -eq 0 ]]; then
        echo -e "${YELLOW}No work requests found for this resource${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo -e "${GREEN}Found $wr_count work request(s) for resource${NC}"
    echo ""
    
    # Print header
    printf "${BOLD}%-3s %-40s %-15s %-6s %-20s %s${NC}\n" "#" "Operation Type" "Status" "%" "Time Started" "Work Request OCID"
    print_separator 180
    
    local idx=0
    declare -gA WR_MAP
    WR_MAP=()
    
    while IFS='|' read -r operation_type status percent_complete time_started wr_id; do
        [[ -z "$operation_type" ]] && continue
        ((idx++))
        
        WR_MAP[$idx]="$wr_id"
        
        local status_color="$GREEN"
        case "$status" in
            SUCCEEDED|COMPLETED) status_color="$GREEN" ;;
            IN_PROGRESS|ACCEPTED) status_color="$YELLOW" ;;
            FAILED|CANCELED|CANCELING) status_color="$RED" ;;
            *) status_color="$GRAY" ;;
        esac
        
        local op_trunc="${operation_type:0:38}"
        [[ ${#operation_type} -gt 38 ]] && op_trunc="${op_trunc}.."
        
        local time_short="${time_started:0:19}"
        local pct_display="${percent_complete:-0}"
        
        printf "${YELLOW}%-3s${NC} %-40s ${status_color}%-15s${NC} %-6s %-20s ${GRAY}%s${NC}\n" \
            "$idx" "$op_trunc" "$status" "${pct_display}%" "$time_short" "$wr_id"
            
    done < <(echo "$wr_json" | jq -r '.data | sort_by(.["time-started"]) | reverse | .[] | "\(.["operation-type"])|\(.status)|\(.["percent-complete"])|\(.["time-started"])|\(.id)"' 2>/dev/null)
    
    WR_COUNT=$idx
    
    echo ""
    echo -e "${GRAY}Enter work request # to view details, or press Enter to continue${NC}"
    echo -n -e "${CYAN}Selection: ${NC}"
    read -r wr_selection
    
    if [[ -n "$wr_selection" && -n "${WR_MAP[$wr_selection]}" ]]; then
        wr_show_work_request_detail "${WR_MAP[$wr_selection]}"
    fi
}

#================================================================================
# FILE STORAGE SERVICE (FSS) MANAGEMENT
#================================================================================

#--------------------------------------------------------------------------------
# Fetch and cache FSS data (file systems, mount targets, exports)
# Usage: fetch_fss_data <compartment_id> [force_refresh]
# Populates: FSS_FS_CACHE, FSS_MT_CACHE, FSS_EXPORT_CACHE
#--------------------------------------------------------------------------------
fetch_fss_data() {
    local compartment_id="$1"
    local force="${2:-false}"
    local cache_ttl=600  # 10 minutes
    
    # Check if all caches are fresh
    if [[ "$force" != "true" ]] && \
       is_cache_fresh "$FSS_FS_CACHE" "$cache_ttl" && \
       is_cache_fresh "$FSS_MT_CACHE" "$cache_ttl" && \
       is_cache_fresh "$FSS_EXPORT_CACHE" "$cache_ttl"; then
        log_info "Using cached FSS data..."
        return 0
    fi
    
    # Get availability domains
    local ads
    ads=$(fss_get_availability_domains "$compartment_id")
    if [[ -z "$ads" ]]; then
        echo -e "${RED}Unable to get availability domains${NC}" >&2
        return 1
    fi
    
    # Fetch file systems across all ADs
    echo -ne "  ${GRAY}Fetching file systems...${NC}"
    local all_fs_json="[]"
    while IFS= read -r ad; do
        [[ -z "$ad" ]] && continue
        local fs_json
        fs_json=$(oci fs file-system list \
            --compartment-id "$compartment_id" \
            --availability-domain "$ad" \
            --all \
            --output json 2>/dev/null)
        if [[ $? -eq 0 ]]; then
            local fs_data
            fs_data=$(echo "$fs_json" | jq '.data // []' 2>/dev/null)
            all_fs_json=$(echo "$all_fs_json" "$fs_data" | jq -s 'add' 2>/dev/null)
        fi
    done <<< "$ads"
    echo "{\"data\":$(echo "$all_fs_json" | jq '.')}" > "$FSS_FS_CACHE"
    local fs_count
    fs_count=$(echo "$all_fs_json" | jq 'length' 2>/dev/null) || fs_count=0
    echo -e "\r  ${GREEN}✓ File systems: ${fs_count} cached${NC}          "
    
    # Fetch mount targets across all ADs
    echo -ne "  ${GRAY}Fetching mount targets...${NC}"
    local all_mt_json="[]"
    while IFS= read -r ad; do
        [[ -z "$ad" ]] && continue
        local mt_json
        mt_json=$(oci fs mount-target list \
            --compartment-id "$compartment_id" \
            --availability-domain "$ad" \
            --all \
            --output json 2>/dev/null)
        if [[ $? -eq 0 ]]; then
            local mt_data
            mt_data=$(echo "$mt_json" | jq '.data // []' 2>/dev/null)
            all_mt_json=$(echo "$all_mt_json" "$mt_data" | jq -s 'add' 2>/dev/null)
        fi
    done <<< "$ads"
    echo "{\"data\":$(echo "$all_mt_json" | jq '.')}" > "$FSS_MT_CACHE"
    local mt_count
    mt_count=$(echo "$all_mt_json" | jq 'length' 2>/dev/null) || mt_count=0
    echo -e "\r  ${GREEN}✓ Mount targets: ${mt_count} cached${NC}          "
    
    # Fetch exports
    echo -ne "  ${GRAY}Fetching exports...${NC}"
    local all_export_json
    all_export_json=$(oci fs export list \
        --compartment-id "$compartment_id" \
        --all \
        --output json 2>/dev/null)
    if [[ $? -ne 0 ]]; then
        all_export_json='{"data":[]}'
    fi
    echo "$all_export_json" > "$FSS_EXPORT_CACHE"
    local export_count
    export_count=$(echo "$all_export_json" | jq '.data | length' 2>/dev/null) || export_count=0
    echo -e "\r  ${GREEN}✓ Exports: ${export_count} cached${NC}          "
}

#--------------------------------------------------------------------------------
# Get availability domains for compartment
#--------------------------------------------------------------------------------
fss_get_availability_domains() {
    local compartment_id="$1"
    
    local ad_json
    ad_json=$(oci iam availability-domain list --compartment-id "$compartment_id" --output json 2>&1)
    
    if [[ $? -ne 0 ]]; then
        echo -e "${RED}Error getting availability domains: $ad_json${NC}" >&2
        return 1
    fi
    
    echo "$ad_json" | jq -r '.data[].name' 2>/dev/null
}

#--------------------------------------------------------------------------------
# FSS - Guided Setup (File System → Mount Target → Export)
# Creates all three FSS components in sequence with a step-by-step wizard
#--------------------------------------------------------------------------------
fss_guided_setup() {
    local compartment_id="$1"
    local ad="$2"
    local log_file="${LOGS_DIR}/fss_actions_$(date +%Y%m%d).log"
    
    echo ""
    echo -e "${BOLD}${GREEN}══════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${GREEN}                        FSS GUIDED SETUP WIZARD                                    ${NC}"
    echo -e "${BOLD}${GREEN}══════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${WHITE}This wizard will guide you through creating:${NC}"
    echo -e "  ${YELLOW}Step 1/3${NC} - File System"
    echo -e "  ${YELLOW}Step 2/3${NC} - Mount Target"
    echo -e "  ${YELLOW}Step 3/3${NC} - Export (links File System to Mount Target)"
    echo ""
    echo -e "${GRAY}You can cancel at any step. Previously created resources will remain.${NC}"
    echo ""
    echo -n -e "${CYAN}Press Enter to begin (or 'q' to cancel): ${NC}"
    local start_confirm
    read -r start_confirm
    [[ "$start_confirm" == "q" || "$start_confirm" == "Q" ]] && return
    
    # ==================== STEP 1: Select Availability Domain ====================
    echo ""
    echo -e "${BOLD}${WHITE}─── Select Availability Domain ───${NC}"
    echo ""
    
    local selected_ad="$ad"
    if [[ -z "$selected_ad" ]]; then
        echo -e "${CYAN}Available Availability Domains:${NC}"
        local ads_json
        ads_json=$(oci iam availability-domain list --compartment-id "$compartment_id" --output json 2>/dev/null)
        
        local idx=0
        declare -A GUIDED_AD_MAP
        while read -r ad_name; do
            [[ -z "$ad_name" ]] && continue
            ((idx++))
            GUIDED_AD_MAP[$idx]="$ad_name"
            echo -e "  ${YELLOW}$idx${NC}) $ad_name"
        done < <(echo "$ads_json" | jq -r '.data[].name' 2>/dev/null)
        
        if [[ $idx -eq 0 ]]; then
            echo -e "${RED}No availability domains found${NC}"
            return
        fi
        
        echo ""
        echo -n -e "${CYAN}Select AD # (or 'q' to cancel): ${NC}"
        local ad_selection
        read -r ad_selection
        [[ "$ad_selection" == "q" || "$ad_selection" == "Q" ]] && return
        
        selected_ad="${GUIDED_AD_MAP[$ad_selection]}"
        if [[ -z "$selected_ad" ]]; then
            echo -e "${RED}Invalid selection${NC}"
            return
        fi
    fi
    
    local ad_short="${selected_ad##*:}"
    echo -e "  ${GREEN}✓${NC} Using AD: ${WHITE}${ad_short}${NC}"
    
    # ==================== STEP 1: Create File System ====================
    echo ""
    echo -e "${BOLD}${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}${YELLOW}  Step 1/3 │ Create File System                                                   ${NC}"
    echo -e "${BOLD}${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    
    echo -n -e "${CYAN}Enter display name for file system: ${NC}"
    local fs_name
    read -r fs_name
    
    if [[ -z "$fs_name" ]]; then
        echo -e "${RED}Display name is required. Wizard cancelled.${NC}"
        return
    fi
    
    echo ""
    local fs_create_cmd="oci fs file-system create --compartment-id \"$compartment_id\" --availability-domain \"$selected_ad\" --display-name \"$fs_name\""
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$fs_create_cmd${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Create file system '${fs_name}'? (y/N): ${NC}"
    local confirm
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Wizard cancelled at Step 1${NC}"
        return
    fi
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] GUIDED SETUP - CREATE FILE SYSTEM: $fs_create_cmd" >> "$log_file"
    echo ""
    echo -e "${CYAN}Creating file system...${NC}"
    
    local fs_result
    fs_result=$(oci fs file-system create \
        --compartment-id "$compartment_id" \
        --availability-domain "$selected_ad" \
        --display-name "$fs_name" \
        --output json 2>&1)
    
    local new_fs_id=""
    if echo "$fs_result" | jq -e '.data.id' > /dev/null 2>&1; then
        new_fs_id=$(echo "$fs_result" | jq -r '.data.id')
        echo -e "${GREEN}✓ File system created: ${WHITE}$fs_name${NC}"
        echo -e "  ${CYAN}OCID:${NC} ${GRAY}$new_fs_id${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created file system $new_fs_id" >> "$log_file"
    else
        echo -e "${RED}✗ Failed to create file system${NC}"
        echo "$fs_result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $fs_result" >> "$log_file"
        echo ""
        echo -e "${RED}Wizard stopped at Step 1. No resources were created.${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # ==================== STEP 2: Create Mount Target ====================
    echo ""
    echo -e "${BOLD}${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}${YELLOW}  Step 2/3 │ Create Mount Target                                                  ${NC}"
    echo -e "${BOLD}${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    
    # Option: use existing mount target or create new
    echo -e "${CYAN}Would you like to create a new mount target or use an existing one?${NC}"
    echo -e "  ${YELLOW}1${NC}) Create new mount target"
    echo -e "  ${YELLOW}2${NC}) Use existing mount target"
    echo -e "  ${CYAN}q${NC}) Cancel (file system already created)"
    echo ""
    echo -n -e "${CYAN}Select [1/2/q]: ${NC}"
    local mt_choice
    read -r mt_choice
    
    local new_mt_id=""
    local export_set_id=""
    
    if [[ "$mt_choice" == "2" ]]; then
        # Use existing mount target
        echo ""
        echo -e "${CYAN}Select an existing mount target:${NC}"
        FSS_SELECTED_MT=""
        fss_list_mount_targets "$compartment_id" "$selected_ad" "select"
        
        if [[ -z "$FSS_SELECTED_MT" ]]; then
            echo -e "${YELLOW}No mount target selected. Wizard stopped at Step 2.${NC}"
            echo -e "${WHITE}Created resources:${NC}"
            echo -e "  ${GREEN}✓${NC} File System: ${WHITE}$fs_name${NC} ${GRAY}($new_fs_id)${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
        
        new_mt_id="$FSS_SELECTED_MT"
        
        # Get export set ID from existing mount target
        local mt_json
        mt_json=$(oci fs mount-target get --mount-target-id "$new_mt_id" --output json 2>/dev/null)
        export_set_id=$(echo "$mt_json" | jq -r '.data["export-set-id"]')
        local mt_display_name
        mt_display_name=$(echo "$mt_json" | jq -r '.data["display-name"]')
        echo -e "${GREEN}✓ Using existing mount target: ${WHITE}$mt_display_name${NC}"
        
    elif [[ "$mt_choice" == "1" ]]; then
        # Create new mount target - select subnet
        echo ""
        echo -e "${CYAN}Available Subnets:${NC}"
        local subnets_json
        subnets_json=$(oci network subnet list --compartment-id "$compartment_id" --all --output json 2>/dev/null)
        
        local idx=0
        declare -A GUIDED_SUBNET_MAP
        while IFS='|' read -r subnet_name subnet_id cidr; do
            [[ -z "$subnet_name" ]] && continue
            ((idx++))
            GUIDED_SUBNET_MAP[$idx]="$subnet_id"
            echo -e "  ${YELLOW}$idx${NC}) $subnet_name (${cidr})"
        done < <(echo "$subnets_json" | jq -r '.data[] | "\(.["display-name"])|\(.id)|\(.["cidr-block"])"' 2>/dev/null)
        
        if [[ $idx -eq 0 ]]; then
            echo -e "${RED}No subnets found. Wizard stopped at Step 2.${NC}"
            echo -e "${WHITE}Created resources:${NC}"
            echo -e "  ${GREEN}✓${NC} File System: ${WHITE}$fs_name${NC} ${GRAY}($new_fs_id)${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
        
        echo ""
        echo -n -e "${CYAN}Select subnet #: ${NC}"
        local subnet_selection
        read -r subnet_selection
        local subnet_id="${GUIDED_SUBNET_MAP[$subnet_selection]}"
        
        if [[ -z "$subnet_id" ]]; then
            echo -e "${RED}Invalid selection. Wizard stopped at Step 2.${NC}"
            echo -e "${WHITE}Created resources:${NC}"
            echo -e "  ${GREEN}✓${NC} File System: ${WHITE}$fs_name${NC} ${GRAY}($new_fs_id)${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
        
        # Suggest mount target name based on file system name
        local suggested_mt_name="${fs_name}-mt"
        echo ""
        echo -n -e "${CYAN}Enter display name for mount target [${suggested_mt_name}]: ${NC}"
        local mt_name
        read -r mt_name
        [[ -z "$mt_name" ]] && mt_name="$suggested_mt_name"
        
        echo ""
        local mt_create_cmd="oci fs mount-target create --compartment-id \"$compartment_id\" --availability-domain \"$selected_ad\" --subnet-id \"$subnet_id\" --display-name \"$mt_name\""
        echo -e "${GRAY}Command to execute:${NC}"
        echo -e "${WHITE}$mt_create_cmd${NC}"
        echo ""
        
        echo -n -e "${YELLOW}Create mount target '${mt_name}'? (y/N): ${NC}"
        read -r confirm
        
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            echo -e "${YELLOW}Wizard stopped at Step 2.${NC}"
            echo -e "${WHITE}Created resources:${NC}"
            echo -e "  ${GREEN}✓${NC} File System: ${WHITE}$fs_name${NC} ${GRAY}($new_fs_id)${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
        
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] GUIDED SETUP - CREATE MOUNT TARGET: $mt_create_cmd" >> "$log_file"
        echo ""
        echo -e "${CYAN}Creating mount target...${NC}"
        
        local mt_result
        mt_result=$(oci fs mount-target create \
            --compartment-id "$compartment_id" \
            --availability-domain "$selected_ad" \
            --subnet-id "$subnet_id" \
            --display-name "$mt_name" \
            --output json 2>&1)
        
        if echo "$mt_result" | jq -e '.data.id' > /dev/null 2>&1; then
            new_mt_id=$(echo "$mt_result" | jq -r '.data.id')
            export_set_id=$(echo "$mt_result" | jq -r '.data["export-set-id"]')
            echo -e "${GREEN}✓ Mount target created: ${WHITE}$mt_name${NC}"
            echo -e "  ${CYAN}OCID:${NC} ${GRAY}$new_mt_id${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created mount target $new_mt_id" >> "$log_file"
        else
            echo -e "${RED}✗ Failed to create mount target${NC}"
            echo "$mt_result"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $mt_result" >> "$log_file"
            echo ""
            echo -e "${RED}Wizard stopped at Step 2.${NC}"
            echo -e "${WHITE}Created resources:${NC}"
            echo -e "  ${GREEN}✓${NC} File System: ${WHITE}$fs_name${NC} ${GRAY}($new_fs_id)${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
    else
        echo -e "${YELLOW}Wizard stopped at Step 2.${NC}"
        echo -e "${WHITE}Created resources:${NC}"
        echo -e "  ${GREEN}✓${NC} File System: ${WHITE}$fs_name${NC} ${GRAY}($new_fs_id)${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Get export set ID if not already set
    if [[ -z "$export_set_id" || "$export_set_id" == "null" ]]; then
        echo -e "${CYAN}Retrieving export set from mount target...${NC}"
        local mt_detail
        mt_detail=$(oci fs mount-target get --mount-target-id "$new_mt_id" --output json 2>/dev/null)
        export_set_id=$(echo "$mt_detail" | jq -r '.data["export-set-id"]')
        
        if [[ -z "$export_set_id" || "$export_set_id" == "null" ]]; then
            echo -e "${RED}Could not retrieve export set ID from mount target${NC}"
            echo -e "${RED}Wizard stopped at Step 3. Mount target may still be initializing.${NC}"
            echo -e "${WHITE}Created resources:${NC}"
            echo -e "  ${GREEN}✓${NC} File System: ${WHITE}$fs_name${NC} ${GRAY}($new_fs_id)${NC}"
            echo -e "  ${GREEN}✓${NC} Mount Target: ${GRAY}($new_mt_id)${NC}"
            echo -e "${GRAY}Tip: Wait for the mount target to become ACTIVE, then use 'ce' to create the export manually.${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
    fi
    
    # ==================== STEP 3: Create Export ====================
    echo ""
    echo -e "${BOLD}${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}${YELLOW}  Step 3/3 │ Create Export                                                        ${NC}"
    echo -e "${BOLD}${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    
    # Suggest export path based on file system name
    local suggested_path="/${fs_name}"
    echo -e "${CYAN}The export path is the NFS mount path clients will use.${NC}"
    echo ""
    echo -n -e "${CYAN}Enter export path [${suggested_path}]: ${NC}"
    local export_path
    read -r export_path
    [[ -z "$export_path" ]] && export_path="$suggested_path"
    
    # Ensure path starts with /
    [[ "${export_path:0:1}" != "/" ]] && export_path="/$export_path"
    
    echo ""
    local export_create_cmd="oci fs export create --file-system-id \"$new_fs_id\" --export-set-id \"$export_set_id\" --path \"$export_path\""
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$export_create_cmd${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Create export '${export_path}'? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Wizard stopped at Step 3.${NC}"
        echo -e "${WHITE}Created resources:${NC}"
        echo -e "  ${GREEN}✓${NC} File System: ${WHITE}$fs_name${NC} ${GRAY}($new_fs_id)${NC}"
        echo -e "  ${GREEN}✓${NC} Mount Target: ${GRAY}($new_mt_id)${NC}"
        echo -e "${GRAY}Tip: Use 'ce' to create the export later.${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] GUIDED SETUP - CREATE EXPORT: $export_create_cmd" >> "$log_file"
    echo ""
    echo -e "${CYAN}Creating export...${NC}"
    
    local export_result
    export_result=$(oci fs export create \
        --file-system-id "$new_fs_id" \
        --export-set-id "$export_set_id" \
        --path "$export_path" \
        --output json 2>&1)
    
    local new_export_id=""
    if echo "$export_result" | jq -e '.data.id' > /dev/null 2>&1; then
        new_export_id=$(echo "$export_result" | jq -r '.data.id')
        echo -e "${GREEN}✓ Export created: ${WHITE}$export_path${NC}"
        echo -e "  ${CYAN}OCID:${NC} ${GRAY}$new_export_id${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created export $new_export_id" >> "$log_file"
    else
        echo -e "${RED}✗ Failed to create export${NC}"
        echo "$export_result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $export_result" >> "$log_file"
        echo ""
        echo -e "${RED}Wizard stopped at Step 3.${NC}"
        echo -e "${WHITE}Created resources:${NC}"
        echo -e "  ${GREEN}✓${NC} File System: ${WHITE}$fs_name${NC} ${GRAY}($new_fs_id)${NC}"
        echo -e "  ${GREEN}✓${NC} Mount Target: ${GRAY}($new_mt_id)${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # ==================== SUMMARY ====================
    echo ""
    echo -e "${BOLD}${GREEN}══════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${GREEN}                       GUIDED SETUP COMPLETE ✓                                     ${NC}"
    echo -e "${BOLD}${GREEN}══════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${WHITE}Resources Created:${NC}"
    echo -e "  ${GREEN}✓${NC} File System:  ${WHITE}$fs_name${NC}"
    echo -e "                  ${GRAY}$new_fs_id${NC}"
    echo -e "  ${GREEN}✓${NC} Mount Target: ${GRAY}$new_mt_id${NC}"
    echo -e "  ${GREEN}✓${NC} Export:       ${WHITE}$export_path${NC}"
    echo -e "                  ${GRAY}$new_export_id${NC}"
    echo ""
    
    # Resolve mount target IP
    local mt_detail_json
    mt_detail_json=$(oci fs mount-target get --mount-target-id "$new_mt_id" --output json 2>/dev/null)
    local mt_ip_id
    mt_ip_id=$(echo "$mt_detail_json" | jq -r '.data["private-ip-ids"][0] // empty' 2>/dev/null)
    local mt_ip="(resolving...)"
    if [[ -n "$mt_ip_id" ]]; then
        mt_ip=$(oci network private-ip get --private-ip-id "$mt_ip_id" --query 'data."ip-address"' --raw-output 2>/dev/null) || mt_ip="(pending)"
    fi
    
    echo -e "${BOLD}${WHITE}Mount Command:${NC}"
    echo -e "  ${CYAN}sudo mount -t nfs -o defaults ${mt_ip}:${export_path} /mnt/${fs_name}${NC}"
    echo ""
    echo -e "${GRAY}Note: Ensure NSGs/Security Lists allow NFS traffic (TCP 111, 2048-2050; UDP 111, 2048).${NC}"
    echo ""
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] GUIDED SETUP COMPLETE: FS=$new_fs_id MT=$new_mt_id Export=$new_export_id" >> "$log_file"
    
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# FSS - Recursive Delete File System
# Finds and deletes associated exports, optionally the mount target, then the FS
#--------------------------------------------------------------------------------
fss_recursive_delete_file_system() {
    local compartment_id="$1"
    local fs_id="$2"
    local log_file="${LOGS_DIR}/fss_actions_$(date +%Y%m%d).log"
    
    echo ""
    echo -e "${BOLD}${RED}══════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${RED}                     RECURSIVE DELETE FILE SYSTEM                                    ${NC}"
    echo -e "${BOLD}${RED}══════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Get file system details
    echo -e "${CYAN}Fetching file system details...${NC}"
    local fs_json
    fs_json=$(oci fs file-system get --file-system-id "$fs_id" --output json 2>/dev/null)
    local fs_name
    fs_name=$(echo "$fs_json" | jq -r '.data["display-name"]' 2>/dev/null)
    local fs_state
    fs_state=$(echo "$fs_json" | jq -r '.data["lifecycle-state"]' 2>/dev/null)
    local fs_metered
    fs_metered=$(echo "$fs_json" | jq -r '.data["metered-bytes"]' 2>/dev/null)
    local fs_metered_gb="0"
    [[ -n "$fs_metered" && "$fs_metered" != "null" ]] && fs_metered_gb=$(echo "scale=2; $fs_metered / 1073741824" | bc 2>/dev/null || echo "0")
    
    echo -e "  ${CYAN}File System:${NC} ${WHITE}$fs_name${NC} (${fs_state}) - ${fs_metered_gb} GB"
    echo -e "  ${GRAY}$fs_id${NC}"
    echo ""
    
    # Find all exports linked to this file system
    echo -e "${CYAN}Searching for exports linked to this file system...${NC}"
    local exports_json
    exports_json=$(oci fs export list --compartment-id "$compartment_id" --file-system-id "$fs_id" --all --output json 2>/dev/null)
    
    local export_count
    export_count=$(echo "$exports_json" | jq '.data | length' 2>/dev/null) || export_count=0
    
    # Track export details and mount targets involved
    declare -a EXPORT_IDS
    declare -a EXPORT_PATHS
    declare -a EXPORT_SET_IDS
    declare -A INVOLVED_MT_IDS  # export_set_id -> mt_id
    local export_idx=0
    
    if [[ "$export_count" -gt 0 ]]; then
        while IFS='|' read -r exp_id exp_path exp_set_id exp_state; do
            [[ -z "$exp_id" ]] && continue
            [[ "$exp_state" == "DELETED" || "$exp_state" == "DELETING" ]] && continue
            
            EXPORT_IDS+=("$exp_id")
            EXPORT_PATHS+=("$exp_path")
            EXPORT_SET_IDS+=("$exp_set_id")
            ((export_idx++))
        done < <(echo "$exports_json" | jq -r '.data[] | "\(.id)|\(.path)|\(.["export-set-id"])|\(.["lifecycle-state"])"' 2>/dev/null)
    fi
    
    # Resolve mount targets for each export set
    declare -A MT_NAMES
    declare -A MT_EXPORT_COUNTS  # mt_id -> total export count (not just this FS)
    
    for exp_set_id in $(printf '%s\n' "${EXPORT_SET_IDS[@]}" | sort -u); do
        [[ -z "$exp_set_id" ]] && continue
        
        # Find mount target with this export set
        local mt_list_json
        mt_list_json=$(cat "$FSS_MT_CACHE" 2>/dev/null)
        
        local mt_id mt_name
        mt_id=$(echo "$mt_list_json" | jq -r --arg esid "$exp_set_id" '.data[] | select(.["export-set-id"] == $esid) | .id' 2>/dev/null)
        mt_name=$(echo "$mt_list_json" | jq -r --arg esid "$exp_set_id" '.data[] | select(.["export-set-id"] == $esid) | .["display-name"]' 2>/dev/null)
        
        if [[ -n "$mt_id" ]]; then
            INVOLVED_MT_IDS[$exp_set_id]="$mt_id"
            MT_NAMES[$mt_id]="$mt_name"
            
            # Count total exports on this mount target (not just from this FS)
            local total_exports
            total_exports=$(oci fs export list --compartment-id "$compartment_id" --export-set-id "$exp_set_id" --all --query 'data[?"lifecycle-state"!=`DELETED`] | length(@)' --raw-output 2>/dev/null) || total_exports=0
            MT_EXPORT_COUNTS[$mt_id]="$total_exports"
        fi
    done
    
    # Count exports from THIS file system per mount target
    declare -A FS_EXPORTS_PER_MT  # mt_id -> count of exports from this FS
    for i in "${!EXPORT_SET_IDS[@]}"; do
        local mt_id="${INVOLVED_MT_IDS[${EXPORT_SET_IDS[$i]}]}"
        if [[ -n "$mt_id" ]]; then
            FS_EXPORTS_PER_MT[$mt_id]=$(( ${FS_EXPORTS_PER_MT[$mt_id]:-0} + 1 ))
        fi
    done
    
    # ==================== Display What Will Be Deleted ====================
    echo ""
    echo -e "${BOLD}${RED}The following resources will be deleted:${NC}"
    echo ""
    
    # Show exports
    if [[ $export_idx -gt 0 ]]; then
        echo -e "  ${RED}Exports (${export_idx}):${NC}"
        for i in "${!EXPORT_IDS[@]}"; do
            echo -e "    ${RED}✗${NC} Export: ${WHITE}${EXPORT_PATHS[$i]}${NC}"
            echo -e "      ${GRAY}${EXPORT_IDS[$i]}${NC}"
        done
        echo ""
    else
        echo -e "  ${GRAY}No active exports linked to this file system${NC}"
        echo ""
    fi
    
    # Determine which mount targets can be deleted (all their exports are from this FS)
    declare -A MT_CAN_DELETE  # mt_id -> true/false
    local mt_delete_count=0
    
    for mt_id in $(printf '%s\n' "${!INVOLVED_MT_IDS[@]}" | while read -r k; do echo "${INVOLVED_MT_IDS[$k]}"; done | sort -u); do
        [[ -z "$mt_id" ]] && continue
        
        local total="${MT_EXPORT_COUNTS[$mt_id]:-0}"
        local from_this_fs="${FS_EXPORTS_PER_MT[$mt_id]:-0}"
        local mt_name="${MT_NAMES[$mt_id]}"
        
        if [[ "$total" -le "$from_this_fs" ]]; then
            # Mount target will have no exports after deletion - safe to delete
            MT_CAN_DELETE[$mt_id]="true"
            ((mt_delete_count++))
            echo -e "  ${RED}Mount Target:${NC}"
            echo -e "    ${RED}✗${NC} ${WHITE}${mt_name}${NC} ${GRAY}(will have 0 exports after delete)${NC}"
            echo -e "      ${GRAY}${mt_id}${NC}"
        else
            MT_CAN_DELETE[$mt_id]="false"
            local remaining=$((total - from_this_fs))
            echo -e "  ${YELLOW}Mount Target (kept):${NC}"
            echo -e "    ${YELLOW}~${NC} ${WHITE}${mt_name}${NC} ${GRAY}(has ${remaining} other export(s) - will NOT be deleted)${NC}"
            echo -e "      ${GRAY}${mt_id}${NC}"
        fi
    done
    echo ""
    
    # Show file system
    echo -e "  ${RED}File System:${NC}"
    echo -e "    ${RED}✗${NC} ${WHITE}${fs_name}${NC} (${fs_metered_gb} GB)"
    echo -e "      ${GRAY}${fs_id}${NC}"
    echo ""
    
    # Summary count
    local total_deletes=$((export_idx + mt_delete_count + 1))
    echo -e "${BOLD}${RED}Total resources to delete: ${total_deletes}${NC} (${export_idx} export(s), ${mt_delete_count} mount target(s), 1 file system)"
    echo ""
    
    # ==================== Confirmation ====================
    echo -e "${RED}This action is ${BOLD}PERMANENT${NC}${RED} and cannot be undone.${NC}"
    echo ""
    echo -n -e "${RED}Type 'DELETE ALL' to confirm recursive deletion: ${NC}"
    local confirm
    read -r confirm
    
    if [[ "$confirm" != "DELETE ALL" ]]; then
        echo -e "${YELLOW}Deletion cancelled${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo ""
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] RECURSIVE DELETE STARTED for file system: $fs_name ($fs_id)" >> "$log_file"
    
    # ==================== Phase 1: Delete Exports ====================
    if [[ $export_idx -gt 0 ]]; then
        echo -e "${BOLD}${WHITE}Phase 1/3: Deleting exports...${NC}"
        for i in "${!EXPORT_IDS[@]}"; do
            local exp_id="${EXPORT_IDS[$i]}"
            local exp_path="${EXPORT_PATHS[$i]}"
            local delete_cmd="oci fs export delete --export-id \"$exp_id\" --force"
            
            echo -e "  ${CYAN}Deleting export: ${WHITE}$exp_path${NC}"
            echo -e "  ${GRAY}$delete_cmd${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTING: $delete_cmd" >> "$log_file"
            
            local result
            result=$(oci fs export delete --export-id "$exp_id" --force 2>&1)
            
            if [[ $? -eq 0 ]]; then
                echo -e "  ${GREEN}✓ Export deleted${NC}"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted export $exp_id" >> "$log_file"
            else
                echo -e "  ${RED}✗ Failed to delete export: $result${NC}"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Delete export $exp_id - $result" >> "$log_file"
            fi
        done
        echo ""
        
        # Brief wait for export deletions to propagate
        echo -e "${GRAY}Waiting 5s for export deletions to propagate...${NC}"
        sleep 5
    fi
    
    # ==================== Phase 2: Delete Mount Targets ====================
    if [[ $mt_delete_count -gt 0 ]]; then
        echo -e "${BOLD}${WHITE}Phase 2/3: Deleting mount targets...${NC}"
        for mt_id in $(printf '%s\n' "${!MT_CAN_DELETE[@]}"); do
            [[ "${MT_CAN_DELETE[$mt_id]}" != "true" ]] && continue
            
            local mt_name="${MT_NAMES[$mt_id]}"
            local delete_cmd="oci fs mount-target delete --mount-target-id \"$mt_id\" --force"
            
            echo -e "  ${CYAN}Deleting mount target: ${WHITE}$mt_name${NC}"
            echo -e "  ${GRAY}$delete_cmd${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTING: $delete_cmd" >> "$log_file"
            
            local result
            result=$(oci fs mount-target delete --mount-target-id "$mt_id" --force 2>&1)
            
            if [[ $? -eq 0 ]]; then
                echo -e "  ${GREEN}✓ Mount target deleted${NC}"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted mount target $mt_id" >> "$log_file"
            else
                echo -e "  ${RED}✗ Failed to delete mount target: $result${NC}"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Delete mount target $mt_id - $result" >> "$log_file"
            fi
        done
        echo ""
    else
        echo -e "${BOLD}${WHITE}Phase 2/3: No mount targets to delete (shared with other exports)${NC}"
        echo ""
    fi
    
    # ==================== Phase 3: Delete File System ====================
    echo -e "${BOLD}${WHITE}Phase 3/3: Deleting file system...${NC}"
    local delete_cmd="oci fs file-system delete --file-system-id \"$fs_id\" --force"
    echo -e "  ${CYAN}Deleting file system: ${WHITE}$fs_name${NC}"
    echo -e "  ${GRAY}$delete_cmd${NC}"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTING: $delete_cmd" >> "$log_file"
    
    local result
    result=$(oci fs file-system delete --file-system-id "$fs_id" --force 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "  ${GREEN}✓ File system deletion initiated${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted file system $fs_id" >> "$log_file"
    else
        echo -e "  ${RED}✗ Failed to delete file system: $result${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Delete file system $fs_id - $result" >> "$log_file"
    fi
    
    echo ""
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] RECURSIVE DELETE COMPLETED for: $fs_name ($fs_id)" >> "$log_file"
    echo -e "${GREEN}Recursive delete complete.${NC}"
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Manage File Storage - Main menu
#--------------------------------------------------------------------------------
manage_file_storage() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local ad="${AVAILABILITY_DOMAIN:-}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    # Show FSS overview on entry
    fss_show_overview "$compartment_id"
    
    while true; do
        echo ""
        echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${MAGENTA}                                      FILE STORAGE SERVICE (FSS)                                                 ${NC}"
        echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}Environment:${NC}"
        echo -e "  ${CYAN}Region:${NC}      ${WHITE}${region}${NC}"
        echo -e "  ${CYAN}Compartment:${NC} ${WHITE}$(resolve_compartment_name "${compartment_id}")${NC} ${GRAY}(${compartment_id})${NC}"
        [[ -n "$ad" ]] && echo -e "  ${CYAN}AD:${NC}          ${WHITE}${ad}${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}─── Selection Options ───${NC}"
        echo -e "  ${YELLOW}f#${NC}        - View file system details (e.g., ${YELLOW}f1${NC})"
        echo -e "  ${YELLOW}m#${NC}        - View mount target details (e.g., ${YELLOW}m1${NC})"
        echo -e "  ${YELLOW}e#${NC}        - View export details (e.g., ${YELLOW}e1${NC})"
        echo ""
        echo -e "  ${GREEN}setup${NC}     - Guided setup wizard (FS → Mount Target → Export)"
        echo -e "  ${GREEN}cf${NC}        - Create file system"
        echo -e "  ${GREEN}cm${NC}        - Create mount target"
        echo -e "  ${GREEN}ce${NC}        - Create export"
        echo -e "  ${GREEN}cs${NC}        - Create snapshot"
        echo ""
        echo -e "  ${RED}df#${NC}       - Delete file system + exports + mount target (e.g., ${RED}df1${NC})"
        echo -e "  ${RED}dm#${NC}       - Delete mount target (e.g., ${RED}dm1${NC})"
        echo -e "  ${RED}de#${NC}       - Delete export (e.g., ${RED}de1${NC})"
        echo ""
        echo -e "  ${MAGENTA}r${NC}         - Reload FSS data"
        echo -e "  ${CYAN}b${NC}         - Back to main menu"
        echo ""
        echo -n -e "${BOLD}${CYAN}[File Storage] Selection: ${NC}"
        read -r selection
        
        [[ -z "$selection" || "$selection" == "b" || "$selection" == "B" ]] && return 0
        
        # Refresh
        if [[ "$selection" == "r" || "$selection" == "R" || "$selection" == "refresh" ]]; then
            rm -f "$FSS_FS_CACHE" "$FSS_MT_CACHE" "$FSS_EXPORT_CACHE"
            fss_show_overview "$compartment_id" "true"
            continue
        fi
        
        # Create commands
        if [[ "$selection" == "setup" || "$selection" == "SETUP" ]]; then
            fss_guided_setup "$compartment_id" "$ad"
            rm -f "$FSS_FS_CACHE" "$FSS_MT_CACHE" "$FSS_EXPORT_CACHE"
            fss_show_overview "$compartment_id" "true"
            continue
        fi
        if [[ "$selection" == "cf" ]]; then
            fss_create_file_system "$compartment_id" "$ad"
            rm -f "$FSS_FS_CACHE"
            fss_show_overview "$compartment_id" "true"
            continue
        fi
        if [[ "$selection" == "cm" ]]; then
            fss_create_mount_target "$compartment_id" "$ad"
            rm -f "$FSS_MT_CACHE"
            fss_show_overview "$compartment_id" "true"
            continue
        fi
        if [[ "$selection" == "ce" ]]; then
            fss_create_export "$compartment_id" "$ad"
            rm -f "$FSS_EXPORT_CACHE"
            fss_show_overview "$compartment_id" "true"
            continue
        fi
        if [[ "$selection" == "cs" ]]; then
            fss_create_snapshot "$compartment_id" "$ad"
            fss_show_overview "$compartment_id"
            continue
        fi
        
        # View file system: f#
        if [[ "$selection" =~ ^f([0-9]+)$ ]]; then
            local sel_idx="${BASH_REMATCH[1]}"
            if [[ -n "${FSS_FS_MAP[$sel_idx]}" ]]; then
                fss_show_file_system_detail "${FSS_FS_MAP[$sel_idx]}"
            else
                echo -e "${RED}Invalid file system number: f${sel_idx}${NC}"
            fi
            continue
        fi
        
        # View mount target: m#
        if [[ "$selection" =~ ^m([0-9]+)$ ]]; then
            local sel_idx="${BASH_REMATCH[1]}"
            if [[ -n "${FSS_MT_MAP[$sel_idx]}" ]]; then
                fss_show_mount_target_detail "${FSS_MT_MAP[$sel_idx]}"
            else
                echo -e "${RED}Invalid mount target number: m${sel_idx}${NC}"
            fi
            continue
        fi
        
        # View export: e#
        if [[ "$selection" =~ ^e([0-9]+)$ ]]; then
            local sel_idx="${BASH_REMATCH[1]}"
            if [[ -n "${FSS_EXPORT_MAP[$sel_idx]}" ]]; then
                fss_show_export_detail "${FSS_EXPORT_MAP[$sel_idx]}"
            else
                echo -e "${RED}Invalid export number: e${sel_idx}${NC}"
            fi
            continue
        fi
        
        # Delete file system: df# (recursive - exports + mount target + FS)
        if [[ "$selection" =~ ^df([0-9]+)$ ]]; then
            local sel_idx="${BASH_REMATCH[1]}"
            if [[ -n "${FSS_FS_MAP[$sel_idx]}" ]]; then
                fss_recursive_delete_file_system "$compartment_id" "${FSS_FS_MAP[$sel_idx]}"
                rm -f "$FSS_FS_CACHE" "$FSS_MT_CACHE" "$FSS_EXPORT_CACHE"
                fss_show_overview "$compartment_id" "true"
            else
                echo -e "${RED}Invalid file system number: df${sel_idx}${NC}"
            fi
            continue
        fi
        
        # Delete mount target: dm#
        if [[ "$selection" =~ ^dm([0-9]+)$ ]]; then
            local sel_idx="${BASH_REMATCH[1]}"
            if [[ -n "${FSS_MT_MAP[$sel_idx]}" ]]; then
                FSS_SELECTED_MT="${FSS_MT_MAP[$sel_idx]}"
                fss_delete_mount_target_direct "$compartment_id"
                rm -f "$FSS_MT_CACHE"
                fss_show_overview "$compartment_id" "true"
            else
                echo -e "${RED}Invalid mount target number: dm${sel_idx}${NC}"
            fi
            continue
        fi
        
        # Delete export: de#
        if [[ "$selection" =~ ^de([0-9]+)$ ]]; then
            local sel_idx="${BASH_REMATCH[1]}"
            if [[ -n "${FSS_EXPORT_MAP[$sel_idx]}" ]]; then
                FSS_SELECTED_EXPORT="${FSS_EXPORT_MAP[$sel_idx]}"
                fss_delete_export_direct "$compartment_id"
                rm -f "$FSS_EXPORT_CACHE"
                fss_show_overview "$compartment_id" "true"
            else
                echo -e "${RED}Invalid export number: de${sel_idx}${NC}"
            fi
            continue
        fi
        
        echo -e "${RED}Invalid selection${NC}"
    done
}


#--------------------------------------------------------------------------------
# FSS - Show Overview (Hierarchical: Mount Targets → Exports → File Systems)
#--------------------------------------------------------------------------------
fss_show_overview() {
    local compartment_id="$1"
    local force_refresh="${2:-false}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${WHITE}                                      FILE STORAGE SERVICE (FSS)                                                 ${NC}"
    echo -e "${BOLD}${WHITE}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    _display_cache_info \
        "${FSS_FS_CACHE}|File Systems" \
        "${FSS_MT_CACHE}|Mount Targets" \
        "${FSS_EXPORT_CACHE}|Exports"
    echo ""
    
    # Fetch and cache FSS data
    fetch_fss_data "$compartment_id" "$force_refresh"
    
    # Clear global maps
    declare -gA FSS_FS_MAP
    declare -gA FSS_MT_MAP
    declare -gA FSS_EXPORT_MAP
    declare -gA FSS_FS_NAMES
    FSS_FS_MAP=()
    FSS_MT_MAP=()
    FSS_EXPORT_MAP=()
    FSS_FS_NAMES=()
    
    local fs_idx=0
    local mt_idx=0
    local export_idx=0
    
    #---------------------------------------------------------------------------
    # Load data from caches
    #---------------------------------------------------------------------------
    local all_fs_json="[]"
    if [[ -f "$FSS_FS_CACHE" ]]; then
        all_fs_json=$(jq '.data // []' "$FSS_FS_CACHE" 2>/dev/null) || all_fs_json="[]"
    fi
    
    local all_mt_json="[]"
    if [[ -f "$FSS_MT_CACHE" ]]; then
        all_mt_json=$(jq '.data // []' "$FSS_MT_CACHE" 2>/dev/null) || all_mt_json="[]"
    fi
    
    local all_export_json='{"data":[]}'
    if [[ -f "$FSS_EXPORT_CACHE" ]]; then
        all_export_json=$(cat "$FSS_EXPORT_CACHE" 2>/dev/null) || all_export_json='{"data":[]}'
    fi
    
    # Get private IPs for mount targets
    echo -ne "  ${GRAY}Resolving private IPs...${NC}"
    declare -A MT_IPS
    while IFS='|' read -r mt_id ip_ids; do
        [[ -z "$mt_id" ]] && continue
        local first_ip_id
        first_ip_id=$(echo "$ip_ids" | jq -r '.[0] // empty' 2>/dev/null)
        if [[ -n "$first_ip_id" ]]; then
            local ip_addr
            ip_addr=$(oci network private-ip get --private-ip-id "$first_ip_id" --query 'data."ip-address"' --raw-output 2>/dev/null)
            MT_IPS[$mt_id]="$ip_addr"
        fi
    done < <(echo "$all_mt_json" | jq -r '.[] | "\(.id)|\(.["private-ip-ids"])"' 2>/dev/null)
    echo -e "\r                                          \r"
    
    # Build file system lookup
    declare -A FS_INFO  # fs_id -> "name|state|metered_bytes|ad"
    while IFS='|' read -r fs_id fs_name fs_state fs_bytes fs_ad; do
        [[ -z "$fs_id" ]] && continue
        FS_INFO[$fs_id]="$fs_name|$fs_state|$fs_bytes|$fs_ad"
    done < <(echo "$all_fs_json" | jq -r '.[] | "\(.id)|\(.["display-name"])|\(.["lifecycle-state"])|\(.["metered-bytes"])|\(.["availability-domain"])"' 2>/dev/null)
    
    # Build export lookup by export-set-id
    declare -A EXPORTS_BY_SET  # export_set_id -> "export_id|path|fs_id;export_id|path|fs_id;..."
    while IFS='|' read -r export_id export_path export_set_id fs_id export_state; do
        [[ -z "$export_id" ]] && continue
        if [[ -n "${EXPORTS_BY_SET[$export_set_id]}" ]]; then
            EXPORTS_BY_SET[$export_set_id]="${EXPORTS_BY_SET[$export_set_id]};$export_id|$export_path|$fs_id|$export_state"
        else
            EXPORTS_BY_SET[$export_set_id]="$export_id|$export_path|$fs_id|$export_state"
        fi
    done < <(echo "$all_export_json" | jq -r '.data[] | "\(.id)|\(.path)|\(.["export-set-id"])|\(.["file-system-id"])|\(.["lifecycle-state"])"' 2>/dev/null)
    
    # Track which file systems have exports
    declare -A FS_HAS_EXPORT
    
    #---------------------------------------------------------------------------
    # Display Mount Targets with Exports and File Systems
    #---------------------------------------------------------------------------
    local mt_count
    mt_count=$(echo "$all_mt_json" | jq 'length' 2>/dev/null) || mt_count=0
    
    if [[ "$mt_count" -gt 0 ]]; then
        echo -e "${BOLD}${WHITE}MOUNT TARGETS WITH EXPORTS${NC}"
        echo ""
        
        while IFS='|' read -r mt_id mt_name mt_state mt_ad export_set_id; do
            [[ -z "$mt_id" ]] && continue
            ((mt_idx++))
            
            FSS_MT_MAP[$mt_idx]="$mt_id"
            
            local mt_state_color="$GREEN"
            case "$mt_state" in
                ACTIVE) mt_state_color="$GREEN" ;;
                CREATING|UPDATING) mt_state_color="$YELLOW" ;;
                DELETING|DELETED|FAILED) mt_state_color="$RED" ;;
                *) mt_state_color="$GRAY" ;;
            esac
            
            local ad_short="${mt_ad##*:}"
            local mt_ip="${MT_IPS[$mt_id]:-N/A}"
            
            echo -e "${BOLD}${CYAN}┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
            echo -e "${BOLD}${CYAN}│${NC} ${YELLOW}[m${mt_idx}]${NC} ${BOLD}${WHITE}${mt_name}${NC}  ${mt_state_color}${mt_state}${NC}"
            echo -e "${BOLD}${CYAN}│${NC}     ${CYAN}IP:${NC} ${WHITE}${mt_ip}${NC}  ${CYAN}AD:${NC} ${WHITE}${ad_short}${NC}"
            echo -e "${BOLD}${CYAN}│${NC}     ${GRAY}${mt_id}${NC}"
            
            # Get exports for this mount target
            local exports="${EXPORTS_BY_SET[$export_set_id]}"
            
            if [[ -n "$exports" ]]; then
                echo -e "${BOLD}${CYAN}│${NC}"
                echo -e "${BOLD}${CYAN}│${NC}     ${BOLD}${WHITE}Exports:${NC}"
                
                # Parse exports (semicolon separated)
                IFS=';' read -ra EXPORT_ARRAY <<< "$exports"
                local exp_count=${#EXPORT_ARRAY[@]}
                local exp_i=0
                
                for export_entry in "${EXPORT_ARRAY[@]}"; do
                    ((exp_i++))
                    ((export_idx++))
                    
                    IFS='|' read -r exp_id exp_path exp_fs_id exp_state <<< "$export_entry"
                    FSS_EXPORT_MAP[$export_idx]="$exp_id"
                    
                    # Mark file system as having export
                    FS_HAS_EXPORT[$exp_fs_id]=1
                    
                    # Get file system info
                    local fs_info="${FS_INFO[$exp_fs_id]}"
                    local fs_name fs_state fs_bytes fs_ad
                    IFS='|' read -r fs_name fs_state fs_bytes fs_ad <<< "$fs_info"
                    
                    # Find fs_idx for this file system
                    local this_fs_idx=""
                    for i in "${!FSS_FS_MAP[@]}"; do
                        if [[ "${FSS_FS_MAP[$i]}" == "$exp_fs_id" ]]; then
                            this_fs_idx=$i
                            break
                        fi
                    done
                    if [[ -z "$this_fs_idx" ]]; then
                        ((fs_idx++))
                        FSS_FS_MAP[$fs_idx]="$exp_fs_id"
                        FSS_FS_NAMES[$fs_idx]="$fs_name"
                        this_fs_idx=$fs_idx
                    fi
                    
                    local exp_state_color="$GREEN"
                    case "$exp_state" in
                        ACTIVE) exp_state_color="$GREEN" ;;
                        CREATING|UPDATING) exp_state_color="$YELLOW" ;;
                        DELETING|DELETED|FAILED) exp_state_color="$RED" ;;
                        *) exp_state_color="$GRAY" ;;
                    esac
                    
                    local fs_state_color="$GREEN"
                    case "$fs_state" in
                        ACTIVE) fs_state_color="$GREEN" ;;
                        CREATING|UPDATING) fs_state_color="$YELLOW" ;;
                        DELETING|DELETED|FAILED) fs_state_color="$RED" ;;
                        *) fs_state_color="$GRAY" ;;
                    esac
                    
                    # Convert bytes to human readable
                    local fs_size="0 B"
                    if [[ -n "$fs_bytes" && "$fs_bytes" != "null" && "$fs_bytes" -gt 0 ]] 2>/dev/null; then
                        if [[ "$fs_bytes" -ge 1073741824 ]]; then
                            fs_size="$(echo "scale=1; $fs_bytes / 1073741824" | bc) GB"
                        elif [[ "$fs_bytes" -ge 1048576 ]]; then
                            fs_size="$(echo "scale=1; $fs_bytes / 1048576" | bc) MB"
                        elif [[ "$fs_bytes" -ge 1024 ]]; then
                            fs_size="$(echo "scale=1; $fs_bytes / 1000" | bc) KB"
                        else
                            fs_size="${fs_bytes} B"
                        fi
                    fi
                    
                    # Tree characters
                    local tree_char="├──"
                    local tree_cont="│  "
                    if [[ $exp_i -eq $exp_count ]]; then
                        tree_char="└──"
                        tree_cont="   "
                    fi
                    
                    echo -e "${BOLD}${CYAN}│${NC}     ${tree_char} ${YELLOW}[e${export_idx}]${NC} ${WHITE}${exp_path}${NC}  ${exp_state_color}${exp_state}${NC}"
                    echo -e "${BOLD}${CYAN}│${NC}     ${tree_cont}    └── ${YELLOW}[f${this_fs_idx}]${NC} ${WHITE}${fs_name:-N/A}${NC}  ${fs_state_color}${fs_state:-N/A}${NC}  ${CYAN}Size:${NC} ${WHITE}${fs_size}${NC}"
                    
                done
            else
                echo -e "${BOLD}${CYAN}│${NC}     ${GRAY}(No exports configured)${NC}"
            fi
            
            echo -e "${BOLD}${CYAN}└──────────────────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
            echo ""
            
        done < <(echo "$all_mt_json" | jq -r '.[] | "\(.id)|\(.["display-name"])|\(.["lifecycle-state"])|\(.["availability-domain"])|\(.["export-set-id"])"' 2>/dev/null)
    fi
    
    #---------------------------------------------------------------------------
    # Display Standalone File Systems (no exports)
    #---------------------------------------------------------------------------
    local standalone_fs=""
    while IFS='|' read -r fs_id fs_name fs_state fs_bytes fs_ad; do
        [[ -z "$fs_id" ]] && continue
        if [[ -z "${FS_HAS_EXPORT[$fs_id]}" ]]; then
            standalone_fs="${standalone_fs}${fs_id}|${fs_name}|${fs_state}|${fs_bytes}|${fs_ad}\n"
        fi
    done < <(echo "$all_fs_json" | jq -r '.[] | "\(.id)|\(.["display-name"])|\(.["lifecycle-state"])|\(.["metered-bytes"])|\(.["availability-domain"])"' 2>/dev/null)
    
    if [[ -n "$standalone_fs" ]]; then
        echo -e "${BOLD}${WHITE}STANDALONE FILE SYSTEMS ${GRAY}(no exports)${NC}"
        echo ""
        
        echo -e "${BOLD}${CYAN}┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
        
        while IFS='|' read -r fs_id fs_name fs_state fs_bytes fs_ad; do
            [[ -z "$fs_id" ]] && continue
            ((fs_idx++))
            
            FSS_FS_MAP[$fs_idx]="$fs_id"
            FSS_FS_NAMES[$fs_idx]="$fs_name"
            
            local fs_state_color="$GREEN"
            case "$fs_state" in
                ACTIVE) fs_state_color="$GREEN" ;;
                CREATING|UPDATING) fs_state_color="$YELLOW" ;;
                DELETING|DELETED|FAILED) fs_state_color="$RED" ;;
                *) fs_state_color="$GRAY" ;;
            esac
            
            local ad_short="${fs_ad##*:}"
            
            # Convert bytes to human readable
            local fs_size="0 B"
            if [[ -n "$fs_bytes" && "$fs_bytes" != "null" && "$fs_bytes" -gt 0 ]] 2>/dev/null; then
                if [[ "$fs_bytes" -ge 1073741824 ]]; then
                    fs_size="$(echo "scale=1; $fs_bytes / 1073741824" | bc) GB"
                elif [[ "$fs_bytes" -ge 1048576 ]]; then
                    fs_size="$(echo "scale=1; $fs_bytes / 1048576" | bc) MB"
                elif [[ "$fs_bytes" -ge 1024 ]]; then
                    fs_size="$(echo "scale=1; $fs_bytes / 1000" | bc) KB"
                else
                    fs_size="${fs_bytes} B"
                fi
            fi
            
            echo -e "${BOLD}${CYAN}│${NC} ${YELLOW}[f${fs_idx}]${NC} ${WHITE}${fs_name}${NC}  ${fs_state_color}${fs_state}${NC}  ${CYAN}Size:${NC} ${WHITE}${fs_size}${NC}  ${CYAN}AD:${NC} ${WHITE}${ad_short}${NC}"
            echo -e "${BOLD}${CYAN}│${NC}      ${GRAY}${fs_id}${NC}"
            
        done < <(echo -e "$standalone_fs")
        
        echo -e "${BOLD}${CYAN}└──────────────────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
        echo ""
    fi
    
    # Store counts
    FSS_FS_COUNT=$fs_idx
    FSS_MT_COUNT=$mt_idx
    FSS_EXPORT_COUNT=$export_idx
    
    #---------------------------------------------------------------------------
    # Summary
    #---------------------------------------------------------------------------
    echo -e "${BOLD}${WHITE}═══ Summary ═══${NC}"
    echo -e "  Mount Targets: ${GREEN}$mt_idx${NC}"
    echo -e "  Exports:       ${GREEN}$export_idx${NC}"
    echo -e "  File Systems:  ${GREEN}$fs_idx${NC}"
    echo ""
    
    # NFS mount example
    if [[ $mt_idx -gt 0 && $export_idx -gt 0 ]]; then
        local sample_ip="${MT_IPS[${FSS_MT_MAP[1]}]:-<mount-target-ip>}"
        echo -e "${BOLD}${WHITE}═══ NFS Mount Example ═══${NC}"
        echo -e "  ${GRAY}sudo mount -t nfs -o nfsvers=3 ${sample_ip}:/<export-path> /mnt/fss${NC}"
        echo ""
    fi
}

#--------------------------------------------------------------------------------
# FSS - Show File System Detail
#--------------------------------------------------------------------------------
fss_show_file_system_detail() {
    local fs_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ File System Details ═══${NC}"
    echo ""
    
    local get_cmd="oci fs file-system get --file-system-id \"$fs_id\" --output json"
    echo -e "${GRAY}$get_cmd${NC}"
    echo ""
    
    local fs_json
    fs_json=$(oci fs file-system get --file-system-id "$fs_id" --output json 2>&1)
    
    if [[ $? -ne 0 ]]; then
        echo -e "${RED}Error getting file system: ${NC}"
        echo "$fs_json"
        return
    fi
    
    local name state ad metered_bytes time_created
    name=$(echo "$fs_json" | jq -r '.data["display-name"] // "N/A"')
    state=$(echo "$fs_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    ad=$(echo "$fs_json" | jq -r '.data["availability-domain"] // "N/A"')
    metered_bytes=$(echo "$fs_json" | jq -r '.data["metered-bytes"] // 0')
    time_created=$(echo "$fs_json" | jq -r '.data["time-created"] // "N/A"')
    
    local metered_gb="0"
    [[ -n "$metered_bytes" && "$metered_bytes" != "null" ]] && metered_gb=$(echo "scale=2; $metered_bytes / 1073741824" | bc 2>/dev/null || echo "0")
    
    echo -e "  ${CYAN}Name:${NC}              ${WHITE}$name${NC}"
    echo -e "  ${CYAN}State:${NC}             ${WHITE}$state${NC}"
    echo -e "  ${CYAN}Availability Domain:${NC} ${WHITE}$ad${NC}"
    echo -e "  ${CYAN}Metered Size:${NC}      ${WHITE}${metered_gb} GB${NC}"
    echo -e "  ${CYAN}Created:${NC}           ${WHITE}$time_created${NC}"
    echo -e "  ${CYAN}OCID:${NC}              ${YELLOW}$fs_id${NC}"
    echo ""
}

#--------------------------------------------------------------------------------
# FSS - Show Mount Target Detail
#--------------------------------------------------------------------------------
fss_show_mount_target_detail() {
    local mt_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Mount Target Details ═══${NC}"
    echo ""
    
    local get_cmd="oci fs mount-target get --mount-target-id \"$mt_id\" --output json"
    echo -e "${GRAY}$get_cmd${NC}"
    echo ""
    
    local mt_json
    mt_json=$(oci fs mount-target get --mount-target-id "$mt_id" --output json 2>&1)
    
    if [[ $? -ne 0 ]]; then
        echo -e "${RED}Error getting mount target: ${NC}"
        echo "$mt_json"
        return
    fi
    
    local name state ad subnet_id export_set_id time_created
    name=$(echo "$mt_json" | jq -r '.data["display-name"] // "N/A"')
    state=$(echo "$mt_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    ad=$(echo "$mt_json" | jq -r '.data["availability-domain"] // "N/A"')
    subnet_id=$(echo "$mt_json" | jq -r '.data["subnet-id"] // "N/A"')
    export_set_id=$(echo "$mt_json" | jq -r '.data["export-set-id"] // "N/A"')
    time_created=$(echo "$mt_json" | jq -r '.data["time-created"] // "N/A"')
    
    # Get private IP
    local private_ip="N/A"
    local private_ip_ids
    private_ip_ids=$(echo "$mt_json" | jq -r '.data["private-ip-ids"][]' 2>/dev/null)
    if [[ -n "$private_ip_ids" ]]; then
        local first_ip_id
        first_ip_id=$(echo "$private_ip_ids" | head -1)
        private_ip=$(oci network private-ip get --private-ip-id "$first_ip_id" --query 'data."ip-address"' --raw-output 2>/dev/null) || private_ip="N/A"
    fi
    
    echo -e "  ${CYAN}Name:${NC}              ${WHITE}$name${NC}"
    echo -e "  ${CYAN}State:${NC}             ${WHITE}$state${NC}"
    echo -e "  ${CYAN}Availability Domain:${NC} ${WHITE}$ad${NC}"
    echo -e "  ${CYAN}Private IP:${NC}        ${WHITE}$private_ip${NC}"
    echo -e "  ${CYAN}Subnet OCID:${NC}       ${YELLOW}$subnet_id${NC}"
    echo -e "  ${CYAN}Export Set OCID:${NC}   ${YELLOW}$export_set_id${NC}"
    echo -e "  ${CYAN}Created:${NC}           ${WHITE}$time_created${NC}"
    echo -e "  ${CYAN}OCID:${NC}              ${YELLOW}$mt_id${NC}"
    echo ""
    
    # Show mount command
    if [[ "$private_ip" != "N/A" ]]; then
        echo -e "${BOLD}${WHITE}═══ Mount Command ═══${NC}"
        echo -e "  ${GREEN}sudo mount -t nfs -o nfsvers=3 ${private_ip}:/<export_path> /mnt/<mount_point>${NC}"
        echo ""
    fi
}

#--------------------------------------------------------------------------------
# FSS - Show Export Detail
#--------------------------------------------------------------------------------
fss_show_export_detail() {
    local export_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Export Details ═══${NC}"
    echo ""
    
    local get_cmd="oci fs export get --export-id \"$export_id\" --output json"
    echo -e "${GRAY}$get_cmd${NC}"
    echo ""
    
    local export_json
    export_json=$(oci fs export get --export-id "$export_id" --output json 2>&1)
    
    if [[ $? -ne 0 ]]; then
        echo -e "${RED}Error getting export: ${NC}"
        echo "$export_json"
        return
    fi
    
    local path state fs_id export_set_id time_created
    path=$(echo "$export_json" | jq -r '.data.path // "N/A"')
    state=$(echo "$export_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    fs_id=$(echo "$export_json" | jq -r '.data["file-system-id"] // "N/A"')
    export_set_id=$(echo "$export_json" | jq -r '.data["export-set-id"] // "N/A"')
    time_created=$(echo "$export_json" | jq -r '.data["time-created"] // "N/A"')
    
    echo -e "  ${CYAN}Path:${NC}              ${WHITE}$path${NC}"
    echo -e "  ${CYAN}State:${NC}             ${WHITE}$state${NC}"
    echo -e "  ${CYAN}File System OCID:${NC}  ${YELLOW}$fs_id${NC}"
    echo -e "  ${CYAN}Export Set OCID:${NC}   ${YELLOW}$export_set_id${NC}"
    echo -e "  ${CYAN}Created:${NC}           ${WHITE}$time_created${NC}"
    echo -e "  ${CYAN}OCID:${NC}              ${YELLOW}$export_id${NC}"
    echo ""
    
    # Show export options
    echo -e "${BOLD}${WHITE}═══ Export Options ═══${NC}"
    echo "$export_json" | jq -r '.data["export-options"][]? | "  Source: \(.source // "N/A"), Access: \(.access // "N/A"), Identity: \(.["identity-squash"] // "N/A")"' 2>/dev/null
    echo ""
}

#--------------------------------------------------------------------------------
# FSS - Delete File System Direct (with confirmation)
#--------------------------------------------------------------------------------
fss_delete_file_system_direct() {
    local compartment_id="$1"
    local log_file="${MAINTENANCE_LOG_FILE}"
    
    echo ""
    echo -e "${BOLD}${RED}═══ Delete File System ═══${NC}"
    echo ""
    
    local delete_cmd="oci fs file-system delete --file-system-id \"$FSS_SELECTED_FS\" --force"
    echo -e "${RED}Command: $delete_cmd${NC}"
    echo ""
    
    echo -n -e "${RED}Type 'DELETE' to confirm deletion: ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "DELETE" ]]; then
        echo -e "${YELLOW}Deletion cancelled${NC}"
        return
    fi
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTING: $delete_cmd" >> "$log_file"
    echo -e "${GRAY}$delete_cmd${NC}"
    
    local result
    result=$(oci fs file-system delete --file-system-id "$FSS_SELECTED_FS" --force 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}File system deletion initiated${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted $FSS_SELECTED_FS" >> "$log_file"
    else
        echo -e "${RED}Failed to delete file system: $result${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Delete $FSS_SELECTED_FS - $result" >> "$log_file"
    fi
}

#--------------------------------------------------------------------------------
# FSS - Delete Mount Target Direct (with confirmation)
#--------------------------------------------------------------------------------
fss_delete_mount_target_direct() {
    local compartment_id="$1"
    local log_file="${MAINTENANCE_LOG_FILE}"
    
    echo ""
    echo -e "${BOLD}${RED}═══ Delete Mount Target ═══${NC}"
    echo ""
    
    local delete_cmd="oci fs mount-target delete --mount-target-id \"$FSS_SELECTED_MT\" --force"
    echo -e "${RED}Command: $delete_cmd${NC}"
    echo ""
    
    echo -n -e "${RED}Type 'DELETE' to confirm deletion: ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "DELETE" ]]; then
        echo -e "${YELLOW}Deletion cancelled${NC}"
        return
    fi
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTING: $delete_cmd" >> "$log_file"
    echo -e "${GRAY}$delete_cmd${NC}"
    
    local result
    result=$(oci fs mount-target delete --mount-target-id "$FSS_SELECTED_MT" --force 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Mount target deletion initiated${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted $FSS_SELECTED_MT" >> "$log_file"
    else
        echo -e "${RED}Failed to delete mount target: $result${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Delete $FSS_SELECTED_MT - $result" >> "$log_file"
    fi
}

#--------------------------------------------------------------------------------
# FSS - Delete Export Direct (with confirmation)
#--------------------------------------------------------------------------------
fss_delete_export_direct() {
    local compartment_id="$1"
    local log_file="${MAINTENANCE_LOG_FILE}"
    
    echo ""
    echo -e "${BOLD}${RED}═══ Delete Export ═══${NC}"
    echo ""
    
    local delete_cmd="oci fs export delete --export-id \"$FSS_SELECTED_EXPORT\" --force"
    echo -e "${RED}Command: $delete_cmd${NC}"
    echo ""
    
    echo -n -e "${RED}Type 'DELETE' to confirm deletion: ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "DELETE" ]]; then
        echo -e "${YELLOW}Deletion cancelled${NC}"
        return
    fi
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTING: $delete_cmd" >> "$log_file"
    echo -e "${GRAY}$delete_cmd${NC}"
    
    local result
    result=$(oci fs export delete --export-id "$FSS_SELECTED_EXPORT" --force 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Export deletion initiated${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted $FSS_SELECTED_EXPORT" >> "$log_file"
    else
        echo -e "${RED}Failed to delete export: $result${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Delete $FSS_SELECTED_EXPORT - $result" >> "$log_file"
    fi
}

#--------------------------------------------------------------------------------
# FSS - List File Systems
#--------------------------------------------------------------------------------
fss_list_file_systems() {
    local compartment_id="$1"
    local ad="$2"
    local action="${3:-none}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ File Systems ═══${NC}"
    echo ""
    
    local fs_json
    local all_fs_json="[]"
    
    if [[ -n "$ad" ]]; then
        # Single AD specified
        local list_cmd="oci fs file-system list --compartment-id \"$compartment_id\" --availability-domain \"$ad\" --all --output json"
        echo -e "${GRAY}$list_cmd${NC}"
        echo ""
        
        fs_json=$(oci fs file-system list \
            --compartment-id "$compartment_id" \
            --availability-domain "$ad" \
            --all \
            --output json 2>&1)
        
        if [[ $? -ne 0 ]]; then
            echo -e "${RED}Error listing file systems:${NC}"
            echo "$fs_json" | while IFS= read -r line; do echo -e "${RED}  $line${NC}"; done
            return 1
        fi
        
        all_fs_json=$(echo "$fs_json" | jq '.data // []' 2>/dev/null)
    else
        # No AD specified - iterate through all ADs
        echo -e "${CYAN}Getting availability domains...${NC}"
        local ads
        ads=$(fss_get_availability_domains "$compartment_id")
        
        if [[ -z "$ads" ]]; then
            echo -e "${RED}Unable to get availability domains${NC}"
            return 1
        fi
        
        while IFS= read -r ad_name; do
            [[ -z "$ad_name" ]] && continue
            
            local list_cmd="oci fs file-system list --compartment-id \"$compartment_id\" --availability-domain \"$ad_name\" --all --output json"
            echo -e "${GRAY}$list_cmd${NC}"
            
            fs_json=$(oci fs file-system list \
                --compartment-id "$compartment_id" \
                --availability-domain "$ad_name" \
                --all \
                --output json 2>&1)
            
            if [[ $? -ne 0 ]]; then
                echo -e "${RED}Error listing file systems in $ad_name:${NC}"
                echo "$fs_json" | head -3 | while IFS= read -r line; do echo -e "${RED}  $line${NC}"; done
                continue
            fi
            
            local fs_data
            fs_data=$(echo "$fs_json" | jq '.data // []' 2>/dev/null)
            all_fs_json=$(echo "$all_fs_json" "$fs_data" | jq -s 'add' 2>/dev/null)
            
        done <<< "$ads"
        echo ""
    fi
    
    local fs_count
    fs_count=$(echo "$all_fs_json" | jq 'length' 2>/dev/null) || fs_count=0
    
    if [[ "$fs_count" -eq 0 ]]; then
        echo -e "${YELLOW}No file systems found${NC}"
        return 1
    fi
    
    echo -e "${GREEN}Found $fs_count file system(s)${NC}"
    echo ""
    
    printf "${BOLD}%-3s %-35s %-12s %-15s %-20s %s${NC}\n" "#" "Display Name" "State" "Metered (GB)" "Availability Domain" "File System OCID"
    print_separator 180
    
    local idx=0
    declare -gA FSS_FS_MAP
    FSS_FS_MAP=()
    
    while IFS='|' read -r display_name state metered_bytes ad_name fs_id; do
        [[ -z "$display_name" ]] && continue
        ((idx++))
        
        FSS_FS_MAP[$idx]="$fs_id"
        
        local state_color="$GREEN"
        case "$state" in
            ACTIVE) state_color="$GREEN" ;;
            CREATING|UPDATING) state_color="$YELLOW" ;;
            DELETING|DELETED|FAILED) state_color="$RED" ;;
            *) state_color="$GRAY" ;;
        esac
        
        local name_trunc="${display_name:0:33}"
        [[ ${#display_name} -gt 33 ]] && name_trunc="${name_trunc}.."
        
        # Convert bytes to GB
        local metered_gb="0"
        [[ -n "$metered_bytes" && "$metered_bytes" != "null" ]] && metered_gb=$(echo "scale=2; $metered_bytes / 1073741824" | bc 2>/dev/null || echo "0")
        
        # Extract AD name (last part)
        local ad_short="${ad_name##*:}"
        
        printf "${YELLOW}%-3s${NC} %-35s ${state_color}%-12s${NC} %-15s %-20s ${GRAY}%s${NC}\n" \
            "$idx" "$name_trunc" "$state" "${metered_gb}" "$ad_short" "$fs_id"
            
    done < <(echo "$all_fs_json" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["metered-bytes"])|\(.["availability-domain"])|\(.id)"' 2>/dev/null)
    
    FSS_FS_COUNT=$idx
    echo ""
    
    case "$action" in
        none)
            echo -e "Press Enter to continue..."
            read -r
            ;;
        select)
            echo -n -e "${CYAN}Enter file system # (or Enter to cancel): ${NC}"
            read -r fs_selection
            if [[ -n "$fs_selection" && -n "${FSS_FS_MAP[$fs_selection]}" ]]; then
                FSS_SELECTED_FS="${FSS_FS_MAP[$fs_selection]}"
            fi
            ;;
    esac
    
    return 0
}

#--------------------------------------------------------------------------------
# FSS - View File System Details
#--------------------------------------------------------------------------------
fss_view_file_system_details() {
    local compartment_id="$1"
    local ad="$2"
    
    FSS_SELECTED_FS=""
    fss_list_file_systems "$compartment_id" "$ad" "select"
    
    [[ -z "$FSS_SELECTED_FS" ]] && return
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ File System Details ═══${NC}"
    echo ""
    
    local get_cmd="oci fs file-system get --file-system-id \"$FSS_SELECTED_FS\" --output json"
    echo -e "${GRAY}$get_cmd${NC}"
    echo ""
    
    local fs_json
    fs_json=$(oci fs file-system get --file-system-id "$FSS_SELECTED_FS" --output json 2>/dev/null)
    
    if [[ -z "$fs_json" || "$fs_json" == "null" ]]; then
        echo -e "${RED}Failed to get file system details${NC}"
        return
    fi
    
    local display_name state metered_bytes ad_name time_created fs_id
    display_name=$(echo "$fs_json" | jq -r '.data["display-name"] // "N/A"')
    state=$(echo "$fs_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    metered_bytes=$(echo "$fs_json" | jq -r '.data["metered-bytes"] // "0"')
    ad_name=$(echo "$fs_json" | jq -r '.data["availability-domain"] // "N/A"')
    time_created=$(echo "$fs_json" | jq -r '.data["time-created"] // "N/A"')
    fs_id=$(echo "$fs_json" | jq -r '.data.id // "N/A"')
    
    local metered_gb
    metered_gb=$(echo "scale=2; $metered_bytes / 1073741824" | bc 2>/dev/null || echo "0")
    
    local state_color="$GREEN"
    case "$state" in
        ACTIVE) state_color="$GREEN" ;;
        CREATING|UPDATING) state_color="$YELLOW" ;;
        *) state_color="$RED" ;;
    esac
    
    echo -e "  ${CYAN}Display Name:${NC}        ${WHITE}$display_name${NC}"
    echo -e "  ${CYAN}State:${NC}               ${state_color}$state${NC}"
    echo -e "  ${CYAN}Metered Size:${NC}        ${WHITE}${metered_gb} GB${NC}"
    echo -e "  ${CYAN}Availability Domain:${NC} ${WHITE}$ad_name${NC}"
    echo -e "  ${CYAN}Time Created:${NC}        ${WHITE}$time_created${NC}"
    echo -e "  ${CYAN}File System OCID:${NC}    ${YELLOW}$fs_id${NC}"
    echo ""
    
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# FSS - Create File System
#--------------------------------------------------------------------------------
fss_create_file_system() {
    local compartment_id="$1"
    local ad="$2"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Create File System ═══${NC}"
    echo ""
    
    # Get AD if not set
    if [[ -z "$ad" ]]; then
        echo -e "${CYAN}Available Availability Domains:${NC}"
        local ads_json
        ads_json=$(oci iam availability-domain list --compartment-id "$compartment_id" --output json 2>/dev/null)
        
        local idx=0
        declare -A AD_MAP
        while read -r ad_name; do
            [[ -z "$ad_name" ]] && continue
            ((idx++))
            AD_MAP[$idx]="$ad_name"
            echo -e "  ${YELLOW}$idx${NC}) $ad_name"
        done < <(echo "$ads_json" | jq -r '.data[].name' 2>/dev/null)
        
        echo ""
        echo -n -e "${CYAN}Select AD #: ${NC}"
        read -r ad_selection
        ad="${AD_MAP[$ad_selection]}"
        
        if [[ -z "$ad" ]]; then
            echo -e "${RED}Invalid selection${NC}"
            return
        fi
    fi
    
    echo -n -e "${CYAN}Enter display name for file system: ${NC}"
    read -r fs_name
    
    if [[ -z "$fs_name" ]]; then
        echo -e "${RED}Display name is required${NC}"
        return
    fi
    
    echo ""
    local create_cmd="oci fs file-system create --compartment-id \"$compartment_id\" --availability-domain \"$ad\" --display-name \"$fs_name\""
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$create_cmd${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Proceed with creation? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    # Log the action
    local log_file="${LOGS_DIR}/fss_actions_$(date +%Y%m%d).log"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] CREATE FILE SYSTEM: $create_cmd" >> "$log_file"
    
    echo ""
    echo -e "${CYAN}Creating file system...${NC}"
    
    local result
    result=$(oci fs file-system create \
        --compartment-id "$compartment_id" \
        --availability-domain "$ad" \
        --display-name "$fs_name" \
        --output json 2>&1)
    
    if echo "$result" | jq -e '.data.id' > /dev/null 2>&1; then
        local new_fs_id
        new_fs_id=$(echo "$result" | jq -r '.data.id')
        echo -e "${GREEN}✓ File system created successfully${NC}"
        echo -e "  ${CYAN}OCID:${NC} ${YELLOW}$new_fs_id${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created $new_fs_id" >> "$log_file"
    else
        echo -e "${RED}Failed to create file system${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# FSS - Update File System
#--------------------------------------------------------------------------------
fss_update_file_system() {
    local compartment_id="$1"
    local ad="$2"
    
    FSS_SELECTED_FS=""
    fss_list_file_systems "$compartment_id" "$ad" "select"
    
    [[ -z "$FSS_SELECTED_FS" ]] && return
    
    echo ""
    echo -n -e "${CYAN}Enter new display name: ${NC}"
    read -r new_name
    
    if [[ -z "$new_name" ]]; then
        echo -e "${RED}Display name is required${NC}"
        return
    fi
    
    echo ""
    local update_cmd="oci fs file-system update --file-system-id \"$FSS_SELECTED_FS\" --display-name \"$new_name\""
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$update_cmd${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Proceed with update? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local log_file="${LOGS_DIR}/fss_actions_$(date +%Y%m%d).log"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] UPDATE FILE SYSTEM: $update_cmd" >> "$log_file"
    
    local result
    result=$(oci fs file-system update \
        --file-system-id "$FSS_SELECTED_FS" \
        --display-name "$new_name" \
        --output json 2>&1)
    
    if echo "$result" | jq -e '.data.id' > /dev/null 2>&1; then
        echo -e "${GREEN}✓ File system updated successfully${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Updated $FSS_SELECTED_FS" >> "$log_file"
    else
        echo -e "${RED}Failed to update file system${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# FSS - Delete File System
#--------------------------------------------------------------------------------
fss_delete_file_system() {
    local compartment_id="$1"
    local ad="$2"
    
    FSS_SELECTED_FS=""
    fss_list_file_systems "$compartment_id" "$ad" "select"
    
    [[ -z "$FSS_SELECTED_FS" ]] && return
    
    echo ""
    echo -e "${RED}WARNING: This will permanently delete the file system and all its data!${NC}"
    echo ""
    local delete_cmd="oci fs file-system delete --file-system-id \"$FSS_SELECTED_FS\" --force"
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$delete_cmd${NC}"
    echo ""
    
    echo -n -e "${RED}Type 'DELETE' to confirm: ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "DELETE" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local log_file="${LOGS_DIR}/fss_actions_$(date +%Y%m%d).log"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] DELETE FILE SYSTEM: $delete_cmd" >> "$log_file"
    
    echo ""
    echo -e "${CYAN}Deleting file system...${NC}"
    
    local result
    result=$(oci fs file-system delete \
        --file-system-id "$FSS_SELECTED_FS" \
        --force 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}✓ File system deletion initiated${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted $FSS_SELECTED_FS" >> "$log_file"
    else
        echo -e "${RED}Failed to delete file system${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# FSS - List Mount Targets
#--------------------------------------------------------------------------------
fss_list_mount_targets() {
    local compartment_id="$1"
    local ad="$2"
    local action="${3:-none}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Mount Targets ═══${NC}"
    echo ""
    
    local mt_json
    local all_mt_json="[]"
    
    if [[ -n "$ad" ]]; then
        # Single AD specified
        local list_cmd="oci fs mount-target list --compartment-id \"$compartment_id\" --availability-domain \"$ad\" --all --output json"
        echo -e "${GRAY}$list_cmd${NC}"
        echo ""
        
        mt_json=$(oci fs mount-target list \
            --compartment-id "$compartment_id" \
            --availability-domain "$ad" \
            --all \
            --output json 2>&1)
        
        if [[ $? -ne 0 ]]; then
            echo -e "${RED}Error listing mount targets:${NC}"
            echo "$mt_json" | while IFS= read -r line; do echo -e "${RED}  $line${NC}"; done
            return 1
        fi
        
        all_mt_json=$(echo "$mt_json" | jq '.data // []' 2>/dev/null)
    else
        # No AD specified - iterate through all ADs
        echo -e "${CYAN}Getting availability domains...${NC}"
        local ads
        ads=$(fss_get_availability_domains "$compartment_id")
        
        if [[ -z "$ads" ]]; then
            echo -e "${RED}Unable to get availability domains${NC}"
            return 1
        fi
        
        while IFS= read -r ad_name; do
            [[ -z "$ad_name" ]] && continue
            
            local list_cmd="oci fs mount-target list --compartment-id \"$compartment_id\" --availability-domain \"$ad_name\" --all --output json"
            echo -e "${GRAY}$list_cmd${NC}"
            
            mt_json=$(oci fs mount-target list \
                --compartment-id "$compartment_id" \
                --availability-domain "$ad_name" \
                --all \
                --output json 2>&1)
            
            if [[ $? -ne 0 ]]; then
                echo -e "${RED}Error listing mount targets in $ad_name:${NC}"
                echo "$mt_json" | head -3 | while IFS= read -r line; do echo -e "${RED}  $line${NC}"; done
                continue
            fi
            
            local mt_data
            mt_data=$(echo "$mt_json" | jq '.data // []' 2>/dev/null)
            all_mt_json=$(echo "$all_mt_json" "$mt_data" | jq -s 'add' 2>/dev/null)
            
        done <<< "$ads"
        echo ""
    fi
    
    local mt_count
    mt_count=$(echo "$all_mt_json" | jq 'length' 2>/dev/null) || mt_count=0
    
    if [[ "$mt_count" -eq 0 ]]; then
        echo -e "${YELLOW}No mount targets found${NC}"
        return 1
    fi
    
    echo -e "${GREEN}Found $mt_count mount target(s)${NC}"
    echo ""
    
    printf "${BOLD}%-3s %-30s %-12s %-20s %-18s %s${NC}\n" "#" "Display Name" "State" "Availability Domain" "Private IP" "Mount Target OCID"
    print_separator 180
    
    local idx=0
    declare -gA FSS_MT_MAP
    FSS_MT_MAP=()
    
    while IFS='|' read -r display_name state ad_name private_ips mt_id; do
        [[ -z "$display_name" ]] && continue
        ((idx++))
        
        FSS_MT_MAP[$idx]="$mt_id"
        
        local state_color="$GREEN"
        case "$state" in
            ACTIVE) state_color="$GREEN" ;;
            CREATING|UPDATING) state_color="$YELLOW" ;;
            DELETING|DELETED|FAILED) state_color="$RED" ;;
            *) state_color="$GRAY" ;;
        esac
        
        local name_trunc="${display_name:0:28}"
        [[ ${#display_name} -gt 28 ]] && name_trunc="${name_trunc}.."
        
        local ad_short="${ad_name##*:}"
        
        # Extract first private IP
        local first_ip
        first_ip=$(echo "$private_ips" | jq -r '.[0] // "N/A"' 2>/dev/null)
        
        printf "${YELLOW}%-3s${NC} %-30s ${state_color}%-12s${NC} %-20s %-18s ${GRAY}%s${NC}\n" \
            "$idx" "$name_trunc" "$state" "$ad_short" "$first_ip" "$mt_id"
            
    done < <(echo "$all_mt_json" | jq -r '.[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["availability-domain"])|\(.["private-ip-ids"])|\(.id)"' 2>/dev/null)
    
    FSS_MT_COUNT=$idx
    echo ""
    
    case "$action" in
        none)
            echo -e "Press Enter to continue..."
            read -r
            ;;
        select)
            echo -n -e "${CYAN}Enter mount target # (or Enter to cancel): ${NC}"
            read -r mt_selection
            if [[ -n "$mt_selection" && -n "${FSS_MT_MAP[$mt_selection]}" ]]; then
                FSS_SELECTED_MT="${FSS_MT_MAP[$mt_selection]}"
            fi
            ;;
    esac
    
    return 0
}

#--------------------------------------------------------------------------------
# FSS - View Mount Target Details (with mount commands)
#--------------------------------------------------------------------------------
fss_view_mount_target_details() {
    local compartment_id="$1"
    local ad="$2"
    
    FSS_SELECTED_MT=""
    fss_list_mount_targets "$compartment_id" "$ad" "select"
    
    [[ -z "$FSS_SELECTED_MT" ]] && return
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Mount Target Details ═══${NC}"
    echo ""
    
    local get_cmd="oci fs mount-target get --mount-target-id \"$FSS_SELECTED_MT\" --output json"
    echo -e "${GRAY}$get_cmd${NC}"
    echo ""
    
    local mt_json
    mt_json=$(oci fs mount-target get --mount-target-id "$FSS_SELECTED_MT" --output json 2>/dev/null)
    
    if [[ -z "$mt_json" || "$mt_json" == "null" ]]; then
        echo -e "${RED}Failed to get mount target details${NC}"
        return
    fi
    
    local display_name state ad_name subnet_id export_set_id time_created mt_id
    display_name=$(echo "$mt_json" | jq -r '.data["display-name"] // "N/A"')
    state=$(echo "$mt_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    ad_name=$(echo "$mt_json" | jq -r '.data["availability-domain"] // "N/A"')
    subnet_id=$(echo "$mt_json" | jq -r '.data["subnet-id"] // "N/A"')
    export_set_id=$(echo "$mt_json" | jq -r '.data["export-set-id"] // "N/A"')
    time_created=$(echo "$mt_json" | jq -r '.data["time-created"] // "N/A"')
    mt_id=$(echo "$mt_json" | jq -r '.data.id // "N/A"')
    
    # Get private IPs
    local private_ip_ids
    private_ip_ids=$(echo "$mt_json" | jq -r '.data["private-ip-ids"][]' 2>/dev/null)
    
    local state_color="$GREEN"
    case "$state" in
        ACTIVE) state_color="$GREEN" ;;
        CREATING|UPDATING) state_color="$YELLOW" ;;
        *) state_color="$RED" ;;
    esac
    
    echo -e "  ${CYAN}Display Name:${NC}        ${WHITE}$display_name${NC}"
    echo -e "  ${CYAN}State:${NC}               ${state_color}$state${NC}"
    echo -e "  ${CYAN}Availability Domain:${NC} ${WHITE}$ad_name${NC}"
    echo -e "  ${CYAN}Subnet OCID:${NC}         ${GRAY}$subnet_id${NC}"
    echo -e "  ${CYAN}Export Set OCID:${NC}     ${GRAY}$export_set_id${NC}"
    echo -e "  ${CYAN}Time Created:${NC}        ${WHITE}$time_created${NC}"
    echo -e "  ${CYAN}Mount Target OCID:${NC}   ${YELLOW}$mt_id${NC}"
    echo ""
    
    # Resolve private IPs to actual addresses
    if [[ -n "$private_ip_ids" ]]; then
        echo -e "${BOLD}${WHITE}Private IP Addresses:${NC}"
        for pip_id in $private_ip_ids; do
            local pip_json
            pip_json=$(oci network private-ip get --private-ip-id "$pip_id" --output json 2>/dev/null)
            local ip_addr
            ip_addr=$(echo "$pip_json" | jq -r '.data["ip-address"] // "N/A"')
            local hostname
            hostname=$(echo "$pip_json" | jq -r '.data["hostname-label"] // ""')
            echo -e "  ${CYAN}IP:${NC} ${WHITE}$ip_addr${NC}  ${GRAY}$hostname${NC}"
            
            # Show mount command example
            echo ""
            echo -e "${BOLD}${WHITE}Mount Command Examples:${NC}"
            echo -e "  ${GRAY}# Mount file system (replace <export-path> with actual export path)${NC}"
            echo -e "  ${WHITE}sudo mount -t nfs -o nfsvers=3 ${ip_addr}:/<export-path> /mnt/fss${NC}"
            echo ""
            echo -e "  ${GRAY}# For NFSv4:${NC}"
            echo -e "  ${WHITE}sudo mount -t nfs -o nfsvers=4 ${ip_addr}:/<export-path> /mnt/fss${NC}"
        done
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# FSS - Create Mount Target
#--------------------------------------------------------------------------------
fss_create_mount_target() {
    local compartment_id="$1"
    local ad="$2"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Create Mount Target ═══${NC}"
    echo ""
    
    # Get AD if not set
    if [[ -z "$ad" ]]; then
        echo -e "${CYAN}Available Availability Domains:${NC}"
        local ads_json
        ads_json=$(oci iam availability-domain list --compartment-id "$compartment_id" --output json 2>/dev/null)
        
        local idx=0
        declare -A AD_MAP
        while read -r ad_name; do
            [[ -z "$ad_name" ]] && continue
            ((idx++))
            AD_MAP[$idx]="$ad_name"
            echo -e "  ${YELLOW}$idx${NC}) $ad_name"
        done < <(echo "$ads_json" | jq -r '.data[].name' 2>/dev/null)
        
        echo ""
        echo -n -e "${CYAN}Select AD #: ${NC}"
        read -r ad_selection
        ad="${AD_MAP[$ad_selection]}"
        
        if [[ -z "$ad" ]]; then
            echo -e "${RED}Invalid selection${NC}"
            return
        fi
    fi
    
    # List subnets
    echo ""
    echo -e "${CYAN}Available Subnets:${NC}"
    local subnets_json
    subnets_json=$(oci network subnet list --compartment-id "$compartment_id" --all --output json 2>/dev/null)
    
    local idx=0
    declare -A SUBNET_MAP
    while IFS='|' read -r subnet_name subnet_id cidr; do
        [[ -z "$subnet_name" ]] && continue
        ((idx++))
        SUBNET_MAP[$idx]="$subnet_id"
        echo -e "  ${YELLOW}$idx${NC}) $subnet_name (${cidr})"
    done < <(echo "$subnets_json" | jq -r '.data[] | "\(.["display-name"])|\(.id)|\(.["cidr-block"])"' 2>/dev/null)
    
    echo ""
    echo -n -e "${CYAN}Select subnet #: ${NC}"
    read -r subnet_selection
    local subnet_id="${SUBNET_MAP[$subnet_selection]}"
    
    if [[ -z "$subnet_id" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return
    fi
    
    echo -n -e "${CYAN}Enter display name for mount target: ${NC}"
    read -r mt_name
    
    if [[ -z "$mt_name" ]]; then
        echo -e "${RED}Display name is required${NC}"
        return
    fi
    
    echo ""
    local create_cmd="oci fs mount-target create --compartment-id \"$compartment_id\" --availability-domain \"$ad\" --subnet-id \"$subnet_id\" --display-name \"$mt_name\""
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$create_cmd${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Proceed with creation? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local log_file="${LOGS_DIR}/fss_actions_$(date +%Y%m%d).log"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] CREATE MOUNT TARGET: $create_cmd" >> "$log_file"
    
    echo ""
    echo -e "${CYAN}Creating mount target...${NC}"
    
    local result
    result=$(oci fs mount-target create \
        --compartment-id "$compartment_id" \
        --availability-domain "$ad" \
        --subnet-id "$subnet_id" \
        --display-name "$mt_name" \
        --output json 2>&1)
    
    if echo "$result" | jq -e '.data.id' > /dev/null 2>&1; then
        local new_mt_id
        new_mt_id=$(echo "$result" | jq -r '.data.id')
        echo -e "${GREEN}✓ Mount target created successfully${NC}"
        echo -e "  ${CYAN}OCID:${NC} ${YELLOW}$new_mt_id${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created $new_mt_id" >> "$log_file"
    else
        echo -e "${RED}Failed to create mount target${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# FSS - Delete Mount Target
#--------------------------------------------------------------------------------
fss_delete_mount_target() {
    local compartment_id="$1"
    local ad="$2"
    
    FSS_SELECTED_MT=""
    fss_list_mount_targets "$compartment_id" "$ad" "select"
    
    [[ -z "$FSS_SELECTED_MT" ]] && return
    
    echo ""
    echo -e "${RED}WARNING: This will delete the mount target!${NC}"
    echo ""
    local delete_cmd="oci fs mount-target delete --mount-target-id \"$FSS_SELECTED_MT\" --force"
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$delete_cmd${NC}"
    echo ""
    
    echo -n -e "${RED}Type 'DELETE' to confirm: ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "DELETE" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local log_file="${LOGS_DIR}/fss_actions_$(date +%Y%m%d).log"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] DELETE MOUNT TARGET: $delete_cmd" >> "$log_file"
    
    echo ""
    echo -e "${CYAN}Deleting mount target...${NC}"
    
    local result
    result=$(oci fs mount-target delete \
        --mount-target-id "$FSS_SELECTED_MT" \
        --force 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}✓ Mount target deletion initiated${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted $FSS_SELECTED_MT" >> "$log_file"
    else
        echo -e "${RED}Failed to delete mount target${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# FSS - List Exports
#--------------------------------------------------------------------------------
fss_list_exports() {
    local compartment_id="$1"
    local action="${2:-none}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Exports ═══${NC}"
    echo ""
    
    local list_cmd="oci fs export list --compartment-id \"$compartment_id\" --all --output json"
    echo -e "${GRAY}$list_cmd${NC}"
    echo ""
    
    local export_json
    export_json=$(oci fs export list \
        --compartment-id "$compartment_id" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$export_json" || "$export_json" == "null" ]]; then
        echo -e "${YELLOW}No exports found or unable to list${NC}"
        return 1
    fi
    
    local export_count
    export_count=$(echo "$export_json" | jq '.data | length' 2>/dev/null)
    
    if [[ "$export_count" -eq 0 ]]; then
        echo -e "${YELLOW}No exports found${NC}"
        return 1
    fi
    
    echo -e "${GREEN}Found $export_count export(s)${NC}"
    echo ""
    
    printf "${BOLD}%-3s %-30s %-12s %-50s %s${NC}\n" "#" "Path" "State" "File System OCID" "Export OCID"
    print_separator 180
    
    local idx=0
    declare -gA FSS_EXPORT_MAP
    FSS_EXPORT_MAP=()
    
    while IFS='|' read -r path state fs_id export_id; do
        [[ -z "$path" ]] && continue
        ((idx++))
        
        FSS_EXPORT_MAP[$idx]="$export_id"
        
        local state_color="$GREEN"
        case "$state" in
            ACTIVE) state_color="$GREEN" ;;
            CREATING|UPDATING) state_color="$YELLOW" ;;
            DELETING|DELETED|FAILED) state_color="$RED" ;;
            *) state_color="$GRAY" ;;
        esac
        
        local path_trunc="${path:0:28}"
        [[ ${#path} -gt 28 ]] && path_trunc="${path_trunc}.."
        
        local fs_short="${fs_id:0:48}..."
        
        printf "${YELLOW}%-3s${NC} %-30s ${state_color}%-12s${NC} ${GRAY}%-50s %s${NC}\n" \
            "$idx" "$path_trunc" "$state" "$fs_short" "$export_id"
            
    done < <(echo "$export_json" | jq -r '.data[] | "\(.path)|\(.["lifecycle-state"])|\(.["file-system-id"])|\(.id)"' 2>/dev/null)
    
    FSS_EXPORT_COUNT=$idx
    echo ""
    
    case "$action" in
        none)
            echo -e "Press Enter to continue..."
            read -r
            ;;
        select)
            echo -n -e "${CYAN}Enter export # (or Enter to cancel): ${NC}"
            read -r export_selection
            if [[ -n "$export_selection" && -n "${FSS_EXPORT_MAP[$export_selection]}" ]]; then
                FSS_SELECTED_EXPORT="${FSS_EXPORT_MAP[$export_selection]}"
            fi
            ;;
    esac
    
    return 0
}

#--------------------------------------------------------------------------------
# FSS - Create Export
#--------------------------------------------------------------------------------
fss_create_export() {
    local compartment_id="$1"
    local ad="$2"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Create Export ═══${NC}"
    echo ""
    
    # Select file system
    echo -e "${CYAN}Select a file system to export:${NC}"
    FSS_SELECTED_FS=""
    fss_list_file_systems "$compartment_id" "$ad" "select"
    
    if [[ -z "$FSS_SELECTED_FS" ]]; then
        echo -e "${RED}No file system selected${NC}"
        return
    fi
    
    # Select mount target (to get export set)
    echo ""
    echo -e "${CYAN}Select a mount target:${NC}"
    FSS_SELECTED_MT=""
    fss_list_mount_targets "$compartment_id" "$ad" "select"
    
    if [[ -z "$FSS_SELECTED_MT" ]]; then
        echo -e "${RED}No mount target selected${NC}"
        return
    fi
    
    # Get export set ID from mount target
    local mt_json
    mt_json=$(oci fs mount-target get --mount-target-id "$FSS_SELECTED_MT" --output json 2>/dev/null)
    local export_set_id
    export_set_id=$(echo "$mt_json" | jq -r '.data["export-set-id"]')
    
    if [[ -z "$export_set_id" || "$export_set_id" == "null" ]]; then
        echo -e "${RED}Could not get export set from mount target${NC}"
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Enter export path (e.g., /myfs): ${NC}"
    read -r export_path
    
    if [[ -z "$export_path" ]]; then
        export_path="/${RANDOM}"
        echo -e "${YELLOW}Using default path: $export_path${NC}"
    fi
    
    echo ""
    local create_cmd="oci fs export create --file-system-id \"$FSS_SELECTED_FS\" --export-set-id \"$export_set_id\" --path \"$export_path\""
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$create_cmd${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Proceed with creation? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local log_file="${LOGS_DIR}/fss_actions_$(date +%Y%m%d).log"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] CREATE EXPORT: $create_cmd" >> "$log_file"
    
    echo ""
    echo -e "${CYAN}Creating export...${NC}"
    
    local result
    result=$(oci fs export create \
        --file-system-id "$FSS_SELECTED_FS" \
        --export-set-id "$export_set_id" \
        --path "$export_path" \
        --output json 2>&1)
    
    if echo "$result" | jq -e '.data.id' > /dev/null 2>&1; then
        local new_export_id
        new_export_id=$(echo "$result" | jq -r '.data.id')
        echo -e "${GREEN}✓ Export created successfully${NC}"
        echo -e "  ${CYAN}OCID:${NC} ${YELLOW}$new_export_id${NC}"
        echo -e "  ${CYAN}Path:${NC} ${WHITE}$export_path${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created $new_export_id" >> "$log_file"
    else
        echo -e "${RED}Failed to create export${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# FSS - Delete Export
#--------------------------------------------------------------------------------
fss_delete_export() {
    local compartment_id="$1"
    
    FSS_SELECTED_EXPORT=""
    fss_list_exports "$compartment_id" "select"
    
    [[ -z "$FSS_SELECTED_EXPORT" ]] && return
    
    echo ""
    echo -e "${RED}WARNING: This will delete the export!${NC}"
    echo ""
    local delete_cmd="oci fs export delete --export-id \"$FSS_SELECTED_EXPORT\" --force"
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$delete_cmd${NC}"
    echo ""
    
    echo -n -e "${RED}Type 'DELETE' to confirm: ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "DELETE" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local log_file="${LOGS_DIR}/fss_actions_$(date +%Y%m%d).log"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] DELETE EXPORT: $delete_cmd" >> "$log_file"
    
    echo ""
    echo -e "${CYAN}Deleting export...${NC}"
    
    local result
    result=$(oci fs export delete \
        --export-id "$FSS_SELECTED_EXPORT" \
        --force 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}✓ Export deletion initiated${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted $FSS_SELECTED_EXPORT" >> "$log_file"
    else
        echo -e "${RED}Failed to delete export${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# FSS - List Snapshots
#--------------------------------------------------------------------------------
fss_list_snapshots() {
    local compartment_id="$1"
    local ad="$2"
    local action="${3:-none}"
    
    # First select a file system
    echo -e "${CYAN}Select a file system to view snapshots:${NC}"
    FSS_SELECTED_FS=""
    fss_list_file_systems "$compartment_id" "$ad" "select"
    
    if [[ -z "$FSS_SELECTED_FS" ]]; then
        return
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Snapshots ═══${NC}"
    echo ""
    
    local list_cmd="oci fs snapshot list --file-system-id \"$FSS_SELECTED_FS\" --all --output json"
    echo -e "${GRAY}$list_cmd${NC}"
    echo ""
    
    local snap_json
    snap_json=$(oci fs snapshot list \
        --file-system-id "$FSS_SELECTED_FS" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$snap_json" || "$snap_json" == "null" ]]; then
        echo -e "${YELLOW}No snapshots found or unable to list${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return 1
    fi
    
    local snap_count
    snap_count=$(echo "$snap_json" | jq '.data | length' 2>/dev/null)
    
    if [[ "$snap_count" -eq 0 ]]; then
        echo -e "${YELLOW}No snapshots found${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return 1
    fi
    
    echo -e "${GREEN}Found $snap_count snapshot(s)${NC}"
    echo ""
    
    printf "${BOLD}%-3s %-40s %-12s %-25s %s${NC}\n" "#" "Name" "State" "Time Created" "Snapshot OCID"
    print_separator 160
    
    local idx=0
    declare -gA FSS_SNAP_MAP
    FSS_SNAP_MAP=()
    
    while IFS='|' read -r name state time_created snap_id; do
        [[ -z "$name" ]] && continue
        ((idx++))
        
        FSS_SNAP_MAP[$idx]="$snap_id"
        
        local state_color="$GREEN"
        case "$state" in
            ACTIVE) state_color="$GREEN" ;;
            CREATING|UPDATING) state_color="$YELLOW" ;;
            DELETING|DELETED|FAILED) state_color="$RED" ;;
            *) state_color="$GRAY" ;;
        esac
        
        local name_trunc="${name:0:38}"
        [[ ${#name} -gt 38 ]] && name_trunc="${name_trunc}.."
        
        local time_short="${time_created:0:23}"
        
        printf "${YELLOW}%-3s${NC} %-40s ${state_color}%-12s${NC} %-25s ${GRAY}%s${NC}\n" \
            "$idx" "$name_trunc" "$state" "$time_short" "$snap_id"
            
    done < <(echo "$snap_json" | jq -r '.data[] | "\(.name)|\(.["lifecycle-state"])|\(.["time-created"])|\(.id)"' 2>/dev/null)
    
    FSS_SNAP_COUNT=$idx
    echo ""
    
    case "$action" in
        none)
            echo -e "Press Enter to continue..."
            read -r
            ;;
        select)
            echo -n -e "${CYAN}Enter snapshot # (or Enter to cancel): ${NC}"
            read -r snap_selection
            if [[ -n "$snap_selection" && -n "${FSS_SNAP_MAP[$snap_selection]}" ]]; then
                FSS_SELECTED_SNAP="${FSS_SNAP_MAP[$snap_selection]}"
            fi
            ;;
    esac
    
    return 0
}

#--------------------------------------------------------------------------------
# FSS - Create Snapshot
#--------------------------------------------------------------------------------
fss_create_snapshot() {
    local compartment_id="$1"
    local ad="$2"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Create Snapshot ═══${NC}"
    echo ""
    
    # Select file system
    echo -e "${CYAN}Select a file system:${NC}"
    FSS_SELECTED_FS=""
    fss_list_file_systems "$compartment_id" "$ad" "select"
    
    if [[ -z "$FSS_SELECTED_FS" ]]; then
        echo -e "${RED}No file system selected${NC}"
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Enter snapshot name: ${NC}"
    read -r snap_name
    
    if [[ -z "$snap_name" ]]; then
        snap_name="snapshot-$(date +%Y%m%d-%H%M%S)"
        echo -e "${YELLOW}Using default name: $snap_name${NC}"
    fi
    
    echo ""
    local create_cmd="oci fs snapshot create --file-system-id \"$FSS_SELECTED_FS\" --name \"$snap_name\""
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$create_cmd${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Proceed with creation? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local log_file="${LOGS_DIR}/fss_actions_$(date +%Y%m%d).log"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] CREATE SNAPSHOT: $create_cmd" >> "$log_file"
    
    echo ""
    echo -e "${CYAN}Creating snapshot...${NC}"
    
    local result
    result=$(oci fs snapshot create \
        --file-system-id "$FSS_SELECTED_FS" \
        --name "$snap_name" \
        --output json 2>&1)
    
    if echo "$result" | jq -e '.data.id' > /dev/null 2>&1; then
        local new_snap_id
        new_snap_id=$(echo "$result" | jq -r '.data.id')
        echo -e "${GREEN}✓ Snapshot created successfully${NC}"
        echo -e "  ${CYAN}OCID:${NC} ${YELLOW}$new_snap_id${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created $new_snap_id" >> "$log_file"
    else
        echo -e "${RED}Failed to create snapshot${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# FSS - Delete Snapshot
#--------------------------------------------------------------------------------
fss_delete_snapshot() {
    local compartment_id="$1"
    local ad="$2"
    
    FSS_SELECTED_SNAP=""
    fss_list_snapshots "$compartment_id" "$ad" "select"
    
    [[ -z "$FSS_SELECTED_SNAP" ]] && return
    
    echo ""
    echo -e "${RED}WARNING: This will delete the snapshot!${NC}"
    echo ""
    local delete_cmd="oci fs snapshot delete --snapshot-id \"$FSS_SELECTED_SNAP\" --force"
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$delete_cmd${NC}"
    echo ""
    
    echo -n -e "${RED}Type 'DELETE' to confirm: ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "DELETE" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local log_file="${LOGS_DIR}/fss_actions_$(date +%Y%m%d).log"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] DELETE SNAPSHOT: $delete_cmd" >> "$log_file"
    
    echo ""
    echo -e "${CYAN}Deleting snapshot...${NC}"
    
    local result
    result=$(oci fs snapshot delete \
        --snapshot-id "$FSS_SELECTED_SNAP" \
        --force 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}✓ Snapshot deletion initiated${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted $FSS_SELECTED_SNAP" >> "$log_file"
    else
        echo -e "${RED}Failed to delete snapshot${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#================================================================================
# LUSTRE FILE SYSTEM MANAGEMENT
#================================================================================

#--------------------------------------------------------------------------------
# Manage Lustre File Systems - Main menu
#--------------------------------------------------------------------------------
manage_lustre_file_systems() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    while true; do
        echo ""
        echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${MAGENTA}                                        LUSTRE FILE SYSTEMS                                                      ${NC}"
        echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}Environment:${NC}"
        echo -e "  ${CYAN}Region:${NC}      ${WHITE}${region}${NC}"
        echo -e "  ${CYAN}Compartment:${NC} ${WHITE}$(resolve_compartment_name "${compartment_id}")${NC} ${GRAY}(${compartment_id})${NC}"
        echo ""
        
        # Fetch all Lustre file systems across all ADs
        echo -e "${GRAY}Fetching Lustre file systems...${NC}"
        local lfs_json
        lfs_json=$(oci lfs lustre-file-system-collection list-lustre-file-systems \
            --compartment-id "$compartment_id" \
            --all \
            --output json 2>/dev/null)
        
        local lfs_count=0
        if [[ -n "$lfs_json" && "$lfs_json" != "null" ]]; then
            lfs_count=$(echo "$lfs_json" | jq '.data.items | length' 2>/dev/null || echo "0")
        fi
        
        # Display summary table
        echo -e "${BOLD}${WHITE}═══ Lustre File Systems Summary (${lfs_count} found) ═══${NC}"
        echo ""
        
        if [[ "$lfs_count" -gt 0 ]]; then
            # Group by AD
            local ads_list
            ads_list=$(echo "$lfs_json" | jq -r '.data.items[]["availability-domain"]' 2>/dev/null | sort -u)
            
            declare -gA LFS_MAP
            LFS_MAP=()
            local idx=0
            
            for ad in $ads_list; do
                local ad_short="${ad##*:}"
                echo -e "${BOLD}${CYAN}─── $ad_short ───${NC}"
                echo ""
                
                printf "  ${BOLD}%-3s %-28s %-10s %-8s %-12s %-10s %-8s %-20s${NC}\n" \
                    "#" "Display Name" "State" "Capacity" "Perf Tier" "Version" "OS Link" "MGS Address"
                print_separator 120
                
                # Get file systems for this AD
                while IFS='|' read -r display_name state capacity_gb perf_tier version mgs_address fs_name lfs_id; do
                    [[ -z "$display_name" ]] && continue
                    ((idx++))
                    
                    LFS_MAP[$idx]="$lfs_id"
                    
                    local state_color="$GREEN"
                    case "$state" in
                        ACTIVE) state_color="$GREEN" ;;
                        CREATING|UPDATING) state_color="$YELLOW" ;;
                        DELETING|DELETED|FAILED) state_color="$RED" ;;
                        *) state_color="$GRAY" ;;
                    esac
                    
                    local name_trunc="${display_name:0:26}"
                    [[ ${#display_name} -gt 26 ]] && name_trunc="${name_trunc}.."
                    
                    # Convert capacity to TB
                    local capacity_display="N/A"
                    if [[ "$capacity_gb" =~ ^[0-9]+$ ]] && [[ "$capacity_gb" -gt 0 ]]; then
                        capacity_display=$(echo "scale=1; $capacity_gb / 1000" | bc)
                        capacity_display="${capacity_display}TB"
                    fi
                    
                    # Shorten performance tier
                    local perf_short="N/A"
                    case "$perf_tier" in
                        MBPS_PER_TB_125) perf_short="125/TB" ;;
                        MBPS_PER_TB_250) perf_short="250/TB" ;;
                        MBPS_PER_TB_500) perf_short="500/TB" ;;
                        MBPS_PER_TB_1000) perf_short="1000/TB" ;;
                        *) perf_short="${perf_tier:0:10}" ;;
                    esac
                    
                    # Check for object storage links
                    local os_link_status="${GRAY}None${NC}"
                    local os_links_json
                    os_links_json=$(oci lfs data-repository-association-collection list-data-repository-associations \
                        --lustre-file-system-id "$lfs_id" \
                        --output json 2>/dev/null)
                    
                    if [[ -n "$os_links_json" ]]; then
                        local link_count
                        link_count=$(echo "$os_links_json" | jq '.data.items | length' 2>/dev/null || echo "0")
                        if [[ "$link_count" -gt 0 ]]; then
                            local link_state
                            link_state=$(echo "$os_links_json" | jq -r '.data.items[0]["lifecycle-state"] // "N/A"' 2>/dev/null)
                            case "$link_state" in
                                ACTIVE) os_link_status="${GREEN}Active${NC}" ;;
                                CREATING) os_link_status="${YELLOW}Creating${NC}" ;;
                                *) os_link_status="${YELLOW}${link_state:0:8}${NC}" ;;
                            esac
                            [[ "$link_count" -gt 1 ]] && os_link_status="${os_link_status} (${link_count})"
                        fi
                    fi
                    
                    # Version display
                    local version_display="${version:0:8}"
                    [[ "$version" == "null" || -z "$version" ]] && version_display="N/A"
                    
                    # MGS address display
                    local mgs_display="${mgs_address:0:18}"
                    [[ "$mgs_address" == "null" || -z "$mgs_address" ]] && mgs_display="N/A"
                    
                    printf "  ${YELLOW}%-3s${NC} %-28s ${state_color}%-10s${NC} %-8s %-12s %-10s %-8b %-20s\n" \
                        "$idx" "$name_trunc" "$state" "$capacity_display" "$perf_short" "$version_display" "$os_link_status" "$mgs_display"
                    
                    # Show mount command if MGS address and file system name are available
                    if [[ "$mgs_address" != "null" && -n "$mgs_address" && "$fs_name" != "null" && -n "$fs_name" ]]; then
                        printf "      ${GRAY}Mount: sudo mount -t lustre %s:/%s /mnt/lustre${NC}\n" "$mgs_address" "$fs_name"
                    fi
                    
                done < <(echo "$lfs_json" | jq -r --arg ad "$ad" '
                    .data.items[] | 
                    select(.["availability-domain"] == $ad) | 
                    "\(.["display-name"])|\(.["lifecycle-state"])|\(.["capacity-in-gbs"] // 0)|\(.["performance-tier"] // "N/A")|\(.["lustre-version"] // .["major-version"] // "N/A")|\(.["mgs-address"] // "N/A")|\(.["file-system-name"] // "N/A")|\(.id)"
                ' 2>/dev/null)
                
                echo ""
            done
            
            LFS_COUNT=$idx
        else
            echo -e "  ${YELLOW}No Lustre file systems found in this compartment${NC}"
            echo ""
        fi
        
        echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
        echo -e "  ${YELLOW}#${NC}   ${WHITE}View details${NC}               - Enter number to view file system details"
        echo ""
        echo -e "${BOLD}${WHITE}─── File System Operations ───${NC}"
        echo -e "  ${GREEN}c${NC})  ${WHITE}Create Lustre File System${NC}  - Create a new Lustre file system"
        echo -e "  ${CYAN}u${NC})  ${WHITE}Update Lustre File System${NC}  - Update name or capacity"
        echo -e "  ${RED}d${NC})  ${WHITE}Delete Lustre File System${NC}  - Delete a Lustre file system"
        echo ""
        echo -e "${BOLD}${WHITE}─── Object Storage Links ───${NC}"
        echo -e "  ${CYAN}ol${NC}) ${WHITE}List Object Storage Links${NC}  - List all HSM links"
        echo -e "  ${GREEN}oc${NC}) ${WHITE}Create Object Storage Link${NC} - Link Lustre to Object Storage"
        echo -e "  ${CYAN}oi${NC}) ${WHITE}Start Import from Object${NC}   - Import data from Object Storage"
        echo -e "  ${CYAN}oe${NC}) ${WHITE}Start Export to Object${NC}     - Export data to Object Storage"
        echo -e "  ${RED}od${NC}) ${WHITE}Delete Object Storage Link${NC} - Remove an Object Storage link"
        echo ""
        echo -e "${BOLD}${WHITE}─── Monitoring ───${NC}"
        echo -e "  ${CYAN}w${NC})  ${WHITE}Work Requests${NC}              - View Lustre work requests (async operations)"
        echo ""
        echo -e "  ${MAGENTA}r${NC})  Refresh"
        echo -e "  ${CYAN}b${NC})  Back to main menu"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Lustre] Enter selection: ${NC}"
        read -r selection
        
        case "$selection" in
            [0-9]|[0-9][0-9])
                if [[ -n "${LFS_MAP[$selection]}" ]]; then
                    LFS_SELECTED="${LFS_MAP[$selection]}"
                    lfs_view_selected_details "$compartment_id"
                else
                    echo -e "${RED}Invalid selection${NC}"
                fi
                ;;
            c|C) lfs_create_file_system "$compartment_id" ;;
            u|U) lfs_update_file_system "$compartment_id" ;;
            d|D) lfs_delete_file_system "$compartment_id" ;;
            ol|OL) lfs_list_object_storage_links "$compartment_id" ;;
            oc|OC) lfs_create_object_storage_link "$compartment_id" ;;
            oi|OI) lfs_start_import_from_object "$compartment_id" ;;
            oe|OE) lfs_start_export_to_object "$compartment_id" ;;
            od|OD) lfs_delete_object_storage_link "$compartment_id" ;;
            w|W) lfs_list_work_requests "$compartment_id" ;;
            r|R) continue ;;
            b|B|back|BACK|"") return ;;
            *) echo -e "${RED}Invalid selection${NC}" ;;
        esac
    done
}

# View details of already selected LFS
lfs_view_selected_details() {
    local compartment_id="$1"
    
    [[ -z "$LFS_SELECTED" ]] && return
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Lustre File System Details ═══${NC}"
    echo ""
    
    local lfs_json
    lfs_json=$(oci lfs lustre-file-system get --lustre-file-system-id "$LFS_SELECTED" --output json 2>/dev/null)
    
    if [[ -z "$lfs_json" || "$lfs_json" == "null" ]]; then
        echo -e "${RED}Failed to get Lustre file system details${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Call the existing details display logic
    _display_lfs_details "$lfs_json"
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

# Internal function to display LFS details (reusable)
_display_lfs_details() {
    local lfs_json="$1"
    
    # Basic fields
    local display_name state capacity_tb ad_name subnet_id time_created lfs_id
    local file_system_name mgs_address
    
    display_name=$(echo "$lfs_json" | jq -r '.data["display-name"] // "N/A"')
    state=$(echo "$lfs_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    local capacity_gb
    capacity_gb=$(echo "$lfs_json" | jq -r '.data["capacity-in-gbs"] // 0')
    capacity_tb=$(echo "scale=1; $capacity_gb / 1000" | bc)
    ad_name=$(echo "$lfs_json" | jq -r '.data["availability-domain"] // "N/A"')
    subnet_id=$(echo "$lfs_json" | jq -r '.data["subnet-id"] // "N/A"')
    time_created=$(echo "$lfs_json" | jq -r '.data["time-created"] // "N/A"')
    lfs_id=$(echo "$lfs_json" | jq -r '.data.id // "N/A"')
    
    # Lustre-specific fields
    file_system_name=$(echo "$lfs_json" | jq -r '.data["file-system-name"] // "N/A"')
    mgs_address=$(echo "$lfs_json" | jq -r '.data["mgs-address"] // "N/A"')
    
    # Performance tier
    local performance_tier
    performance_tier=$(echo "$lfs_json" | jq -r '.data["performance-tier"] // "N/A"')
    local throughput_display="N/A"
    if [[ "$performance_tier" != "N/A" && "$capacity_gb" -gt 0 ]]; then
        local tier_value
        case "$performance_tier" in
            MBPS_PER_TB_125) tier_value=125 ;;
            MBPS_PER_TB_250) tier_value=250 ;;
            MBPS_PER_TB_500) tier_value=500 ;;
            MBPS_PER_TB_1000) tier_value=1000 ;;
            *) tier_value=0 ;;
        esac
        if [[ "$tier_value" -gt 0 ]]; then
            local expected_throughput
            expected_throughput=$(echo "$capacity_tb * $tier_value" | bc | cut -d'.' -f1)
            throughput_display="${expected_throughput} MB/s (${tier_value} MB/s per TB)"
        fi
    fi
    
    # Lustre version
    local lustre_version
    lustre_version=$(echo "$lfs_json" | jq -r '.data["lustre-version"] // .data["major-version"] // "N/A"')
    
    # Root squash configuration
    local root_squash
    root_squash=$(echo "$lfs_json" | jq -r '.data["root-squash-configuration"]["root-squash"] // .data["root-squash"] // "N/A"')
    
    # Network Security Groups
    local nsg_ids
    nsg_ids=$(echo "$lfs_json" | jq -r '.data["nsg-ids"] // []')
    
    # Encryption / KMS
    local kms_key_id
    kms_key_id=$(echo "$lfs_json" | jq -r '.data["kms-key-id"] // "N/A"')
    local encryption_type="Oracle-managed"
    if [[ "$kms_key_id" != "N/A" && "$kms_key_id" != "null" && -n "$kms_key_id" ]]; then
        encryption_type="Customer-managed (KMS)"
    fi
    
    local state_color="$GREEN"
    case "$state" in
        ACTIVE) state_color="$GREEN" ;;
        CREATING|UPDATING) state_color="$YELLOW" ;;
        *) state_color="$RED" ;;
    esac
    
    # Display basic info section
    echo -e "${BOLD}${CYAN}─── Basic Information ───${NC}"
    echo -e "  ${CYAN}Display Name:${NC}        ${WHITE}$display_name${NC}"
    echo -e "  ${CYAN}File System Name:${NC}    ${WHITE}$file_system_name${NC}"
    echo -e "  ${CYAN}Lustre Version:${NC}      ${WHITE}$lustre_version${NC}"
    echo -e "  ${CYAN}State:${NC}               ${state_color}$state${NC}"
    echo -e "  ${CYAN}Lustre FS OCID:${NC}      ${YELLOW}$lfs_id${NC}"
    echo -e "  ${CYAN}Time Created:${NC}        ${WHITE}$time_created${NC}"
    echo ""
    
    # Display capacity and performance section
    echo -e "${BOLD}${CYAN}─── Capacity & Performance ───${NC}"
    echo -e "  ${CYAN}Capacity:${NC}            ${WHITE}${capacity_tb} TB (${capacity_gb} GB)${NC}"
    echo -e "  ${CYAN}Performance Tier:${NC}    ${WHITE}$performance_tier${NC}"
    echo -e "  ${CYAN}Expected Throughput:${NC} ${WHITE}$throughput_display${NC}"
    echo ""
    
    # Display network section
    echo -e "${BOLD}${CYAN}─── Network Configuration ───${NC}"
    echo -e "  ${CYAN}MGS Address:${NC}         ${WHITE}$mgs_address${NC}"
    echo -e "  ${CYAN}Availability Domain:${NC} ${WHITE}$ad_name${NC}"
    echo -e "  ${CYAN}Subnet OCID:${NC}         ${YELLOW}$subnet_id${NC}"
    local nsg_display
    nsg_display=$(echo "$nsg_ids" | jq -r 'if length > 0 then .[] else empty end' 2>/dev/null)
    if [[ -n "$nsg_display" ]]; then
        echo -e "  ${CYAN}Network Security Groups:${NC}"
        echo "$nsg_ids" | jq -r '.[]?' 2>/dev/null | while read -r nsg; do
            [[ -n "$nsg" ]] && echo -e "    ${YELLOW}$nsg${NC}"
        done
    else
        echo -e "  ${CYAN}Network Security Groups:${NC} ${GRAY}None${NC}"
    fi
    echo ""
    
    # Display security section
    echo -e "${BOLD}${CYAN}─── Security Configuration ───${NC}"
    echo -e "  ${CYAN}Root Squash:${NC}         ${WHITE}$root_squash${NC}"
    echo -e "  ${CYAN}Encryption:${NC}          ${WHITE}$encryption_type${NC}"
    if [[ "$kms_key_id" != "N/A" && "$kms_key_id" != "null" && -n "$kms_key_id" ]]; then
        echo -e "  ${CYAN}KMS Key OCID:${NC}        ${YELLOW}$kms_key_id${NC}"
    fi
    echo ""
    
    # Fetch and display Object Storage Links
    echo -e "${BOLD}${CYAN}─── Object Storage Links ───${NC}"
    local os_links_json
    os_links_json=$(oci lfs data-repository-association-collection list-data-repository-associations \
        --lustre-file-system-id "$lfs_id" \
        --output json 2>/dev/null)
    
    local link_count=0
    if [[ -n "$os_links_json" ]]; then
        link_count=$(echo "$os_links_json" | jq '.data.items | length' 2>/dev/null || echo "0")
    fi
    
    if [[ "$link_count" -gt 0 ]]; then
        local link_idx=0
        while IFS='|' read -r assoc_id assoc_state fs_path bucket prefix import_policy export_policy; do
            ((link_idx++))
            
            local link_state_color="$GREEN"
            case "$assoc_state" in
                ACTIVE) link_state_color="$GREEN" ;;
                CREATING|UPDATING) link_state_color="$YELLOW" ;;
                *) link_state_color="$RED" ;;
            esac
            
            echo -e "  ${CYAN}Link #${link_idx}:${NC}"
            echo -e "    ${CYAN}State:${NC}              ${link_state_color}${assoc_state}${NC}"
            echo -e "    ${CYAN}File System Path:${NC}   ${WHITE}$fs_path${NC}"
            echo -e "    ${CYAN}Bucket:${NC}             ${WHITE}$bucket${NC}"
            echo -e "    ${CYAN}Prefix:${NC}             ${WHITE}${prefix:-none}${NC}"
            echo -e "    ${CYAN}Import Policy:${NC}      ${WHITE}$import_policy${NC}"
            echo -e "    ${CYAN}Export Policy:${NC}      ${WHITE}$export_policy${NC}"
            echo -e "    ${CYAN}Association OCID:${NC}   ${YELLOW}$assoc_id${NC}"
            echo ""
        done < <(echo "$os_links_json" | jq -r '
            .data.items[] |
            "\(.id)|\(.["lifecycle-state"])|\(.["file-system-path"] // "N/A")|\(.bucket // "N/A")|\(.prefix // "")|\(.["data-repository-import-policy"]["import-policy-type"] // "N/A")|\(.["data-repository-export-policy"]["export-policy-type"] // "N/A")"
        ' 2>/dev/null)
    else
        echo -e "  ${GRAY}No Object Storage links configured${NC}"
        echo ""
    fi
    
    # Mount commands
    if [[ "$mgs_address" != "N/A" && "$mgs_address" != "null" && -n "$file_system_name" ]]; then
        echo -e "${BOLD}${CYAN}─── Mount Commands ───${NC}"
        echo ""
        echo -e "  ${GRAY}# Install Lustre client (Oracle Linux / RHEL):${NC}"
        echo -e "  ${WHITE}sudo yum install -y lustre-client${NC}"
        echo ""
        echo -e "  ${GRAY}# Create mount point and mount:${NC}"
        echo -e "  ${WHITE}sudo mkdir -p /mnt/lustre${NC}"
        echo -e "  ${WHITE}sudo mount -t lustre ${mgs_address}:/${file_system_name} /mnt/lustre${NC}"
        echo ""
        echo -e "  ${GRAY}# Add to /etc/fstab for persistent mount:${NC}"
        echo -e "  ${WHITE}${mgs_address}:/${file_system_name} /mnt/lustre lustre defaults,_netdev 0 0${NC}"
    fi
}

#--------------------------------------------------------------------------------
# Lustre - List File Systems
#--------------------------------------------------------------------------------
lfs_list_file_systems() {
    local compartment_id="$1"
    local action="${2:-none}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Lustre File Systems ═══${NC}"
    echo ""
    
    local list_cmd="oci lfs lustre-file-system-collection list-lustre-file-systems --compartment-id \"$compartment_id\" --all --output json"
    echo -e "${GRAY}$list_cmd${NC}"
    echo ""
    
    local lfs_json
    lfs_json=$(oci lfs lustre-file-system-collection list-lustre-file-systems \
        --compartment-id "$compartment_id" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$lfs_json" || "$lfs_json" == "null" ]]; then
        echo -e "${YELLOW}No Lustre file systems found or unable to list${NC}"
        return 1
    fi
    
    local lfs_count
    lfs_count=$(echo "$lfs_json" | jq '.data.items | length' 2>/dev/null)
    
    if [[ "$lfs_count" -eq 0 || -z "$lfs_count" ]]; then
        echo -e "${YELLOW}No Lustre file systems found${NC}"
        return 1
    fi
    
    echo -e "${GREEN}Found $lfs_count Lustre file system(s)${NC}"
    echo ""
    
    printf "${BOLD}%-3s %-30s %-12s %-10s %-20s %s${NC}\n" "#" "Display Name" "State" "Capacity" "Availability Domain" "Lustre FS OCID"
    print_separator 180
    
    local idx=0
    declare -gA LFS_MAP
    LFS_MAP=()
    
    while IFS='|' read -r display_name state capacity_gb ad_name lfs_id; do
        [[ -z "$display_name" ]] && continue
        ((idx++))
        
        LFS_MAP[$idx]="$lfs_id"
        
        local state_color="$GREEN"
        case "$state" in
            ACTIVE) state_color="$GREEN" ;;
            CREATING|UPDATING) state_color="$YELLOW" ;;
            DELETING|DELETED|FAILED) state_color="$RED" ;;
            *) state_color="$GRAY" ;;
        esac
        
        local name_trunc="${display_name:0:28}"
        [[ ${#display_name} -gt 28 ]] && name_trunc="${name_trunc}.."
        
        local ad_short="${ad_name##*:}"
        
        # Display capacity - API may return in GB, convert to TB for display
        local capacity_display
        if [[ "$capacity_gb" =~ ^[0-9]+$ ]] && [[ "$capacity_gb" -gt 500 ]]; then
            # Likely in GB, convert to TB
            capacity_display=$(echo "scale=1; $capacity_gb / 1000" | bc)
            capacity_display="${capacity_display}TB"
        else
            capacity_display="${capacity_gb}TB"
        fi
        
        printf "${YELLOW}%-3s${NC} %-30s ${state_color}%-12s${NC} %-10s %-20s ${GRAY}%s${NC}\n" \
            "$idx" "$name_trunc" "$state" "$capacity_display" "$ad_short" "$lfs_id"
            
    done < <(echo "$lfs_json" | jq -r '.data.items[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["capacity-in-gbs"] // .["capacity-in-tbs"] // "N/A")|\(.["availability-domain"])|\(.id)"' 2>/dev/null)
    
    LFS_COUNT=$idx
    echo ""
    
    case "$action" in
        none)
            echo -e "Press Enter to continue..."
            read -r
            ;;
        select)
            echo -n -e "${CYAN}Enter Lustre file system # (or Enter to cancel): ${NC}"
            read -r lfs_selection
            if [[ -n "$lfs_selection" && -n "${LFS_MAP[$lfs_selection]}" ]]; then
                LFS_SELECTED="${LFS_MAP[$lfs_selection]}"
            fi
            ;;
    esac
    
    return 0
}

#--------------------------------------------------------------------------------
# Lustre - View File System Details (with mount commands)
#--------------------------------------------------------------------------------
lfs_view_file_system_details() {
    local compartment_id="$1"
    
    LFS_SELECTED=""
    lfs_list_file_systems "$compartment_id" "select"
    
    [[ -z "$LFS_SELECTED" ]] && return
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Lustre File System Details ═══${NC}"
    echo ""
    
    local get_cmd="oci lfs lustre-file-system get --lustre-file-system-id \"$LFS_SELECTED\" --output json"
    echo -e "${GRAY}$get_cmd${NC}"
    echo ""
    
    local lfs_json
    lfs_json=$(oci lfs lustre-file-system get --lustre-file-system-id "$LFS_SELECTED" --output json 2>/dev/null)
    
    if [[ -z "$lfs_json" || "$lfs_json" == "null" ]]; then
        echo -e "${RED}Failed to get Lustre file system details${NC}"
        return
    fi
    
    # Basic fields
    local display_name state capacity_tb ad_name subnet_id time_created lfs_id
    local file_system_name mgs_address
    
    display_name=$(echo "$lfs_json" | jq -r '.data["display-name"] // "N/A"')
    state=$(echo "$lfs_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    capacity_tb=$(echo "$lfs_json" | jq -r '.data["capacity-in-gbs"] // .data["capacity-in-tbs"] // "N/A"')
    # Convert to TB if in GB
    if [[ "$capacity_tb" =~ ^[0-9]+$ ]] && [[ "$capacity_tb" -gt 500 ]]; then
        capacity_tb=$(echo "scale=1; $capacity_tb / 1000" | bc)
    fi
    ad_name=$(echo "$lfs_json" | jq -r '.data["availability-domain"] // "N/A"')
    subnet_id=$(echo "$lfs_json" | jq -r '.data["subnet-id"] // "N/A"')
    time_created=$(echo "$lfs_json" | jq -r '.data["time-created"] // "N/A"')
    lfs_id=$(echo "$lfs_json" | jq -r '.data.id // "N/A"')
    
    # Lustre-specific fields
    file_system_name=$(echo "$lfs_json" | jq -r '.data["file-system-name"] // "N/A"')
    mgs_address=$(echo "$lfs_json" | jq -r '.data["mgs-address"] // "N/A"')
    
    # Performance tier
    local performance_tier
    performance_tier=$(echo "$lfs_json" | jq -r '.data["performance-tier"] // "N/A"')
    local throughput_display="N/A"
    if [[ "$performance_tier" != "N/A" && "$capacity_tb" != "N/A" ]]; then
        local tier_value
        case "$performance_tier" in
            MBPS_PER_TB_125) tier_value=125 ;;
            MBPS_PER_TB_250) tier_value=250 ;;
            MBPS_PER_TB_500) tier_value=500 ;;
            MBPS_PER_TB_1000) tier_value=1000 ;;
            *) tier_value=0 ;;
        esac
        if [[ "$tier_value" -gt 0 ]]; then
            local expected_throughput
            expected_throughput=$(echo "$capacity_tb * $tier_value" | bc | cut -d'.' -f1)
            throughput_display="${expected_throughput} MB/s (${tier_value} MB/s per TB)"
        fi
    fi
    
    # Lustre version
    local lustre_version
    lustre_version=$(echo "$lfs_json" | jq -r '.data["lustre-version"] // .data["major-version"] // "N/A"')
    
    # Root squash configuration
    local root_squash
    root_squash=$(echo "$lfs_json" | jq -r '.data["root-squash-configuration"]["root-squash"] // .data["root-squash"] // "N/A"')
    
    # Network Security Groups
    local nsg_ids nsg_display
    nsg_ids=$(echo "$lfs_json" | jq -r '.data["nsg-ids"] // []')
    if [[ "$nsg_ids" == "[]" || "$nsg_ids" == "null" || -z "$nsg_ids" ]]; then
        nsg_display="None"
    else
        nsg_display=$(echo "$nsg_ids" | jq -r 'if length > 0 then .[] else "None" end' 2>/dev/null)
    fi
    
    # Encryption / KMS
    local kms_key_id
    kms_key_id=$(echo "$lfs_json" | jq -r '.data["kms-key-id"] // "N/A"')
    local encryption_type="Oracle-managed"
    if [[ "$kms_key_id" != "N/A" && "$kms_key_id" != "null" && -n "$kms_key_id" ]]; then
        encryption_type="Customer-managed (KMS)"
    fi
    
    # Cluster placement and replication
    local cluster_placement_group_id replication_target_id
    cluster_placement_group_id=$(echo "$lfs_json" | jq -r '.data["cluster-placement-group-id"] // "N/A"')
    replication_target_id=$(echo "$lfs_json" | jq -r '.data["replication-target-id"] // "N/A"')
    
    # Object Storage Links (data repository associations)
    local data_repository_associations
    data_repository_associations=$(echo "$lfs_json" | jq -r '.data["data-repository-associations"] // []')
    
    # Lifecycle details and freeform tags
    local lifecycle_details freeform_tags defined_tags
    lifecycle_details=$(echo "$lfs_json" | jq -r '.data["lifecycle-details"] // "N/A"')
    freeform_tags=$(echo "$lfs_json" | jq -r '.data["freeform-tags"] // {}')
    defined_tags=$(echo "$lfs_json" | jq -r '.data["defined-tags"] // {}')
    
    local state_color="$GREEN"
    case "$state" in
        ACTIVE) state_color="$GREEN" ;;
        CREATING|UPDATING) state_color="$YELLOW" ;;
        *) state_color="$RED" ;;
    esac
    
    # Display basic info section
    echo -e "${BOLD}${CYAN}─── Basic Information ───${NC}"
    echo -e "  ${CYAN}Display Name:${NC}        ${WHITE}$display_name${NC}"
    echo -e "  ${CYAN}File System Name:${NC}    ${WHITE}$file_system_name${NC}"
    echo -e "  ${CYAN}Lustre Version:${NC}      ${WHITE}$lustre_version${NC}"
    echo -e "  ${CYAN}State:${NC}               ${state_color}$state${NC}"
    [[ "$lifecycle_details" != "N/A" && -n "$lifecycle_details" ]] && \
        echo -e "  ${CYAN}Lifecycle Details:${NC}   ${WHITE}$lifecycle_details${NC}"
    echo -e "  ${CYAN}Lustre FS OCID:${NC}      ${YELLOW}$lfs_id${NC}"
    echo -e "  ${CYAN}Time Created:${NC}        ${WHITE}$time_created${NC}"
    echo ""
    
    # Display capacity and performance section
    echo -e "${BOLD}${CYAN}─── Capacity & Performance ───${NC}"
    echo -e "  ${CYAN}Capacity:${NC}            ${WHITE}${capacity_tb} TB${NC}"
    echo -e "  ${CYAN}Performance Tier:${NC}    ${WHITE}$performance_tier${NC}"
    echo -e "  ${CYAN}Expected Throughput:${NC} ${WHITE}$throughput_display${NC}"
    echo ""
    
    # Display network section
    echo -e "${BOLD}${CYAN}─── Network Configuration ───${NC}"
    echo -e "  ${CYAN}MGS Address:${NC}         ${WHITE}$mgs_address${NC}"
    echo -e "  ${CYAN}Availability Domain:${NC} ${WHITE}$ad_name${NC}"
    echo -e "  ${CYAN}Subnet OCID:${NC}         ${YELLOW}$subnet_id${NC}"
    echo -e "  ${CYAN}Network Security Groups:${NC}"
    if [[ "$nsg_display" == "None" ]]; then
        echo -e "    ${GRAY}None${NC}"
    else
        echo "$nsg_ids" | jq -r '.[]?' 2>/dev/null | while read -r nsg; do
            [[ -n "$nsg" ]] && echo -e "    ${YELLOW}$nsg${NC}"
        done
    fi
    echo ""
    
    # Display security section
    echo -e "${BOLD}${CYAN}─── Security Configuration ───${NC}"
    echo -e "  ${CYAN}Root Squash:${NC}         ${WHITE}$root_squash${NC}"
    echo -e "  ${CYAN}Encryption:${NC}          ${WHITE}$encryption_type${NC}"
    if [[ "$kms_key_id" != "N/A" && "$kms_key_id" != "null" && -n "$kms_key_id" ]]; then
        echo -e "  ${CYAN}KMS Key OCID:${NC}        ${YELLOW}$kms_key_id${NC}"
    fi
    echo ""
    
    # Display Object Storage Links section (if configured)
    local has_data_repos
    has_data_repos=$(echo "$data_repository_associations" | jq 'if type == "array" then length > 0 else false end' 2>/dev/null)
    if [[ "$has_data_repos" == "true" ]]; then
        echo -e "${BOLD}${CYAN}─── Object Storage Links ───${NC}"
        local assoc_count
        assoc_count=$(echo "$data_repository_associations" | jq 'length' 2>/dev/null)
        local i
        for ((i=0; i<assoc_count; i++)); do
            local assoc_id assoc_state fs_path bucket prefix import_policy export_policy
            assoc_id=$(echo "$data_repository_associations" | jq -r ".[$i].id // \"N/A\"")
            assoc_state=$(echo "$data_repository_associations" | jq -r ".[$i][\"lifecycle-state\"] // \"N/A\"")
            fs_path=$(echo "$data_repository_associations" | jq -r ".[$i][\"file-system-path\"] // \"N/A\"")
            bucket=$(echo "$data_repository_associations" | jq -r ".[$i].bucket // \"N/A\"")
            prefix=$(echo "$data_repository_associations" | jq -r ".[$i].prefix // \"none\"")
            import_policy=$(echo "$data_repository_associations" | jq -r ".[$i][\"data-repository-import-policy\"][\"import-policy-type\"] // \"N/A\"" 2>/dev/null)
            export_policy=$(echo "$data_repository_associations" | jq -r ".[$i][\"data-repository-export-policy\"][\"export-policy-type\"] // \"N/A\"" 2>/dev/null)
            
            local assoc_state_color="$GREEN"
            case "$assoc_state" in
                ACTIVE) assoc_state_color="$GREEN" ;;
                CREATING|UPDATING) assoc_state_color="$YELLOW" ;;
                *) assoc_state_color="$RED" ;;
            esac
            
            echo -e "  ${CYAN}Association ID:${NC}      ${YELLOW}$assoc_id${NC}"
            echo -e "    ${CYAN}State:${NC}              ${assoc_state_color}${assoc_state}${NC}"
            echo -e "    ${CYAN}File System Path:${NC}   ${WHITE}$fs_path${NC}"
            echo -e "    ${CYAN}Bucket:${NC}             ${WHITE}$bucket${NC}"
            echo -e "    ${CYAN}Prefix:${NC}             ${WHITE}$prefix${NC}"
            echo -e "    ${CYAN}Import Policy:${NC}      ${WHITE}$import_policy${NC}"
            echo -e "    ${CYAN}Export Policy:${NC}      ${WHITE}$export_policy${NC}"
            echo ""
        done
    fi
    
    # Display placement section (if applicable)
    if [[ "$cluster_placement_group_id" != "N/A" && "$cluster_placement_group_id" != "null" && -n "$cluster_placement_group_id" ]]; then
        echo -e "${BOLD}${CYAN}─── Placement ───${NC}"
        echo -e "  ${CYAN}Cluster Placement Group:${NC} ${YELLOW}$cluster_placement_group_id${NC}"
        echo ""
    fi
    
    # Display replication section (if applicable)
    if [[ "$replication_target_id" != "N/A" && "$replication_target_id" != "null" && -n "$replication_target_id" ]]; then
        echo -e "${BOLD}${CYAN}─── Replication ───${NC}"
        echo -e "  ${CYAN}Replication Target:${NC} ${YELLOW}$replication_target_id${NC}"
        echo ""
    fi
    
    # Display tags section
    local has_freeform_tags has_defined_tags
    has_freeform_tags=$(echo "$freeform_tags" | jq 'length > 0' 2>/dev/null)
    has_defined_tags=$(echo "$defined_tags" | jq 'to_entries | length > 0' 2>/dev/null)
    
    if [[ "$has_freeform_tags" == "true" || "$has_defined_tags" == "true" ]]; then
        echo -e "${BOLD}${CYAN}─── Tags ───${NC}"
        if [[ "$has_freeform_tags" == "true" ]]; then
            echo -e "  ${CYAN}Freeform Tags:${NC}"
            echo "$freeform_tags" | jq -r 'to_entries[] | "    \(.key): \(.value)"' 2>/dev/null | while read -r line; do
                echo -e "  ${WHITE}$line${NC}"
            done
        fi
        if [[ "$has_defined_tags" == "true" ]]; then
            echo -e "  ${CYAN}Defined Tags:${NC}"
            echo "$defined_tags" | jq -r 'to_entries[] | .key as $ns | .value | to_entries[] | "    \($ns).\(.key): \(.value)"' 2>/dev/null | while read -r line; do
                echo -e "  ${WHITE}$line${NC}"
            done
        fi
        echo ""
    fi
    
    # Mount commands
    if [[ "$mgs_address" != "N/A" && -n "$file_system_name" ]]; then
        echo -e "${BOLD}${CYAN}─── Mount Commands ───${NC}"
        echo ""
        echo -e "  ${GRAY}# Install Lustre client (Oracle Linux / RHEL):${NC}"
        echo -e "  ${WHITE}sudo yum install -y lustre-client${NC}"
        echo ""
        echo -e "  ${GRAY}# Create mount point and mount:${NC}"
        echo -e "  ${WHITE}sudo mkdir -p /mnt/lustre${NC}"
        echo -e "  ${WHITE}sudo mount -t lustre ${mgs_address}:/${file_system_name} /mnt/lustre${NC}"
        echo ""
        echo -e "  ${GRAY}# Add to /etc/fstab for persistent mount:${NC}"
        echo -e "  ${WHITE}${mgs_address}:/${file_system_name} /mnt/lustre lustre defaults,_netdev 0 0${NC}"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Lustre - Create File System
#--------------------------------------------------------------------------------
lfs_create_file_system() {
    local compartment_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Create Lustre File System ═══${NC}"
    echo ""
    
    # Get AD
    echo -e "${CYAN}Available Availability Domains:${NC}"
    local ads_json
    ads_json=$(oci iam availability-domain list --compartment-id "$compartment_id" --output json 2>/dev/null)
    
    local idx=0
    declare -A AD_MAP
    while read -r ad_name; do
        [[ -z "$ad_name" ]] && continue
        ((idx++))
        AD_MAP[$idx]="$ad_name"
        echo -e "  ${YELLOW}$idx${NC}) $ad_name"
    done < <(echo "$ads_json" | jq -r '.data[].name' 2>/dev/null)
    
    echo ""
    echo -n -e "${CYAN}Select AD #: ${NC}"
    read -r ad_selection
    local ad="${AD_MAP[$ad_selection]}"
    
    if [[ -z "$ad" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return
    fi
    
    # List subnets
    echo ""
    echo -e "${CYAN}Available Subnets:${NC}"
    local subnets_json
    subnets_json=$(oci network subnet list --compartment-id "$compartment_id" --all --output json 2>/dev/null)
    
    idx=0
    declare -A SUBNET_MAP
    while IFS='|' read -r subnet_name subnet_id cidr; do
        [[ -z "$subnet_name" ]] && continue
        ((idx++))
        SUBNET_MAP[$idx]="$subnet_id"
        echo -e "  ${YELLOW}$idx${NC}) $subnet_name (${cidr})"
    done < <(echo "$subnets_json" | jq -r '.data[] | "\(.["display-name"])|\(.id)|\(.["cidr-block"])"' 2>/dev/null)
    
    echo ""
    echo -n -e "${CYAN}Select subnet #: ${NC}"
    read -r subnet_selection
    local subnet_id="${SUBNET_MAP[$subnet_selection]}"
    
    if [[ -z "$subnet_id" ]]; then
        echo -e "${RED}Invalid selection${NC}"
        return
    fi
    
    # List NSGs (optional)
    echo ""
    echo -e "${CYAN}Available Network Security Groups (optional):${NC}"
    local nsgs_json
    nsgs_json=$(oci network nsg list --compartment-id "$compartment_id" --all --output json 2>/dev/null)
    
    idx=0
    declare -A NSG_MAP
    echo -e "  ${YELLOW}0${NC}) None (skip NSG)"
    while IFS='|' read -r nsg_name nsg_id; do
        [[ -z "$nsg_name" ]] && continue
        ((idx++))
        NSG_MAP[$idx]="$nsg_id"
        echo -e "  ${YELLOW}$idx${NC}) $nsg_name"
    done < <(echo "$nsgs_json" | jq -r '.data[] | "\(.["display-name"])|\(.id)"' 2>/dev/null)
    
    echo ""
    echo -n -e "${CYAN}Select NSG # (0 for none): ${NC}"
    read -r nsg_selection
    local nsg_id=""
    if [[ "$nsg_selection" != "0" && -n "${NSG_MAP[$nsg_selection]}" ]]; then
        nsg_id="${NSG_MAP[$nsg_selection]}"
    fi
    
    echo ""
    echo -n -e "${CYAN}Enter display name: ${NC}"
    read -r lfs_name
    
    if [[ -z "$lfs_name" ]]; then
        echo -e "${RED}Display name is required${NC}"
        return
    fi
    
    echo ""
    echo -e "${GRAY}File system name rules: 1-8 characters, letters (a-z, A-Z), numbers, and underscore only${NC}"
    echo -n -e "${CYAN}Enter file system name (e.g., lfs1, myfs_01): ${NC}"
    read -r fs_name
    
    if [[ -z "$fs_name" ]]; then
        # Generate default: lfs + random 4 digits
        fs_name="lfs$(shuf -i 1000-9999 -n 1)"
        echo -e "${YELLOW}Using default: $fs_name${NC}"
    fi
    
    # Validate file system name: 1-8 characters, alphanumeric and underscore only
    while true; do
        if [[ ${#fs_name} -lt 1 || ${#fs_name} -gt 8 ]]; then
            echo -e "${RED}File system name must be 1-8 characters. You entered: ${#fs_name} characters${NC}"
        elif [[ ! "$fs_name" =~ ^[a-zA-Z0-9_]+$ ]]; then
            echo -e "${RED}File system name can only contain letters (a-z, A-Z), numbers, and underscore${NC}"
        else
            break
        fi
        echo -n -e "${CYAN}Enter valid name: ${NC}"
        read -r fs_name
        if [[ -z "$fs_name" ]]; then
            echo -e "${RED}Name required. Aborting.${NC}"
            return
        fi
    done
    
    # Capacity selection with proper Lustre sizing rules
    echo ""
    echo -e "${CYAN}Select capacity:${NC}"
    echo -e "${GRAY}  Rules: Min 31,200 GB (31.2 TB), must be multiple of 10,400 GB (10.4 TB)${NC}"
    echo -e "  ${YELLOW}1${NC})  31.2 TB  (31,200 GB - minimum)"
    echo -e "  ${YELLOW}2${NC})  41.6 TB  (41,600 GB)"
    echo -e "  ${YELLOW}3${NC})  52.0 TB  (52,000 GB)"
    echo -e "  ${YELLOW}4${NC})  62.4 TB  (62,400 GB)"
    echo -e "  ${YELLOW}5${NC})  72.8 TB  (72,800 GB)"
    echo -e "  ${YELLOW}6${NC})  83.2 TB  (83,200 GB)"
    echo -e "  ${YELLOW}7${NC})  93.6 TB  (93,600 GB)"
    echo -e "  ${YELLOW}8${NC}) 104.0 TB (104,000 GB)"
    echo -e "  ${YELLOW}9${NC}) 114.4 TB (114,400 GB)"
    echo -e "  ${YELLOW}10${NC}) 124.8 TB (124,800 GB)"
    echo -e "  ${YELLOW}11${NC}) 166.4 TB (166,400 GB)"
    echo -e "  ${YELLOW}12${NC}) 208.0 TB (208,000 GB)"
    echo -e "  ${YELLOW}c${NC})  Custom"
    echo -n -e "${CYAN}Select #: ${NC}"
    read -r cap_selection
    
    local capacity_tb
    case "$cap_selection" in
        1) capacity_tb="31.2" ;;
        2) capacity_tb="41.6" ;;
        3) capacity_tb="52.0" ;;
        4) capacity_tb="62.4" ;;
        5) capacity_tb="72.8" ;;
        6) capacity_tb="83.2" ;;
        7) capacity_tb="93.6" ;;
        8) capacity_tb="104.0" ;;
        9) capacity_tb="114.4" ;;
        10) capacity_tb="124.8" ;;
        11) capacity_tb="166.4" ;;
        12) capacity_tb="208.0" ;;
        c|C|13)
            echo ""
            echo -e "${GRAY}Capacity must be a multiple of 10.4 TB (10,400 GB), minimum 31.2 TB${NC}"
            echo -e "${GRAY}Examples: 31.2, 41.6, 52.0, 62.4, 72.8, 83.2, 93.6, 104.0, 114.4, 124.8, 135.2, ...${NC}"
            echo -n -e "${CYAN}Enter capacity in TB: ${NC}"
            read -r capacity_tb
            # Validate the capacity
            if ! lfs_validate_capacity "$capacity_tb"; then
                local entered_gb
                entered_gb=$(echo "scale=0; $capacity_tb * 1000 / 1" | bc 2>/dev/null)
                echo -e "${RED}Invalid capacity. ${entered_gb} GB is not a multiple of 10,400 GB.${NC}"
                echo -e "${GRAY}Nearest valid values: $(( (entered_gb / 10400) * 10400 )) GB or $(( ((entered_gb / 10400) + 1) * 10400 )) GB${NC}"
                return
            fi
            ;;
        *) capacity_tb="31.2" ;;
    esac
    
    # Performance tier selection
    echo ""
    echo -e "${CYAN}Select performance tier (MB/s per TB):${NC}"
    echo -e "  ${YELLOW}1${NC}) MBPS_PER_TB_125   (125 MB/s per TB)"
    echo -e "  ${YELLOW}2${NC}) MBPS_PER_TB_250   (250 MB/s per TB)"
    echo -e "  ${YELLOW}3${NC}) MBPS_PER_TB_500   (500 MB/s per TB)"
    echo -e "  ${YELLOW}4${NC}) MBPS_PER_TB_1000  (1000 MB/s per TB)"
    echo -n -e "${CYAN}Select #: ${NC}"
    read -r perf_selection
    
    local performance_tier
    case "$perf_selection" in
        1) performance_tier="MBPS_PER_TB_125" ;;
        2) performance_tier="MBPS_PER_TB_250" ;;
        3) performance_tier="MBPS_PER_TB_500" ;;
        4) performance_tier="MBPS_PER_TB_1000" ;;
        *) performance_tier="MBPS_PER_TB_125" ;;
    esac
    
    # Calculate expected throughput
    local expected_throughput
    case "$performance_tier" in
        MBPS_PER_TB_125) expected_throughput=$(echo "$capacity_tb * 125" | bc) ;;
        MBPS_PER_TB_250) expected_throughput=$(echo "$capacity_tb * 250" | bc) ;;
        MBPS_PER_TB_500) expected_throughput=$(echo "$capacity_tb * 500" | bc) ;;
        MBPS_PER_TB_1000) expected_throughput=$(echo "$capacity_tb * 1000" | bc) ;;
    esac
    echo -e "${GRAY}  Expected throughput: ~${expected_throughput} MB/s${NC}"
    
    # Root squash selection
    echo ""
    echo -e "${CYAN}Select root squash mode:${NC}"
    echo -e "  ${YELLOW}1${NC}) NONE  (no root squashing - root has full access)"
    echo -e "  ${YELLOW}2${NC}) ROOT  (root is squashed to anonymous user)"
    echo -n -e "${CYAN}Select #: ${NC}"
    read -r squash_selection
    
    local root_squash
    case "$squash_selection" in
        1) root_squash="NONE" ;;
        2) root_squash="ROOT" ;;
        *) root_squash="NONE" ;;
    esac
    
    # Encryption selection
    echo ""
    echo -e "${CYAN}Select encryption:${NC}"
    echo -e "  ${YELLOW}1${NC}) Oracle-managed keys (default)"
    echo -e "  ${YELLOW}2${NC}) Customer-managed keys (KMS)"
    echo -n -e "${CYAN}Select #: ${NC}"
    read -r enc_selection
    
    local kms_key_id=""
    if [[ "$enc_selection" == "2" ]]; then
        echo ""
        echo -e "${CYAN}Available KMS Keys:${NC}"
        local vaults_json keys_found=0
        
        # List vaults first
        vaults_json=$(oci kms management vault list --compartment-id "$compartment_id" --all --output json 2>/dev/null)
        
        idx=0
        declare -A KMS_KEY_MAP
        
        while IFS='|' read -r vault_name vault_id mgmt_endpoint; do
            [[ -z "$vault_id" ]] && continue
            [[ "$vault_name" == "null" ]] && continue
            
            # List keys in this vault
            local keys_json
            keys_json=$(oci kms management key list --compartment-id "$compartment_id" --endpoint "$mgmt_endpoint" --all --output json 2>/dev/null)
            
            while IFS='|' read -r key_name key_id key_state; do
                [[ -z "$key_id" ]] && continue
                [[ "$key_state" != "ENABLED" ]] && continue
                ((idx++))
                ((keys_found++))
                KMS_KEY_MAP[$idx]="$key_id"
                echo -e "  ${YELLOW}$idx${NC}) $key_name (Vault: $vault_name)"
            done < <(echo "$keys_json" | jq -r '.data[] | "\(.["display-name"])|\(.id)|\(.["lifecycle-state"])"' 2>/dev/null)
            
        done < <(echo "$vaults_json" | jq -r '.data[] | select(.["lifecycle-state"]=="ACTIVE") | "\(.["display-name"])|\(.id)|\(.["management-endpoint"])"' 2>/dev/null)
        
        if [[ $keys_found -eq 0 ]]; then
            echo -e "${YELLOW}No KMS keys found. Using Oracle-managed keys.${NC}"
        else
            echo ""
            echo -n -e "${CYAN}Select KMS key #: ${NC}"
            read -r kms_selection
            kms_key_id="${KMS_KEY_MAP[$kms_selection]}"
            
            if [[ -z "$kms_key_id" ]]; then
                echo -e "${YELLOW}Invalid selection. Using Oracle-managed keys.${NC}"
                kms_key_id=""
            fi
        fi
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Configuration Summary ═══${NC}"
    echo -e "  ${CYAN}Display Name:${NC}      $lfs_name"
    echo -e "  ${CYAN}File System Name:${NC}  $fs_name"
    echo -e "  ${CYAN}Availability Domain:${NC} $ad"
    echo -e "  ${CYAN}Subnet:${NC}            ${subnet_id:0:50}..."
    [[ -n "$nsg_id" ]] && echo -e "  ${CYAN}NSG:${NC}               ${nsg_id:0:50}..."
    echo -e "  ${CYAN}Capacity:${NC}          ${capacity_tb} TB"
    echo -e "  ${CYAN}Performance Tier:${NC}  $performance_tier (~${expected_throughput} MB/s)"
    echo -e "  ${CYAN}Root Squash:${NC}       $root_squash"
    if [[ -n "$kms_key_id" ]]; then
        echo -e "  ${CYAN}Encryption:${NC}        Customer-managed (KMS)"
        echo -e "  ${CYAN}KMS Key:${NC}           ${kms_key_id:0:50}..."
    else
        echo -e "  ${CYAN}Encryption:${NC}        Oracle-managed"
    fi
    echo ""
    
    # Convert TB to GB for API (API uses --capacity-in-gbs)
    # API requires multiples of 10400 GB
    # Preset values: 31.2 TB = 31200 GB, 41.6 TB = 41600 GB, etc.
    local capacity_gb
    capacity_gb=$(echo "scale=0; $capacity_tb * 1000 / 1" | bc)
    
    # Build root-squash-configuration JSON (identitySquash required by API)
    local root_squash_config="{\"rootSquash\": \"$root_squash\", \"identitySquash\": \"NONE\"}"
    
    # Build the create command (display shows TB, API uses GB)
    local create_cmd="oci lfs lustre-file-system create"
    create_cmd+=" --compartment-id \"$compartment_id\""
    create_cmd+=" --availability-domain \"$ad\""
    create_cmd+=" --subnet-id \"$subnet_id\""
    create_cmd+=" --display-name \"$lfs_name\""
    create_cmd+=" --file-system-name \"$fs_name\""
    create_cmd+=" --capacity-in-gbs $capacity_gb"
    create_cmd+=" --performance-tier $performance_tier"
    create_cmd+=" --root-squash-configuration '$root_squash_config'"
    [[ -n "$nsg_id" ]] && create_cmd+=" --nsg-ids '[\"$nsg_id\"]'"
    [[ -n "$kms_key_id" ]] && create_cmd+=" --kms-key-id \"$kms_key_id\""
    
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$create_cmd${NC}"
    echo -e "${GRAY}(${capacity_tb} TB = ${capacity_gb} GB)${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Proceed with creation? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local log_file="${LOGS_DIR}/lustre_actions_$(date +%Y%m%d).log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] CREATE LUSTRE: $create_cmd" >> "$log_file"
    
    echo ""
    echo -e "${CYAN}Creating Lustre file system (this may take several minutes)...${NC}"
    
    # Build the actual command with optional parameters
    local result
    if [[ -n "$kms_key_id" && -n "$nsg_id" ]]; then
        result=$(oci lfs lustre-file-system create \
            --compartment-id "$compartment_id" \
            --availability-domain "$ad" \
            --subnet-id "$subnet_id" \
            --display-name "$lfs_name" \
            --file-system-name "$fs_name" \
            --capacity-in-gbs "$capacity_gb" \
            --performance-tier "$performance_tier" \
            --root-squash-configuration "$root_squash_config" \
            --nsg-ids "[\"$nsg_id\"]" \
            --kms-key-id "$kms_key_id" \
            --output json 2>&1)
    elif [[ -n "$kms_key_id" ]]; then
        result=$(oci lfs lustre-file-system create \
            --compartment-id "$compartment_id" \
            --availability-domain "$ad" \
            --subnet-id "$subnet_id" \
            --display-name "$lfs_name" \
            --file-system-name "$fs_name" \
            --capacity-in-gbs "$capacity_gb" \
            --performance-tier "$performance_tier" \
            --root-squash-configuration "$root_squash_config" \
            --kms-key-id "$kms_key_id" \
            --output json 2>&1)
    elif [[ -n "$nsg_id" ]]; then
        result=$(oci lfs lustre-file-system create \
            --compartment-id "$compartment_id" \
            --availability-domain "$ad" \
            --subnet-id "$subnet_id" \
            --display-name "$lfs_name" \
            --file-system-name "$fs_name" \
            --capacity-in-gbs "$capacity_gb" \
            --performance-tier "$performance_tier" \
            --root-squash-configuration "$root_squash_config" \
            --nsg-ids "[\"$nsg_id\"]" \
            --output json 2>&1)
    else
        result=$(oci lfs lustre-file-system create \
            --compartment-id "$compartment_id" \
            --availability-domain "$ad" \
            --subnet-id "$subnet_id" \
            --display-name "$lfs_name" \
            --file-system-name "$fs_name" \
            --capacity-in-gbs "$capacity_gb" \
            --performance-tier "$performance_tier" \
            --root-squash-configuration "$root_squash_config" \
            --output json 2>&1)
    fi
    
    if echo "$result" | jq -e '.data.id' > /dev/null 2>&1; then
        local new_lfs_id
        new_lfs_id=$(echo "$result" | jq -r '.data.id')
        echo -e "${GREEN}✓ Lustre file system creation initiated${NC}"
        echo -e "  ${CYAN}OCID:${NC} ${YELLOW}$new_lfs_id${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created $new_lfs_id" >> "$log_file"
    else
        echo -e "${RED}Failed to create Lustre file system${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Lustre - Validate capacity follows sizing rules
# Min 31.2 TB, increment 10.4 TB (≤124.8 TB), increment 41.6 TB (>124.8 TB)
#--------------------------------------------------------------------------------
lfs_validate_capacity() {
    local capacity="$1"
    
    # Check if it's a valid number
    if ! [[ "$capacity" =~ ^[0-9]+\.?[0-9]*$ ]]; then
        return 1
    fi
    
    # Convert to GB and check if it's a multiple of 10400
    local capacity_gb
    capacity_gb=$(echo "scale=0; $capacity * 1000 / 1" | bc)
    
    # Minimum is 31200 GB (3 * 10400)
    if [[ "$capacity_gb" -lt 31200 ]]; then
        return 1
    fi
    
    # Must be multiple of 10400
    local remainder=$((capacity_gb % 10400))
    if [[ "$remainder" -ne 0 ]]; then
        return 1
    fi
    
    return 0
}

# Convert TB to valid GB (multiple of 10400)
lfs_tb_to_gb() {
    local tb="$1"
    echo "scale=0; $tb * 1000 / 1" | bc
}

#--------------------------------------------------------------------------------
# Lustre - Update File System
#--------------------------------------------------------------------------------
lfs_update_file_system() {
    local compartment_id="$1"
    
    LFS_SELECTED=""
    lfs_list_file_systems "$compartment_id" "select"
    
    [[ -z "$LFS_SELECTED" ]] && return
    
    # Get current file system details
    local lfs_json
    lfs_json=$(oci lfs lustre-file-system get --lustre-file-system-id "$LFS_SELECTED" --output json 2>/dev/null)
    
    # Get capacity in GB (API returns GB)
    local current_capacity_gb
    current_capacity_gb=$(echo "$lfs_json" | jq -r '.data["capacity-in-gbs"] // "0"')
    
    # Convert GB to TB for display (1000 GB = 1 TB for Lustre)
    local current_capacity_tb
    current_capacity_tb=$(echo "scale=1; $current_capacity_gb / 1000" | bc)
    
    local current_name
    current_name=$(echo "$lfs_json" | jq -r '.data["display-name"] // "N/A"')
    
    # Get NSG IDs if configured
    local nsg_ids_json
    nsg_ids_json=$(echo "$lfs_json" | jq -c '.data["nsg-ids"] // []')
    local has_nsg="false"
    if [[ "$nsg_ids_json" != "[]" && "$nsg_ids_json" != "null" && -n "$nsg_ids_json" ]]; then
        local nsg_count
        nsg_count=$(echo "$nsg_ids_json" | jq 'length' 2>/dev/null || echo "0")
        if [[ "$nsg_count" -gt 0 ]]; then
            has_nsg="true"
        fi
    fi
    
    echo ""
    echo -e "${WHITE}Current file system:${NC} $current_name"
    echo -e "${WHITE}Current capacity:${NC}    ${current_capacity_tb} TB (${current_capacity_gb} GB)"
    if [[ "$has_nsg" == "true" ]]; then
        echo -e "${WHITE}NSG configured:${NC}      ${GREEN}Yes${NC} (will be preserved)"
    fi
    echo ""
    
    echo -e "${CYAN}What would you like to update?${NC}"
    echo -e "  ${YELLOW}1${NC}) Display name"
    echo -e "  ${YELLOW}2${NC}) Capacity (increase only)"
    echo -n -e "${CYAN}Select #: ${NC}"
    read -r update_type
    
    local update_cmd=""
    local new_name=""
    local new_capacity_gb=""
    local new_capacity_tb=""
    local nsg_param=""
    
    # Build NSG parameter if NSGs are configured
    if [[ "$has_nsg" == "true" ]]; then
        nsg_param="--nsg-ids '$nsg_ids_json'"
    fi
    
    case "$update_type" in
        1)
            echo -n -e "${CYAN}Enter new display name: ${NC}"
            read -r new_name
            [[ -z "$new_name" ]] && { echo -e "${RED}Name required${NC}"; return; }
            update_cmd="oci lfs lustre-file-system update --lustre-file-system-id \"$LFS_SELECTED\" --display-name \"$new_name\""
            [[ -n "$nsg_param" ]] && update_cmd="$update_cmd $nsg_param --force"
            ;;
        2)
            echo ""
            echo -e "${GRAY}Lustre capacity sizing rules:${NC}"
            echo -e "${GRAY}  - Capacity can only be INCREASED (not decreased)${NC}"
            echo -e "${GRAY}  - Minimum: 31200 GB (31.2 TB)${NC}"
            echo -e "${GRAY}  - Increment: 10400 GB (10.4 TB) when capacity ≤ 124800 GB${NC}"
            echo -e "${GRAY}  - Increment: 41600 GB (41.6 TB) when capacity > 124800 GB${NC}"
            echo -e "${GRAY}  - All values must be multiples of 10400 GB${NC}"
            echo ""
            
            # Calculate next valid capacities in GB (must be multiples of 10400)
            echo -e "${CYAN}Suggested next capacities:${NC}"
            local next_caps_gb=()
            local next_caps_tb=()
            
            # Find next valid capacity (round up to next multiple of 10400)
            local next_gb=$((current_capacity_gb + 10400))
            # Round to nearest multiple of 10400
            next_gb=$(( ((next_gb + 10399) / 10400) * 10400 ))
            
            if [[ "$next_gb" -le 124800 ]]; then
                # Show next few 10400 GB increments
                for i in 1 2 3 4 5; do
                    if [[ "$next_gb" -le 124800 ]]; then
                        next_caps_gb+=("$next_gb")
                        local tb_val=$(echo "scale=1; $next_gb / 1000" | bc)
                        next_caps_tb+=("$tb_val")
                        next_gb=$((next_gb + 10400))
                    else
                        break
                    fi
                done
                # Add first 41600 increment option (166400 GB = 166.4 TB)
                if [[ ${#next_caps_gb[@]} -lt 6 ]]; then
                    next_caps_gb+=("166400")
                    next_caps_tb+=("166.4")
                fi
            else
                # Already above 124800, show 41600 increments
                # Round up to next multiple of 41600 above 124800
                next_gb=$(( ((current_capacity_gb - 124800 + 41600) / 41600) * 41600 + 124800 ))
                if [[ "$next_gb" -le "$current_capacity_gb" ]]; then
                    next_gb=$((next_gb + 41600))
                fi
                for i in 1 2 3 4 5; do
                    next_caps_gb+=("$next_gb")
                    local tb_val=$(echo "scale=1; $next_gb / 1000" | bc)
                    next_caps_tb+=("$tb_val")
                    next_gb=$((next_gb + 41600))
                done
            fi
            
            local idx=0
            for i in "${!next_caps_gb[@]}"; do
                ((idx++))
                echo -e "  ${YELLOW}$idx${NC}) ${next_caps_tb[$i]} TB (${next_caps_gb[$i]} GB)"
            done
            echo -e "  ${YELLOW}c${NC}) Custom capacity (in GB)"
            echo ""
            echo -n -e "${CYAN}Select #: ${NC}"
            read -r cap_selection
            
            if [[ "$cap_selection" == "c" || "$cap_selection" == "C" ]]; then
                echo ""
                echo -e "${GRAY}Enter capacity in GB (must be multiple of 10400, e.g., 41600, 52000, 62400)${NC}"
                echo -n -e "${CYAN}Enter new capacity in GB: ${NC}"
                read -r new_capacity_gb
                
                # Validate it's a number
                if ! [[ "$new_capacity_gb" =~ ^[0-9]+$ ]]; then
                    echo -e "${RED}Invalid number${NC}"
                    return
                fi
                
                # Validate it's a multiple of 10400
                if [[ $((new_capacity_gb % 10400)) -ne 0 ]]; then
                    echo -e "${RED}Capacity must be a multiple of 10400 GB${NC}"
                    local suggested=$(( ((new_capacity_gb + 10399) / 10400) * 10400 ))
                    echo -e "${YELLOW}Suggested: ${suggested} GB${NC}"
                    return
                fi
                
                # Validate minimum
                if [[ "$new_capacity_gb" -lt 31200 ]]; then
                    echo -e "${RED}Minimum capacity is 31200 GB${NC}"
                    return
                fi
                
                # Check that it's an increase
                if [[ "$new_capacity_gb" -le "$current_capacity_gb" ]]; then
                    echo -e "${RED}New capacity must be greater than current capacity (${current_capacity_gb} GB)${NC}"
                    return
                fi
                
                new_capacity_tb=$(echo "scale=1; $new_capacity_gb / 1000" | bc)
            elif [[ "$cap_selection" =~ ^[0-9]+$ ]] && [[ "$cap_selection" -ge 1 ]] && [[ "$cap_selection" -le ${#next_caps_gb[@]} ]]; then
                new_capacity_gb="${next_caps_gb[$((cap_selection-1))]}"
                new_capacity_tb="${next_caps_tb[$((cap_selection-1))]}"
            else
                echo -e "${RED}Invalid selection${NC}"
                return
            fi
            
            update_cmd="oci lfs lustre-file-system update --lustre-file-system-id \"$LFS_SELECTED\" --capacity-in-gbs $new_capacity_gb"
            [[ -n "$nsg_param" ]] && update_cmd="$update_cmd $nsg_param --force"
            ;;
        *)
            echo -e "${RED}Invalid selection${NC}"
            return
            ;;
    esac
    
    echo ""
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$update_cmd${NC}"
    if [[ "$update_type" == "2" ]]; then
        echo -e "${GRAY}(${new_capacity_tb} TB = ${new_capacity_gb} GB)${NC}"
    fi
    echo ""
    
    echo -n -e "${YELLOW}Proceed with update? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local log_file="${LOGS_DIR}/lustre_actions_$(date +%Y%m%d).log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] UPDATE LUSTRE: $update_cmd" >> "$log_file"
    
    local result
    if [[ "$update_type" == "1" ]]; then
        if [[ "$has_nsg" == "true" ]]; then
            result=$(oci lfs lustre-file-system update \
                --lustre-file-system-id "$LFS_SELECTED" \
                --display-name "$new_name" \
                --nsg-ids "$nsg_ids_json" \
                --force \
                --output json 2>&1)
        else
            result=$(oci lfs lustre-file-system update \
                --lustre-file-system-id "$LFS_SELECTED" \
                --display-name "$new_name" \
                --output json 2>&1)
        fi
    else
        if [[ "$has_nsg" == "true" ]]; then
            result=$(oci lfs lustre-file-system update \
                --lustre-file-system-id "$LFS_SELECTED" \
                --capacity-in-gbs "$new_capacity_gb" \
                --nsg-ids "$nsg_ids_json" \
                --force \
                --output json 2>&1)
        else
            result=$(oci lfs lustre-file-system update \
                --lustre-file-system-id "$LFS_SELECTED" \
                --capacity-in-gbs "$new_capacity_gb" \
                --output json 2>&1)
        fi
    fi
    
    # Check for success - either direct response with data.id OR async work request
    local work_request_id
    work_request_id=$(echo "$result" | jq -r '.["opc-work-request-id"] // empty' 2>/dev/null)
    
    if echo "$result" | jq -e '.data.id' > /dev/null 2>&1; then
        echo -e "${GREEN}✓ Lustre file system updated${NC}"
        if [[ "$update_type" == "2" ]]; then
            echo -e "  ${CYAN}New capacity:${NC} ${new_capacity_tb} TB / ${new_capacity_gb} GB (was ${current_capacity_tb} TB / ${current_capacity_gb} GB)"
        fi
        [[ "$has_nsg" == "true" ]] && echo -e "  ${CYAN}NSG:${NC} Preserved"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Updated $LFS_SELECTED" >> "$log_file"
    elif [[ -n "$work_request_id" ]]; then
        echo -e "${GREEN}✓ Lustre file system update initiated${NC}"
        if [[ "$update_type" == "2" ]]; then
            echo -e "  ${CYAN}New capacity:${NC} ${new_capacity_tb} TB / ${new_capacity_gb} GB (was ${current_capacity_tb} TB / ${current_capacity_gb} GB)"
        fi
        [[ "$has_nsg" == "true" ]] && echo -e "  ${CYAN}NSG:${NC} Preserved"
        echo -e "  ${CYAN}Work Request:${NC} ${YELLOW}$work_request_id${NC}"
        echo -e "  ${GRAY}File system will show UPDATING state until complete${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Update initiated, work-request: $work_request_id" >> "$log_file"
    else
        echo -e "${RED}Failed to update Lustre file system${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Lustre - List Work Requests
#--------------------------------------------------------------------------------
lfs_list_work_requests() {
    local compartment_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Lustre Work Requests ═══${NC}"
    echo ""
    
    local list_cmd="oci lfs work-request list --compartment-id \"$compartment_id\" --all --output json"
    echo -e "${GRAY}$list_cmd${NC}"
    echo ""
    
    local wr_json
    wr_json=$(oci lfs work-request list --compartment-id "$compartment_id" --all --output json 2>/dev/null)
    
    if [[ -z "$wr_json" || "$wr_json" == "null" ]]; then
        echo -e "${YELLOW}No work requests found or unable to list${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Handle both .data.items and .data structures
    local wr_count
    wr_count=$(echo "$wr_json" | jq '.data.items | length // 0' 2>/dev/null)
    [[ -z "$wr_count" || "$wr_count" == "null" ]] && wr_count=0
    
    if [[ "$wr_count" -eq 0 ]]; then
        echo -e "${YELLOW}No work requests found${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo -e "${GREEN}Found $wr_count work request(s)${NC}"
    echo ""
    
    # Header
    printf "${BOLD}%-3s %-22s %-12s %-6s %-20s %-20s %s${NC}\n" \
        "#" "Operation Type" "Status" "%" "Time Started" "Time Finished" "Work Request ID"
    print_separator 160
    
    local idx=0
    declare -A WR_MAP
    WR_MAP=()
    
    while IFS='|' read -r op_type status percent_complete time_started time_finished wr_id; do
        [[ -z "$op_type" ]] && continue
        ((idx++))
        
        WR_MAP[$idx]="$wr_id"
        
        local status_color="$GREEN"
        case "$status" in
            SUCCEEDED|COMPLETED) status_color="$GREEN" ;;
            IN_PROGRESS|ACCEPTED) status_color="$YELLOW" ;;
            FAILED|CANCELED|CANCELING) status_color="$RED" ;;
            *) status_color="$GRAY" ;;
        esac
        
        # Format times - extract just date and time
        local start_display="${time_started:0:19}"
        [[ "$time_started" == "null" || -z "$time_started" ]] && start_display="N/A"
        start_display="${start_display/T/ }"
        
        local finish_display="${time_finished:0:19}"
        [[ "$time_finished" == "null" || -z "$time_finished" ]] && finish_display="--"
        finish_display="${finish_display/T/ }"
        
        # Shorten operation type for display
        local op_short="$op_type"
        case "$op_type" in
            CREATE_LUSTRE_FILE_SYSTEM) op_short="CREATE_LFS" ;;
            UPDATE_LUSTRE_FILE_SYSTEM) op_short="UPDATE_LFS" ;;
            DELETE_LUSTRE_FILE_SYSTEM) op_short="DELETE_LFS" ;;
            *) op_short="${op_type:0:20}" ;;
        esac
        
        # Format percent
        local pct_display
        if [[ "$percent_complete" == "null" || -z "$percent_complete" ]]; then
            pct_display="--"
        else
            pct_display=$(printf "%.0f%%" "$percent_complete")
        fi
        
        printf "${YELLOW}%-3s${NC} %-22s ${status_color}%-12s${NC} %-6s %-20s %-20s ${GRAY}%s${NC}\n" \
            "$idx" "$op_short" "$status" "$pct_display" "$start_display" "$finish_display" "$wr_id"
            
    done < <(echo "$wr_json" | jq -r '.data.items[] | "\(.["operation-type"])|\(.status)|\(.["percent-complete"])|\(.["time-started"])|\(.["time-finished"])|\(.id)"' 2>/dev/null)
    
    echo ""
    echo -e "${CYAN}Options:${NC}"
    echo -e "  ${YELLOW}#${NC}  View work request details"
    echo -e "  ${WHITE}Enter${NC} to go back"
    echo ""
    echo -n -e "${CYAN}Select #: ${NC}"
    read -r wr_selection
    
    if [[ -n "$wr_selection" && -n "${WR_MAP[$wr_selection]}" ]]; then
        lfs_view_work_request_details "${WR_MAP[$wr_selection]}"
    fi
}

#--------------------------------------------------------------------------------
# Lustre - View Work Request Details
#--------------------------------------------------------------------------------
lfs_view_work_request_details() {
    local wr_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Work Request Details ═══${NC}"
    echo ""
    
    local wr_json
    wr_json=$(oci lfs work-request get --work-request-id "$wr_id" --output json 2>/dev/null)
    
    if [[ -z "$wr_json" || "$wr_json" == "null" ]]; then
        echo -e "${RED}Failed to get work request details${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Extract fields
    local op_type status percent_complete time_accepted time_started time_finished
    op_type=$(echo "$wr_json" | jq -r '.data["operation-type"] // "N/A"')
    status=$(echo "$wr_json" | jq -r '.data.status // "N/A"')
    percent_complete=$(echo "$wr_json" | jq -r '.data["percent-complete"] // "N/A"')
    time_accepted=$(echo "$wr_json" | jq -r '.data["time-accepted"] // "N/A"')
    time_started=$(echo "$wr_json" | jq -r '.data["time-started"] // "N/A"')
    time_finished=$(echo "$wr_json" | jq -r '.data["time-finished"] // "N/A"')
    
    local status_color="$GREEN"
    case "$status" in
        SUCCEEDED|COMPLETED) status_color="$GREEN" ;;
        IN_PROGRESS|ACCEPTED) status_color="$YELLOW" ;;
        FAILED|CANCELED|CANCELING) status_color="$RED" ;;
        *) status_color="$GRAY" ;;
    esac
    
    echo -e "${BOLD}${CYAN}─── Basic Information ───${NC}"
    echo -e "  ${CYAN}Operation Type:${NC}   ${WHITE}$op_type${NC}"
    echo -e "  ${CYAN}Status:${NC}           ${status_color}$status${NC}"
    echo -e "  ${CYAN}Progress:${NC}         ${WHITE}${percent_complete}%${NC}"
    echo -e "  ${CYAN}Work Request ID:${NC}  ${YELLOW}$wr_id${NC}"
    echo ""
    
    echo -e "${BOLD}${CYAN}─── Timing ───${NC}"
    echo -e "  ${CYAN}Time Accepted:${NC}    ${WHITE}${time_accepted/T/ }${NC}"
    echo -e "  ${CYAN}Time Started:${NC}     ${WHITE}${time_started/T/ }${NC}"
    echo -e "  ${CYAN}Time Finished:${NC}    ${WHITE}${time_finished/T/ }${NC}"
    
    # Calculate duration if both start and finish are available
    if [[ "$time_started" != "N/A" && "$time_started" != "null" && "$time_finished" != "N/A" && "$time_finished" != "null" ]]; then
        local start_epoch finish_epoch duration_sec
        start_epoch=$(date -d "${time_started}" +%s 2>/dev/null || echo "0")
        finish_epoch=$(date -d "${time_finished}" +%s 2>/dev/null || echo "0")
        if [[ "$start_epoch" -gt 0 && "$finish_epoch" -gt 0 ]]; then
            duration_sec=$((finish_epoch - start_epoch))
            local duration_min=$((duration_sec / 60))
            local duration_sec_rem=$((duration_sec % 60))
            echo -e "  ${CYAN}Duration:${NC}         ${WHITE}${duration_min}m ${duration_sec_rem}s${NC}"
        fi
    fi
    echo ""
    
    # Resources affected
    local resources
    resources=$(echo "$wr_json" | jq -r '.data.resources // []')
    local resource_count
    resource_count=$(echo "$resources" | jq 'length' 2>/dev/null || echo "0")
    
    if [[ "$resource_count" -gt 0 ]]; then
        echo -e "${BOLD}${CYAN}─── Resources Affected ───${NC}"
        while IFS='|' read -r entity_type entity_uri action_type; do
            [[ -z "$entity_type" ]] && continue
            echo -e "  ${CYAN}Type:${NC}   ${WHITE}$entity_type${NC}"
            echo -e "  ${CYAN}Action:${NC} ${WHITE}$action_type${NC}"
            echo -e "  ${CYAN}URI:${NC}    ${YELLOW}$entity_uri${NC}"
            echo ""
        done < <(echo "$resources" | jq -r '.[] | "\(.["entity-type"])|\(.["entity-uri"])|\(.["action-type"])"' 2>/dev/null)
    fi
    
    # Fetch errors from separate API (errors are not in the main work-request get response)
    echo -e "${BOLD}${RED}─── Errors ───${NC}"
    local errors_json
    errors_json=$(oci lfs work-request-error list --work-request-id "$wr_id" --all --output json 2>/dev/null)
    
    local error_count=0
    if [[ -n "$errors_json" && "$errors_json" != "null" ]]; then
        error_count=$(echo "$errors_json" | jq '.data.items | length // 0' 2>/dev/null || echo "0")
    fi
    
    if [[ "$error_count" -gt 0 ]]; then
        while IFS='|' read -r code message timestamp; do
            [[ -z "$code" ]] && continue
            local ts_display="${timestamp/T/ }"
            ts_display="${ts_display:0:19}"
            echo -e "  ${RED}Code:${NC}      ${WHITE}$code${NC}"
            echo -e "  ${RED}Message:${NC}   ${WHITE}$message${NC}"
            echo -e "  ${RED}Timestamp:${NC} ${GRAY}$ts_display${NC}"
            echo ""
        done < <(echo "$errors_json" | jq -r '.data.items[] | "\(.code)|\(.message)|\(.timestamp)"' 2>/dev/null)
    else
        echo -e "  ${GREEN}No errors${NC}"
    fi
    echo ""
    
    # Logs
    echo -e "${BOLD}${CYAN}─── Work Request Logs ───${NC}"
    local logs_json
    logs_json=$(oci lfs work-request-log list --work-request-id "$wr_id" --all --output json 2>/dev/null)
    
    local log_count=0
    if [[ -n "$logs_json" && "$logs_json" != "null" ]]; then
        log_count=$(echo "$logs_json" | jq '.data.items | length // 0' 2>/dev/null || echo "0")
    fi
    
    if [[ "$log_count" -gt 0 ]]; then
        echo ""
        while IFS='|' read -r timestamp message; do
            [[ -z "$timestamp" ]] && continue
            local ts_display="${timestamp/T/ }"
            ts_display="${ts_display:0:19}"
            echo -e "  ${GRAY}[$ts_display]${NC} ${WHITE}$message${NC}"
        done < <(echo "$logs_json" | jq -r '.data.items[] | "\(.timestamp)|\(.message)"' 2>/dev/null)
    else
        echo -e "  ${GRAY}No logs available${NC}"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Lustre - Delete File System
#--------------------------------------------------------------------------------
lfs_delete_file_system() {
    local compartment_id="$1"
    
    LFS_SELECTED=""
    lfs_list_file_systems "$compartment_id" "select"
    
    [[ -z "$LFS_SELECTED" ]] && return
    
    echo ""
    echo -e "${RED}WARNING: This will permanently delete the Lustre file system and ALL data!${NC}"
    echo ""
    local delete_cmd="oci lfs lustre-file-system delete --lustre-file-system-id \"$LFS_SELECTED\" --force"
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$delete_cmd${NC}"
    echo ""
    
    echo -n -e "${RED}Type 'DELETE' to confirm: ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "DELETE" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local log_file="${LOGS_DIR}/lustre_actions_$(date +%Y%m%d).log"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] DELETE LUSTRE: $delete_cmd" >> "$log_file"
    
    echo ""
    echo -e "${CYAN}Deleting Lustre file system...${NC}"
    
    local result
    result=$(oci lfs lustre-file-system delete \
        --lustre-file-system-id "$LFS_SELECTED" \
        --force 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}✓ Lustre file system deletion initiated${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted $LFS_SELECTED" >> "$log_file"
    else
        echo -e "${RED}Failed to delete Lustre file system${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Lustre - List Object Storage Links
#--------------------------------------------------------------------------------
lfs_list_object_storage_links() {
    local compartment_id="$1"
    local action="${2:-none}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Object Storage Links ═══${NC}"
    echo ""
    
    local list_cmd="oci lfs object-storage-link-collection list-object-storage-links --compartment-id \"$compartment_id\" --all --output json"
    echo -e "${GRAY}$list_cmd${NC}"
    echo ""
    
    local links_json
    links_json=$(oci lfs object-storage-link-collection list-object-storage-links \
        --compartment-id "$compartment_id" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$links_json" || "$links_json" == "null" ]]; then
        echo -e "${YELLOW}No Object Storage links found or unable to list${NC}"
        return 1
    fi
    
    local link_count
    link_count=$(echo "$links_json" | jq '.data.items | length' 2>/dev/null)
    
    if [[ "$link_count" -eq 0 || -z "$link_count" ]]; then
        echo -e "${YELLOW}No Object Storage links found${NC}"
        return 1
    fi
    
    echo -e "${GREEN}Found $link_count Object Storage link(s)${NC}"
    echo ""
    
    printf "${BOLD}%-3s %-25s %-12s %-30s %s${NC}\n" "#" "Display Name" "State" "Bucket" "Link OCID"
    print_separator 160
    
    local idx=0
    declare -gA LFS_LINK_MAP
    LFS_LINK_MAP=()
    
    while IFS='|' read -r display_name state bucket_name link_id; do
        [[ -z "$display_name" ]] && continue
        ((idx++))
        
        LFS_LINK_MAP[$idx]="$link_id"
        
        local state_color="$GREEN"
        case "$state" in
            ACTIVE) state_color="$GREEN" ;;
            CREATING|UPDATING) state_color="$YELLOW" ;;
            DELETING|DELETED|FAILED) state_color="$RED" ;;
            *) state_color="$GRAY" ;;
        esac
        
        local name_trunc="${display_name:0:23}"
        [[ ${#display_name} -gt 23 ]] && name_trunc="${name_trunc}.."
        
        local bucket_trunc="${bucket_name:0:28}"
        [[ ${#bucket_name} -gt 28 ]] && bucket_trunc="${bucket_trunc}.."
        
        printf "${YELLOW}%-3s${NC} %-25s ${state_color}%-12s${NC} %-30s ${GRAY}%s${NC}\n" \
            "$idx" "$name_trunc" "$state" "$bucket_trunc" "$link_id"
            
    done < <(echo "$links_json" | jq -r '.data.items[] | "\(.["display-name"])|\(.["lifecycle-state"])|\(.["bucket-name"] // "N/A")|\(.id)"' 2>/dev/null)
    
    LFS_LINK_COUNT=$idx
    echo ""
    
    case "$action" in
        none)
            echo -e "Press Enter to continue..."
            read -r
            ;;
        select)
            echo -n -e "${CYAN}Enter link # (or Enter to cancel): ${NC}"
            read -r link_selection
            if [[ -n "$link_selection" && -n "${LFS_LINK_MAP[$link_selection]}" ]]; then
                LFS_SELECTED_LINK="${LFS_LINK_MAP[$link_selection]}"
            fi
            ;;
    esac
    
    return 0
}

#--------------------------------------------------------------------------------
# Lustre - Create Object Storage Link
#--------------------------------------------------------------------------------
lfs_create_object_storage_link() {
    local compartment_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Create Object Storage Link ═══${NC}"
    echo ""
    
    # Select Lustre file system
    echo -e "${CYAN}Select a Lustre file system:${NC}"
    LFS_SELECTED=""
    lfs_list_file_systems "$compartment_id" "select"
    
    if [[ -z "$LFS_SELECTED" ]]; then
        echo -e "${RED}No Lustre file system selected${NC}"
        return
    fi
    
    echo -n -e "${CYAN}Enter Object Storage namespace: ${NC}"
    read -r os_namespace
    
    echo -n -e "${CYAN}Enter bucket name: ${NC}"
    read -r bucket_name
    
    echo -n -e "${CYAN}Enter link display name: ${NC}"
    read -r link_name
    
    if [[ -z "$os_namespace" || -z "$bucket_name" ]]; then
        echo -e "${RED}Namespace and bucket name are required${NC}"
        return
    fi
    
    [[ -z "$link_name" ]] && link_name="link-$bucket_name"
    
    echo ""
    local create_cmd="oci lfs object-storage-link create --lustre-file-system-id \"$LFS_SELECTED\" --bucket-name \"$bucket_name\" --namespace \"$os_namespace\" --display-name \"$link_name\""
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$create_cmd${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Proceed with creation? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local log_file="${LOGS_DIR}/lustre_actions_$(date +%Y%m%d).log"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] CREATE OS LINK: $create_cmd" >> "$log_file"
    
    echo ""
    echo -e "${CYAN}Creating Object Storage link...${NC}"
    
    local result
    result=$(oci lfs object-storage-link create \
        --lustre-file-system-id "$LFS_SELECTED" \
        --bucket-name "$bucket_name" \
        --namespace "$os_namespace" \
        --display-name "$link_name" \
        --output json 2>&1)
    
    if echo "$result" | jq -e '.data.id' > /dev/null 2>&1; then
        local new_link_id
        new_link_id=$(echo "$result" | jq -r '.data.id')
        echo -e "${GREEN}✓ Object Storage link created${NC}"
        echo -e "  ${CYAN}OCID:${NC} ${YELLOW}$new_link_id${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created $new_link_id" >> "$log_file"
    else
        echo -e "${RED}Failed to create Object Storage link${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Lustre - Start Import from Object Storage
#--------------------------------------------------------------------------------
lfs_start_import_from_object() {
    local compartment_id="$1"
    
    LFS_SELECTED_LINK=""
    lfs_list_object_storage_links "$compartment_id" "select"
    
    [[ -z "$LFS_SELECTED_LINK" ]] && return
    
    echo ""
    local import_cmd="oci lfs object-storage-link start-import-from-object --object-storage-link-id \"$LFS_SELECTED_LINK\""
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$import_cmd${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Start import from Object Storage? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local log_file="${LOGS_DIR}/lustre_actions_$(date +%Y%m%d).log"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] START IMPORT: $import_cmd" >> "$log_file"
    
    echo ""
    echo -e "${CYAN}Starting import...${NC}"
    
    local result
    result=$(oci lfs object-storage-link start-import-from-object \
        --object-storage-link-id "$LFS_SELECTED_LINK" 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}✓ Import started${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Import started for $LFS_SELECTED_LINK" >> "$log_file"
    else
        echo -e "${RED}Failed to start import${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Lustre - Start Export to Object Storage
#--------------------------------------------------------------------------------
lfs_start_export_to_object() {
    local compartment_id="$1"
    
    LFS_SELECTED_LINK=""
    lfs_list_object_storage_links "$compartment_id" "select"
    
    [[ -z "$LFS_SELECTED_LINK" ]] && return
    
    echo ""
    local export_cmd="oci lfs object-storage-link start-export-to-object --object-storage-link-id \"$LFS_SELECTED_LINK\""
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$export_cmd${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Start export to Object Storage? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local log_file="${LOGS_DIR}/lustre_actions_$(date +%Y%m%d).log"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] START EXPORT: $export_cmd" >> "$log_file"
    
    echo ""
    echo -e "${CYAN}Starting export...${NC}"
    
    local result
    result=$(oci lfs object-storage-link start-export-to-object \
        --object-storage-link-id "$LFS_SELECTED_LINK" 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}✓ Export started${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Export started for $LFS_SELECTED_LINK" >> "$log_file"
    else
        echo -e "${RED}Failed to start export${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Lustre - Delete Object Storage Link
#--------------------------------------------------------------------------------
lfs_delete_object_storage_link() {
    local compartment_id="$1"
    
    LFS_SELECTED_LINK=""
    lfs_list_object_storage_links "$compartment_id" "select"
    
    [[ -z "$LFS_SELECTED_LINK" ]] && return
    
    echo ""
    echo -e "${RED}WARNING: This will delete the Object Storage link!${NC}"
    echo ""
    local delete_cmd="oci lfs object-storage-link delete --object-storage-link-id \"$LFS_SELECTED_LINK\" --force"
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$delete_cmd${NC}"
    echo ""
    
    echo -n -e "${RED}Type 'DELETE' to confirm: ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "DELETE" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local log_file="${LOGS_DIR}/lustre_actions_$(date +%Y%m%d).log"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] DELETE OS LINK: $delete_cmd" >> "$log_file"
    
    echo ""
    echo -e "${CYAN}Deleting Object Storage link...${NC}"
    
    local result
    result=$(oci lfs object-storage-link delete \
        --object-storage-link-id "$LFS_SELECTED_LINK" \
        --force 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}✓ Object Storage link deleted${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted $LFS_SELECTED_LINK" >> "$log_file"
    else
        echo -e "${RED}Failed to delete Object Storage link${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Manage Capacity Topology - View host lifecycle states summary
#--------------------------------------------------------------------------------
manage_capacity_topology() {
    local tenancy_id="${TENANCY_ID:-}"
    
    while true; do
        echo ""
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${CYAN}                                      CAPACITY TOPOLOGY                                                         ${NC}"
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        _display_cache_info \
            "${CAPACITY_TOPOLOGY_CACHE}|Capacity Hosts"
        echo ""
        
        if [[ -z "$tenancy_id" ]]; then
            echo -e "${RED}TENANCY_ID not set. Cannot query capacity topology.${NC}"
            echo ""
            echo -n -e "${CYAN}Press Enter to return...${NC}"
            read -r
            return
        fi
        
        # Refresh capacity topology cache
        echo -e "${CYAN}Fetching capacity topology data...${NC}"
        fetch_capacity_topology
        
        if [[ ! -f "$CAPACITY_TOPOLOGY_CACHE" ]]; then
            echo -e "${RED}Failed to fetch capacity topology data${NC}"
            echo ""
            echo -n -e "${CYAN}Press Enter to return...${NC}"
            read -r
            return
        fi
        
        # Count total hosts (excluding comment lines)
        local total_hosts
        total_hosts=$(grep -v "^#" "$CAPACITY_TOPOLOGY_CACHE" | wc -l)
        
        if [[ "$total_hosts" -eq 0 ]]; then
            echo -e "${YELLOW}No capacity topology hosts found${NC}"
            echo ""
            echo -n -e "${CYAN}Press Enter to return...${NC}"
            read -r
            return
        fi
        
        echo ""
        echo -e "${BOLD}${WHITE}═══ Summary ═══════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "  ${WHITE}Total Hosts:${NC} ${GREEN}$total_hosts${NC}"
        echo ""
        
        #-----------------------------------------------------------------------
        # Lifecycle State Summary
        #-----------------------------------------------------------------------
        echo -e "${BOLD}${WHITE}─── Lifecycle State Summary ───────────────────────────────────────────────────────────────────────────────────${NC}"
        printf "  ${BOLD}%-25s %8s %8s${NC}\n" "STATE" "COUNT" "PERCENT"
        echo -e "  ─────────────────────────────────────────────"
        
        # Get unique lifecycle states and counts
        grep -v "^#" "$CAPACITY_TOPOLOGY_CACHE" | cut -d'|' -f2 | sort | uniq -c | sort -rn | while read -r count state; do
            local pct
            pct=$(echo "scale=1; $count * 100 / $total_hosts" | bc)
            
            local state_color="$WHITE"
            case "$state" in
                ACTIVE|HEALTHY) state_color="$GREEN" ;;
                DEGRADED|IMPAIRED) state_color="$YELLOW" ;;
                INACTIVE|FAILED|UNAVAILABLE) state_color="$RED" ;;
                *) state_color="$GRAY" ;;
            esac
            
            printf "  ${state_color}%-25s${NC} %8s %7s%%\n" "$state" "$count" "$pct"
        done
        
        echo ""
        
        #-----------------------------------------------------------------------
        # Lifecycle Details Summary
        #-----------------------------------------------------------------------
        echo -e "${BOLD}${WHITE}─── Lifecycle Details Summary ─────────────────────────────────────────────────────────────────────────────────${NC}"
        printf "  ${BOLD}%-40s %8s %8s${NC}\n" "DETAILS" "COUNT" "PERCENT"
        echo -e "  ─────────────────────────────────────────────────────────────"
        
        # Get unique lifecycle details and counts
        grep -v "^#" "$CAPACITY_TOPOLOGY_CACHE" | cut -d'|' -f3 | sort | uniq -c | sort -rn | while read -r count details; do
            local pct
            pct=$(echo "scale=1; $count * 100 / $total_hosts" | bc)
            
            local details_color="$WHITE"
            local details_display="${details:0:38}"
            [[ ${#details} -gt 38 ]] && details_display="${details_display}.."
            
            case "$details" in
                N/A|"") 
                    details_color="$GRAY"
                    details_display="(none)"
                    ;;
                *HEALTHY*|*ACTIVE*) details_color="$GREEN" ;;
                *DEGRADED*|*WARNING*|*IMPAIRED*) details_color="$YELLOW" ;;
                *FAILED*|*ERROR*|*UNAVAILABLE*) details_color="$RED" ;;
                *) details_color="$WHITE" ;;
            esac
            
            printf "  ${details_color}%-40s${NC} %8s %7s%%\n" "$details_display" "$count" "$pct"
        done
        
        echo ""
        
        #-----------------------------------------------------------------------
        # Topology Summary (by Topology OCID)
        #-----------------------------------------------------------------------
        echo -e "${BOLD}${WHITE}─── Topology Summary ──────────────────────────────────────────────────────────────────────────────────────────${NC}"
        printf "  ${BOLD}%-50s %8s${NC}\n" "TOPOLOGY OCID" "HOSTS"
        echo -e "  ─────────────────────────────────────────────────────────────"
        
        grep -v "^#" "$CAPACITY_TOPOLOGY_CACHE" | cut -d'|' -f4 | sort | uniq -c | sort -rn | while read -r count topo_id; do
            local topo_short="${topo_id:0:48}"
            [[ ${#topo_id} -gt 48 ]] && topo_short="${topo_short}.."
            printf "  ${YELLOW}%-50s${NC} %8s\n" "$topo_short" "$count"
        done
        
        echo ""
        
        #-----------------------------------------------------------------------
        # Actions Menu
        #-----------------------------------------------------------------------
        echo -e "${BOLD}${WHITE}─── Actions ───────────────────────────────────────────────────────────────────────────────────────────────────${NC}"
        echo -e "  ${YELLOW}1${NC}) View hosts by lifecycle state"
        echo -e "  ${YELLOW}2${NC}) View hosts by lifecycle details"
        echo -e "  ${YELLOW}3${NC}) View all hosts (detailed)"
        echo -e "  ${MAGENTA}r${NC}) Refresh data"
        echo -e "  ${CYAN}Enter${NC}) Return to menu"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Capacity Topology] Select [1-3/r/Enter]: ${NC}"
        
        local choice
        read -r choice
        
        case "$choice" in
            1)
                capacity_topology_view_by_state
                ;;
            2)
                capacity_topology_view_by_details
                ;;
            3)
                capacity_topology_view_all_hosts
                ;;
            r|R)
                # Force refresh by removing cache
                rm -f "$CAPACITY_TOPOLOGY_CACHE"
                echo -e "${YELLOW}Cache cleared, refreshing...${NC}"
                sleep 1
                ;;
            *)
                return
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# Capacity Topology - View hosts filtered by lifecycle state
#--------------------------------------------------------------------------------
capacity_topology_view_by_state() {
    echo ""
    echo -e "${CYAN}Select lifecycle state to filter:${NC}"
    
    # Get unique states
    local states
    states=$(grep -v "^#" "$CAPACITY_TOPOLOGY_CACHE" | cut -d'|' -f2 | sort -u)
    
    local idx=0
    declare -A state_map
    while IFS= read -r state; do
        [[ -z "$state" ]] && continue
        ((idx++))
        state_map[$idx]="$state"
        local count
        count=$(grep -v "^#" "$CAPACITY_TOPOLOGY_CACHE" | cut -d'|' -f2 | grep -c "^${state}$")
        echo -e "  ${GREEN}$idx${NC}) $state ($count hosts)"
    done <<< "$states"
    
    echo ""
    echo -n -e "${CYAN}Select #: ${NC}"
    read -r sel
    
    local selected_state="${state_map[$sel]}"
    [[ -z "$selected_state" ]] && return
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Hosts with Lifecycle State: ${CYAN}$selected_state${NC} ${BOLD}${WHITE}═══${NC}"
    echo ""
    printf "${BOLD}%-50s %-15s %-30s${NC}\n" "INSTANCE OCID" "STATE" "DETAILS"
    echo "─────────────────────────────────────────────────────────────────────────────────────────────────────"
    
    grep -v "^#" "$CAPACITY_TOPOLOGY_CACHE" | grep "|${selected_state}|" | while IFS='|' read -r inst_id state details topo_id; do
        local inst_short="${inst_id:0:48}"
        [[ ${#inst_id} -gt 48 ]] && inst_short="${inst_short}.."
        
        local state_color="$GREEN"
        case "$state" in
            ACTIVE|HEALTHY) state_color="$GREEN" ;;
            DEGRADED|IMPAIRED) state_color="$YELLOW" ;;
            INACTIVE|FAILED|UNAVAILABLE) state_color="$RED" ;;
        esac
        
        local details_display="${details:0:28}"
        [[ ${#details} -gt 28 ]] && details_display="${details_display}.."
        [[ "$details" == "N/A" ]] && details_display="-"
        
        printf "${YELLOW}%-50s${NC} ${state_color}%-15s${NC} %-30s\n" "$inst_short" "$state" "$details_display"
    done
    
    echo ""
    echo -n -e "${CYAN}Press Enter to continue...${NC}"
    read -r
}

#--------------------------------------------------------------------------------
# Capacity Topology - View hosts filtered by lifecycle details
#--------------------------------------------------------------------------------
capacity_topology_view_by_details() {
    echo ""
    echo -e "${CYAN}Select lifecycle details to filter:${NC}"
    
    # Get unique details
    local details_list
    details_list=$(grep -v "^#" "$CAPACITY_TOPOLOGY_CACHE" | cut -d'|' -f3 | sort -u)
    
    local idx=0
    declare -A details_map
    while IFS= read -r details; do
        [[ -z "$details" ]] && continue
        ((idx++))
        details_map[$idx]="$details"
        local count
        count=$(grep -v "^#" "$CAPACITY_TOPOLOGY_CACHE" | awk -F'|' -v d="$details" '$3 == d' | wc -l)
        local display="${details:0:50}"
        [[ "$details" == "N/A" ]] && display="(none)"
        echo -e "  ${GREEN}$idx${NC}) $display ($count hosts)"
    done <<< "$details_list"
    
    echo ""
    echo -n -e "${CYAN}Select #: ${NC}"
    read -r sel
    
    local selected_details="${details_map[$sel]}"
    [[ -z "$selected_details" ]] && return
    
    local display_title="$selected_details"
    [[ "$selected_details" == "N/A" ]] && display_title="(none)"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Hosts with Lifecycle Details: ${CYAN}$display_title${NC} ${BOLD}${WHITE}═══${NC}"
    echo ""
    printf "${BOLD}%-50s %-15s %-30s${NC}\n" "INSTANCE OCID" "STATE" "DETAILS"
    echo "─────────────────────────────────────────────────────────────────────────────────────────────────────"
    
    grep -v "^#" "$CAPACITY_TOPOLOGY_CACHE" | awk -F'|' -v d="$selected_details" '$3 == d' | while IFS='|' read -r inst_id state details topo_id; do
        local inst_short="${inst_id:0:48}"
        [[ ${#inst_id} -gt 48 ]] && inst_short="${inst_short}.."
        
        local state_color="$GREEN"
        case "$state" in
            ACTIVE|HEALTHY) state_color="$GREEN" ;;
            DEGRADED|IMPAIRED) state_color="$YELLOW" ;;
            INACTIVE|FAILED|UNAVAILABLE) state_color="$RED" ;;
        esac
        
        local details_display="${details:0:28}"
        [[ ${#details} -gt 28 ]] && details_display="${details_display}.."
        [[ "$details" == "N/A" ]] && details_display="-"
        
        printf "${YELLOW}%-50s${NC} ${state_color}%-15s${NC} %-30s\n" "$inst_short" "$state" "$details_display"
    done
    
    echo ""
    echo -n -e "${CYAN}Press Enter to continue...${NC}"
    read -r
}

#--------------------------------------------------------------------------------
# Capacity Topology - View all hosts detailed
#--------------------------------------------------------------------------------
capacity_topology_view_all_hosts() {
    echo ""
    echo -e "${BOLD}${WHITE}═══ All Capacity Topology Hosts ═══${NC}"
    echo ""
    printf "${BOLD}%-55s %-12s %-25s %-30s${NC}\n" "INSTANCE OCID" "STATE" "DETAILS" "TOPOLOGY"
    echo "═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════"
    
    grep -v "^#" "$CAPACITY_TOPOLOGY_CACHE" | sort -t'|' -k2,2 -k3,3 | while IFS='|' read -r inst_id state details topo_id; do
        local inst_short="${inst_id:0:53}"
        [[ ${#inst_id} -gt 53 ]] && inst_short="${inst_short}.."
        
        local state_color="$GREEN"
        case "$state" in
            ACTIVE|HEALTHY) state_color="$GREEN" ;;
            DEGRADED|IMPAIRED) state_color="$YELLOW" ;;
            INACTIVE|FAILED|UNAVAILABLE) state_color="$RED" ;;
        esac
        
        local details_display="${details:0:23}"
        [[ ${#details} -gt 23 ]] && details_display="${details_display}.."
        [[ "$details" == "N/A" ]] && details_display="-"
        
        local topo_short="${topo_id:0:28}"
        [[ ${#topo_id} -gt 28 ]] && topo_short="${topo_short}.."
        
        printf "${YELLOW}%-55s${NC} ${state_color}%-12s${NC} %-25s ${GRAY}%-30s${NC}\n" "$inst_short" "$state" "$details_display" "$topo_short"
    done | less -R
    
    echo ""
    echo -n -e "${CYAN}Press Enter to continue...${NC}"
    read -r
}

#--------------------------------------------------------------------------------
# Manage GPU Instance Tagging - Main menu
#--------------------------------------------------------------------------------
#--------------------------------------------------------------------------------
# Manage Kubernetes - Node operations, kubelet troubleshooting
#--------------------------------------------------------------------------------
manage_kubernetes() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    while true; do
        echo ""
        echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${GREEN}                                         KUBERNETES MANAGEMENT                                                    ${NC}"
        echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}Environment:${NC}"
        echo -e "  ${CYAN}Region:${NC}      ${WHITE}${region}${NC}"
        echo -e "  ${CYAN}Compartment:${NC} ${WHITE}$(resolve_compartment_name "${compartment_id}")${NC} ${GRAY}(${compartment_id})${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
        echo ""
        echo -e "  ${RED}1${NC})  ${WHITE}Deregister Node (Kubelet Issue)${NC}  - Drain → Delete from K8s (for nodes with kubelet problems)"
        echo ""
        echo -e "  ${CYAN}b${NC})  Back to main menu"
        echo ""
        echo -n -e "${BOLD}${CYAN}[K8s Management] Enter selection [1/b]: ${NC}"
        
        local choice
        read -r choice
        
        case "$choice" in
            1)
                k8s_deregister_node "$compartment_id" "$region"
                ;;
            b|B|back|BACK|"")
                return
                ;;
            *)
                echo -e "${RED}Invalid selection${NC}"
                sleep 1
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# K8s Deregister Node - Drain and remove node from cluster
# For nodes with kubelet issues that need to be deregistered from K8s
#--------------------------------------------------------------------------------
k8s_deregister_node() {
    local compartment_id="$1"
    local region="$2"
    local log_file="${LOG_DIR}/k8s_deregister_$(date +%Y%m%d_%H%M%S).log"
    
    echo ""
    echo -e "${BOLD}${YELLOW}═══ Deregister Node (Kubelet Issue) ═══${NC}"
    echo ""
    echo -e "${GRAY}This will drain and remove a node from the Kubernetes cluster.${NC}"
    echo -e "${GRAY}Use when a node has kubelet issues and needs to be deregistered.${NC}"
    echo ""
    
    # Check kubectl available
    if ! command -v kubectl &>/dev/null; then
        echo -e "${RED}kubectl not available - cannot manage K8s nodes${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return 1
    fi
    
    # Fetch instances from OCI (reuse cache from manage 5)
    local instances_json
    local instance_cache_ttl=300
    if is_cache_fresh "$INSTANCE_LIST_CACHE" "$instance_cache_ttl"; then
        instances_json=$(cat "$INSTANCE_LIST_CACHE")
    else
        echo -e "${GRAY}Fetching instances from OCI...${NC}"
        instances_json=$(oci compute instance list \
            --compartment-id "$compartment_id" \
            --region "$region" \
            --all \
            --output json 2>/dev/null)
        if [[ -n "$instances_json" ]] && echo "$instances_json" | jq -e '.data' > /dev/null 2>&1; then
            echo "$instances_json" > "$INSTANCE_LIST_CACHE"
        fi
    fi
    
    if [[ -z "$instances_json" ]] || ! echo "$instances_json" | jq -e '.data' > /dev/null 2>&1; then
        echo -e "${RED}Failed to fetch instances${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return 1
    fi
    
    # Fetch K8s nodes for lookup
    local k8s_nodes_json
    k8s_nodes_json=$(kubectl get nodes -o json 2>/dev/null)
    
    if [[ -z "$k8s_nodes_json" ]]; then
        echo -e "${RED}Failed to fetch K8s nodes - check kubectl access${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return 1
    fi
    
    local k8s_lookup
    k8s_lookup=$(echo "$k8s_nodes_json" | jq -r '
        .items[] |
        (.status.conditions[] | select(.type=="Ready") | .status) as $ready |
        (.spec.unschedulable // false) as $unsched |
        "\(.spec.providerID)|\(.metadata.name)|\($ready)|\($unsched)"
    ' 2>/dev/null)
    
    # Build and display instance list with K8s node names
    echo -e "${BOLD}${WHITE}═══ Instances with K8s Node Names ═══${NC}"
    echo ""
    printf "${BOLD}%-5s %-50s %-10s %-8s %-8s %-45s %s${NC}\n" \
        "ID" "Display Name" "State" "K8s" "Ready" "K8s Node Name" "Instance OCID"
    print_separator 200
    
    declare -A DEREG_INDEX_MAP
    declare -A DEREG_NODE_MAP
    local dereg_idx=0
    
    while IFS='|' read -r time_created name state shape ad ocid; do
        [[ -z "$ocid" ]] && continue
        ((dereg_idx++))
        local iid="i${dereg_idx}"
        DEREG_INDEX_MAP[$iid]="$ocid"
        
        # Color state
        local state_color="$GREEN"
        case "$state" in
            RUNNING) state_color="$GREEN" ;;
            STOPPED) state_color="$RED" ;;
            STARTING|STOPPING) state_color="$YELLOW" ;;
            *) state_color="$WHITE" ;;
        esac
        
        # Look up K8s node
        local k8s_status="No"
        local k8s_color="$YELLOW"
        local k8s_ready="-"
        local k8s_node_name="-"
        
        local k8s_match
        k8s_match=$(echo "$k8s_lookup" | grep "$ocid" 2>/dev/null)
        
        if [[ -n "$k8s_match" ]]; then
            k8s_node_name=$(echo "$k8s_match" | cut -d'|' -f2)
            local ready_status=$(echo "$k8s_match" | cut -d'|' -f3)
            k8s_status="Yes"
            k8s_color="$GREEN"
            
            if [[ "$ready_status" == "True" ]]; then
                k8s_ready="Yes"
            else
                k8s_ready="No"
                k8s_color="$RED"
            fi
            
            DEREG_NODE_MAP[$iid]="$k8s_node_name"
        fi
        
        printf "${YELLOW}%-5s${NC} %-50s ${state_color}%-10s${NC} ${k8s_color}%-8s${NC} %-8s ${CYAN}%-45s${NC} ${GRAY}%s${NC}\n" \
            "$iid" "${name:0:50}" "$state" "$k8s_status" "$k8s_ready" "${k8s_node_name:0:45}" "$ocid"
            
    done < <(echo "$instances_json" | jq -r '
        .data[] |
        select(.["lifecycle-state"] != "TERMINATED") |
        "\(.["time-created"] // "N/A")|\(.["display-name"])|\(.["lifecycle-state"])|\(.shape)|\(.["availability-domain"])|\(.id)"
    ' 2>/dev/null | sort -t'|' -k1,1)
    
    echo ""
    echo -e "${GRAY}Total: ${dereg_idx} instance(s)${NC}"
    echo ""
    
    # Prompt for node selection
    echo -n -e "${BOLD}${CYAN}Enter instance ID to deregister (e.g., i1): ${NC}"
    local target
    read -r target
    
    if [[ -z "$target" ]]; then
        return
    fi
    
    local target_ocid="${DEREG_INDEX_MAP[$target]:-}"
    local target_node="${DEREG_NODE_MAP[$target]:-}"
    
    if [[ -z "$target_ocid" ]]; then
        echo -e "${RED}Invalid instance ID: ${target}${NC}"
        sleep 2
        return
    fi
    
    if [[ -z "$target_node" || "$target_node" == "-" ]]; then
        echo -e "${RED}Instance ${target} is not registered in Kubernetes - no K8s node name found.${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    # Get display name
    local target_name
    target_name=$(echo "$instances_json" | jq -r --arg ocid "$target_ocid" '.data[] | select(.id == $ocid) | .["display-name"]' 2>/dev/null)
    
    echo ""
    echo -e "${BOLD}${WHITE}Selected Node:${NC}"
    echo -e "  ${CYAN}Instance:${NC}    ${WHITE}${target_name}${NC}"
    echo -e "  ${CYAN}K8s Node:${NC}    ${WHITE}${target_node}${NC}"
    echo -e "  ${CYAN}OCID:${NC}        ${YELLOW}${target_ocid}${NC}"
    echo ""
    
    echo -e "${BOLD}${WHITE}The following commands will be executed:${NC}"
    echo ""
    echo -e "  ${YELLOW}1.${NC} ${WHITE}kubectl drain ${target_node} --ignore-daemonsets --delete-emptydir-data${NC}"
    echo -e "  ${YELLOW}2.${NC} ${WHITE}kubectl delete node ${target_node}${NC}"
    echo ""
    echo -e "${BOLD}${RED}⚠  This will remove the node from the Kubernetes cluster.${NC}"
    echo ""
    echo -n -e "${BOLD}${RED}Type 'yes' to confirm: ${NC}"
    local confirm
    read -r confirm
    
    if [[ "$confirm" != "yes" ]]; then
        echo -e "${YELLOW}Cancelled.${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return
    fi
    
    mkdir -p "$LOG_DIR"
    
    # Step 1: Drain the node
    echo ""
    local drain_cmd="kubectl drain ${target_node} --ignore-daemonsets --delete-emptydir-data"
    echo -e "${BOLD}${YELLOW}[Step 1/2] Draining node...${NC}"
    echo -e "${GRAY}Executing: ${WHITE}${drain_cmd}${NC}"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] DRAIN NODE: ${drain_cmd}" >> "$log_file"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Instance: ${target_name} (${target_ocid})" >> "$log_file"
    
    if kubectl drain "$target_node" --ignore-daemonsets --delete-emptydir-data 2>&1 | tee -a "$log_file"; then
        echo ""
        echo -e "${GREEN}✓ Node drained successfully${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] RESULT: Drain successful" >> "$log_file"
    else
        echo ""
        echo -e "${RED}✗ Drain returned an error (may be partial)${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] RESULT: Drain returned error" >> "$log_file"
        echo ""
        echo -n -e "${YELLOW}Continue with delete node anyway? (yes/no): ${NC}"
        local cont
        read -r cont
        if [[ "$cont" != "yes" ]]; then
            echo -e "${YELLOW}Stopped. Node was partially drained but NOT deleted from cluster.${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] RESULT: User cancelled after drain error" >> "$log_file"
            echo ""
            echo -e "${GRAY}Log: ${log_file}${NC}"
            echo -e "Press Enter to return..."
            read -r
            return
        fi
    fi
    
    # Step 2: Delete the node from K8s
    echo ""
    local delete_cmd="kubectl delete node ${target_node}"
    echo -e "${BOLD}${YELLOW}[Step 2/2] Deleting node from cluster...${NC}"
    echo -e "${GRAY}Executing: ${WHITE}${delete_cmd}${NC}"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] DELETE NODE: ${delete_cmd}" >> "$log_file"
    
    if kubectl delete node "$target_node" 2>&1 | tee -a "$log_file"; then
        echo ""
        echo -e "${GREEN}✓ Node deleted from Kubernetes cluster${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] RESULT: Node delete successful" >> "$log_file"
    else
        echo ""
        echo -e "${RED}✗ Failed to delete node${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] RESULT: Node delete failed" >> "$log_file"
    fi
    
    # Display manual steps for the problematic node
    echo ""
    echo -e "${BOLD}${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${YELLOW}  On the problematic node (${WHITE}${target_name}${YELLOW}), run:${NC}"
    echo -e "${BOLD}${YELLOW}═══════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "  ${WHITE}# Stop kubelet and container runtime${NC}"
    echo -e "  ${YELLOW}sudo systemctl stop kubelet crio${NC}"
    echo ""
    echo -e "${GRAY}This stops the kubelet and container runtime on the node to complete the deregistration.${NC}"
    echo -e "${GRAY}The node will no longer attempt to rejoin the cluster until these services are restarted.${NC}"
    echo ""
    echo -e "${GRAY}Log: ${WHITE}${log_file}${NC}"
    echo ""
    echo -e "Press Enter to return..."
    read -r
}

manage_gpu_instance_tagging() {
    local tenancy_ocid="${TENANCY_ID:-$TENANCY_OCID}"
    local home_region
    
    # Get home region for IAM operations
    echo -e "${GRAY}Detecting home region...${NC}"
    home_region=$(get_home_region)
    
    if [[ -z "$home_region" ]]; then
        echo ""
        echo -e "${RED}Error: Could not determine home region.${NC}"
        echo -e "${YELLOW}Please ensure TENANCY_ID or TENANCY_OCID is set in variables.sh${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return 1
    fi
    
    while true; do
        echo ""
        echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${MAGENTA}                                        GPU INSTANCE TAGGING                                                     ${NC}"
        echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}Configuration:${NC}"
        echo -e "  ${CYAN}Tenancy:${NC}     ${YELLOW}${tenancy_ocid}${NC}"
        echo -e "  ${CYAN}Home Region:${NC} ${WHITE}${home_region}${NC}"
        echo -e "  ${CYAN}Namespace:${NC}   ${WHITE}${GPU_TAG_NAMESPACE}${NC}"
        echo -e "  ${CYAN}Tag Name:${NC}    ${WHITE}${GPU_TAG_NAME}${NC}"
        echo -e "  ${CYAN}Tag Values:${NC}  ${WHITE}${GPU_TAG_VALUES}${NC}"
        echo ""
        echo -e "${GRAY}Home region derived from: oci iam region-subscription list --tenancy-id \"\$TENANCY_ID\" --query \"data[?\\\"is-home-region\\\"==\\\`true\\\`].\\\"region-name\\\" | [0]\"${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
        echo ""
        echo -e "  ${GREEN}c${NC}) ${WHITE}Create namespace and tag${NC}      - Create ${GPU_TAG_NAMESPACE} namespace with ${GPU_TAG_NAME} tag"
        echo -e "  ${CYAN}v${NC}) ${WHITE}Validate namespace and tag${NC}    - Check if namespace exists with proper tag configuration"
        echo -e "  ${RED}d${NC}) ${WHITE}Delete namespace${NC}              - Retire and cascade-delete the namespace"
        echo ""
        echo -e "  ${CYAN}b${NC}) Back to main menu"
        echo ""
        echo -n -e "${BOLD}${CYAN}[GPU Tagging] Enter selection [c/v/d/b]: ${NC}"
        
        local choice
        read -r choice
        
        case "$choice" in
            c|C|1)
                create_gpu_tagging_namespace "$tenancy_ocid" "$home_region"
                ;;
            v|V|2)
                validate_gpu_tagging_namespace "$tenancy_ocid" "$home_region"
                ;;
            d|D|3)
                delete_gpu_tagging_namespace "$tenancy_ocid" "$home_region"
                ;;
            b|B|back|BACK|"")
                return
                ;;
            *)
                echo -e "${RED}Invalid selection${NC}"
                sleep 1
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# Kubernetes Management - Node operations and troubleshooting
#--------------------------------------------------------------------------------
manage_kubernetes() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    while true; do
        echo ""
        echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${MAGENTA}                                        KUBERNETES MANAGEMENT                                                     ${NC}"
        echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}Environment:${NC}"
        echo -e "  ${CYAN}Region:${NC}      ${WHITE}${region}${NC}"
        echo -e "  ${CYAN}Compartment:${NC} ${WHITE}$(resolve_compartment_name "${compartment_id}")${NC} ${GRAY}(${compartment_id})${NC}"
        echo ""
        
        echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
        echo ""
        echo -e "  ${RED}1${NC}) ${WHITE}Kubelet Deregister${NC}  - Drain, delete K8s node, and show recovery steps for kubelet issues"
        echo ""
        echo -e "  ${CYAN}b${NC}) Back to main menu"
        echo ""
        echo -n -e "${BOLD}${CYAN}[K8s Management] Enter selection [1/b]: ${NC}"
        
        local choice
        read -r choice
        
        case "$choice" in
            1)
                k8s_kubelet_deregister
                ;;
            b|B|back|BACK|"")
                return
                ;;
            *)
                echo -e "${RED}Invalid selection${NC}"
                sleep 1
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# Kubelet Deregister - Drain and delete a K8s node, show recovery steps
#--------------------------------------------------------------------------------
k8s_kubelet_deregister() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    local log_file="${LOGS_DIR}/k8s_deregister_$(date '+%Y%m%d_%H%M%S').log"
    
    echo ""
    echo -e "${BOLD}${RED}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${RED}                                     KUBELET DEREGISTER (DRAIN + DELETE NODE)                                      ${NC}"
    echo -e "${BOLD}${RED}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Check kubectl availability
    if ! command -v kubectl &>/dev/null; then
        echo -e "${RED}kubectl not available - cannot perform node operations${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return 1
    fi
    
    # Fetch instances from cache or OCI
    echo -e "${GRAY}Fetching instances and K8s node mappings...${NC}"
    local instances_json
    local instance_cache_ttl=300
    if is_cache_fresh "$INSTANCE_LIST_CACHE" "$instance_cache_ttl"; then
        instances_json=$(cat "$INSTANCE_LIST_CACHE")
    else
        instances_json=$(oci compute instance list \
            --compartment-id "$compartment_id" \
            --region "$region" \
            --all \
            --output json 2>/dev/null)
        if [[ -n "$instances_json" ]] && echo "$instances_json" | jq -e '.data' > /dev/null 2>&1; then
            echo "$instances_json" > "$INSTANCE_LIST_CACHE"
        fi
    fi
    
    if [[ -z "$instances_json" ]] || ! echo "$instances_json" | jq -e '.data' > /dev/null 2>&1; then
        echo -e "${RED}Failed to fetch instances${NC}"
        echo -e "Press Enter to return..."
        read -r
        return 1
    fi
    
    # Fetch K8s node info
    local k8s_nodes_json
    k8s_nodes_json=$(kubectl get nodes -o json 2>/dev/null)
    
    local k8s_lookup
    k8s_lookup=$(echo "$k8s_nodes_json" | jq -r '
        .items[] |
        (.spec.taints // [] | map(select(.key == "newNode")) | if length > 0 then .[0].effect else "N/A" end) as $newNodeTaint |
        (.spec.unschedulable // false) as $unschedulable |
        "\(.spec.providerID)|\(.metadata.name)|\(.status.conditions[] | select(.type=="Ready") | .status)|\($newNodeTaint)|\($unschedulable)"
    ' 2>/dev/null)
    
    # Build instance list with K8s node names
    declare -A DEREG_MAP=()      # i# -> ocid|name|k8s_node_name
    local dereg_idx=0
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Instances with K8s Node Names ═══${NC}"
    echo ""
    printf "${BOLD}%-5s %-50s %-10s %-8s %-45s %s${NC}\n" \
        "ID" "Display Name" "State" "K8s" "Kubectl Node Name" "Instance OCID"
    print_separator 210
    
    echo "$instances_json" | jq -r '
        .data[] |
        select(.["lifecycle-state"] != "TERMINATED") |
        "\(.["time-created"] // "N/A")|\(.["display-name"])|\(.["lifecycle-state"])|\(.id)"
    ' 2>/dev/null | sort -t'|' -k1,1 | while IFS='|' read -r time_created name state ocid; do
        ((dereg_idx++))
        local iid="i${dereg_idx}"
        
        # Color state
        local state_color="$GREEN"
        case "$state" in
            RUNNING) state_color="$GREEN" ;;
            STOPPED) state_color="$RED" ;;
            STARTING|STOPPING) state_color="$YELLOW" ;;
            *) state_color="$WHITE" ;;
        esac
        
        # Check K8s membership
        local k8s_status="No"
        local k8s_color="$YELLOW"
        local k8s_node_name="-"
        
        local k8s_match
        k8s_match=$(echo "$k8s_lookup" | grep "$ocid" 2>/dev/null)
        
        if [[ -n "$k8s_match" ]]; then
            k8s_node_name=$(echo "$k8s_match" | cut -d'|' -f2)
            local k8s_ready
            k8s_ready=$(echo "$k8s_match" | cut -d'|' -f3)
            
            if [[ "$k8s_ready" == "True" ]]; then
                k8s_status="Ready"
                k8s_color="$GREEN"
            else
                k8s_status="NotRdy"
                k8s_color="$RED"
            fi
        fi
        
        printf "${YELLOW}%-5s${NC} %-50s ${state_color}%-10s${NC} ${k8s_color}%-8s${NC} ${WHITE}%-45s${NC} ${GRAY}%s${NC}\n" \
            "$iid" "${name:0:50}" "$state" "$k8s_status" "${k8s_node_name:0:45}" "$ocid"
        
        # Write to temp file for map (subshell)
        echo "${iid}|${ocid}|${name}|${k8s_node_name}" >> "${TEMP_DIR}/dereg_map_$$"
    done
    
    # Read map from temp file
    if [[ -f "${TEMP_DIR}/dereg_map_$$" ]]; then
        while IFS='|' read -r iid ocid name k8s_node; do
            DEREG_MAP[$iid]="${ocid}|${name}|${k8s_node}"
        done < "${TEMP_DIR}/dereg_map_$$"
        rm -f "${TEMP_DIR}/dereg_map_$$"
    fi
    
    local total=${#DEREG_MAP[@]}
    echo ""
    echo -e "${GRAY}Total: ${total} instances (excluding TERMINATED)${NC}"
    echo ""
    
    # Selection loop
    while true; do
        echo -e "${BOLD}${WHITE}─── Actions ───${NC}"
        echo -e "  ${YELLOW}i#${NC}  - Select instance to deregister (e.g., 'i1', 'i5')"
        echo -e "  ${CYAN}b${NC}   - Back"
        echo ""
        echo -n -e "${CYAN}Select instance [i#/b]: ${NC}"
        local selection
        read -r selection
        
        [[ -z "$selection" || "$selection" == "b" || "$selection" == "B" ]] && return 0
        
        # Validate selection
        local selected_data="${DEREG_MAP[$selection]:-}"
        if [[ -z "$selected_data" ]]; then
            echo -e "${RED}Invalid selection: ${selection}${NC}"
            sleep 1
            continue
        fi
        
        local sel_ocid sel_name sel_k8s_node
        IFS='|' read -r sel_ocid sel_name sel_k8s_node <<< "$selected_data"
        
        if [[ "$sel_k8s_node" == "-" || -z "$sel_k8s_node" ]]; then
            echo -e "${RED}Instance '${sel_name}' is not registered as a K8s node${NC}"
            sleep 1
            continue
        fi
        
        echo ""
        echo -e "${BOLD}${WHITE}═══ Kubelet Deregister ═══${NC}"
        echo ""
        echo -e "  ${CYAN}Instance:${NC}  ${WHITE}${sel_name}${NC}"
        echo -e "  ${CYAN}OCID:${NC}      ${YELLOW}${sel_ocid}${NC}"
        echo -e "  ${CYAN}K8s Node:${NC}  ${WHITE}${sel_k8s_node}${NC}"
        echo ""
        
        echo -e "${BOLD}${YELLOW}This will execute:${NC}"
        echo -e "  ${GRAY}1. kubectl drain ${sel_k8s_node} --ignore-daemonsets --delete-emptydir-data${NC}"
        echo -e "  ${GRAY}2. kubectl delete node ${sel_k8s_node}${NC}"
        echo ""
        echo -e "${RED}WARNING: This will evict all pods and remove the node from the cluster.${NC}"
        echo ""
        echo -n -e "${BOLD}${YELLOW}Proceed? [y/N]: ${NC}"
        local confirm
        read -r confirm
        
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            echo -e "${GRAY}Cancelled${NC}"
            continue
        fi
        
        # Ensure log directory exists
        mkdir -p "$(dirname "$log_file")" 2>/dev/null || true
        
        # Step 1: Drain
        echo ""
        local drain_cmd="kubectl drain ${sel_k8s_node} --ignore-daemonsets --delete-emptydir-data"
        echo -e "${BOLD}${WHITE}Step 1: Draining node...${NC}"
        echo -e "${GRAY}\$ ${drain_cmd}${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: ${drain_cmd}" >> "$log_file"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Instance: ${sel_name} (${sel_ocid})" >> "$log_file"
        
        if kubectl drain "$sel_k8s_node" --ignore-daemonsets --delete-emptydir-data 2>&1 | tee -a "$log_file"; then
            echo ""
            echo -e "${GREEN}✓ Node drained successfully${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] RESULT: Drain succeeded" >> "$log_file"
        else
            echo ""
            echo -e "${YELLOW}⚠ Drain encountered errors (see above). Continuing with delete...${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] RESULT: Drain had errors" >> "$log_file"
        fi
        
        # Step 2: Delete node
        echo ""
        local delete_cmd="kubectl delete node ${sel_k8s_node}"
        echo -e "${BOLD}${WHITE}Step 2: Deleting node from cluster...${NC}"
        echo -e "${GRAY}\$ ${delete_cmd}${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: ${delete_cmd}" >> "$log_file"
        
        if kubectl delete node "$sel_k8s_node" 2>&1 | tee -a "$log_file"; then
            echo ""
            echo -e "${GREEN}✓ Node deleted from cluster${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] RESULT: Delete succeeded" >> "$log_file"
        else
            echo ""
            echo -e "${RED}✗ Failed to delete node${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] RESULT: Delete failed" >> "$log_file"
        fi
        
        # Step 3: Show manual recovery steps
        echo ""
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${CYAN}                              ON THE PROBLEMATIC NODE, RUN THE FOLLOWING:                                         ${NC}"
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo ""
        echo -e "  ${WHITE}# SSH to the node${NC}"
        echo -e "  ${GRAY}ssh opc@<node-ip>${NC}"
        echo ""
        echo -e "  ${WHITE}# Step 1: Stop kubelet and CRI-O${NC}"
        echo -e "  ${YELLOW}sudo systemctl stop kubelet crio${NC}"
        echo ""
        echo -e "  ${WHITE}# Step 2: Remove kubelet PKI certificates${NC}"
        echo -e "  ${YELLOW}sudo rm /var/lib/kubelet/pki/*${NC}"
        echo ""
        echo -e "  ${WHITE}# Step 3: Re-bootstrap the node${NC}"
        echo -e "  ${YELLOW}sudo oke bootstrap${NC}"
        echo ""
        echo -e "${GRAY}The node will re-register with the cluster and rejoin as a fresh worker node.${NC}"
        echo -e "${GRAY}Log file: ${log_file}${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
    done
}

#--------------------------------------------------------------------------------
# Manage NVIDIA GPU Stack Health - Check GPU Operator & DRA per node
#--------------------------------------------------------------------------------
manage_nvidia_gpu_stack_health() {
    echo ""
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${GREEN}                                                    NVIDIA GPU STACK HEALTH CHECK                                                                      ${NC}"
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Check if kubectl is available
    if ! command -v kubectl &>/dev/null; then
        echo -e "${RED}kubectl not available - cannot check GPU stack health${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return 1
    fi
    
    # Test cluster connectivity
    if ! kubectl cluster-info &>/dev/null; then
        echo -e "${RED}Cannot connect to Kubernetes cluster${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return 1
    fi
    
    echo -e "${GRAY}Fetching node and pod information...${NC}"
    echo ""
    
    # Show validation commands used
    echo -e "${BOLD}${WHITE}═══ Validation Commands ═══${NC}"
    echo ""
    echo -e "${GRAY}Node & GPU info:${NC}"
    echo -e "  ${CYAN}kubectl get nodes -o json | jq '.items[] | {name, gpu: .status.capacity[\"nvidia.com/gpu\"], taints: .spec.taints}'${NC}"
    echo ""
    echo -e "${GRAY}GPU Operator pods per node:${NC}"
    echo -e "  ${CYAN}kubectl get pods -n gpu-operator -o json | jq '.items[] | {node: .spec.nodeName, name: .metadata.name, phase: .status.phase}'${NC}"
    echo ""
    echo -e "${GRAY}DRA Driver pods per node:${NC}"
    echo -e "  ${CYAN}kubectl get pods -n nvidia-dra-driver-gpu -o json | jq '.items[] | {node: .spec.nodeName, name: .metadata.name, phase: .status.phase}'${NC}"
    echo ""
    echo -e "${GRAY}DRA Controller (deployment - runs on any node):${NC}"
    echo -e "  ${CYAN}kubectl get pods -n nvidia-dra-driver-gpu -l app=nvidia-dra-controller -o wide${NC}"
    echo ""
    
    # Get all nodes with GPU info including taints
    local nodes_json
    nodes_json=$(kubectl get nodes -o json 2>/dev/null)
    
    if [[ -z "$nodes_json" ]]; then
        echo -e "${RED}Failed to get nodes${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return 1
    fi
    
    # Build node list with GPU detection and taints
    local node_data
    node_data=$(echo "$nodes_json" | jq -r '
        .items[] | 
        {
            name: .metadata.name,
            gpu_count: (.status.capacity["nvidia.com/gpu"] // "0"),
            gpu_product: (.metadata.labels["nvidia.com/gpu.product"] // "-"),
            ready: (.status.conditions[] | select(.type=="Ready") | .status),
            unschedulable: (.spec.unschedulable // false),
            taints: ((.spec.taints // []) | map(.key + "=" + (.value // "") + ":" + .effect) | join(","))
        } | "\(.name)|\(.gpu_count)|\(.gpu_product)|\(.ready)|\(.unschedulable)|\(.taints)"
    ' 2>/dev/null)
    
    # Get all pods from gpu-operator namespace with ready status
    # Format: nodeName|podName|phase|readyContainers/totalContainers
    local gpu_op_pods
    gpu_op_pods=$(kubectl get pods -n gpu-operator -o json 2>/dev/null | jq -r '
        .items[] | 
        ((.status.containerStatuses // []) | map(select(.ready == true)) | length) as $ready |
        ((.status.containerStatuses // []) | length) as $total |
        "\(.spec.nodeName // "N/A")|\(.metadata.name)|\(.status.phase)|\($ready)/\($total)"
    ' 2>/dev/null)
    
    # Get all pods from nvidia-dra-driver-gpu namespace with ready status
    # Format: nodeName|podName|phase|readyContainers/totalContainers
    local dra_pods
    dra_pods=$(kubectl get pods -n nvidia-dra-driver-gpu -o json 2>/dev/null | jq -r '
        .items[] | 
        ((.status.containerStatuses // []) | map(select(.ready == true)) | length) as $ready |
        ((.status.containerStatuses // []) | length) as $total |
        "\(.spec.nodeName // "N/A")|\(.metadata.name)|\(.status.phase)|\($ready)/\($total)"
    ' 2>/dev/null)
    
    # Check if namespaces exist
    local gpu_op_ns_exists=false
    local dra_ns_exists=false
    kubectl get ns gpu-operator &>/dev/null && gpu_op_ns_exists=true
    kubectl get ns nvidia-dra-driver-gpu &>/dev/null && dra_ns_exists=true
    
    # Check DRA kubelet plugin status globally
    # Pattern matches: nvidia-dra-driver-gpu-kubelet-plugin-* or *-k8s-dra-driver-kubelet-plugin-*
    local dra_kubelet_plugin_count=0
    local dra_kubelet_plugin_ready=0
    local dra_kubelet_plugin_status="${GRAY}-"
    if [[ "$dra_ns_exists" == "true" ]]; then
        # Count kubelet-plugin pods and their ready status (flexible pattern)
        while IFS='|' read -r node_name pod_name phase ready_status; do
            if [[ "$pod_name" == *"kubelet-plugin"* ]]; then
                ((dra_kubelet_plugin_count++))
                if [[ "$phase" == "Running" ]]; then
                    # Check if all containers are ready (e.g., "2/2" means ready)
                    local ready_num total_num
                    ready_num=$(echo "$ready_status" | cut -d'/' -f1)
                    total_num=$(echo "$ready_status" | cut -d'/' -f2)
                    if [[ "$ready_num" == "$total_num" && "$total_num" != "0" ]]; then
                        ((dra_kubelet_plugin_ready++))
                    fi
                fi
            fi
        done <<< "$dra_pods"
        
        if [[ $dra_kubelet_plugin_count -gt 0 ]]; then
            if [[ $dra_kubelet_plugin_ready -eq $dra_kubelet_plugin_count ]]; then
                dra_kubelet_plugin_status="${GREEN}✓ ${dra_kubelet_plugin_ready}/${dra_kubelet_plugin_count} Ready"
            else
                dra_kubelet_plugin_status="${YELLOW}◐ ${dra_kubelet_plugin_ready}/${dra_kubelet_plugin_count} Ready"
            fi
        else
            dra_kubelet_plugin_status="${RED}✗ No kubelet-plugin pods found"
        fi
    fi
    
    # Summary section
    echo -e "${BOLD}${WHITE}═══ Namespace Status ═══${NC}"
    echo ""
    if [[ "$gpu_op_ns_exists" == "true" ]]; then
        local gpu_op_pod_count
        gpu_op_pod_count=$(kubectl get pods -n gpu-operator --no-headers 2>/dev/null | wc -l | tr -d ' ')
        echo -e "  ${CYAN}gpu-operator:${NC}          ${GREEN}EXISTS${NC} (${gpu_op_pod_count} pods)"
        
        # Check if using host drivers (no nvidia-driver pods)
        local driver_pod_count
        driver_pod_count=$(kubectl get pods -n gpu-operator --no-headers 2>/dev/null | grep -c "nvidia-driver" 2>/dev/null || true)
        driver_pod_count=${driver_pod_count:-0}
        driver_pod_count=$(echo "$driver_pod_count" | tr -d '[:space:]')
        if [[ -z "$driver_pod_count" || "$driver_pod_count" == "0" ]]; then
            echo -e "  ${CYAN}Driver Mode:${NC}           ${GRAY}HOST${NC} (driver.enabled: false - using pre-installed drivers)"
        else
            echo -e "  ${CYAN}Driver Mode:${NC}           ${GREEN}OPERATOR${NC} (${driver_pod_count} nvidia-driver pods)"
        fi
    else
        echo -e "  ${CYAN}gpu-operator:${NC}          ${RED}NOT FOUND${NC}"
    fi
    
    if [[ "$dra_ns_exists" == "true" ]]; then
        local dra_pod_count
        dra_pod_count=$(kubectl get pods -n nvidia-dra-driver-gpu --no-headers 2>/dev/null | wc -l | tr -d ' ')
        echo -e "  ${CYAN}nvidia-dra-driver-gpu:${NC} ${GREEN}EXISTS${NC} (${dra_pod_count} pods)"
        echo -e "  ${CYAN}DRA Kubelet Plugin:${NC}    ${dra_kubelet_plugin_status}${NC}"
    else
        echo -e "  ${CYAN}nvidia-dra-driver-gpu:${NC} ${RED}NOT FOUND${NC}"
    fi
    echo ""
    
    # Build header for component matrix
    echo -e "${BOLD}${WHITE}═══ Per-Node Component Status (GPU Nodes Only) ═══${NC}"
    echo ""
    echo -e "${GRAY}Components: driver=NVIDIA Driver (or 'host' if using pre-installed drivers) | toolkit=Container Toolkit | plugin=Device Plugin${NC}"
    echo -e "${GRAY}            gfd=GPU Feature Discovery | dcgm=DCGM Exporter | validator=Operator Validator | mig-mgr=MIG Manager${NC}"
    echo -e "${GRAY}            dra-drv=DRA Kubelet Plugin (*kubelet-plugin* pods in nvidia-dra-driver-gpu namespace)${NC}"
    echo ""
    
    # Print header
    printf "${BOLD}%-3s %-28s %-5s %-6s %-20s %-7s %-7s %-7s %-5s %-5s %-9s %-8s %-8s %-80s${NC}\n" \
        "#" "Node Name" "GPUs" "Ready" "GPU Product" "driver" "toolkit" "plugin" "gfd" "dcgm" "validator" "mig-mgr" "dra-drv" "Taints"
    print_separator 245
    
    # Process each node - only GPU nodes
    local node_idx=0
    declare -A NODE_INDEX_MAP
    local total_nodes=0
    local gpu_nodes=0
    local healthy_nodes=0
    
    while IFS='|' read -r node_name gpu_count gpu_product ready unschedulable taints; do
        [[ -z "$node_name" ]] && continue
        ((total_nodes++))
        
        # Skip non-GPU nodes
        [[ "$gpu_count" == "0" || -z "$gpu_count" ]] && continue
        
        ((gpu_nodes++))
        ((node_idx++))
        NODE_INDEX_MAP[$node_idx]="$node_name"
        
        # Truncate fields
        local node_trunc="${node_name:0:28}"
        local product_trunc="${gpu_product:0:20}"
        
        # Process taints for display
        local taints_display="-"
        local taints_color="$GRAY"
        if [[ -n "$taints" && "$taints" != "null" ]]; then
            # Shorten common taint patterns
            taints_display=$(echo "$taints" | sed 's/nvidia.com\/gpu=:NoSchedule/gpu:NoSched/g' \
                | sed 's/node.kubernetes.io\/unschedulable:NoSchedule/unschedulable/g' \
                | sed 's/oci.oraclecloud.com\/oke-new-node:NoSchedule/newNode/g' \
                | sed 's/:NoSchedule/:NoSch/g' \
                | sed 's/:NoExecute/:NoEx/g' \
                | sed 's/:PreferNoSchedule/:PrefNo/g')
            taints_display="${taints_display:0:80}"
            taints_color="$YELLOW"
        fi
        
        # Ready status color
        local ready_color="$GREEN"
        [[ "$ready" != "True" ]] && ready_color="$RED"
        
        # GPU count color
        local gpu_color="$CYAN"
        
        # Helper function to get component status from pod list
        # Returns: "color|value" (e.g., "GREEN|1/1" or "RED|-")
        _get_pod_status() {
            local pods="$1"
            local node="$2"
            local pattern="$3"
            local optional="$4"  # "optional" if component is optional
            
            local pod_line
            pod_line=$(echo "$pods" | grep "^${node}|.*${pattern}" | head -1)
            
            if [[ -n "$pod_line" ]]; then
                local phase ready_status ready_num total_num
                phase=$(echo "$pod_line" | cut -d'|' -f3)
                ready_status=$(echo "$pod_line" | cut -d'|' -f4)
                ready_num=$(echo "$ready_status" | cut -d'/' -f1)
                total_num=$(echo "$ready_status" | cut -d'/' -f2)
                
                if [[ "$phase" == "Succeeded" ]]; then
                    echo "GREEN|done"
                elif [[ "$phase" == "Running" && "$ready_num" == "$total_num" && "$total_num" != "0" ]]; then
                    echo "GREEN|run"
                elif [[ "$phase" == "Running" ]]; then
                    echo "YELLOW|${ready_status}"
                else
                    echo "YELLOW|${phase:0:4}"
                fi
            else
                if [[ "$optional" == "optional" ]]; then
                    echo "GRAY|-"
                else
                    echo "RED|-"
                fi
            fi
        }
        
        # Check each GPU Operator component - store color and value separately
        local driver_color="GRAY" driver_val="-"
        local toolkit_color="GRAY" toolkit_val="-"
        local plugin_color="GRAY" plugin_val="-"
        local gfd_color="GRAY" gfd_val="-"
        local dcgm_color="GRAY" dcgm_val="-"
        local validator_color="GRAY" validator_val="-"
        local mig_color="GRAY" mig_val="-"
        
        if [[ "$gpu_op_ns_exists" == "true" ]]; then
            # Check driver - handle host driver mode
            local driver_pod
            driver_pod=$(echo "$gpu_op_pods" | grep "^${node_name}|.*nvidia-driver" | head -1)
            if [[ -n "$driver_pod" ]]; then
                local d_phase d_ready d_rnum d_tnum
                d_phase=$(echo "$driver_pod" | cut -d'|' -f3)
                d_ready=$(echo "$driver_pod" | cut -d'|' -f4)
                d_rnum=$(echo "$d_ready" | cut -d'/' -f1)
                d_tnum=$(echo "$d_ready" | cut -d'/' -f2)
                if [[ "$d_phase" == "Running" && "$d_rnum" == "$d_tnum" && "$d_tnum" != "0" ]]; then
                    driver_color="GREEN"; driver_val="$d_ready"
                elif [[ "$d_phase" == "Running" ]]; then
                    driver_color="YELLOW"; driver_val="$d_ready"
                else
                    driver_color="YELLOW"; driver_val="${d_phase:0:4}"
                fi
            else
                # Check if any driver pods exist cluster-wide
                if echo "$gpu_op_pods" | grep -q "nvidia-driver"; then
                    driver_color="RED"; driver_val="-"
                else
                    driver_color="GRAY"; driver_val="host"
                fi
            fi
            
            # Check other components using helper
            local result
            result=$(_get_pod_status "$gpu_op_pods" "$node_name" "container-toolkit")
            toolkit_color="${result%%|*}"; toolkit_val="${result#*|}"
            
            result=$(_get_pod_status "$gpu_op_pods" "$node_name" "device-plugin")
            plugin_color="${result%%|*}"; plugin_val="${result#*|}"
            
            result=$(_get_pod_status "$gpu_op_pods" "$node_name" "feature-discovery")
            gfd_color="${result%%|*}"; gfd_val="${result#*|}"
            
            result=$(_get_pod_status "$gpu_op_pods" "$node_name" "dcgm")
            dcgm_color="${result%%|*}"; dcgm_val="${result#*|}"
            
            result=$(_get_pod_status "$gpu_op_pods" "$node_name" "validator")
            validator_color="${result%%|*}"; validator_val="${result#*|}"
            
            result=$(_get_pod_status "$gpu_op_pods" "$node_name" "mig-manager" "optional")
            mig_color="${result%%|*}"; mig_val="${result#*|}"
        fi
        
        # Check DRA kubelet-plugin (per-node daemonset)
        local dra_color="GRAY" dra_val="-"
        
        if [[ "$dra_ns_exists" == "true" ]]; then
            local node_dra_pod
            node_dra_pod=$(echo "$dra_pods" | grep "^${node_name}|.*kubelet-plugin" | head -1)
            
            if [[ -n "$node_dra_pod" ]]; then
                local dra_phase dra_ready_status dra_ready_num dra_total_num
                dra_phase=$(echo "$node_dra_pod" | cut -d'|' -f3)
                dra_ready_status=$(echo "$node_dra_pod" | cut -d'|' -f4)
                dra_ready_num=$(echo "$dra_ready_status" | cut -d'/' -f1)
                dra_total_num=$(echo "$dra_ready_status" | cut -d'/' -f2)
                
                if [[ "$dra_phase" == "Running" && "$dra_ready_num" == "$dra_total_num" && "$dra_total_num" != "0" ]]; then
                    dra_color="GREEN"; dra_val="$dra_ready_status"
                elif [[ "$dra_phase" == "Running" ]]; then
                    dra_color="YELLOW"; dra_val="$dra_ready_status"
                else
                    dra_color="YELLOW"; dra_val="${dra_phase:0:4}"
                fi
            else
                dra_color="RED"; dra_val="-"
            fi
        fi
        
        # Check if node is healthy (all required components running for GPU node)
        local node_healthy=true
        if [[ "$gpu_op_ns_exists" == "true" ]]; then
            # Driver: either has green status or using host drivers is acceptable
            [[ "$driver_color" != "GREEN" && "$driver_val" != "host" ]] && node_healthy=false
            [[ "$toolkit_color" != "GREEN" ]] && node_healthy=false
            [[ "$plugin_color" != "GREEN" ]] && node_healthy=false
        fi
        [[ "$node_healthy" == "true" ]] && ((healthy_nodes++))
        
        # Convert color names to actual codes
        local dc tc pc gc dcc vc mc drac
        case "$driver_color" in GREEN) dc="$GREEN";; YELLOW) dc="$YELLOW";; RED) dc="$RED";; *) dc="$GRAY";; esac
        case "$toolkit_color" in GREEN) tc="$GREEN";; YELLOW) tc="$YELLOW";; RED) tc="$RED";; *) tc="$GRAY";; esac
        case "$plugin_color" in GREEN) pc="$GREEN";; YELLOW) pc="$YELLOW";; RED) pc="$RED";; *) pc="$GRAY";; esac
        case "$gfd_color" in GREEN) gc="$GREEN";; YELLOW) gc="$YELLOW";; RED) gc="$RED";; *) gc="$GRAY";; esac
        case "$dcgm_color" in GREEN) dcc="$GREEN";; YELLOW) dcc="$YELLOW";; RED) dcc="$RED";; *) dcc="$GRAY";; esac
        case "$validator_color" in GREEN) vc="$GREEN";; YELLOW) vc="$YELLOW";; RED) vc="$RED";; *) vc="$GRAY";; esac
        case "$mig_color" in GREEN) mc="$GREEN";; YELLOW) mc="$YELLOW";; RED) mc="$RED";; *) mc="$GRAY";; esac
        case "$dra_color" in GREEN) drac="$GREEN";; YELLOW) drac="$YELLOW";; RED) drac="$RED";; *) drac="$GRAY";; esac
        
        # Print row with proper alignment
        printf "${YELLOW}%-3s${NC} %-28s ${gpu_color}%-5s${NC} ${ready_color}%-6s${NC} %-20s ${dc}%-7s${NC} ${tc}%-7s${NC} ${pc}%-7s${NC} ${gc}%-5s${NC} ${dcc}%-5s${NC} ${vc}%-9s${NC} ${mc}%-8s${NC} ${drac}%-8s${NC} ${taints_color}%-80s${NC}\n" \
            "$node_idx" "$node_trunc" "$gpu_count" "$ready" "$product_trunc" "$driver_val" "$toolkit_val" "$plugin_val" "$gfd_val" "$dcgm_val" "$validator_val" "$mig_val" "$dra_val" "$taints_display"
            
    done <<< "$node_data"
    
    if [[ $gpu_nodes -eq 0 ]]; then
        echo -e "  ${YELLOW}No GPU nodes found in the cluster${NC}"
    fi
    
    echo ""
    print_separator 245
    
    # Summary
    echo ""
    echo -e "${BOLD}${WHITE}═══ Summary ═══${NC}"
    echo ""
    echo -e "  ${WHITE}Total Nodes:${NC}   $total_nodes"
    echo -e "  ${WHITE}GPU Nodes:${NC}     $gpu_nodes"
    if [[ $gpu_nodes -gt 0 ]]; then
        if [[ $healthy_nodes -eq $gpu_nodes ]]; then
            echo -e "  ${WHITE}Healthy:${NC}       ${GREEN}$healthy_nodes / $gpu_nodes${NC} ${GREEN}✓ All GPU nodes healthy${NC}"
        else
            echo -e "  ${WHITE}Healthy:${NC}       ${YELLOW}$healthy_nodes / $gpu_nodes${NC} ${RED}⚠ Some nodes have issues${NC}"
        fi
    fi
    echo ""
    
    # Legend
    echo -e "${BOLD}${WHITE}Legend:${NC}"
    echo -e "  ${GREEN}run${NC}, ${GREEN}done${NC} = Healthy    ${YELLOW}0/1${NC}, ${YELLOW}1/2${NC} = Not all containers Ready    ${RED}-${NC} = Missing    ${GRAY}-${NC} = N/A or Optional"
    echo ""
    echo -e "${BOLD}${WHITE}Status Values:${NC}"
    echo -e "  ${GREEN}run${NC}  = Pod Running with all containers Ready"
    echo -e "  ${GREEN}done${NC} = Pod Succeeded (completed successfully, e.g., validator)"
    echo -e "  ${YELLOW}N/N${NC}  = Pod Running but not all containers Ready (e.g., 0/1, 1/2)"
    echo -e "  ${YELLOW}Pend${NC} = Pod in Pending state"
    echo -e "  ${GRAY}host${NC} = Using pre-installed host drivers (driver.enabled: false)"
    echo -e "  ${RED}-${NC}    = Required component missing"
    echo -e "  ${GRAY}-${NC}    = Optional component not deployed (e.g., mig-mgr)"
    echo ""
    echo -e "${BOLD}${WHITE}Common Taints:${NC}"
    echo -e "  ${YELLOW}newNode${NC} = oci.oraclecloud.com/oke-new-node:NoSchedule (node initializing)"
    echo -e "  ${YELLOW}gpu:NoSch${NC} = nvidia.com/gpu:NoSchedule (GPU dedicated)"
    echo -e "  ${YELLOW}unschedulable${NC} = node.kubernetes.io/unschedulable:NoSchedule (cordoned)"
    echo ""
    
    # Interactive menu
    while true; do
        echo -e "${BOLD}${WHITE}─── Actions ───${NC}"
        echo -e "  Enter ${YELLOW}#${NC} (e.g., 1) to view detailed pod status for a node"
        echo -e "  Enter ${CYAN}pods${NC} to list all GPU-related pods"
        echo -e "  Enter ${CYAN}dra${NC} to list DRA kubelet-plugin pods with READY status"
        echo -e "  Enter ${CYAN}events${NC} to show recent events from GPU namespaces"
        echo -e "  Enter ${MAGENTA}r${NC} to refresh the status"
        echo -e "  Enter ${CYAN}b${NC} to go back"
        echo ""
        echo -n -e "${BOLD}${CYAN}[GPU Stack Health] Selection: ${NC}"
        read -r selection
        
        case "$selection" in
            [0-9]*)
                local selected_node="${NODE_INDEX_MAP[$selection]:-}"
                if [[ -z "$selected_node" ]]; then
                    echo -e "${RED}Invalid node number: $selection${NC}"
                    continue
                fi
                
                echo ""
                echo -e "${BOLD}${CYAN}═══ Pod Details for Node: ${WHITE}${selected_node}${NC} ${BOLD}${CYAN}═══${NC}"
                echo ""
                
                # Show node taints
                echo -e "${BOLD}${WHITE}Node Taints:${NC}"
                kubectl get node "$selected_node" -o json 2>/dev/null | jq -r '
                    .spec.taints // [] | if length == 0 then "  (none)" else .[] | "  \(.key)=\(.value // ""):\(.effect)" end
                ' 2>/dev/null || echo -e "${GRAY}  Unable to fetch taints${NC}"
                echo ""
                
                echo -e "${BOLD}${WHITE}GPU Operator Pods (gpu-operator namespace):${NC}"
                kubectl get pods -n gpu-operator -o wide --field-selector spec.nodeName="$selected_node" 2>/dev/null || echo -e "${GRAY}  No pods found${NC}"
                echo ""
                
                echo -e "${BOLD}${WHITE}DRA Pods (nvidia-dra-driver-gpu namespace):${NC}"
                kubectl get pods -n nvidia-dra-driver-gpu -o wide --field-selector spec.nodeName="$selected_node" 2>/dev/null || echo -e "${GRAY}  No pods found${NC}"
                echo ""
                
                # Show node labels related to NVIDIA
                echo -e "${BOLD}${WHITE}NVIDIA Node Labels:${NC}"
                kubectl get node "$selected_node" -o json 2>/dev/null | jq -r '
                    .metadata.labels | to_entries[] | 
                    select(.key | startswith("nvidia.com") or startswith("feature.node.kubernetes.io/pci-10de")) |
                    "  \(.key) = \(.value)"
                ' 2>/dev/null || echo -e "${GRAY}  No NVIDIA labels found${NC}"
                echo ""
                ;;
            pods|PODS)
                echo ""
                echo -e "${BOLD}${WHITE}═══ All GPU Operator Pods ═══${NC}"
                kubectl get pods -n gpu-operator -o wide 2>/dev/null || echo -e "${GRAY}Namespace not found${NC}"
                echo ""
                echo -e "${BOLD}${WHITE}═══ All DRA Pods ═══${NC}"
                kubectl get pods -n nvidia-dra-driver-gpu -o wide 2>/dev/null || echo -e "${GRAY}Namespace not found${NC}"
                echo ""
                ;;
            dra|DRA)
                echo ""
                echo -e "${BOLD}${WHITE}═══ DRA Kubelet Plugin Pods (*kubelet-plugin*) ═══${NC}"
                echo ""
                # Show kubelet-plugin pods with their ready status
                kubectl get pods -n nvidia-dra-driver-gpu -o wide 2>/dev/null | grep -E "NAME|kubelet-plugin" || echo -e "${GRAY}No kubelet-plugin pods found${NC}"
                echo ""
                # Also show summary
                local total_plugin_pods ready_plugin_pods
                total_plugin_pods=$(kubectl get pods -n nvidia-dra-driver-gpu --no-headers 2>/dev/null | grep -c "kubelet-plugin" 2>/dev/null || true)
                total_plugin_pods=${total_plugin_pods:-0}
                total_plugin_pods=$(echo "$total_plugin_pods" | tr -d '[:space:]')
                [[ -z "$total_plugin_pods" ]] && total_plugin_pods=0
                ready_plugin_pods=$(kubectl get pods -n nvidia-dra-driver-gpu --no-headers 2>/dev/null | grep "kubelet-plugin" | awk '$2 ~ /^[0-9]+\/[0-9]+$/ {split($2,a,"/"); if(a[1]==a[2] && $3=="Running") count++} END {print count+0}')
                echo -e "${WHITE}Summary: ${CYAN}${ready_plugin_pods}${NC}/${CYAN}${total_plugin_pods}${NC} kubelet-plugin pods fully ready${NC}"
                echo ""
                ;;
            events|EVENTS)
                echo ""
                echo -e "${BOLD}${WHITE}═══ Recent Events (gpu-operator) ═══${NC}"
                kubectl get events -n gpu-operator --sort-by='.lastTimestamp' 2>/dev/null | tail -20 || echo -e "${GRAY}No events${NC}"
                echo ""
                echo -e "${BOLD}${WHITE}═══ Recent Events (nvidia-dra-driver-gpu) ═══${NC}"
                kubectl get events -n nvidia-dra-driver-gpu --sort-by='.lastTimestamp' 2>/dev/null | tail -20 || echo -e "${GRAY}No events${NC}"
                echo ""
                ;;
            r|R|refresh|REFRESH)
                manage_nvidia_gpu_stack_health
                return
                ;;
            b|B|back|BACK|"")
                return
                ;;
            *)
                echo -e "${RED}Unknown command${NC}"
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# Create GPU Tagging Namespace and Tag
#--------------------------------------------------------------------------------
create_gpu_tagging_namespace() {
    local tenancy_ocid="$1"
    local home_region="$2"
    
    echo ""
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${GREEN}                                  CREATE TAG NAMESPACE AND TAG                                                    ${NC}"
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Use global DEBUG_MODE
    local debug_flag=""
    if [[ "$DEBUG_MODE" == "true" ]]; then
        debug_flag="--debug"
    fi
    
    # Step 1: Check if namespace already exists
    echo -e "${YELLOW}Step 1: Checking if namespace already exists...${NC}"
    echo ""
    
    local check_cmd="oci iam tag-namespace list --compartment-id \"$tenancy_ocid\" --all --query \"data[?name=='${GPU_TAG_NAMESPACE}']\" --output json"
    echo -e "${GRAY}$check_cmd${NC}"
    echo ""
    
    local existing_ns
    existing_ns=$(oci iam tag-namespace list \
        --compartment-id "$tenancy_ocid" \
        --all \
        --query "data[?name=='${GPU_TAG_NAMESPACE}']" \
        --output json 2>/dev/null)
    
    local namespace_ocid
    namespace_ocid=$(echo "$existing_ns" | jq -r '.[0].id // empty' 2>/dev/null)
    
    if [[ -n "$namespace_ocid" ]]; then
        local ns_state
        ns_state=$(echo "$existing_ns" | jq -r '.[0]["lifecycle-state"] // "UNKNOWN"' 2>/dev/null)
        
        echo -e "${YELLOW}⚠ Namespace '${GPU_TAG_NAMESPACE}' already exists${NC}"
        echo -e "  ${CYAN}OCID:${NC}  ${YELLOW}${namespace_ocid}${NC}"
        echo -e "  ${CYAN}State:${NC} ${WHITE}${ns_state}${NC}"
        echo ""
        
        if [[ "$ns_state" == "ACTIVE" ]]; then
            echo -e "${WHITE}Checking if tag '${GPU_TAG_NAME}' exists...${NC}"
            echo ""
            
            local existing_tag
            existing_tag=$(oci iam tag list \
                --tag-namespace-id "$namespace_ocid" \
                --all \
                --query "data[?name=='${GPU_TAG_NAME}']" \
                --output json 2>/dev/null)
            
            local tag_ocid
            tag_ocid=$(echo "$existing_tag" | jq -r '.[0].id // empty' 2>/dev/null)
            
            if [[ -n "$tag_ocid" ]]; then
                echo -e "${GREEN}✓ Tag '${GPU_TAG_NAME}' already exists${NC}"
                echo -e "  ${CYAN}OCID:${NC} ${YELLOW}${tag_ocid}${NC}"
                echo ""
                echo -e "${WHITE}No action needed - namespace and tag are already configured.${NC}"
            else
                echo -e "${YELLOW}Tag '${GPU_TAG_NAME}' does not exist. Creating...${NC}"
                echo ""
                _create_gpu_tag "$namespace_ocid" "$home_region" "$debug_flag"
            fi
        else
            echo -e "${RED}Namespace is in state '${ns_state}' - cannot create tag${NC}"
        fi
        
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo -e "${GREEN}✓ Namespace does not exist. Proceeding with creation...${NC}"
    echo ""
    
    # Step 2: Create namespace
    echo -e "${YELLOW}Step 2: Creating tag namespace '${GPU_TAG_NAMESPACE}'...${NC}"
    echo ""
    
    local create_ns_cmd="oci iam tag-namespace create \\
    --compartment-id \"$tenancy_ocid\" \\
    --name \"${GPU_TAG_NAMESPACE}\" \\
    --description \"${GPU_TAG_NAMESPACE_DESCRIPTION}\" \\
    --region \"$home_region\""
    
    echo -e "${BOLD}${YELLOW}Command to execute:${NC}"
    echo -e "${GRAY}$create_ns_cmd${NC}"
    echo ""
    
    echo -n -e "${CYAN}Execute this command? [y/N]: ${NC}"
    local confirm
    read -r confirm
    
    if [[ ! "$confirm" =~ ^[Yy] ]]; then
        echo -e "${YELLOW}Operation cancelled${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo ""
    log_action "CREATE_TAG_NAMESPACE" "$create_ns_cmd"
    
    local ns_result
    ns_result=$(oci iam tag-namespace create \
        --compartment-id "$tenancy_ocid" \
        --name "${GPU_TAG_NAMESPACE}" \
        --description "${GPU_TAG_NAMESPACE_DESCRIPTION}" \
        --region "$home_region" \
        --output json $debug_flag 2>&1)
    local ns_exit=$?
    
    if [[ $ns_exit -eq 0 ]]; then
        namespace_ocid=$(echo "$ns_result" | jq -r '.data.id // empty' 2>/dev/null)
        echo -e "${GREEN}✓ Namespace created successfully${NC}"
        echo -e "  ${CYAN}OCID:${NC} ${YELLOW}${namespace_ocid}${NC}"
        log_action_result "SUCCESS" "Namespace ${GPU_TAG_NAMESPACE} created: ${namespace_ocid}"
        echo ""
        
        # Wait for namespace to be active
        echo -e "${YELLOW}Waiting for namespace to become active...${NC}"
        sleep 5
        
        # Step 3: Create tag
        echo ""
        echo -e "${YELLOW}Step 3: Creating tag '${GPU_TAG_NAME}' in namespace...${NC}"
        echo ""
        
        _create_gpu_tag "$namespace_ocid" "$home_region" "$debug_flag"
    else
        echo -e "${RED}✗ Failed to create namespace${NC}"
        echo -e "${GRAY}Error: $ns_result${NC}"
        log_action_result "FAILED" "Namespace creation failed"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Helper: Create GPU tag in namespace
#--------------------------------------------------------------------------------
_create_gpu_tag() {
    local namespace_ocid="$1"
    local home_region="$2"
    local debug_flag="$3"
    
    # Build validator JSON for enum values
    local values_json
    values_json=$(echo "${GPU_TAG_VALUES}" | tr ',' '\n' | jq -R . | jq -s '.')
    local validator_json="{\"validator-type\": \"ENUM\", \"values\": ${values_json}}"
    
    local create_tag_cmd="oci iam tag create \\
    --tag-namespace-id \"$namespace_ocid\" \\
    --name \"${GPU_TAG_NAME}\" \\
    --description \"${GPU_TAG_NAME_DESCRIPTION}\" \\
    --validator '${validator_json}' \\
    --region \"$home_region\""
    
    echo -e "${BOLD}${YELLOW}Command to execute:${NC}"
    echo -e "${GRAY}$create_tag_cmd${NC}"
    echo ""
    
    echo -n -e "${CYAN}Execute this command? [y/N]: ${NC}"
    local confirm
    read -r confirm
    
    if [[ ! "$confirm" =~ ^[Yy] ]]; then
        echo -e "${YELLOW}Tag creation cancelled${NC}"
        return
    fi
    
    echo ""
    log_action "CREATE_TAG" "$create_tag_cmd"
    
    local tag_result
    tag_result=$(oci iam tag create \
        --tag-namespace-id "$namespace_ocid" \
        --name "${GPU_TAG_NAME}" \
        --description "${GPU_TAG_NAME_DESCRIPTION}" \
        --validator "$validator_json" \
        --region "$home_region" \
        --output json $debug_flag 2>&1)
    local tag_exit=$?
    
    if [[ $tag_exit -eq 0 ]]; then
        local tag_ocid
        tag_ocid=$(echo "$tag_result" | jq -r '.data.id // empty' 2>/dev/null)
        echo -e "${GREEN}✓ Tag created successfully${NC}"
        echo -e "  ${CYAN}OCID:${NC} ${YELLOW}${tag_ocid}${NC}"
        log_action_result "SUCCESS" "Tag ${GPU_TAG_NAME} created: ${tag_ocid}"
    else
        echo -e "${RED}✗ Failed to create tag${NC}"
        echo -e "${GRAY}Error: $tag_result${NC}"
        log_action_result "FAILED" "Tag creation failed"
    fi
}

#--------------------------------------------------------------------------------
# Validate GPU Tagging Namespace and Tag
#--------------------------------------------------------------------------------
validate_gpu_tagging_namespace() {
    local tenancy_ocid="$1"
    local home_region="$2"
    
    echo ""
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${CYAN}                                  VALIDATE TAG NAMESPACE AND TAG                                                  ${NC}"
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    local all_valid=true
    
    # Step 1: Check namespace exists
    echo -e "${YELLOW}Step 1: Checking for namespace '${GPU_TAG_NAMESPACE}'...${NC}"
    echo ""
    
    local check_cmd="oci iam tag-namespace list --compartment-id \"$tenancy_ocid\" --all --query \"data[?name=='${GPU_TAG_NAMESPACE}']\" --output json"
    echo -e "${GRAY}$check_cmd${NC}"
    echo ""
    
    local existing_ns
    existing_ns=$(oci iam tag-namespace list \
        --compartment-id "$tenancy_ocid" \
        --all \
        --query "data[?name=='${GPU_TAG_NAMESPACE}']" \
        --output json 2>/dev/null)
    
    local namespace_ocid ns_state ns_description
    namespace_ocid=$(echo "$existing_ns" | jq -r '.[0].id // empty' 2>/dev/null)
    
    if [[ -z "$namespace_ocid" ]]; then
        echo -e "${RED}✗ Namespace '${GPU_TAG_NAMESPACE}' does NOT exist${NC}"
        all_valid=false
    else
        ns_state=$(echo "$existing_ns" | jq -r '.[0]["lifecycle-state"] // "UNKNOWN"' 2>/dev/null)
        ns_description=$(echo "$existing_ns" | jq -r '.[0].description // "N/A"' 2>/dev/null)
        
        echo -e "${GREEN}✓ Namespace '${GPU_TAG_NAMESPACE}' exists${NC}"
        echo -e "  ${CYAN}OCID:${NC}        ${YELLOW}${namespace_ocid}${NC}"
        echo -e "  ${CYAN}State:${NC}       ${WHITE}${ns_state}${NC}"
        echo -e "  ${CYAN}Description:${NC} ${WHITE}${ns_description}${NC}"
        
        if [[ "$ns_state" != "ACTIVE" ]]; then
            echo -e "${RED}  ⚠ Namespace is not ACTIVE (state: ${ns_state})${NC}"
            all_valid=false
        fi
    fi
    
    echo ""
    
    # Step 2: Check tag exists
    if [[ -n "$namespace_ocid" && "$ns_state" == "ACTIVE" ]]; then
        echo -e "${YELLOW}Step 2: Checking for tag '${GPU_TAG_NAME}' in namespace...${NC}"
        echo ""
        
        # Use 'oci iam tag get' to get full tag details including validator
        local tag_get_cmd="oci iam tag get --tag-namespace-id \"$namespace_ocid\" --tag-name \"${GPU_TAG_NAME}\" --output json"
        echo -e "${GRAY}$tag_get_cmd${NC}"
        echo ""
        
        local tag_info
        tag_info=$(oci iam tag get \
            --tag-namespace-id "$namespace_ocid" \
            --tag-name "${GPU_TAG_NAME}" \
            --output json 2>/dev/null)
        
        # Extract from .data since tag get wraps in data
        local tag_data
        tag_data=$(echo "$tag_info" | jq '.data' 2>/dev/null)
        
        if [[ -z "$tag_data" || "$tag_data" == "null" ]]; then
            echo -e "${RED}✗ Tag '${GPU_TAG_NAME}' does NOT exist in namespace${NC}"
            all_valid=false
        else
            local tag_ocid tag_state tag_description validator_type
            tag_ocid=$(echo "$tag_data" | jq -r '.id // empty')
            tag_state=$(echo "$tag_data" | jq -r '.["lifecycle-state"] // "UNKNOWN"')
            tag_description=$(echo "$tag_data" | jq -r '.description // "N/A"')
            validator_type=$(echo "$tag_data" | jq -r '.validator["validator-type"] // "NONE"')
            
            # Get validator values as array
            local validator_values_array
            validator_values_array=$(echo "$tag_data" | jq -r '.validator.values // []')
            local validator_values_display
            validator_values_display=$(echo "$tag_data" | jq -r '.validator.values // [] | join(", ")')
            
            echo -e "${GREEN}✓ Tag '${GPU_TAG_NAME}' exists${NC}"
            echo -e "  ${CYAN}OCID:${NC}        ${YELLOW}${tag_ocid}${NC}"
            echo -e "  ${CYAN}State:${NC}       ${WHITE}${tag_state}${NC}"
            echo -e "  ${CYAN}Description:${NC} ${WHITE}${tag_description}${NC}"
            echo -e "  ${CYAN}Validator:${NC}   ${WHITE}${validator_type}${NC}"
            if [[ -n "$validator_values_display" ]]; then
                echo -e "  ${CYAN}Values:${NC}      ${WHITE}${validator_values_display}${NC}"
            fi
            
            if [[ "$tag_state" != "ACTIVE" ]]; then
                echo -e "${RED}  ⚠ Tag is not ACTIVE (state: ${tag_state})${NC}"
                all_valid=false
            fi
            
            # Step 3: Validate that expected values exist in validator.values array
            echo ""
            echo -e "${YELLOW}Step 3: Checking validator values for required entries...${NC}"
            echo ""
            
            # Check if validator type is ENUM (required for value checking)
            if [[ "$validator_type" != "ENUM" ]]; then
                echo -e "${RED}  ✗ Validator type is '${validator_type}', expected 'ENUM'${NC}"
                all_valid=false
            else
                echo -e "${GREEN}  ✓ Validator type is 'ENUM'${NC}"
            fi
            
            # Check each expected value exists in the validator.values array
            local expected_values
            IFS=',' read -ra expected_values <<< "${GPU_TAG_VALUES}"
            for val in "${expected_values[@]}"; do
                # Trim whitespace
                val=$(echo "$val" | xargs)
                
                # Check if value exists in JSON array using jq
                local value_exists
                value_exists=$(echo "$tag_data" | jq -r --arg v "$val" '.validator.values // [] | map(select(. == $v)) | length')
                
                if [[ "$value_exists" -gt 0 ]]; then
                    echo -e "${GREEN}  ✓ Required value '${val}' found in validator.values${NC}"
                else
                    echo -e "${RED}  ✗ Required value '${val}' NOT found in validator.values${NC}"
                    echo -e "${GRAY}    Current values: [${validator_values_display}]${NC}"
                    all_valid=false
                fi
            done
            
            # Show raw JSON for debugging
            echo ""
            echo -e "${GRAY}Raw validator JSON:${NC}"
            echo "$tag_data" | jq '.validator' 2>/dev/null | sed 's/^/  /'
        fi
        
        echo ""
        
        # List all tags in namespace (using tag list for overview)
        echo -e "${YELLOW}All tags in namespace:${NC}"
        echo ""
        
        local existing_tags
        existing_tags=$(oci iam tag list \
            --tag-namespace-id "$namespace_ocid" \
            --all \
            --output json 2>/dev/null)
        
        printf "  ${GRAY}%-30s %-12s %s${NC}\n" "Name" "State" "OCID"
        echo "$existing_tags" | jq -r '.data[] | "\(.name)|\(.["lifecycle-state"])|\(.id)"' 2>/dev/null | \
        while IFS='|' read -r t_name t_state t_ocid; do
            local state_color="$GREEN"
            [[ "$t_state" != "ACTIVE" ]] && state_color="$YELLOW"
            printf "  ${WHITE}%-30s${NC} ${state_color}%-12s${NC} ${YELLOW}%s${NC}\n" "$t_name" "$t_state" "$t_ocid"
        done
    else
        echo -e "${YELLOW}Step 2: Skipping tag check (namespace not available)${NC}"
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Validation Summary ═══${NC}"
    echo ""
    if [[ "$all_valid" == "true" ]]; then
        echo -e "${GREEN}✓ All validation checks PASSED${NC}"
        echo -e "${WHITE}  The GPU instance tagging namespace and tag are properly configured.${NC}"
    else
        echo -e "${RED}✗ Some validation checks FAILED${NC}"
        echo -e "${WHITE}  Use option 1 to create the missing namespace/tag.${NC}"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Delete GPU Tagging Namespace
#--------------------------------------------------------------------------------
delete_gpu_tagging_namespace() {
    local tenancy_ocid="$1"
    local home_region="$2"
    
    echo ""
    echo -e "${BOLD}${RED}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${RED}                                      DELETE TAG NAMESPACE                                                        ${NC}"
    echo -e "${BOLD}${RED}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Use global DEBUG_MODE
    local debug_flag=""
    if [[ "$DEBUG_MODE" == "true" ]]; then
        debug_flag="--debug"
    fi
    
    # Step 1: Find namespace
    echo -e "${YELLOW}Step 1: Finding namespace '${GPU_TAG_NAMESPACE}'...${NC}"
    echo ""
    
    local check_cmd="oci iam tag-namespace list --compartment-id \"$tenancy_ocid\" --all --query \"data[?name=='${GPU_TAG_NAMESPACE}']\" --output json"
    echo -e "${GRAY}$check_cmd${NC}"
    echo ""
    
    local existing_ns
    existing_ns=$(oci iam tag-namespace list \
        --compartment-id "$tenancy_ocid" \
        --all \
        --query "data[?name=='${GPU_TAG_NAMESPACE}']" \
        --output json 2>/dev/null)
    
    local namespace_ocid ns_state
    namespace_ocid=$(echo "$existing_ns" | jq -r '.[0].id // empty' 2>/dev/null)
    
    if [[ -z "$namespace_ocid" ]]; then
        echo -e "${YELLOW}Namespace '${GPU_TAG_NAMESPACE}' does not exist. Nothing to delete.${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    ns_state=$(echo "$existing_ns" | jq -r '.[0]["lifecycle-state"] // "UNKNOWN"' 2>/dev/null)
    
    echo -e "${WHITE}Found namespace:${NC}"
    echo -e "  ${CYAN}Name:${NC}  ${WHITE}${GPU_TAG_NAMESPACE}${NC}"
    echo -e "  ${CYAN}OCID:${NC}  ${YELLOW}${namespace_ocid}${NC}"
    echo -e "  ${CYAN}State:${NC} ${WHITE}${ns_state}${NC}"
    echo ""
    
    if [[ "$ns_state" == "DELETED" ]]; then
        echo -e "${YELLOW}Namespace is already in DELETED state${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Warning
    echo -e "${RED}╔════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${RED}║                      ⚠️  WARNING  ⚠️                             ║${NC}"
    echo -e "${RED}╚════════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "${RED}This will:${NC}"
    echo -e "${WHITE}  1. Retire the namespace (mark as inactive)${NC}"
    echo -e "${WHITE}  2. Cascade-delete the namespace and ALL tags within it${NC}"
    echo ""
    echo -e "${RED}This action cannot be undone!${NC}"
    echo ""
    
    echo -n -e "${RED}Type 'DELETE' to confirm: ${NC}"
    local confirm
    read -r confirm
    
    if [[ "$confirm" != "DELETE" ]]; then
        echo -e "${YELLOW}Operation cancelled${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo ""
    
    # Step 2: Retire namespace (required before delete)
    if [[ "$ns_state" == "ACTIVE" ]]; then
        echo -e "${YELLOW}Step 2: Retiring namespace...${NC}"
        echo ""
        
        local retire_cmd="oci iam tag-namespace retire \\
    --tag-namespace-id \"$namespace_ocid\" \\
    --region \"$home_region\""
        
        echo -e "${GRAY}$retire_cmd${NC}"
        echo ""
        
        log_action "RETIRE_TAG_NAMESPACE" "$retire_cmd"
        
        local retire_result
        retire_result=$(oci iam tag-namespace retire \
            --tag-namespace-id "$namespace_ocid" \
            --region "$home_region" \
            $debug_flag 2>&1)
        local retire_exit=$?
        
        if [[ $retire_exit -eq 0 ]]; then
            echo -e "${GREEN}✓ Namespace retired successfully${NC}"
            log_action_result "SUCCESS" "Namespace retired"
        else
            echo -e "${RED}✗ Failed to retire namespace${NC}"
            echo -e "${GRAY}Error: $retire_result${NC}"
            log_action_result "FAILED" "Namespace retire failed"
            echo ""
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
        
        echo ""
        echo -e "${YELLOW}Waiting for retire to complete...${NC}"
        sleep 3
    else
        echo -e "${YELLOW}Step 2: Namespace already retired (state: ${ns_state}), skipping retire...${NC}"
    fi
    
    echo ""
    
    # Step 3: Cascade delete
    echo -e "${YELLOW}Step 3: Cascade-deleting namespace and all tags...${NC}"
    echo ""
    
    local delete_cmd="oci iam tag-namespace cascade-delete \\
    --tag-namespace-id \"$namespace_ocid\" \\
    --region \"$home_region\""
    
    echo -e "${GRAY}$delete_cmd${NC}"
    echo ""
    
    log_action "CASCADE_DELETE_TAG_NAMESPACE" "$delete_cmd"
    
    local delete_result
    delete_result=$(oci iam tag-namespace cascade-delete \
        --tag-namespace-id "$namespace_ocid" \
        --region "$home_region" \
        $debug_flag 2>&1)
    local delete_exit=$?
    
    if [[ $delete_exit -eq 0 ]]; then
        echo -e "${GREEN}✓ Namespace cascade-delete initiated successfully${NC}"
        echo -e "${YELLOW}Note: The delete operation runs asynchronously. It may take a few minutes to complete.${NC}"
        log_action_result "SUCCESS" "Namespace cascade-delete initiated"
    else
        echo -e "${RED}✗ Failed to delete namespace${NC}"
        echo -e "${GRAY}Error: $delete_result${NC}"
        log_action_result "FAILED" "Namespace cascade-delete failed"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Create Instance Configuration interactively
#--------------------------------------------------------------------------------
create_instance_configuration_interactive() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    local ad="${AD:-}"
    local worker_subnet="${WORKER_SUBNET_ID:-}"
    local worker_nsg="${WORKER_SUBNET_NSG_ID:-}"
    local pod_subnet="${POD_SUBNET_ID:-}"
    local pod_nsg="${POD_SUBNET_NSG_ID:-}"
    local image_id="${IMAGE_ID:-}"
    
    echo ""
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${GREEN}                                    CREATE INSTANCE CONFIGURATION                                               ${NC}"
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Validate required variables
    local missing_vars=""
    [[ -z "$compartment_id" ]] && missing_vars+="COMPARTMENT_ID "
    [[ -z "$region" ]] && missing_vars+="REGION "
    [[ -z "$ad" ]] && missing_vars+="AD "
    [[ -z "$worker_subnet" ]] && missing_vars+="WORKER_SUBNET_ID "
    [[ -z "$worker_nsg" ]] && missing_vars+="WORKER_SUBNET_NSG_ID "
    
    if [[ -n "$missing_vars" ]]; then
        echo -e "${RED}Missing required variables in variables.sh:${NC}"
        echo -e "${YELLOW}  $missing_vars${NC}"
        echo ""
        echo -e "${WHITE}Please run ${CYAN}--setup${WHITE} or manually configure variables.sh${NC}"
        echo ""
        echo -e "Press Enter to return..."
        read -r
        return 1
    fi
    
    echo -e "${BOLD}${WHITE}Current Environment:${NC}"
    echo -e "  ${CYAN}Region:${NC}           ${WHITE}${region}${NC}"
    echo -e "  ${CYAN}Compartment:${NC}      ${WHITE}$(resolve_compartment_name "${compartment_id}")${NC} ${GRAY}(${compartment_id})${NC}"
    echo -e "  ${CYAN}Availability Domain:${NC} ${WHITE}${ad}${NC}"
    echo -e "  ${CYAN}Worker Subnet:${NC}    ${YELLOW}...${worker_subnet: -20}${NC}"
    echo -e "  ${CYAN}Worker NSG:${NC}       ${YELLOW}...${worker_nsg: -20}${NC}"
    if [[ -n "$image_id" ]]; then
        echo -e "  ${CYAN}Image ID:${NC}         ${YELLOW}...${image_id: -20}${NC}"
    else
        echo -e "  ${CYAN}Image ID:${NC}         ${GRAY}(will select after shape)${NC}"
    fi
    echo ""
    
    # ========== STEP 1: Cloud-init file selection ==========
    echo -e "${BOLD}${MAGENTA}─── Step 1: Cloud-Init Configuration ───${NC}"
    echo ""
    
    local cloud_init_file="cloud-init.yml"
    local cwd
    cwd=$(pwd)
    
    # Check for cloud-init files in current directory (using associative array to avoid duplicates)
    declare -A found_files_map
    local found_files=()
    
    # First pass: collect all matching files, using basename as key to prevent duplicates
    for f in "$cwd"/*.yml "$cwd"/*.yaml "$cwd"/cloud-init*; do
        [[ -f "$f" ]] || continue
        local bname
        bname=$(basename "$f")
        # Only add if not already in map
        if [[ -z "${found_files_map[$bname]:-}" ]]; then
            found_files_map[$bname]="$f"
            found_files+=("$f")
        fi
    done
    
    if [[ ${#found_files[@]} -gt 0 ]]; then
        echo -e "${WHITE}Found cloud-init files in current directory ($cwd):${NC}"
        local idx=0
        for f in "${found_files[@]}"; do
            ((idx++))
            local fname
            fname=$(basename "$f")
            echo -e "  ${YELLOW}${idx}${NC}) $fname"
        done
        echo ""
    fi
    
    echo -n -e "${CYAN}Enter cloud-init file path [${cloud_init_file}]: ${NC}"
    local input_file
    read -r input_file
    
    # Handle numeric selection
    if [[ "$input_file" =~ ^[0-9]+$ ]] && [[ $input_file -ge 1 ]] && [[ $input_file -le ${#found_files[@]} ]]; then
        cloud_init_file="${found_files[$((input_file-1))]}"
    elif [[ -n "$input_file" ]]; then
        cloud_init_file="$input_file"
    fi
    
    # Validate file exists
    if [[ ! -f "$cloud_init_file" ]]; then
        echo -e "${RED}Error: Cloud-init file not found: ${cloud_init_file}${NC}"
        echo -e "Press Enter to return..."
        read -r
        return 1
    fi
    
    echo ""
    echo -e "${GREEN}✓ Using cloud-init file: ${WHITE}${cloud_init_file}${NC}"
    echo ""
    
    # Show preview of cloud-init
    echo -e "${BOLD}${MAGENTA}─── Cloud-Init Preview (first 30 lines) ───${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    head -30 "$cloud_init_file"
    local total_lines
    total_lines=$(wc -l < "$cloud_init_file")
    if [[ $total_lines -gt 30 ]]; then
        echo -e "${GRAY}... (${total_lines} total lines, showing first 30)${NC}"
    fi
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    
    echo -n -e "${CYAN}Is this the correct cloud-init file? [Y/n]: ${NC}"
    local confirm_ci
    read -r confirm_ci
    if [[ "$confirm_ci" =~ ^[Nn] ]]; then
        echo -e "${YELLOW}Cancelled.${NC}"
        echo -e "Press Enter to return..."
        read -r
        return 0
    fi
    
    # ========== STEP 2: Network Type Selection ==========
    echo ""
    echo -e "${BOLD}${MAGENTA}─── Step 2: Network Type ───${NC}"
    echo ""
    echo -e "  ${GREEN}1${NC}) ${WHITE}flannel${NC}     - OKE Flannel CNI (overlay networking)"
    echo -e "  ${GREEN}2${NC}) ${WHITE}native${NC}      - OCI VCN Native Pod Networking"
    echo ""
    echo -n -e "${CYAN}Select network type [1]: ${NC}"
    local net_choice
    read -r net_choice
    
    local network_type="flannel"
    local max_pods="60"
    case "$net_choice" in
        2|native|NATIVE)
            network_type="native"
            max_pods="60"
            ;;
        *)
            network_type="flannel"
            max_pods="60"
            ;;
    esac
    echo -e "${GREEN}✓ Network type: ${WHITE}${network_type}${NC}"
    
    # Validate pod subnet/NSG when native is selected
    if [[ "$network_type" == "native" ]]; then
        local native_missing=""
        [[ -z "$pod_subnet" ]] && native_missing+="POD_SUBNET_ID "
        [[ -z "$pod_nsg" ]] && native_missing+="POD_SUBNET_NSG_ID "
        
        if [[ -n "$native_missing" ]]; then
            echo ""
            echo -e "${RED}Native pod networking requires additional variables in variables.sh:${NC}"
            echo -e "${YELLOW}  ${native_missing}${NC}"
            echo ""
            echo -e "${WHITE}Please run ${CYAN}--setup${WHITE} or manually add these to variables.sh${NC}"
            echo ""
            echo -e "Press Enter to return..."
            read -r
            return 1
        fi
        
        # Show pod networking details
        local pod_subnet_name pod_nsg_name
        pod_subnet_name=$(oci network subnet get --subnet-id "$pod_subnet" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
        pod_nsg_name=$(oci network nsg get --nsg-id "$pod_nsg" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
        echo -e "  ${CYAN}Pod Subnet:${NC}  ${WHITE}${pod_subnet_name}${NC} ${GRAY}(${YELLOW}...${pod_subnet: -20}${GRAY})${NC}"
        echo -e "  ${CYAN}Pod NSG:${NC}     ${WHITE}${pod_nsg_name}${NC} ${GRAY}(${YELLOW}...${pod_nsg: -20}${GRAY})${NC}"
    fi
    
    # ========== STEP 3: Shape Selection ==========
    echo ""
    echo -e "${BOLD}${MAGENTA}─── Step 3: Instance Shape ───${NC}"
    echo ""
    echo -e "${WHITE}Common GPU shapes:${NC}"
    echo -e "  ${GREEN}1${NC}) BM.GPU.GB200-v3.4  (4x GB200 NVL72)"
    echo -e "  ${GREEN}2${NC}) BM.GPU.H100.8      (8x H100 80GB)"
    echo -e "  ${GREEN}3${NC}) BM.GPU.H200.8      (8x H200 141GB)"
    echo -e "  ${GREEN}4${NC}) BM.GPU.A100-v2.8   (8x A100 80GB)"
    echo -e "  ${GREEN}5${NC}) BM.GPU4.8          (8x A100 40GB)"
    echo -e "${WHITE}Common VM shapes:${NC}"
    echo -e "  ${GREEN}6${NC}) VM.Standard.E5.Flex (AMD EPYC, Flexible)"
    echo -e "${WHITE}Other:${NC}"
    echo -e "  ${GREEN}7${NC}) Custom (enter shape name)"
    echo ""
    
    local shape_name="${SHAPE_NAME:-BM.GPU.H100.8}"
    echo -n -e "${CYAN}Select shape [${shape_name}]: ${NC}"
    local shape_choice
    read -r shape_choice
    
    case "$shape_choice" in
        1) shape_name="BM.GPU.GB200-v3.4" ;;
        2) shape_name="BM.GPU.H100.8" ;;
        3) shape_name="BM.GPU.H200.8" ;;
        4) shape_name="BM.GPU.A100-v2.8" ;;
        5) shape_name="BM.GPU4.8" ;;
        6) shape_name="VM.Standard.E5.Flex" ;;
        7)
            echo -n -e "${CYAN}Enter custom shape name: ${NC}"
            read -r shape_name
            ;;
        "") ;; # Keep default
        *)
            # If they typed a shape name directly
            if [[ "$shape_choice" =~ ^(BM\.|VM\.) ]]; then
                shape_name="$shape_choice"
            fi
            ;;
    esac
    echo -e "${GREEN}✓ Shape: ${WHITE}${shape_name}${NC}"
    
    # Flex shape config - detect and prompt for OCPUs and Memory
    local flex_ocpus=""
    local flex_memory_gb=""
    local is_flex_shape=false
    
    if [[ "$shape_name" == *".Flex"* || "$shape_name" == *".Flex" ]]; then
        is_flex_shape=true
        echo ""
        echo -e "${BOLD}${MAGENTA}─── Step 3a: Flex Shape Configuration ───${NC}"
        echo ""
        echo -e "${WHITE}Flex shapes require OCPU and Memory configuration.${NC}"
        echo ""
        
        # OCPUs
        echo -n -e "${CYAN}Number of OCPUs [2]: ${NC}"
        local ocpu_input
        read -r ocpu_input
        flex_ocpus="${ocpu_input:-2}"
        if ! [[ "$flex_ocpus" =~ ^[0-9]+$ ]] || [[ "$flex_ocpus" -lt 1 ]]; then
            echo -e "${YELLOW}Invalid value, using default: 2${NC}"
            flex_ocpus="2"
        fi
        echo -e "${GREEN}✓ OCPUs: ${WHITE}${flex_ocpus}${NC}"
        
        # Memory - default is 16x OCPUs for E5.Flex (max ratio)
        local default_memory=$((flex_ocpus * 16))
        echo -e "${GRAY}  Memory range: 1 GB to ${flex_ocpus} x 64 GB (max $((flex_ocpus * 64)) GB)${NC}"
        echo -n -e "${CYAN}Memory in GB [${default_memory}]: ${NC}"
        local mem_input
        read -r mem_input
        flex_memory_gb="${mem_input:-$default_memory}"
        if ! [[ "$flex_memory_gb" =~ ^[0-9]+$ ]] || [[ "$flex_memory_gb" -lt 1 ]]; then
            echo -e "${YELLOW}Invalid value, using default: ${default_memory}${NC}"
            flex_memory_gb="$default_memory"
        fi
        echo -e "${GREEN}✓ Memory: ${WHITE}${flex_memory_gb} GB${NC}"
    fi
    
    # ========== STEP 3b: Image Selection ==========
    echo ""
    echo -e "${BOLD}${MAGENTA}─── Step 3b: Image Selection ───${NC}"
    echo ""
    
    echo -e "${YELLOW}Fetching compatible images for ${WHITE}${shape_name}${YELLOW}...${NC}"
    
    # Single query: fetch ALL images compatible with this shape (both platform and custom)
    local all_compat_images
    all_compat_images=$(oci compute image list \
        --compartment-id "$compartment_id" \
        --shape "$shape_name" \
        --lifecycle-state "AVAILABLE" \
        --sort-by "TIMECREATED" \
        --sort-order "DESC" \
        --all \
        --output json 2>/dev/null)
    
    # Split into platform images vs custom images based on compartment-id
    local images_json custom_only_json
    if [[ -n "$all_compat_images" ]] && echo "$all_compat_images" | jq -e '.data' > /dev/null 2>&1; then
        # Platform images: compartment-id does NOT match user's compartment (Oracle-owned)
        images_json=$(echo "$all_compat_images" | jq --arg cid "$compartment_id" \
            '{ data: [.data[] | select(.["compartment-id"] != $cid)] }' 2>/dev/null)
        # Custom images: compartment-id matches user's compartment
        custom_only_json=$(echo "$all_compat_images" | jq --arg cid "$compartment_id" \
            '{ data: [.data[] | select(.["compartment-id"] == $cid)] }' 2>/dev/null)
    else
        images_json='{"data":[]}'
        custom_only_json='{"data":[]}'
    fi
    
    local images_count=0
    [[ -n "$images_json" ]] && images_count=$(echo "$images_json" | jq -r '.data | length' 2>/dev/null) || images_count=0
    [[ ! "$images_count" =~ ^[0-9]+$ ]] && images_count=0
    
    local custom_count=0
    [[ -n "$custom_only_json" ]] && custom_count=$(echo "$custom_only_json" | jq -r '.data | length' 2>/dev/null) || custom_count=0
    [[ ! "$custom_count" =~ ^[0-9]+$ ]] && custom_count=0
    
    # Resolve default IMAGE_ID name if set
    local default_image_name=""
    if [[ -n "$image_id" ]]; then
        default_image_name=$(oci compute image get --image-id "$image_id" --query 'data."display-name"' --raw-output 2>/dev/null || echo "")
    fi
    
    if [[ $images_count -eq 0 && $custom_count -eq 0 ]]; then
        if [[ -z "$image_id" ]]; then
            echo -e "${RED}No compatible images found and no IMAGE_ID in variables.sh${NC}"
            echo -e "${WHITE}Please set IMAGE_ID in variables.sh or choose a different shape.${NC}"
            echo ""
            echo -e "Press Enter to return..."
            read -r
            return 1
        fi
        echo -e "${YELLOW}No compatible images found for ${WHITE}${shape_name}${NC}"
        echo -e "${WHITE}Using IMAGE_ID from variables.sh: ${CYAN}${default_image_name:-Unknown}${NC}"
        echo -e "  ${GRAY}OCID: ${YELLOW}...${image_id: -30}${NC}"
        echo ""
        echo -n -e "${CYAN}Continue with this image? [Y/n]: ${NC}"
        local img_confirm
        read -r img_confirm
        if [[ "$img_confirm" =~ ^[Nn] ]]; then
            echo -e "${YELLOW}Cancelled.${NC}"
            echo -e "Press Enter to return..."
            read -r
            return 1
        fi
    else
        echo ""
        echo -e "${WHITE}Compatible images for ${CYAN}${shape_name}${WHITE}:${NC}"
        echo ""
        
        # Build array of images
        declare -a IMAGE_LIST=()
        local img_idx=0
        
        printf "  ${GRAY}%-4s %-105s %-20s${NC}\n" "#" "Image Name" "OS Version"
        echo -e "  ${GRAY}$(printf '─%.0s' {1..135})${NC}"
        
        # Platform images
        if [[ $images_count -gt 0 ]]; then
            while IFS='|' read -r img_ocid img_name img_os img_os_ver; do
                [[ -z "$img_ocid" ]] && continue
                ((img_idx++))
                IMAGE_LIST+=("$img_ocid")
                
                printf "  ${YELLOW}%-4s${NC} ${WHITE}%-105s${NC} ${CYAN}%-20s${NC}\n" "${img_idx})" "$img_name" "$img_os_ver"
            done < <(echo "$images_json" | jq -r '.data[] | "\(.id)|\(.["display-name"] // "N/A")|\(.["operating-system"] // "N/A")|\(.["operating-system-version"] // "N/A")"' 2>/dev/null)
        fi
        
        # Custom images section
        if [[ $custom_count -gt 0 ]]; then
            echo ""
            echo -e "  ${MAGENTA}── Custom Images (${custom_count} compatible with ${shape_name}) ──${NC}"
            while IFS='|' read -r img_ocid img_name img_os img_os_ver; do
                [[ -z "$img_ocid" ]] && continue
                ((img_idx++))
                IMAGE_LIST+=("$img_ocid")
                
                printf "  ${YELLOW}%-4s${NC} ${MAGENTA}%-105s${NC} ${CYAN}%-20s${NC}\n" "${img_idx})" "$img_name" "$img_os_ver"
            done < <(echo "$custom_only_json" | jq -r '.data[] | "\(.id)|\(.["display-name"] // "N/A")|\(.["operating-system"] // "N/A")|\(.["operating-system-version"] // "N/A")"' 2>/dev/null)
        fi
        
        echo ""
        if [[ -n "$image_id" ]]; then
            echo -e "  ${GREEN}0${NC}) Use IMAGE_ID from variables.sh: ${CYAN}${default_image_name:-Unknown}${NC} ${GRAY}(${YELLOW}...${image_id: -25}${GRAY})${NC} ${WHITE}(default)${NC}"
            echo ""
            echo -n -e "${CYAN}Select image [0]: ${NC}"
        else
            echo -n -e "${CYAN}Select image [1]: ${NC}"
        fi
        local img_choice
        read -r img_choice
        
        # Default based on whether IMAGE_ID exists
        if [[ -z "$img_choice" ]]; then
            if [[ -n "$image_id" ]]; then
                img_choice="0"
            else
                img_choice="1"
            fi
        fi
        
        if [[ "$img_choice" == "0" ]] && [[ -n "$image_id" ]]; then
            echo -e "${GREEN}✓ Using IMAGE_ID from variables.sh: ${CYAN}${default_image_name:-...${image_id: -30}}${NC}"
        elif [[ "$img_choice" =~ ^[0-9]+$ ]] && [[ $img_choice -ge 1 ]] && [[ $img_choice -le ${#IMAGE_LIST[@]} ]]; then
            image_id="${IMAGE_LIST[$((img_choice-1))]}"
            local selected_img_name
            selected_img_name=$(oci compute image get --image-id "$image_id" --query 'data."display-name"' --raw-output 2>/dev/null || echo "...${image_id: -30}")
            echo -e "${GREEN}✓ Selected image: ${CYAN}${selected_img_name}${NC}"
        else
            echo -e "${RED}Invalid selection${NC}"
            if [[ -n "$image_id" ]]; then
                echo -e "${YELLOW}Using IMAGE_ID from variables.sh${NC}"
            else
                echo -e "${RED}No valid image selected. Aborting.${NC}"
                echo -e "Press Enter to return..."
                read -r
                return 1
            fi
        fi
    fi
    echo ""
    
    # ========== STEP 4: Boot Volume Configuration ==========
    echo ""
    echo -e "${BOLD}${MAGENTA}─── Step 4: Boot Volume Configuration ───${NC}"
    echo ""
    
    local boot_volume_size="512"
    echo -n -e "${CYAN}Boot volume size in GB [${boot_volume_size}]: ${NC}"
    local bv_size_input
    read -r bv_size_input
    [[ -n "$bv_size_input" ]] && boot_volume_size="$bv_size_input"
    echo -e "${GREEN}✓ Boot volume size: ${WHITE}${boot_volume_size} GB${NC}"
    
    local boot_volume_vpus="20"
    echo ""
    echo -e "${WHITE}VPUs per GB (performance):${NC}"
    echo -e "  ${GRAY}10 = Balanced, 20 = Higher Performance, 30+ = Ultra High Performance${NC}"
    echo -n -e "${CYAN}Boot volume VPUs per GB [${boot_volume_vpus}]: ${NC}"
    local bv_vpus_input
    read -r bv_vpus_input
    [[ -n "$bv_vpus_input" ]] && boot_volume_vpus="$bv_vpus_input"
    echo -e "${GREEN}✓ Boot volume VPUs/GB: ${WHITE}${boot_volume_vpus}${NC}"
    
    # ========== STEP 5: Max Pods Configuration ==========
    echo ""
    echo -e "${BOLD}${MAGENTA}─── Step 5: OKE Max Pods ───${NC}"
    echo ""
    echo -n -e "${CYAN}Max pods per node [${max_pods}]: ${NC}"
    local max_pods_input
    read -r max_pods_input
    [[ -n "$max_pods_input" ]] && max_pods="$max_pods_input"
    echo -e "${GREEN}✓ Max pods: ${WHITE}${max_pods}${NC}"
    
    # ========== STEP 6: Generate Display Name ==========
    echo ""
    echo -e "${BOLD}${MAGENTA}─── Step 6: Display Name ───${NC}"
    echo ""
    
    # Get OKE cluster version for naming
    local oke_version="unknown"
    
    # Method 1: Try to get from OKE environment cache
    if [[ -f "$OKE_ENV_CACHE" ]]; then
        oke_version=$(get_oke_env_value "CLUSTER_VERSION" 2>/dev/null)
        # Clean up version - remove 'v' prefix and keep major.minor
        if [[ -n "$oke_version" && "$oke_version" != "N/A" && "$oke_version" != "null" ]]; then
            oke_version=$(echo "$oke_version" | sed 's/^v//' | cut -d'.' -f1,2)
        else
            oke_version=""
        fi
    fi
    
    # Method 2: If not found, try to get cluster ID from cache and fetch directly
    if [[ -z "$oke_version" || "$oke_version" == "unknown" ]]; then
        local cached_cluster_id
        cached_cluster_id=$(get_oke_env_value "OKE_CLUSTER_ID" 2>/dev/null)
        if [[ -n "$cached_cluster_id" && "$cached_cluster_id" != "N/A" ]]; then
            local fetched_version
            fetched_version=$(oci ce cluster get --cluster-id "$cached_cluster_id" --query 'data["kubernetes-version"]' --raw-output 2>/dev/null)
            if [[ -n "$fetched_version" && "$fetched_version" != "null" ]]; then
                oke_version=$(echo "$fetched_version" | sed 's/^v//' | cut -d'.' -f1,2)
            fi
        fi
    fi
    
    # Method 3: Try kubectl to get server version
    if [[ -z "$oke_version" || "$oke_version" == "unknown" ]]; then
        local kubectl_version
        kubectl_version=$(kubectl version --short 2>/dev/null | grep "Server" | grep -oP 'v\K[0-9]+\.[0-9]+' | head -1)
        [[ -n "$kubectl_version" ]] && oke_version="$kubectl_version"
    fi
    
    # Final fallback
    [[ -z "$oke_version" || "$oke_version" == "null" ]] && oke_version="unknown"
    
    # Count existing instance configs with similar naming pattern to auto-increment
    # New format: ic-<shape>-oke-<version>-<networking>-#
    local base_name="ic-${shape_name}-oke-${oke_version}-${network_type}"
    local next_num=1
    
    # Find the highest existing number for this base pattern
    if [[ -f "$INSTANCE_CONFIG_CACHE" ]]; then
        local highest=0
        while IFS='|' read -r _ ic_existing_name _; do
            # Match pattern: ic-<shape>-oke-<version>-<networking>-<N>
            if [[ "$ic_existing_name" =~ ^${base_name}-([0-9]+)$ ]]; then
                local found_num="${BASH_REMATCH[1]}"
                (( found_num > highest )) && highest=$found_num
            fi
        done < <(grep -v '^#' "$INSTANCE_CONFIG_CACHE" 2>/dev/null)
        next_num=$((highest + 1))
    fi
    
    # Also check via live OCI API in case cache is stale
    local live_ics
    live_ics=$(oci compute-management instance-configuration list \
        --compartment-id "$compartment_id" \
        --all --output json 2>/dev/null)
    
    if [[ -n "$live_ics" ]] && echo "$live_ics" | jq -e '.data[0]' &>/dev/null; then
        while read -r ic_existing_name; do
            [[ -z "$ic_existing_name" ]] && continue
            if [[ "$ic_existing_name" =~ ^${base_name}-([0-9]+)$ ]]; then
                local found_num="${BASH_REMATCH[1]}"
                (( found_num >= next_num )) && next_num=$((found_num + 1))
            fi
        done < <(echo "$live_ics" | jq -r '.data[]["display-name"] // empty' 2>/dev/null)
    fi
    
    local display_name="${base_name}-${next_num}"
    
    echo -e "${WHITE}Auto-generated display name: ${CYAN}${display_name}${NC}"
    echo -n -e "${CYAN}Accept or enter custom name [${display_name}]: ${NC}"
    local name_input
    read -r name_input
    [[ -n "$name_input" ]] && display_name="$name_input"
    echo -e "${GREEN}✓ Display name: ${WHITE}${display_name}${NC}"
    
    # ========== STEP 7: Compare with Existing Configs ==========
    echo ""
    echo -e "${BOLD}${MAGENTA}─── Existing Instance Configurations ───${NC}"
    echo ""
    
    # Refresh instance configs
    fetch_instance_configurations > /dev/null 2>&1
    
    if [[ -f "$INSTANCE_CONFIG_CACHE" ]]; then
        local ic_count=0
        printf "${BOLD}%-4s %-60s %s${NC}\n" "#" "Name" "OCID"
        print_separator 120
        while IFS='|' read -r ic_ocid ic_name _; do
            [[ "$ic_ocid" =~ ^#.*$ ]] && continue
            [[ -z "$ic_ocid" ]] && continue
            ((ic_count++))
            printf "${YELLOW}%-4s${NC} ${WHITE}%-60s${NC} ${GRAY}...%s${NC}\n" \
                "$ic_count" "${ic_name:0:60}" "${ic_ocid: -20}"
        done < <(grep -v '^#' "$INSTANCE_CONFIG_CACHE" 2>/dev/null)
        
        if [[ $ic_count -eq 0 ]]; then
            echo -e "  ${GRAY}(No existing instance configurations found)${NC}"
        fi
    else
        echo -e "  ${GRAY}(No existing instance configurations found)${NC}"
    fi
    echo ""
    
    echo -n -e "${CYAN}Compare with existing config? Enter number or press Enter to continue: ${NC}"
    local compare_choice
    read -r compare_choice
    
    if [[ -n "$compare_choice" && "$compare_choice" =~ ^[0-9]+$ ]]; then
        local compare_idx=0
        local compare_ocid=""
        while IFS='|' read -r ic_ocid ic_name _; do
            [[ "$ic_ocid" =~ ^#.*$ ]] && continue
            [[ -z "$ic_ocid" ]] && continue
            ((compare_idx++))
            if [[ $compare_idx -eq $compare_choice ]]; then
                compare_ocid="$ic_ocid"
                break
            fi
        done < <(grep -v '^#' "$INSTANCE_CONFIG_CACHE" 2>/dev/null)
        
        if [[ -n "$compare_ocid" ]]; then
            echo ""
            echo -e "${BOLD}${CYAN}─── Comparing with: ${ic_name} ───${NC}"
            echo ""
            echo -e "${YELLOW}Fetching full configuration details...${NC}"
            
            # Get FULL instance configuration JSON for existing config
            local existing_json
            existing_json=$(oci compute-management instance-configuration get \
                --instance-configuration-id "$compare_ocid" \
                --output json 2>/dev/null)
            
            if [[ -z "$existing_json" ]]; then
                echo -e "${RED}Failed to fetch configuration details${NC}"
                echo -e "Press Enter to continue..."
                read -r
            else
                # Extract launch-details for comparison
                local existing_launch
                existing_launch=$(echo "$existing_json" | jq '.data["instance-details"]["launch-details"]')
                
                echo ""
                echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
                echo -e "${BOLD}${MAGENTA}                                    CONFIGURATION COMPARISON                                                   ${NC}"
                echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
                echo ""
                echo -e "${BOLD}Comparing:${NC}"
                echo -e "  ${GREEN}A (new):${NC} ${display_name}"
                echo -e "  ${BLUE}B (existing):${NC} ${ic_name}"
                
                local has_diff=false
                
                # Shape
                local ex_shape
                ex_shape=$(echo "$existing_launch" | jq -r '.shape // "N/A"')
                echo ""
                echo -e "${BOLD}${WHITE}Shape:${NC}"
                if [[ "$shape_name" == "$ex_shape" ]]; then
                    echo -e "  ${GREEN}✓ Same:${NC} $shape_name"
                else
                    echo -e "  ${RED}✗ Different:${NC}"
                    echo -e "    ${GREEN}New:${NC} $shape_name"
                    echo -e "    ${BLUE}Existing:${NC} $ex_shape"
                    has_diff=true
                fi
                
                # Shape Config (for flex shapes)
                if [[ "$is_flex_shape" == "true" ]]; then
                    local ex_ocpus ex_memory
                    ex_ocpus=$(echo "$existing_launch" | jq -r '.["shape-config"].ocpus // "N/A"')
                    ex_memory=$(echo "$existing_launch" | jq -r '.["shape-config"]["memory-in-gbs"] // "N/A"')
                    echo ""
                    echo -e "${BOLD}${WHITE}Shape Config (OCPUs):${NC}"
                    if [[ "$flex_ocpus" == "$ex_ocpus" ]]; then
                        echo -e "  ${GREEN}✓ Same:${NC} $flex_ocpus"
                    else
                        echo -e "  ${RED}✗ Different:${NC}"
                        echo -e "    ${GREEN}New:${NC} $flex_ocpus"
                        echo -e "    ${BLUE}Existing:${NC} $ex_ocpus"
                        has_diff=true
                    fi
                    echo ""
                    echo -e "${BOLD}${WHITE}Shape Config (Memory GB):${NC}"
                    if [[ "$flex_memory_gb" == "$ex_memory" ]]; then
                        echo -e "  ${GREEN}✓ Same:${NC} $flex_memory_gb"
                    else
                        echo -e "  ${RED}✗ Different:${NC}"
                        echo -e "    ${GREEN}New:${NC} $flex_memory_gb"
                        echo -e "    ${BLUE}Existing:${NC} $ex_memory"
                        has_diff=true
                    fi
                fi
                
                # Availability Domain
                local ex_ad
                ex_ad=$(echo "$existing_launch" | jq -r '.["availability-domain"] // "N/A"')
                echo ""
                echo -e "${BOLD}${WHITE}Availability Domain:${NC}"
                if [[ "$ad" == "$ex_ad" ]]; then
                    echo -e "  ${GREEN}✓ Same:${NC} $ad"
                else
                    echo -e "  ${RED}✗ Different:${NC}"
                    echo -e "    ${GREEN}New:${NC} $ad"
                    echo -e "    ${BLUE}Existing:${NC} $ex_ad"
                    has_diff=true
                fi
                
                # Boot Volume Size
                local ex_bvsize
                ex_bvsize=$(echo "$existing_launch" | jq -r '.["source-details"]["boot-volume-size-in-gbs"] // "N/A"')
                echo ""
                echo -e "${BOLD}${WHITE}Boot Volume Size (GB):${NC}"
                if [[ "$boot_volume_size" == "$ex_bvsize" ]]; then
                    echo -e "  ${GREEN}✓ Same:${NC} $boot_volume_size"
                else
                    echo -e "  ${RED}✗ Different:${NC}"
                    echo -e "    ${GREEN}New:${NC} $boot_volume_size"
                    echo -e "    ${BLUE}Existing:${NC} $ex_bvsize"
                    has_diff=true
                fi
                
                # Boot Volume VPUs
                local ex_bvvpus
                ex_bvvpus=$(echo "$existing_launch" | jq -r '.["source-details"]["boot-volume-vpus-per-gb"] // "N/A"')
                echo ""
                echo -e "${BOLD}${WHITE}Boot Volume VPUs/GB:${NC}"
                if [[ "$boot_volume_vpus" == "$ex_bvvpus" ]]; then
                    echo -e "  ${GREEN}✓ Same:${NC} $boot_volume_vpus"
                else
                    echo -e "  ${RED}✗ Different:${NC}"
                    echo -e "    ${GREEN}New:${NC} $boot_volume_vpus"
                    echo -e "    ${BLUE}Existing:${NC} $ex_bvvpus"
                    has_diff=true
                fi
                
                # Image
                local ex_img_id ex_img_name
                ex_img_id=$(echo "$existing_launch" | jq -r '.["source-details"]["image-id"] // "N/A"')
                ex_img_name="(fetching...)"
                [[ -n "$ex_img_id" && "$ex_img_id" != "N/A" ]] && ex_img_name=$(oci compute image get --image-id "$ex_img_id" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
                local new_img_name
                new_img_name=$(oci compute image get --image-id "$image_id" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
                echo ""
                echo -e "${BOLD}${WHITE}Image:${NC}"
                if [[ "$image_id" == "$ex_img_id" ]]; then
                    echo -e "  ${GREEN}✓ Same:${NC} ${WHITE}$new_img_name${NC} (${YELLOW}$image_id${NC})"
                else
                    echo -e "  ${RED}✗ Different:${NC}"
                    echo -e "    ${GREEN}New:${NC} ${WHITE}$new_img_name${NC}"
                    echo -e "      ${YELLOW}$image_id${NC}"
                    echo -e "    ${BLUE}Existing:${NC} ${WHITE}$ex_img_name${NC}"
                    echo -e "      ${YELLOW}$ex_img_id${NC}"
                    has_diff=true
                fi
                
                # Subnet
                local ex_subnet
                ex_subnet=$(echo "$existing_launch" | jq -r '.["create-vnic-details"]["subnet-id"] // "N/A"')
                echo ""
                echo -e "${BOLD}${WHITE}Subnet ID:${NC}"
                if [[ "$worker_subnet" == "$ex_subnet" ]]; then
                    echo -e "  ${GREEN}✓ Same:${NC} $worker_subnet"
                else
                    echo -e "  ${RED}✗ Different:${NC}"
                    echo -e "    ${GREEN}New:${NC} $worker_subnet"
                    echo -e "    ${BLUE}Existing:${NC} $ex_subnet"
                    has_diff=true
                fi
                
                # NSG
                local ex_nsgs new_nsgs_sorted ex_nsgs_sorted
                ex_nsgs_sorted=$(echo "$existing_launch" | jq -r '.["create-vnic-details"]["nsg-ids"] // [] | .[]' 2>/dev/null | sort)
                new_nsgs_sorted="$worker_nsg"
                echo ""
                echo -e "${BOLD}${WHITE}NSG IDs:${NC}"
                if [[ "$new_nsgs_sorted" == "$ex_nsgs_sorted" ]]; then
                    echo -e "  ${GREEN}✓ Same:${NC} $worker_nsg"
                else
                    echo -e "  ${RED}✗ Different:${NC}"
                    echo -e "    ${GREEN}New:${NC} $worker_nsg"
                    echo -e "    ${BLUE}Existing:${NC}"
                    if [[ -n "$ex_nsgs_sorted" ]]; then
                        echo "$ex_nsgs_sorted" | while read -r nsg; do echo -e "      $nsg"; done
                    else
                        echo -e "      (none)"
                    fi
                    has_diff=true
                fi
                
                # Metadata (excluding user_data)
                echo ""
                echo -e "${BOLD}${WHITE}Metadata Fields:${NC}"
                local ex_meta_keys
                ex_meta_keys=$(echo "$existing_launch" | jq -r '.metadata // {} | keys[]' 2>/dev/null | grep -v '^user_data$' | sort)
                local new_max_pods_val="$max_pods"
                local ex_max_pods
                ex_max_pods=$(echo "$existing_launch" | jq -r '.metadata["oke-max-pods"] // "(not set)"')
                if [[ "$new_max_pods_val" == "$ex_max_pods" ]]; then
                    echo -e "  ${GREEN}✓${NC} ${WHITE}oke-max-pods:${NC} $new_max_pods_val"
                else
                    echo -e "  ${RED}✗${NC} ${WHITE}oke-max-pods:${NC}"
                    echo -e "      ${GREEN}New:${NC} $new_max_pods_val"
                    echo -e "      ${BLUE}Existing:${NC} $ex_max_pods"
                    has_diff=true
                fi
                
                # Native pod networking metadata comparison
                local ex_native_flag
                ex_native_flag=$(echo "$existing_launch" | jq -r '.metadata["oke-native-pod-networking"] // "(not set)"')
                local new_native_flag="(not set)"
                [[ "$network_type" == "native" ]] && new_native_flag="true"
                
                if [[ "$new_native_flag" != "$ex_native_flag" ]]; then
                    echo -e "  ${RED}✗${NC} ${WHITE}oke-native-pod-networking:${NC}"
                    echo -e "      ${GREEN}New:${NC} $new_native_flag"
                    echo -e "      ${BLUE}Existing:${NC} $ex_native_flag"
                    has_diff=true
                else
                    echo -e "  ${GREEN}✓${NC} ${WHITE}oke-native-pod-networking:${NC} $new_native_flag"
                fi
                
                local ex_pod_subnets ex_pod_nsgids
                ex_pod_subnets=$(echo "$existing_launch" | jq -r '.metadata["pod-subnets"] // "(not set)"')
                ex_pod_nsgids=$(echo "$existing_launch" | jq -r '.metadata["pod-nsgids"] // "(not set)"')
                local new_pod_subnets="(not set)" new_pod_nsgids="(not set)"
                if [[ "$network_type" == "native" ]]; then
                    new_pod_subnets="$pod_subnet"
                    new_pod_nsgids="$pod_nsg"
                fi
                
                if [[ "$new_pod_subnets" != "$ex_pod_subnets" ]]; then
                    echo -e "  ${RED}✗${NC} ${WHITE}pod-subnets:${NC}"
                    echo -e "      ${GREEN}New:${NC} $new_pod_subnets"
                    echo -e "      ${BLUE}Existing:${NC} $ex_pod_subnets"
                    has_diff=true
                elif [[ "$new_pod_subnets" != "(not set)" ]]; then
                    echo -e "  ${GREEN}✓${NC} ${WHITE}pod-subnets:${NC} ...${new_pod_subnets: -25}"
                fi
                
                if [[ "$new_pod_nsgids" != "$ex_pod_nsgids" ]]; then
                    echo -e "  ${RED}✗${NC} ${WHITE}pod-nsgids:${NC}"
                    echo -e "      ${GREEN}New:${NC} $new_pod_nsgids"
                    echo -e "      ${BLUE}Existing:${NC} $ex_pod_nsgids"
                    has_diff=true
                elif [[ "$new_pod_nsgids" != "(not set)" ]]; then
                    echo -e "  ${GREEN}✓${NC} ${WHITE}pod-nsgids:${NC} ...${new_pod_nsgids: -25}"
                fi
                
                # Cloud-init diff
                echo ""
                echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
                echo -e "${BOLD}${MAGENTA}                               CLOUD-INIT USER-DATA COMPARISON                                                ${NC}"
                echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
                echo ""
                echo -e "${WHITE}Legend:${NC}"
                echo -e "  ${RED}- Lines only in:${NC} ${GREEN}New config${NC}"
                echo -e "  ${GREEN}+ Lines only in:${NC} ${BLUE}${ic_name}${NC}"
                echo ""
                
                local ex_ud
                ex_ud=$(echo "$existing_launch" | jq -r '.metadata.user_data // empty')
                
                local tmp_new tmp_existing
                tmp_new=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
                tmp_existing=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
                
                # New cloud-init is the file itself
                cp "$cloud_init_file" "$tmp_new" 2>/dev/null || echo "# No cloud-init" > "$tmp_new"
                
                if [[ -n "$ex_ud" ]]; then
                    decode_user_data_to_file "$ex_ud" "$tmp_existing" || echo "# Failed to decode user_data" > "$tmp_existing"
                else
                    echo "# No user_data" > "$tmp_existing"
                fi
                
                if diff -q "$tmp_new" "$tmp_existing" > /dev/null 2>&1; then
                    echo -e "${GREEN}✓ Cloud-init user-data is identical${NC}"
                else
                    echo -e "${RED}✗ Cloud-init user-data is DIFFERENT${NC}"
                    echo ""
                    echo -e "${BOLD}${WHITE}Differences found:${NC}"
                    echo ""
                    
                    local diff_output
                    diff_output=$(diff -u "$tmp_new" "$tmp_existing" 2>/dev/null | tail -n +4)
                    
                    while IFS= read -r line; do
                        if [[ "$line" =~ ^@@ ]]; then
                            echo ""
                            echo -e "${YELLOW}${line}${NC}"
                        elif [[ "$line" =~ ^- ]]; then
                            echo -e "${RED}${line}${NC}  ${GRAY}← New${NC}"
                        elif [[ "$line" =~ ^\+ ]]; then
                            echo -e "${GREEN}${line}${NC}  ${GRAY}← ${ic_name}${NC}"
                        elif [[ "$line" =~ ^[[:space:]] ]]; then
                            echo -e "${GRAY}${line}${NC}"
                        fi
                    done <<< "$diff_output"
                    
                    has_diff=true
                fi
                
                rm -f "$tmp_new" "$tmp_existing"
                
                # Summary
                echo ""
                echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
                if [[ "$has_diff" == "true" ]]; then
                    echo -e "${RED}✗ Configurations have differences${NC}"
                else
                    echo -e "${GREEN}✓ Configurations are identical${NC}"
                fi
                echo -e "${BOLD}${MAGENTA}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
                
                echo ""
                echo -e "Press Enter to continue..."
                read -r
            fi
        fi
    fi
    
    # ========== STEP 8: Build and Show Command ==========
    echo ""
    echo -e "${BOLD}${MAGENTA}─── Configuration Summary ───${NC}"
    echo ""
    echo -e "  ${WHITE}Display Name:${NC}       ${CYAN}${display_name}${NC}"
    if [[ "$is_flex_shape" == "true" ]]; then
        echo -e "  ${WHITE}Shape:${NC}              ${WHITE}${shape_name}${NC} (${CYAN}${flex_ocpus} OCPUs${NC}, ${CYAN}${flex_memory_gb} GB Memory${NC})"
    else
        echo -e "  ${WHITE}Shape:${NC}              ${WHITE}${shape_name}${NC}"
    fi
    echo -e "  ${WHITE}Network Type:${NC}       ${WHITE}${network_type}${NC}"
    echo -e "  ${WHITE}Boot Volume:${NC}        ${WHITE}${boot_volume_size} GB @ ${boot_volume_vpus} VPUs/GB${NC}"
    echo -e "  ${WHITE}Max Pods:${NC}           ${WHITE}${max_pods}${NC}"
    echo -e "  ${WHITE}Cloud-Init:${NC}         ${WHITE}${cloud_init_file}${NC}"
    echo -e "  ${WHITE}Region:${NC}             ${WHITE}${region}${NC}"
    echo -e "  ${WHITE}AD:${NC}                 ${WHITE}${ad}${NC}"
    echo ""
    
    # Show compartment with name
    local compartment_name_display
    compartment_name_display=$(resolve_compartment_name "$compartment_id")
    echo -e "  ${WHITE}Compartment:${NC}        ${WHITE}${compartment_name_display}${NC} (${YELLOW}${compartment_id}${NC})"
    
    # Show subnet with name
    local subnet_name_display
    subnet_name_display=$(oci network subnet get --subnet-id "$worker_subnet" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
    echo -e "  ${WHITE}Worker Subnet:${NC}      ${WHITE}${subnet_name_display}${NC} (${YELLOW}${worker_subnet}${NC})"
    
    # Show NSG with name
    local nsg_name_display
    nsg_name_display=$(oci network nsg get --nsg-id "$worker_nsg" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
    echo -e "  ${WHITE}Worker NSG:${NC}         ${WHITE}${nsg_name_display}${NC} (${YELLOW}${worker_nsg}${NC})"
    
    # Show pod subnet/NSG when native
    if [[ "$network_type" == "native" ]]; then
        local pod_subnet_name_display pod_nsg_name_display
        pod_subnet_name_display=$(oci network subnet get --subnet-id "$pod_subnet" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
        pod_nsg_name_display=$(oci network nsg get --nsg-id "$pod_nsg" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
        echo -e "  ${WHITE}Pod Subnet:${NC}         ${WHITE}${pod_subnet_name_display}${NC} (${YELLOW}${pod_subnet}${NC})"
        echo -e "  ${WHITE}Pod NSG:${NC}            ${WHITE}${pod_nsg_name_display}${NC} (${YELLOW}${pod_nsg}${NC})"
    fi
    
    # Show image with name
    local img_name_display
    img_name_display=$(oci compute image get --image-id "$image_id" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
    echo -e "  ${WHITE}Image:${NC}              ${WHITE}${img_name_display}${NC} (${YELLOW}${image_id}${NC})"
    echo ""
    
    # Encode cloud-init
    local base64_cloud_init
    base64_cloud_init=$(base64 -w 0 "$cloud_init_file")
    
    # Build the JSON payload
    local shape_config_json=""
    if [[ "$is_flex_shape" == "true" ]]; then
        shape_config_json=$(cat <<SCEOF
    "shapeConfig": {
      "ocpus": ${flex_ocpus},
      "memoryInGBs": ${flex_memory_gb}
    },
SCEOF
)
    fi
    
    # Build metadata block based on network type
    local metadata_json=""
    if [[ "$network_type" == "native" ]]; then
        metadata_json=$(cat <<MDEOF
    "metadata": {
      "user_data": "${base64_cloud_init}",
      "oke-native-pod-networking": "true",
      "oke-max-pods": "${max_pods}",
      "pod-subnets": "${pod_subnet}",
      "pod-nsgids": "${pod_nsg}"
    },
MDEOF
)
    else
        metadata_json=$(cat <<MDEOF
    "metadata": {
      "user_data": "${base64_cloud_init}",
      "oke-max-pods": "${max_pods}"
    },
MDEOF
)
    fi
    
    local instance_details_json
    instance_details_json=$(cat <<EOF
{
  "instanceType": "compute",
  "launchDetails": {
    "availabilityDomain": "${ad}",
    "compartmentId": "${compartment_id}",
    "createVnicDetails": {
      "assignIpv6Ip": false,
      "assignPublicIp": false,
      "assignPrivateDnsRecord": true,
      "subnetId": "${worker_subnet}",
      "nsgIds": [
        "${worker_nsg}"
      ]
    },
${metadata_json}
    "shape": "${shape_name}",
${shape_config_json}
    "sourceDetails": {
      "bootVolumeSizeInGBs": "${boot_volume_size}",
      "bootVolumeVpusPerGB": "${boot_volume_vpus}",
      "sourceType": "image",
      "imageId": "${image_id}"
    },
    "agentConfig": {
      "isMonitoringDisabled": false,
      "isManagementDisabled": false,
      "pluginsConfig": [
        { "name": "WebLogic Management Service", "desiredState": "DISABLED" },
        { "name": "Vulnerability Scanning", "desiredState": "DISABLED" },
        { "name": "Oracle Java Management Service", "desiredState": "DISABLED" },
        { "name": "Oracle Autonomous Linux", "desiredState": "DISABLED" },
        { "name": "OS Management Service Agent", "desiredState": "DISABLED" },
        { "name": "OS Management Hub Agent", "desiredState": "DISABLED" },
        { "name": "Management Agent", "desiredState": "DISABLED" },
        { "name": "Custom Logs Monitoring", "desiredState": "ENABLED" },
        { "name": "Compute RDMA GPU Monitoring", "desiredState": "ENABLED" },
        { "name": "Compute Instance Run Command", "desiredState": "ENABLED" },
        { "name": "Compute Instance Monitoring", "desiredState": "ENABLED" },
        { "name": "Compute HPC RDMA Auto-Configuration", "desiredState": "ENABLED" },
        { "name": "Compute HPC RDMA Authentication", "desiredState": "ENABLED" },
        { "name": "Cloud Guard Workload Protection", "desiredState": "DISABLED" },
        { "name": "Block Volume Management", "desiredState": "DISABLED" },
        { "name": "Bastion", "desiredState": "DISABLED" }
      ]
    },
    "isPvEncryptionInTransitEnabled": false,
    "instanceOptions": {
      "areLegacyImdsEndpointsDisabled": false
    },
    "availabilityConfig": {
      "recoveryAction": "RESTORE_INSTANCE"
    }
  }
}
EOF
)
    
    # Clean up JSON - remove empty lines from non-flex shapes and ensure valid JSON
    instance_details_json=$(echo "$instance_details_json" | jq '.' 2>/dev/null || echo "$instance_details_json")
    
    echo -e "${BOLD}${YELLOW}─── Configuration Summary ───${NC}"
    echo ""
    if [[ "$is_flex_shape" == "true" ]]; then
        echo -e "  ${CYAN}Shape:${NC}       ${WHITE}${shape_name}${NC} (${CYAN}${flex_ocpus} OCPUs${NC}, ${CYAN}${flex_memory_gb} GB Memory${NC})"
    else
        echo -e "  ${CYAN}Shape:${NC}       ${WHITE}${shape_name}${NC}"
    fi
    echo -e "  ${CYAN}Boot Vol:${NC}    ${WHITE}${boot_volume_size} GB @ ${boot_volume_vpus} VPUs/GB${NC}"
    echo -e "  ${CYAN}Max Pods:${NC}    ${WHITE}${max_pods}${NC}"
    echo -e "  ${CYAN}Network:${NC}     ${WHITE}${network_type}${NC}"
    echo ""
    
    # Show image with name and OCID on same line
    local img_summary_name
    img_summary_name=$(oci compute image get --image-id "$image_id" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
    echo -e "  ${CYAN}Image:${NC}       ${WHITE}${img_summary_name}${NC} (${YELLOW}${image_id}${NC})"
    
    # Show worker subnet with name and OCID on same line
    local subnet_summary_name
    subnet_summary_name=$(oci network subnet get --subnet-id "$worker_subnet" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
    echo -e "  ${CYAN}Worker Sub:${NC}  ${WHITE}${subnet_summary_name}${NC} (${YELLOW}${worker_subnet}${NC})"
    
    # Show worker NSG with name and OCID on same line
    local nsg_summary_name
    nsg_summary_name=$(oci network nsg get --nsg-id "$worker_nsg" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
    echo -e "  ${CYAN}Worker NSG:${NC}  ${WHITE}${nsg_summary_name}${NC} (${YELLOW}${worker_nsg}${NC})"
    
    # Show pod subnet/NSG when native
    if [[ "$network_type" == "native" ]]; then
        local pod_sub_summary pod_nsg_summary
        pod_sub_summary=$(oci network subnet get --subnet-id "$pod_subnet" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
        pod_nsg_summary=$(oci network nsg get --nsg-id "$pod_nsg" --query 'data."display-name"' --raw-output 2>/dev/null || echo "Unknown")
        echo -e "  ${CYAN}Pod Sub:${NC}     ${WHITE}${pod_sub_summary}${NC} (${YELLOW}${pod_subnet}${NC})"
        echo -e "  ${CYAN}Pod NSG:${NC}     ${WHITE}${pod_nsg_summary}${NC} (${YELLOW}${pod_nsg}${NC})"
    fi
    echo ""
    
    echo -e "${BOLD}${YELLOW}─── Command to Execute ───${NC}"
    echo ""
    printf "%s\n" "oci --region \"${region}\" \\"
    printf "%s\n" "  compute-management instance-configuration create \\"
    printf "%s\n" "  --compartment-id \"${compartment_id}\" \\"
    printf "%s\n" "  --display-name \"${display_name}\" \\"
    printf "%s\n" "  --instance-details '...'"
    echo ""
    
    echo -e "${BOLD}${YELLOW}─── Instance Details JSON Payload ───${NC}"
    echo ""
    echo "$instance_details_json" | jq '.' 2>/dev/null || echo "$instance_details_json"
    echo ""
    
    # Ensure logs directory exists
    mkdir -p "${LOGS_DIR}" 2>/dev/null
    local log_file="${LOGS_DIR}/instance_config_create_$(date +%Y%m%d_%H%M%S).log"
    
    echo -e "${BOLD}${RED}═══ CONFIRM CREATION ═══${NC}"
    echo ""
    echo -e "${YELLOW}This will create a new Instance Configuration.${NC}"
    echo -e "${WHITE}Log file: ${CYAN}${log_file}${NC}"
    echo ""
    echo -n -e "${CYAN}Type 'CREATE' to confirm: ${NC}"
    local confirm
    read -r confirm
    
    if [[ "$confirm" != "CREATE" ]]; then
        echo -e "${YELLOW}Cancelled.${NC}"
        echo -e "Press Enter to return..."
        read -r
        return 0
    fi
    
    # Execute the command
    echo ""
    echo -e "${YELLOW}Creating Instance Configuration...${NC}"
    
    # Log the command with full details
    {
        echo "=========================================="
        echo "Instance Configuration Creation"
        echo "Timestamp: $(date)"
        echo "=========================================="
        echo ""
        echo "Display Name: ${display_name}"
        echo "Shape: ${shape_name}"
        if [[ "$is_flex_shape" == "true" ]]; then
            echo "Shape Config: ${flex_ocpus} OCPUs, ${flex_memory_gb} GB Memory"
        fi
        echo "Image ID: ${image_id}"
        echo "Network Type: ${network_type}"
        if [[ "$network_type" == "native" ]]; then
            echo "Pod Subnet ID: ${pod_subnet}"
            echo "Pod NSG ID: ${pod_nsg}"
        fi
        echo "Boot Volume: ${boot_volume_size} GB @ ${boot_volume_vpus} VPUs/GB"
        echo "Max Pods: ${max_pods}"
        echo "Cloud-Init File: ${cloud_init_file}"
        echo ""
        echo "Command:"
        echo "oci --region \"${region}\" \\"
        echo "  compute-management instance-configuration create \\"
        echo "  --compartment-id \"${compartment_id}\" \\"
        echo "  --display-name \"${display_name}\" \\"
        echo "  --instance-details '<see JSON payload below>'"
        echo ""
        echo "=========================================="
        echo "Instance Details JSON Payload:"
        echo "=========================================="
        echo "$instance_details_json" | jq '.' 2>/dev/null || echo "$instance_details_json"
        echo ""
        echo "=========================================="
        echo "Execution Output:"
        echo "=========================================="
    } > "$log_file"
    
    local result
    result=$(oci --region "${region}" \
        compute-management instance-configuration create \
        --compartment-id "${compartment_id}" \
        --display-name "${display_name}" \
        --instance-details "${instance_details_json}" 2>&1)
    local exit_code=$?
    
    # Log the result
    echo "$result" >> "$log_file"
    
    if [[ $exit_code -eq 0 ]]; then
        local new_ocid
        new_ocid=$(echo "$result" | jq -r '.data.id // empty' 2>/dev/null)
        
        echo ""
        echo -e "${GREEN}╔════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${GREEN}║                    INSTANCE CONFIGURATION CREATED                          ║${NC}"
        echo -e "${GREEN}╚════════════════════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "${WHITE}Name:${NC} ${CYAN}${display_name}${NC}"
        echo -e "${WHITE}OCID:${NC} ${YELLOW}${new_ocid}${NC}"
        echo -e "${WHITE}Log:${NC}  ${WHITE}${log_file}${NC}"
        echo ""
        
        # Invalidate cache
        rm -f "$INSTANCE_CONFIG_CACHE"
        
        echo -e "${GREEN}✓ Instance Configuration created successfully!${NC}"
    else
        echo ""
        echo -e "${RED}╔════════════════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${RED}║                    FAILED TO CREATE INSTANCE CONFIGURATION                 ║${NC}"
        echo -e "${RED}╚════════════════════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "${RED}Error:${NC}"
        echo "$result"
        echo ""
        echo -e "${WHITE}Log file: ${CYAN}${log_file}${NC}"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
    
    # Refresh the menu to show new instance config
    display_gpu_management_menu > /dev/null 2>&1
}

#--------------------------------------------------------------------------------
# Delete Instance Configuration interactively
#--------------------------------------------------------------------------------
delete_instance_configuration_interactive() {
    local delete_args="$1"
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local log_file="${LOGS_DIR}/instance_config_actions.log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    
    echo ""
    echo -e "${BOLD}${RED}═══ Delete Instance Configuration ═══${NC}"
    echo ""
    
    # Refresh caches to get latest data
    echo -e "${YELLOW}Refreshing data from OCI...${NC}"
    rm -f "$INSTANCE_CONFIG_CACHE" "$CLUSTER_CACHE"
    fetch_instance_configurations
    fetch_gpu_clusters
    
    # Rebuild index maps
    display_gpu_management_menu > /dev/null 2>&1
    
    echo -e "${GREEN}✓ Data refreshed${NC}"
    echo ""
    
    # Check if any instance configurations exist
    if [[ ${#IC_INDEX_MAP[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No Instance Configurations available to delete${NC}"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
        return 0
    fi
    
    # Display Instance Configurations
    echo -e "${WHITE}Available Instance Configurations:${NC}"
    echo ""
    printf "${BOLD}%-6s %-60s %-20s %s${NC}\n" \
        "ID" "Instance Configuration Name" "Created" "OCID"
    print_separator 160
    
    # Sort and display instance configs, build display map
    local ic_output_temp
    ic_output_temp=$(mktemp "${TEMP_DIR}/tmp.XXXXXXXXXX")
    
    local iid
    for iid in "${!IC_INDEX_MAP[@]}"; do
        local ic_ocid="${IC_INDEX_MAP[$iid]}"
        [[ -z "$ic_ocid" ]] && continue
        
        local ic_line ic_name ic_time_created
        ic_line=$(grep "^${ic_ocid}|" "$INSTANCE_CONFIG_CACHE" 2>/dev/null | head -1)
        if [[ -n "$ic_line" ]]; then
            IFS='|' read -r _ ic_name ic_time_created <<< "$ic_line"
        else
            ic_name="N/A"
            ic_time_created="N/A"
        fi
        
        local time_display="N/A"
        if [[ -n "$ic_time_created" && "$ic_time_created" != "N/A" ]]; then
            time_display="${ic_time_created:0:16}"
            time_display="${time_display/T/ }"
        fi
        
        local iid_num="${iid#i}"
        echo "${iid_num}|${iid}|${ic_name}|${time_display}|${ic_ocid}" >> "$ic_output_temp"
    done
    
    sort -t'|' -k1 -n "$ic_output_temp" | while IFS='|' read -r _ iid ic_name time_display ic_ocid; do
        printf "${YELLOW}%-6s${NC} ${GREEN}%-60s${NC} ${GRAY}%-20s${NC} ${CYAN}%s${NC}\n" \
            "$iid" "$ic_name" "$time_display" "$ic_ocid"
    done
    
    rm -f "$ic_output_temp"
    echo ""
    
    # If no args provided, prompt interactively
    if [[ -z "$delete_args" ]]; then
        echo -e "${WHITE}Usage: Enter one of the following:${NC}"
        echo -e "  ${YELLOW}i#${NC}          - Delete a single config (e.g., ${YELLOW}i1${NC})"
        echo -e "  ${YELLOW}i#,i#,i#${NC}   - Delete multiple configs (e.g., ${YELLOW}i1,i3,i5${NC})"
        echo -e "  ${RED}all${NC}         - Delete ALL instance configurations"
        echo -e "  ${CYAN}cancel${NC}      - Cancel"
        echo ""
        echo -n -e "${CYAN}Select Instance Configuration(s) to delete: ${NC}"
        read -r delete_args
    fi
    
    # Check for cancel
    if [[ -z "$delete_args" || "$delete_args" == "cancel" || "$delete_args" == "c" ]]; then
        echo -e "${YELLOW}Delete cancelled${NC}"
        return 0
    fi
    
    # Build list of ICs to delete
    declare -a DELETE_IDS=()
    declare -a DELETE_OCIDS=()
    declare -a DELETE_NAMES=()
    
    if [[ "${delete_args,,}" == "all" ]]; then
        # Delete all
        for iid in "${!IC_INDEX_MAP[@]}"; do
            local ic_ocid="${IC_INDEX_MAP[$iid]}"
            [[ -z "$ic_ocid" ]] && continue
            DELETE_IDS+=("$iid")
            DELETE_OCIDS+=("$ic_ocid")
            
            local ic_line ic_name
            ic_line=$(grep "^${ic_ocid}|" "$INSTANCE_CONFIG_CACHE" 2>/dev/null | head -1)
            if [[ -n "$ic_line" ]]; then
                IFS='|' read -r _ ic_name _ <<< "$ic_line"
            else
                ic_name="Unknown"
            fi
            DELETE_NAMES+=("$ic_name")
        done
    else
        # Parse comma-separated list: i1,i3,i5 or i1
        local IFS_SAVE="$IFS"
        IFS=',' read -ra INPUT_IDS <<< "$delete_args"
        IFS="$IFS_SAVE"
        
        for raw_id in "${INPUT_IDS[@]}"; do
            # Trim whitespace
            local clean_id
            clean_id=$(echo "$raw_id" | tr -d ' ')
            
            # Ensure it starts with 'i'
            [[ "$clean_id" =~ ^[0-9]+$ ]] && clean_id="i${clean_id}"
            
            local ic_ocid="${IC_INDEX_MAP[$clean_id]:-}"
            if [[ -z "$ic_ocid" ]]; then
                echo -e "${RED}Invalid ID: ${clean_id} - skipping${NC}"
                continue
            fi
            
            DELETE_IDS+=("$clean_id")
            DELETE_OCIDS+=("$ic_ocid")
            
            local ic_line ic_name
            ic_line=$(grep "^${ic_ocid}|" "$INSTANCE_CONFIG_CACHE" 2>/dev/null | head -1)
            if [[ -n "$ic_line" ]]; then
                IFS='|' read -r _ ic_name _ <<< "$ic_line"
            else
                ic_name="Unknown"
            fi
            DELETE_NAMES+=("$ic_name")
        done
    fi
    
    # Validate we have something to delete
    if [[ ${#DELETE_OCIDS[@]} -eq 0 ]]; then
        echo -e "${RED}No valid instance configurations selected for deletion${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return 1
    fi
    
    # Show what will be deleted
    echo ""
    echo -e "${RED}╔════════════════════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${RED}║              ⚠️  WARNING: DELETE INSTANCE CONFIGURATION(S)  ⚠️                  ║${NC}"
    echo -e "${RED}╚════════════════════════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "${WHITE}The following ${RED}${#DELETE_OCIDS[@]}${WHITE} instance configuration(s) will be deleted:${NC}"
    echo ""
    
    local clusters_warning=""
    for i in "${!DELETE_OCIDS[@]}"; do
        local ic_ocid="${DELETE_OCIDS[$i]}"
        local ic_name="${DELETE_NAMES[$i]}"
        local iid="${DELETE_IDS[$i]}"
        
        printf "  ${YELLOW}%-5s${NC} ${WHITE}%-60s${NC} ${GRAY}%s${NC}\n" "$iid" "$ic_name" "$ic_ocid"
        
        # Check if this IC is in use by any GPU memory clusters
        if [[ -f "$CLUSTER_CACHE" ]]; then
            while IFS='|' read -r cluster_ocid cluster_name cluster_state _ cluster_ic_id _; do
                [[ "$cluster_ocid" =~ ^#.*$ ]] && continue
                [[ -z "$cluster_ocid" ]] && continue
                [[ "$cluster_state" == "DELETED" ]] && continue
                
                if [[ "$cluster_ic_id" == "$ic_ocid" ]]; then
                    clusters_warning+="        ↳ ${RED}IN USE by cluster: ${YELLOW}${cluster_name}${NC} ${GRAY}(${cluster_state})${NC}\n"
                fi
            done < "$CLUSTER_CACHE"
        fi
        
        if [[ -n "$clusters_warning" ]]; then
            echo -e "$clusters_warning"
            clusters_warning=""
        fi
    done
    
    echo ""
    echo -e "${RED}This action cannot be undone!${NC}"
    echo ""
    
    # Confirmation
    if [[ ${#DELETE_OCIDS[@]} -gt 1 ]]; then
        echo -n -e "${RED}Type 'DELETE ${#DELETE_OCIDS[@]}' to confirm deletion of ${#DELETE_OCIDS[@]} configs: ${NC}"
        local confirm
        read -r confirm
        if [[ "$confirm" != "DELETE ${#DELETE_OCIDS[@]}" ]]; then
            echo -e "${YELLOW}Delete cancelled${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return 0
        fi
    else
        echo -n -e "${RED}Type 'DELETE' to confirm deletion: ${NC}"
        local confirm
        read -r confirm
        if [[ "$confirm" != "DELETE" ]]; then
            echo -e "${YELLOW}Delete cancelled${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return 0
        fi
    fi
    
    # Execute deletions
    echo ""
    local success_count=0
    local fail_count=0
    
    for i in "${!DELETE_OCIDS[@]}"; do
        local ic_ocid="${DELETE_OCIDS[$i]}"
        local ic_name="${DELETE_NAMES[$i]}"
        local iid="${DELETE_IDS[$i]}"
        
        local cmd="oci compute-management instance-configuration delete --instance-configuration-id \"${ic_ocid}\" --force"
        
        echo -e "${BOLD}${WHITE}Command to execute:${NC}"
        echo -e "${GRAY}$ ${cmd}${NC}"
        
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: $cmd" >> "$log_file"
        
        local result
        result=$(eval "$cmd" 2>&1)
        local exit_code=$?
        
        if [[ $exit_code -eq 0 ]]; then
            echo -e "${GREEN}✓ Deleted: ${WHITE}${ic_name}${NC} ${GRAY}(${iid})${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted IC '${ic_name}' (${ic_ocid})" >> "$log_file"
            ((success_count++))
        else
            echo -e "${RED}✗ Failed: ${WHITE}${ic_name}${NC} ${GRAY}(${iid})${NC}"
            echo -e "  ${RED}${result}${NC}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: Delete IC '${ic_name}' (${ic_ocid}): ${result}" >> "$log_file"
            ((fail_count++))
        fi
        echo ""
    done
    
    # Summary
    echo -e "${BOLD}${WHITE}─── Delete Summary ───${NC}"
    echo -e "  ${GREEN}Succeeded:${NC} ${success_count}"
    [[ $fail_count -gt 0 ]] && echo -e "  ${RED}Failed:${NC}    ${fail_count}"
    echo -e "  ${GRAY}Log file:  ${log_file}${NC}"
    echo ""
    
    # Invalidate cache
    rm -f "$INSTANCE_CONFIG_CACHE"
    
    echo -e "Press Enter to continue..."
    read -r
}

#===============================================================================
# OBJECT STORAGE MANAGEMENT
#===============================================================================

manage_object_storage() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    # Get namespace
    local namespace
    namespace=$(oci os ns get --output json 2>/dev/null | jq -r '.data // empty')
    
    if [[ -z "$namespace" ]]; then
        echo -e "${RED}Failed to get Object Storage namespace${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    while true; do
        echo ""
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${CYAN}                                              OBJECT STORAGE MANAGEMENT                                            ${NC}"
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo ""
        echo -e "${BOLD}${WHITE}Environment:${NC}"
        echo -e "  ${CYAN}Region:${NC}      ${WHITE}${region}${NC}"
        echo -e "  ${CYAN}Compartment:${NC} ${WHITE}$(resolve_compartment_name "${compartment_id}")${NC} ${GRAY}(${compartment_id})${NC}"
        echo -e "  ${CYAN}Namespace:${NC}   ${WHITE}${namespace}${NC}"
        echo ""
        
        # Fetch and display buckets summary
        echo -e "${GRAY}Fetching Object Storage configuration...${NC}"
        
        local buckets_json
        buckets_json=$(oci os bucket list --compartment-id "$compartment_id" --namespace-name "$namespace" --output json 2>/dev/null)
        
        local bucket_count=0
        if [[ -n "$buckets_json" && "$buckets_json" != "null" ]]; then
            bucket_count=$(echo "$buckets_json" | jq '.data | length // 0' 2>/dev/null)
        fi
        
        # Fetch private endpoints
        local pe_json
        pe_json=$(oci os private-endpoint list --compartment-id "$compartment_id" --output json 2>&1)
        
        local pe_count=0
        if [[ -n "$pe_json" ]] && echo "$pe_json" | jq -e '.data' > /dev/null 2>&1; then
            pe_count=$(echo "$pe_json" | jq '.data | length' 2>/dev/null)
        fi
        [[ -z "$pe_count" || "$pe_count" == "null" ]] && pe_count=0
        
        echo ""
        echo -e "${BOLD}${WHITE}═══ Object Storage Summary ═══${NC}"
        echo ""
        echo -e "  ${CYAN}Buckets:${NC}           ${WHITE}${bucket_count}${NC}"
        echo -e "  ${CYAN}Private Endpoints:${NC} ${WHITE}${pe_count}${NC}"
        echo ""
        
        # Declare maps outside if blocks for proper scope
        local idx=0
        local pe_idx=0
        declare -A BUCKET_MAP
        declare -A PE_MAP
        BUCKET_MAP=()
        PE_MAP=()
        
        # Display buckets summary table
        if [[ "$bucket_count" -gt 0 ]]; then
            echo -e "${BOLD}${WHITE}─── Buckets ───${NC}"
            printf "  ${BOLD}%-4s %-40s %-15s %-12s %-15s${NC}\n" "b#" "Bucket Name" "Storage Tier" "Versioning" "Auto-Tiering"
            print_separator 100
            
            while IFS='|' read -r bucket_name storage_tier versioning auto_tiering; do
                [[ -z "$bucket_name" ]] && continue
                ((idx++))
                
                BUCKET_MAP[$idx]="$bucket_name"
                
                local tier_display="${storage_tier:-Standard}"
                local version_display="${versioning:-Disabled}"
                local auto_tier_display="${auto_tiering:-Disabled}"
                
                # Color code versioning
                local version_color="$GRAY"
                [[ "$versioning" == "Enabled" ]] && version_color="$GREEN"
                
                printf "  ${YELLOW}%-4s${NC} %-40s %-15s ${version_color}%-12s${NC} %-15s\n" \
                    "b${idx}" "${bucket_name:0:38}" "$tier_display" "$version_display" "$auto_tier_display"
                    
            done < <(echo "$buckets_json" | jq -r '.data[] | "\(.name)|\(.["storage-tier"] // "Standard")|\(.versioning // "Disabled")|\(.["auto-tiering"] // "Disabled")"' 2>/dev/null)
            echo ""
        fi
        
        # Display private endpoints summary
        if [[ "$pe_count" -gt 0 ]]; then
            echo -e "${BOLD}${WHITE}─── Private Endpoints ───${NC}"
            printf "  ${BOLD}%-4s %-30s %-12s %-15s %s${NC}\n" "p#" "Name" "State" "Namespace" "Prefix"
            print_separator 120
            
            # PE_MAP stores: name|namespace for later lookup
            while IFS='|' read -r pe_name pe_state pe_namespace prefix; do
                [[ -z "$pe_name" ]] && continue
                ((pe_idx++))
                
                # Store name|namespace for lookup
                PE_MAP[$pe_idx]="${pe_name}|${pe_namespace}"
                
                local state_color="$GREEN"
                case "$pe_state" in
                    ACTIVE) state_color="$GREEN" ;;
                    CREATING|UPDATING) state_color="$YELLOW" ;;
                    DELETING|DELETED|FAILED) state_color="$RED" ;;
                    *) state_color="$GRAY" ;;
                esac
                
                local prefix_display="${prefix:-N/A}"
                local ns_display="${pe_namespace:-N/A}"
                
                printf "  ${YELLOW}%-4s${NC} %-30s ${state_color}%-12s${NC} %-15s %s\n" \
                    "p${pe_idx}" "${pe_name:0:28}" "$pe_state" "${ns_display:0:13}" "$prefix_display"
                    
            done < <(echo "$pe_json" | jq -r '.data[] | "\(.name)|\(.["lifecycle-state"])|\(.namespace)|\(.prefix // "N/A")"' 2>/dev/null)
            echo ""
        fi
        
        echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
        echo ""
        echo -e "${BOLD}${WHITE}─── Buckets ───${NC}"
        echo -e "  ${YELLOW}b#${NC}) ${WHITE}View Bucket Details${NC}    - Enter 'b' + number (e.g., b1)"
        echo ""
        echo -e "${BOLD}${WHITE}─── Private Endpoints ───${NC}"
        echo -e "  ${YELLOW}p#${NC}) ${WHITE}View PE Details${NC}        - Enter 'p' + number (e.g., p1)"
        echo -e "  ${GREEN}pc${NC}) ${WHITE}Create Private Endpoint${NC}"
        echo -e "  ${RED}pd${NC}) ${WHITE}Delete Private Endpoint${NC}"
        echo ""
        echo -e "${BOLD}${WHITE}─── Operations ───${NC}"
        echo -e "  ${CYAN}w${NC})  ${WHITE}Work Requests${NC}          - View work request status and logs"
        echo ""
        echo -e "  ${MAGENTA}r${NC})  Refresh"
        echo -e "  ${CYAN}b${NC})  Back to main menu"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Object Storage] Enter selection: ${NC}"
        read -r selection
        
        case "$selection" in
            b[0-9]|b[0-9][0-9])
                local bucket_num="${selection:1}"
                if [[ -n "${BUCKET_MAP[$bucket_num]}" ]]; then
                    os_view_bucket_details "$namespace" "${BUCKET_MAP[$bucket_num]}"
                else
                    echo -e "${RED}Invalid bucket number${NC}"
                    sleep 1
                fi
                ;;
            p[0-9]|p[0-9][0-9])
                local pe_num="${selection:1}"
                if [[ -n "${PE_MAP[$pe_num]}" ]]; then
                    os_view_private_endpoint_details "${PE_MAP[$pe_num]}"
                else
                    echo -e "${RED}Invalid private endpoint number${NC}"
                    sleep 1
                fi
                ;;
            pc|PC)
                os_create_private_endpoint "$compartment_id" "$namespace"
                ;;
            pd|PD)
                os_delete_private_endpoint "$compartment_id"
                ;;
            w|W)
                os_manage_work_requests "$compartment_id"
                ;;
            r|R) continue ;;
            b|B|back|BACK|"") return ;;
            *)
                echo -e "${RED}Invalid selection${NC}"
                sleep 1
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# Object Storage - Manage Work Requests
#--------------------------------------------------------------------------------
os_manage_work_requests() {
    local compartment_id="$1"
    
    while true; do
        echo ""
        echo -e "${BOLD}${WHITE}═══ Object Storage Work Requests ═══${NC}"
        echo ""
        
        echo -e "${GRAY}Fetching work requests...${NC}"
        
        # Fetch work requests using oci os work-request list
        local wr_json
        wr_json=$(oci os work-request list \
            --compartment-id "$compartment_id" \
            --output json 2>/dev/null)
        
        local wr_count=0
        if [[ -n "$wr_json" ]] && echo "$wr_json" | jq -e '.data' > /dev/null 2>&1; then
            wr_count=$(echo "$wr_json" | jq '.data | length' 2>/dev/null)
        fi
        [[ -z "$wr_count" || "$wr_count" == "null" ]] && wr_count=0
        
        echo ""
        echo -e "${BOLD}${WHITE}─── Work Requests (${wr_count}) ───${NC}"
        
        if [[ "$wr_count" -eq 0 ]]; then
            echo -e "  ${GRAY}No work requests found${NC}"
            echo ""
            echo -e "${GRAY}Note: Work requests may have completed or expired${NC}"
            echo ""
            echo -e "Press Enter to return..."
            read -r
            return
        fi
        
        printf "  ${BOLD}%-3s %-12s %-25s %-20s %-8s %-20s${NC}\n" "#" "Status" "Operation" "Resource" "%" "Time"
        print_separator 100
        
        declare -A WR_MAP
        WR_MAP=()
        local idx=0
        
        while IFS='|' read -r wr_id wr_status wr_operation wr_resource wr_percent wr_time wr_finished; do
            [[ -z "$wr_id" ]] && continue
            ((idx++))
            
            WR_MAP[$idx]="$wr_id"
            
            # Format status with color
            local status_color="$WHITE"
            case "$wr_status" in
                ACCEPTED|IN_PROGRESS) status_color="$YELLOW" ;;
                COMPLETED) status_color="$GREEN" ;;
                FAILED|CANCELING|CANCELED) status_color="$RED" ;;
            esac
            
            # Format operation type - clean up the name
            local op_display="${wr_operation//_/ }"
            op_display="${op_display:0:23}"
            
            # Format resource - extract PE name if present
            local resource_display="N/A"
            if [[ -n "$wr_resource" && "$wr_resource" != "null" ]]; then
                # Check if it's an OCID
                if [[ "$wr_resource" =~ ^ocid1\. ]]; then
                    resource_display="...${wr_resource: -15}"
                else
                    resource_display="${wr_resource:0:18}"
                fi
            fi
            
            # Format time
            local time_display="${wr_time:0:19}"
            [[ -n "$wr_finished" && "$wr_finished" != "null" ]] && time_display="${wr_finished:0:19}"
            
            # Format percentage
            local percent_display="${wr_percent:-0}%"
            
            printf "  ${YELLOW}%-3s${NC} ${status_color}%-12s${NC} %-25s %-20s %-8s %-20s\n" \
                "$idx" "$wr_status" "$op_display" "$resource_display" "$percent_display" "$time_display"
                
        done < <(echo "$wr_json" | jq -r '.data[] | "\(.id)|\(.status)|\(.["operation-type"])|\(.resources[0].identifier // "N/A")|\(.["percent-complete"])|\(.["time-accepted"])|\(.["time-finished"])"' 2>/dev/null)
        
        echo ""
        echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
        echo -e "  ${YELLOW}1-${idx}${NC}) View work request details and logs"
        echo -e "  ${MAGENTA}r${NC})   Refresh"
        echo -e "  ${CYAN}b${NC})   Back"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Object Storage > Work Requests] Enter selection: ${NC}"
        read -r selection
        
        case "$selection" in
            [0-9]|[0-9][0-9])
                if [[ -n "${WR_MAP[$selection]}" ]]; then
                    os_view_work_request_details "${WR_MAP[$selection]}"
                else
                    echo -e "${RED}Invalid selection${NC}"
                    sleep 1
                fi
                ;;
            r|R) continue ;;
            b|B|back|BACK|"") return ;;
            *)
                echo -e "${RED}Invalid selection${NC}"
                sleep 1
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# Object Storage - View Work Request Details
#--------------------------------------------------------------------------------
os_view_work_request_details() {
    local wr_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Work Request Details ═══${NC}"
    echo ""
    
    # Get work request details using oci os work-request get
    echo -e "${GRAY}Fetching work request details...${NC}"
    local wr_json
    wr_json=$(oci os work-request get \
        --work-request-id "$wr_id" \
        --output json 2>/dev/null)
    
    if [[ -z "$wr_json" ]] || ! echo "$wr_json" | jq -e '.data' > /dev/null 2>&1; then
        echo -e "${RED}Failed to fetch work request details${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Extract details
    local wr_status wr_operation wr_percent wr_accepted wr_started wr_finished
    wr_status=$(echo "$wr_json" | jq -r '.data.status // "N/A"')
    wr_operation=$(echo "$wr_json" | jq -r '.data["operation-type"] // "N/A"')
    wr_percent=$(echo "$wr_json" | jq -r '.data["percent-complete"] // 0')
    wr_accepted=$(echo "$wr_json" | jq -r '.data["time-accepted"] // "N/A"')
    wr_started=$(echo "$wr_json" | jq -r '.data["time-started"] // "N/A"')
    wr_finished=$(echo "$wr_json" | jq -r '.data["time-finished"] // "N/A"')
    
    # Status color
    local status_color="$WHITE"
    case "$wr_status" in
        ACCEPTED|IN_PROGRESS) status_color="$YELLOW" ;;
        COMPLETED) status_color="$GREEN" ;;
        FAILED|CANCELING|CANCELED) status_color="$RED" ;;
    esac
    
    echo ""
    echo -e "${BOLD}${WHITE}─── Basic Info ───${NC}"
    echo -e "  ${CYAN}Work Request ID:${NC} ${YELLOW}$wr_id${NC}"
    echo -e "  ${CYAN}Operation:${NC}       ${WHITE}$wr_operation${NC}"
    echo -e "  ${CYAN}Status:${NC}          ${status_color}$wr_status${NC}"
    echo -e "  ${CYAN}Progress:${NC}        ${WHITE}${wr_percent}%${NC}"
    echo ""
    echo -e "${BOLD}${WHITE}─── Timestamps ───${NC}"
    echo -e "  ${CYAN}Accepted:${NC}  ${WHITE}${wr_accepted:0:19}${NC}"
    echo -e "  ${CYAN}Started:${NC}   ${WHITE}${wr_started:0:19}${NC}"
    echo -e "  ${CYAN}Finished:${NC}  ${WHITE}${wr_finished:0:19}${NC}"
    
    # Show resources
    local resources
    resources=$(echo "$wr_json" | jq -r '.data.resources // []')
    local resource_count
    resource_count=$(echo "$resources" | jq 'length' 2>/dev/null)
    
    if [[ "$resource_count" -gt 0 ]]; then
        echo ""
        echo -e "${BOLD}${WHITE}─── Resources ───${NC}"
        echo "$resources" | jq -r '.[] | "  \(.["entity-type"] // "Unknown"): \(.identifier // "N/A")"' 2>/dev/null
    fi
    
    # Check for errors if status is FAILED
    if [[ "$wr_status" == "FAILED" || "$wr_status" == "CANCELED" ]]; then
        echo ""
        echo -e "${BOLD}${RED}─── Errors ───${NC}"
        
        local errors_json
        errors_json=$(oci os work-request-error list \
            --work-request-id "$wr_id" \
            --output json 2>/dev/null)
        
        if [[ -n "$errors_json" ]] && echo "$errors_json" | jq -e '.data[0]' > /dev/null 2>&1; then
            echo "$errors_json" | jq -r '.data[] | "  [\(.code // "ERROR")] \(.message // "No message")"' 2>/dev/null | while read -r line; do
                echo -e "  ${RED}$line${NC}"
            done
        else
            echo -e "  ${GRAY}No error details available${NC}"
        fi
    fi
    
    # Fetch and display logs
    echo ""
    echo -e "${BOLD}${WHITE}─── Work Request Logs ───${NC}"
    
    local logs_json
    logs_json=$(oci os work-request-log-entry list \
        --work-request-id "$wr_id" \
        --output json 2>/dev/null)
    
    if [[ -n "$logs_json" ]] && echo "$logs_json" | jq -e '.data[0]' > /dev/null 2>&1; then
        local log_count
        log_count=$(echo "$logs_json" | jq '.data | length' 2>/dev/null)
        echo -e "  ${GRAY}(${log_count} log entries)${NC}"
        echo ""
        
        echo "$logs_json" | jq -r '.data[] | "\(.timestamp // "N/A")|\(.message // "No message")"' 2>/dev/null | while IFS='|' read -r log_time log_msg; do
            local time_display="${log_time:0:19}"
            echo -e "  ${GRAY}[$time_display]${NC} $log_msg"
        done
    else
        echo -e "  ${GRAY}No log entries available${NC}"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Object Storage - View Bucket Details
#--------------------------------------------------------------------------------
os_view_bucket_details() {
    local namespace="$1"
    local bucket_name="$2"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Bucket Details: $bucket_name ═══${NC}"
    echo ""
    
    local bucket_json
    bucket_json=$(oci os bucket get --namespace-name "$namespace" --bucket-name "$bucket_name" --output json 2>/dev/null)
    
    if [[ -z "$bucket_json" || "$bucket_json" == "null" ]]; then
        echo -e "${RED}Failed to get bucket details${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Extract fields
    local compartment_id created_by etag storage_tier versioning auto_tiering
    local public_access object_events_enabled replication_enabled kms_key_id
    local approximate_count approximate_size
    
    compartment_id=$(echo "$bucket_json" | jq -r '.data["compartment-id"] // "N/A"')
    created_by=$(echo "$bucket_json" | jq -r '.data["created-by"] // "N/A"')
    etag=$(echo "$bucket_json" | jq -r '.data.etag // "N/A"')
    storage_tier=$(echo "$bucket_json" | jq -r '.data["storage-tier"] // "Standard"')
    versioning=$(echo "$bucket_json" | jq -r '.data.versioning // "Disabled"')
    auto_tiering=$(echo "$bucket_json" | jq -r '.data["auto-tiering"] // "Disabled"')
    public_access=$(echo "$bucket_json" | jq -r '.data["public-access-type"] // "NoPublicAccess"')
    object_events_enabled=$(echo "$bucket_json" | jq -r '.data["object-events-enabled"] // false')
    replication_enabled=$(echo "$bucket_json" | jq -r '.data["replication-enabled"] // false')
    kms_key_id=$(echo "$bucket_json" | jq -r '.data["kms-key-id"] // "N/A"')
    approximate_count=$(echo "$bucket_json" | jq -r '.data["approximate-count"] // "N/A"')
    approximate_size=$(echo "$bucket_json" | jq -r '.data["approximate-size"] // "N/A"')
    time_created=$(echo "$bucket_json" | jq -r '.data["time-created"] // "N/A"')
    
    # Format size
    local size_display="N/A"
    if [[ "$approximate_size" =~ ^[0-9]+$ ]] && [[ "$approximate_size" -gt 0 ]]; then
        if [[ "$approximate_size" -gt 1099511627776 ]]; then
            size_display=$(echo "scale=2; $approximate_size / 1099511627776" | bc)" TB"
        elif [[ "$approximate_size" -gt 1073741824 ]]; then
            size_display=$(echo "scale=2; $approximate_size / 1073741824" | bc)" GB"
        elif [[ "$approximate_size" -gt 1048576 ]]; then
            size_display=$(echo "scale=2; $approximate_size / 1048576" | bc)" MB"
        else
            size_display="${approximate_size} bytes"
        fi
    fi
    
    echo -e "${BOLD}${CYAN}─── Basic Information ───${NC}"
    echo -e "  ${CYAN}Bucket Name:${NC}      ${WHITE}$bucket_name${NC}"
    echo -e "  ${CYAN}Namespace:${NC}        ${WHITE}$namespace${NC}"
    echo -e "  ${CYAN}Storage Tier:${NC}     ${WHITE}$storage_tier${NC}"
    echo -e "  ${CYAN}Time Created:${NC}     ${WHITE}${time_created/T/ }${NC}"
    echo -e "  ${CYAN}Compartment:${NC}      ${WHITE}$(resolve_compartment_name "$compartment_id")${NC} ${GRAY}($compartment_id)${NC}"
    echo ""
    
    echo -e "${BOLD}${CYAN}─── Storage Statistics ───${NC}"
    echo -e "  ${CYAN}Object Count:${NC}     ${WHITE}$approximate_count${NC}"
    echo -e "  ${CYAN}Total Size:${NC}       ${WHITE}$size_display${NC}"
    echo ""
    
    echo -e "${BOLD}${CYAN}─── Configuration ───${NC}"
    local version_color="$GRAY"
    [[ "$versioning" == "Enabled" ]] && version_color="$GREEN"
    echo -e "  ${CYAN}Versioning:${NC}       ${version_color}$versioning${NC}"
    
    local auto_tier_color="$GRAY"
    [[ "$auto_tiering" == "InfrequentAccess" ]] && auto_tier_color="$GREEN"
    echo -e "  ${CYAN}Auto-Tiering:${NC}     ${auto_tier_color}$auto_tiering${NC}"
    
    local public_color="$GREEN"
    [[ "$public_access" != "NoPublicAccess" ]] && public_color="$YELLOW"
    echo -e "  ${CYAN}Public Access:${NC}    ${public_color}$public_access${NC}"
    
    local events_color="$GRAY"
    [[ "$object_events_enabled" == "true" ]] && events_color="$GREEN"
    echo -e "  ${CYAN}Object Events:${NC}    ${events_color}$object_events_enabled${NC}"
    
    local repl_color="$GRAY"
    [[ "$replication_enabled" == "true" ]] && repl_color="$GREEN"
    echo -e "  ${CYAN}Replication:${NC}      ${repl_color}$replication_enabled${NC}"
    echo ""
    
    echo -e "${BOLD}${CYAN}─── Encryption ───${NC}"
    if [[ "$kms_key_id" != "N/A" && "$kms_key_id" != "null" && -n "$kms_key_id" ]]; then
        echo -e "  ${CYAN}Encryption:${NC}       ${WHITE}Customer-managed KMS${NC}"
        echo -e "  ${CYAN}KMS Key:${NC}          ${YELLOW}$kms_key_id${NC}"
    else
        echo -e "  ${CYAN}Encryption:${NC}       ${WHITE}Oracle-managed${NC}"
    fi
    echo ""
    
    echo -e "${BOLD}${CYAN}─── Access URLs ───${NC}"
    echo -e "  ${CYAN}Object Storage:${NC}  ${WHITE}https://objectstorage.${EFFECTIVE_REGION:-$REGION}.oraclecloud.com/n/${namespace}/b/${bucket_name}/o/${NC}"
    echo -e "  ${CYAN}Swift:${NC}           ${WHITE}https://swiftobjectstorage.${EFFECTIVE_REGION:-$REGION}.oraclecloud.com/v1/${namespace}/${bucket_name}${NC}"
    echo ""
    
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Object Storage - View Private Endpoint Details
#--------------------------------------------------------------------------------
os_view_private_endpoint_details() {
    local pe_info="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Private Endpoint Details ═══${NC}"
    echo ""
    
    # Parse name|namespace from pe_info
    local pe_name pe_namespace
    IFS='|' read -r pe_name pe_namespace <<< "$pe_info"
    
    # Validate
    if [[ -z "$pe_name" || -z "$pe_namespace" ]]; then
        echo -e "${RED}Invalid private endpoint reference${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo -e "${GRAY}Fetching details for: $pe_name (namespace: $pe_namespace)${NC}"
    
    local pe_json
    pe_json=$(oci os private-endpoint get --pe-name "$pe_name" --namespace-name "$pe_namespace" --output json 2>&1)
    
    # Check for API error
    if ! echo "$pe_json" | jq -e '.data' > /dev/null 2>&1; then
        echo -e "${RED}Failed to get private endpoint details${NC}"
        echo -e "${GRAY}Error: ${pe_json:0:200}${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Extract fields
    local name state compartment_id namespace prefix subnet_id
    local private_ip time_created pe_id
    
    name=$(echo "$pe_json" | jq -r '.data.name // "N/A"')
    state=$(echo "$pe_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    compartment_id=$(echo "$pe_json" | jq -r '.data["compartment-id"] // "N/A"')
    namespace=$(echo "$pe_json" | jq -r '.data.namespace // "N/A"')
    prefix=$(echo "$pe_json" | jq -r '.data.prefix // "N/A"')
    subnet_id=$(echo "$pe_json" | jq -r '.data["subnet-id"] // "N/A"')
    private_ip=$(echo "$pe_json" | jq -r '.data["private-endpoint-ip"] // "N/A"')
    time_created=$(echo "$pe_json" | jq -r '.data["time-created"] // "N/A"')
    pe_id=$(echo "$pe_json" | jq -r '.data.id // "N/A"')
    
    local state_color="$GREEN"
    case "$state" in
        ACTIVE) state_color="$GREEN" ;;
        CREATING|UPDATING) state_color="$YELLOW" ;;
        DELETING|DELETED|FAILED) state_color="$RED" ;;
        *) state_color="$GRAY" ;;
    esac
    
    echo ""
    echo -e "${BOLD}${CYAN}─── Basic Information ───${NC}"
    echo -e "  ${CYAN}Name:${NC}            ${WHITE}$name${NC}"
    echo -e "  ${CYAN}State:${NC}           ${state_color}$state${NC}"
    echo -e "  ${CYAN}Namespace:${NC}       ${WHITE}$namespace${NC}"
    echo -e "  ${CYAN}Prefix:${NC}          ${WHITE}$prefix${NC}"
    echo -e "  ${CYAN}Time Created:${NC}    ${WHITE}${time_created/T/ }${NC}"
    echo -e "  ${CYAN}PE OCID:${NC}         ${YELLOW}$pe_id${NC}"
    echo -e "  ${CYAN}Compartment:${NC}     ${WHITE}$(resolve_compartment_name "$compartment_id")${NC} ${GRAY}($compartment_id)${NC}"
    echo ""
    
    echo -e "${BOLD}${CYAN}─── Network Configuration ───${NC}"
    echo -e "  ${CYAN}Private IP:${NC}      ${WHITE}$private_ip${NC}"
    
    # Get subnet details
    if [[ -n "$subnet_id" && "$subnet_id" != "N/A" && "$subnet_id" != "null" ]]; then
        local subnet_json
        subnet_json=$(oci network subnet get --subnet-id "$subnet_id" --output json 2>/dev/null)
        local subnet_name subnet_cidr
        subnet_name=$(echo "$subnet_json" | jq -r '.data["display-name"] // "N/A"' 2>/dev/null)
        subnet_cidr=$(echo "$subnet_json" | jq -r '.data["cidr-block"] // "N/A"' 2>/dev/null)
        echo -e "  ${CYAN}Subnet:${NC}          ${WHITE}$subnet_name${NC} (${subnet_cidr})"
        echo -e "  ${CYAN}Subnet OCID:${NC}     ${YELLOW}$subnet_id${NC}"
    else
        echo -e "  ${CYAN}Subnet OCID:${NC}     ${GRAY}N/A${NC}"
    fi
    echo ""
    
    # NSGs - get display names
    local nsg_ids_json
    nsg_ids_json=$(echo "$pe_json" | jq -c '.data["nsg-ids"] // []')
    local nsg_count
    nsg_count=$(echo "$nsg_ids_json" | jq 'length' 2>/dev/null || echo "0")
    
    # Store NSGs for selection (use global for child function access)
    # Clear any previous values
    PE_NSG_MAP=()
    local nsg_idx=0
    
    if [[ "$nsg_count" -gt 0 ]]; then
        # Pre-fetch all NSG rules with parallel caching
        local nsg_ids_list=""
        while read -r nsg_id; do
            [[ -n "$nsg_id" ]] && nsg_ids_list+="$nsg_id"$'\n'
        done < <(echo "$nsg_ids_json" | jq -r '.[]' 2>/dev/null)
        
        fetch_nsg_rules_detail_parallel "$nsg_ids_list"
        
        echo -e "${BOLD}${CYAN}─── Network Security Groups ───${NC}"
        printf "  ${BOLD}%-3s %-35s %s${NC}\n" "#" "NSG Name" "OCID"
        
        while read -r nsg_id; do
            [[ -z "$nsg_id" ]] && continue
            ((nsg_idx++))
            PE_NSG_MAP[$nsg_idx]="$nsg_id"
            
            # Get NSG name from cache
            local nsg_name="Unknown"
            local cached_data
            cached_data=$(get_cached_nsg_rules "$nsg_id")
            if [[ -n "$cached_data" ]]; then
                nsg_name=$(echo "$cached_data" | jq -r '.nsg_name // "Unknown"' 2>/dev/null)
            fi
            
            printf "  ${YELLOW}%-3s${NC} ${WHITE}%-35s${NC} ${GRAY}%s${NC}\n" "$nsg_idx" "${nsg_name:0:33}" "$nsg_id"
        done < <(echo "$nsg_ids_json" | jq -r '.[]' 2>/dev/null)
        echo ""
    else
        echo -e "${BOLD}${CYAN}─── Network Security Groups ───${NC}"
        echo -e "  ${GRAY}None configured${NC}"
        echo ""
    fi
    
    # Access targets
    local access_targets
    access_targets=$(echo "$pe_json" | jq -r '.data["access-targets"] // []')
    local target_count
    target_count=$(echo "$access_targets" | jq 'length' 2>/dev/null || echo "0")
    
    if [[ "$target_count" -gt 0 ]]; then
        echo -e "${BOLD}${CYAN}─── Access Targets ───${NC}"
        while IFS='|' read -r target_namespace target_compartment target_bucket; do
            [[ -z "$target_namespace" ]] && continue
            echo -e "  ${CYAN}Namespace:${NC}   ${WHITE}$target_namespace${NC}"
            if [[ "$target_compartment" == "*" ]]; then
                echo -e "  ${CYAN}Compartment:${NC} ${WHITE}All compartments${NC}"
            else
                echo -e "  ${CYAN}Compartment:${NC} ${WHITE}$(resolve_compartment_name "$target_compartment")${NC} ${GRAY}($target_compartment)${NC}"
            fi
            if [[ "$target_bucket" == "*" ]]; then
                echo -e "  ${CYAN}Bucket:${NC}      ${WHITE}All buckets${NC}"
            elif [[ "$target_bucket" != "null" && -n "$target_bucket" ]]; then
                echo -e "  ${CYAN}Bucket:${NC}      ${WHITE}$target_bucket${NC}"
            fi
            echo ""
        done < <(echo "$access_targets" | jq -r '.[] | "\(.namespace)|\(.["compartment-id"])|\(.bucket // "null")"' 2>/dev/null)
    fi
    
    # FQDNs - correct structure: .data.fqdns["prefix-fqdns"]
    echo -e "${BOLD}${CYAN}─── FQDNs ───${NC}"
    local obj_fqdn swift_fqdn s3_fqdn
    obj_fqdn=$(echo "$pe_json" | jq -r '.data.fqdns["prefix-fqdns"]["object-storage-api-fqdn"] // "N/A"')
    swift_fqdn=$(echo "$pe_json" | jq -r '.data.fqdns["prefix-fqdns"]["swift-api-fqdn"] // "N/A"')
    s3_fqdn=$(echo "$pe_json" | jq -r '.data.fqdns["prefix-fqdns"]["s3-compatibility-api-fqdn"] // "N/A"')
    
    # Store FQDNs in map for dig selection (use global for child function access)
    PE_FQDN_MAP=()
    local fqdn_idx=0
    
    if [[ "$obj_fqdn" != "N/A" && -n "$obj_fqdn" ]]; then
        ((fqdn_idx++))
        PE_FQDN_MAP[$fqdn_idx]="$obj_fqdn|Object Storage API"
    fi
    if [[ "$swift_fqdn" != "N/A" && -n "$swift_fqdn" ]]; then
        ((fqdn_idx++))
        PE_FQDN_MAP[$fqdn_idx]="$swift_fqdn|Swift API"
    fi
    if [[ "$s3_fqdn" != "N/A" && -n "$s3_fqdn" ]]; then
        ((fqdn_idx++))
        PE_FQDN_MAP[$fqdn_idx]="$s3_fqdn|S3 Compatibility API"
    fi
    
    printf "  ${BOLD}%-3s %-25s %s${NC}\n" "#" "API Type" "FQDN"
    local fidx=0
    if [[ "$obj_fqdn" != "N/A" && -n "$obj_fqdn" ]]; then
        ((fidx++))
        printf "  ${YELLOW}%-3s${NC} %-25s ${WHITE}%s${NC}\n" "$fidx" "Object Storage API" "$obj_fqdn"
    fi
    if [[ "$swift_fqdn" != "N/A" && -n "$swift_fqdn" ]]; then
        ((fidx++))
        printf "  ${YELLOW}%-3s${NC} %-25s ${WHITE}%s${NC}\n" "$fidx" "Swift API" "$swift_fqdn"
    fi
    if [[ "$s3_fqdn" != "N/A" && -n "$s3_fqdn" ]]; then
        ((fidx++))
        printf "  ${YELLOW}%-3s${NC} %-25s ${WHITE}%s${NC}\n" "$fidx" "S3 Compatibility API" "$s3_fqdn"
    fi
    echo ""
    
    # Additional FQDN entries
    local additional_fqdns
    additional_fqdns=$(echo "$pe_json" | jq -r '.data.fqdns["additional-prefixes-fqdns"] // {}')
    local add_fqdn_count
    add_fqdn_count=$(echo "$additional_fqdns" | jq 'keys | length' 2>/dev/null || echo "0")
    
    if [[ "$add_fqdn_count" -gt 0 ]]; then
        echo -e "${BOLD}${CYAN}─── Additional Prefix FQDNs ───${NC}"
        while IFS='|' read -r add_key add_val; do
            [[ -z "$add_key" ]] && continue
            ((fqdn_idx++))
            PE_FQDN_MAP[$fqdn_idx]="$add_val|Additional: $add_key"
            printf "  ${YELLOW}%-3s${NC} %-25s ${WHITE}%s${NC}\n" "$fqdn_idx" "Additional: $add_key" "$add_val"
        done < <(echo "$additional_fqdns" | jq -r 'to_entries[] | "\(.key)|\(.value)"' 2>/dev/null)
        echo ""
    fi
    
    # Interactive actions
    echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
    echo ""
    echo -e "${BOLD}${WHITE}─── DNS Lookup (dig) ───${NC}"
    if [[ "$fqdn_idx" -gt 0 ]]; then
        echo -e "  ${YELLOW}d1-d${fqdn_idx}${NC}) Dig individual FQDN (e.g., d1)"
        echo -e "  ${CYAN}da${NC})   Dig ALL FQDNs"
    fi
    echo ""
    if [[ "$nsg_idx" -gt 0 ]]; then
        echo -e "${BOLD}${WHITE}─── NSG Rules ───${NC}"
        echo -e "  ${YELLOW}n1-n${nsg_idx}${NC}) View individual NSG rules (e.g., n1)"
        echo -e "  ${CYAN}na${NC})   Show ALL NSG rules"
        echo -e "  ${CYAN}p${NC})    Check for required ports (80/443 ingress)"
        echo ""
    fi
    echo -e "  ${WHITE}Enter${NC}) Return"
    echo ""
    echo -n -e "${BOLD}${CYAN}Select option (or Enter to return): ${NC}"
    read -r selection
    
    # Handle port check command
    if [[ "$selection" == "p" || "$selection" == "P" || "$selection" == "port" || "$selection" == "ports" ]]; then
        pe_check_required_ports "$nsg_idx" "$private_ip" "$subnet_id"
        echo ""
        echo -e "Press Enter to continue..."
        read -r
    # Handle dig commands
    elif [[ "$selection" =~ ^d[0-9]+$ ]]; then
        local dig_num="${selection:1}"
        if [[ -n "${PE_FQDN_MAP[$dig_num]}" ]]; then
            local fqdn_entry="${PE_FQDN_MAP[$dig_num]}"
            local fqdn_val="${fqdn_entry%%|*}"
            local fqdn_label="${fqdn_entry##*|}"
            echo ""
            pe_dig_fqdn "$fqdn_val" "$fqdn_label"
        else
            echo -e "${RED}Invalid FQDN number${NC}"
        fi
        echo ""
        echo -e "Press Enter to continue..."
        read -r
    elif [[ "$selection" == "da" || "$selection" == "DA" ]]; then
        echo ""
        echo -e "${BOLD}${WHITE}═══ DNS Lookup for All FQDNs ═══${NC}"
        for i in $(seq 1 $fqdn_idx); do
            local fqdn_entry="${PE_FQDN_MAP[$i]}"
            [[ -z "$fqdn_entry" ]] && continue
            local fqdn_val="${fqdn_entry%%|*}"
            local fqdn_label="${fqdn_entry##*|}"
            echo ""
            echo -e "${BOLD}${MAGENTA}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
            pe_dig_fqdn "$fqdn_val" "$fqdn_label"
        done
        echo ""
        echo -e "Press Enter to continue..."
        read -r
    # Handle NSG commands
    elif [[ "$selection" =~ ^n[0-9]+$ ]]; then
        local nsg_num="${selection:1}"
        if [[ -n "${PE_NSG_MAP[$nsg_num]}" ]]; then
            os_view_nsg_rules "${PE_NSG_MAP[$nsg_num]}"
        else
            echo -e "${RED}Invalid NSG number${NC}"
            sleep 1
        fi
    elif [[ "$selection" == "na" || "$selection" == "NA" ]]; then
        # Show all NSGs using cached data
        echo ""
        echo -e "${BOLD}${WHITE}═══ All NSG Rules ═══${NC}"
        for i in $(seq 1 $nsg_idx); do
            local nsg_id="${PE_NSG_MAP[$i]}"
            [[ -z "$nsg_id" ]] && continue
            
            echo ""
            echo -e "${BOLD}${MAGENTA}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
            
            # Get NSG details from cache
            local cached_data nsg_name rules_json
            cached_data=$(get_cached_nsg_rules "$nsg_id")
            
            if [[ -n "$cached_data" ]]; then
                nsg_name=$(echo "$cached_data" | jq -r '.nsg_name // "Unknown"')
                # Wrap rules in data format for display_nsg_rules_table
                rules_json=$(echo "$cached_data" | jq '{data: .rules}')
            else
                # Fallback to direct fetch if cache miss
                local nsg_detail_json
                nsg_detail_json=$(oci network nsg get --nsg-id "$nsg_id" --output json 2>/dev/null)
                nsg_name=$(echo "$nsg_detail_json" | jq -r '.data["display-name"] // "Unknown"')
                rules_json=$(oci network nsg rules list --nsg-id "$nsg_id" --all --output json 2>/dev/null)
            fi
            
            echo -e "${BOLD}${CYAN}NSG #${i}: ${WHITE}$nsg_name${NC}"
            echo -e "${CYAN}NSG OCID:${NC} ${YELLOW}$nsg_id${NC}"
            echo ""
            
            display_nsg_rules_table "$rules_json" "false"
        done
        echo ""
        echo -e "Press Enter to continue..."
        read -r
    elif [[ -z "$selection" ]]; then
        # Enter pressed, return
        return
    fi
}

#--------------------------------------------------------------------------------
# Private Endpoint - Dig FQDN and check for private IP
#--------------------------------------------------------------------------------
pe_dig_fqdn() {
    local fqdn="$1"
    local label="$2"
    
    echo -e "${BOLD}${CYAN}FQDN:${NC} ${WHITE}$label${NC}"
    echo -e "${CYAN}Host:${NC} ${WHITE}$fqdn${NC}"
    echo ""
    
    # Perform dig
    local dig_output
    dig_output=$(dig +short "$fqdn" 2>/dev/null)
    
    if [[ -z "$dig_output" ]]; then
        echo -e "${RED}No DNS response received${NC}"
        return
    fi
    
    echo -e "${BOLD}${WHITE}DNS Resolution:${NC}"
    
    # Check each IP in the response
    local has_private=false
    local has_public=false
    
    while read -r ip_line; do
        [[ -z "$ip_line" ]] && continue
        
        # Check if it's a private IP (10.x.x.x, 172.16-31.x.x, 192.168.x.x)
        if [[ "$ip_line" =~ ^10\. ]] || \
           [[ "$ip_line" =~ ^172\.(1[6-9]|2[0-9]|3[0-1])\. ]] || \
           [[ "$ip_line" =~ ^192\.168\. ]]; then
            echo -e "  ${GREEN}✓ $ip_line${NC} ${GRAY}(Private IP)${NC}"
            has_private=true
        elif [[ "$ip_line" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo -e "  ${RED}✗ $ip_line${NC} ${RED}(PUBLIC IP - NOT using Private Endpoint!)${NC}"
            has_public=true
        else
            # Could be a CNAME or other record
            echo -e "  ${YELLOW}→ $ip_line${NC} ${GRAY}(CNAME/Alias)${NC}"
        fi
    done <<< "$dig_output"
    
    echo ""
    
    # Summary
    if [[ "$has_public" == "true" ]]; then
        echo -e "${BOLD}${RED}⚠ WARNING: DNS is resolving to PUBLIC IP!${NC}"
        echo -e "${RED}  Traffic is NOT routing through the Private Endpoint.${NC}"
        echo -e "${RED}  Check VCN DNS resolver configuration.${NC}"
    elif [[ "$has_private" == "true" ]]; then
        echo -e "${BOLD}${GREEN}✓ DNS is correctly resolving to Private IP${NC}"
        echo -e "${GREEN}  Traffic will route through the Private Endpoint.${NC}"
    fi
}

#--------------------------------------------------------------------------------
# Private Endpoint - Check for required ports (80/443 ingress)
#--------------------------------------------------------------------------------
pe_check_required_ports() {
    local nsg_count="$1"
    local private_ip="$2"
    local subnet_id="$3"
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    
    # Declare function-level variables for tracking missing rules
    declare -A missing_nsg_ports
    declare -A missing_sl_ports
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Required Ports Check (80/443 Ingress) ═══${NC}"
    echo ""
    
    # Build NSG name lookup map for the compartment (to resolve source NSG OCIDs to names)
    echo -e "${GRAY}Building NSG name lookup...${NC}"
    declare -gA PE_NSG_NAME_LOOKUP
    PE_NSG_NAME_LOOKUP=()
    
    local all_nsgs_json
    all_nsgs_json=$(oci network nsg list --compartment-id "$compartment_id" --all --output json 2>/dev/null)
    
    if [[ -n "$all_nsgs_json" ]]; then
        while IFS='|' read -r lookup_id lookup_name; do
            [[ -n "$lookup_id" ]] && PE_NSG_NAME_LOOKUP["$lookup_id"]="$lookup_name"
        done < <(echo "$all_nsgs_json" | jq -r '.data[] | "\(.id)|\(.["display-name"])"' 2>/dev/null)
    fi
    
    # Collect all NSG IDs for parallel fetch
    local nsg_ids=""
    for i in $(seq 1 $nsg_count); do
        local nsg_id="${PE_NSG_MAP[$i]}"
        [[ -n "$nsg_id" ]] && nsg_ids+="$nsg_id"$'\n'
    done
    
    # Fetch all NSG rules in parallel with caching
    if [[ "$nsg_count" -gt 0 ]]; then
        fetch_nsg_rules_detail_parallel "$nsg_ids"
    fi
    echo ""
    
    # Track overall findings - arrays for good/missing rules
    local missing_rules=()
    declare -A nsg_good_rules   # nsg_id -> pipe-delimited good rules
    declare -A nsg_has_80       # nsg_id -> true/false
    declare -A nsg_has_443      # nsg_id -> true/false
    declare -A NSG_NAMES        # nsg_id -> name
    
    # ═══════════════════════════════════════════════════════════════════════════
    # NSG SECTION
    # ═══════════════════════════════════════════════════════════════════════════
    echo -e "${BOLD}${MAGENTA}═══ Network Security Groups ═══${NC}"
    echo ""
    
    if [[ "$nsg_count" -eq 0 ]]; then
        echo -e "${YELLOW}No NSGs configured on this Private Endpoint${NC}"
    else
        # Check each NSG using cached data
        for i in $(seq 1 $nsg_count); do
            local nsg_id="${PE_NSG_MAP[$i]}"
            [[ -z "$nsg_id" ]] && continue
            
            # Get cached NSG rules
            local cached_data nsg_name rules_data
            cached_data=$(get_cached_nsg_rules "$nsg_id")
            
            if [[ -n "$cached_data" ]]; then
                nsg_name=$(echo "$cached_data" | jq -r '.nsg_name // "Unknown"')
                rules_data=$(echo "$cached_data" | jq -c '.rules // []')
            else
                # Fallback to direct fetch if cache miss
                local nsg_json
                nsg_json=$(oci network nsg get --nsg-id "$nsg_id" --output json 2>/dev/null)
                nsg_name=$(echo "$nsg_json" | jq -r '.data["display-name"] // "Unknown"')
                
                local rules_json
                rules_json=$(oci network nsg rules list --nsg-id "$nsg_id" --all --output json 2>/dev/null)
                rules_data=$(echo "$rules_json" | jq -c '.data // []')
            fi
            
            NSG_NAMES[$nsg_id]="$nsg_name"
            nsg_has_80[$nsg_id]="false"
            nsg_has_443[$nsg_id]="false"
            nsg_good_rules[$nsg_id]=""
            
            if [[ -z "$rules_data" ]] || [[ "$rules_data" == "[]" ]] || [[ "$rules_data" == "null" ]]; then
                missing_rules+=("$nsg_id|$nsg_name|80")
                missing_rules+=("$nsg_id|$nsg_name|443")
                continue
            fi
            
            # Check for port 80 and 443 ingress rules
            while IFS='|' read -r rule_source rule_protocol rule_ports rule_desc rule_port_type; do
                [[ -z "$rule_source" ]] && continue
                
                # Resolve source to name if it's an NSG OCID
                local resolved_source="$rule_source"
                if [[ "$rule_source" =~ ^ocid1\.networksecuritygroup\. ]]; then
                    local lookup_name="${PE_NSG_NAME_LOOKUP[$rule_source]}"
                    if [[ -n "$lookup_name" ]]; then
                        resolved_source="$lookup_name"
                    else
                        resolved_source="...${rule_source: -12}"
                    fi
                fi
                
                # Store the good rule
                local rule_entry="$resolved_source|$rule_protocol|$rule_ports|$rule_desc"
                if [[ -n "${nsg_good_rules[$nsg_id]}" ]]; then
                    nsg_good_rules[$nsg_id]="${nsg_good_rules[$nsg_id]}"$'\n'"$rule_entry"
                else
                    nsg_good_rules[$nsg_id]="$rule_entry"
                fi
                
                # Check which ports this rule covers
                if [[ "$rule_port_type" == "80" || "$rule_port_type" == "both" ]]; then
                    nsg_has_80[$nsg_id]="true"
                fi
                if [[ "$rule_port_type" == "443" || "$rule_port_type" == "both" ]]; then
                    nsg_has_443[$nsg_id]="true"
                fi
            done < <(echo "$rules_data" | jq -r '
                .[] | 
                select(.direction == "INGRESS") |
                select(.protocol == "6" or .protocol == "all") |
                # Check if covers port 80
                (if (.protocol == "all") or (.["tcp-options"] == null) or (.["tcp-options"]["destination-port-range"] == null) or
                   ((.["tcp-options"]["destination-port-range"]["min"] // 0) <= 80 and (.["tcp-options"]["destination-port-range"]["max"] // 0) >= 80)
                then true else false end) as $covers80 |
                # Check if covers port 443  
                (if (.protocol == "all") or (.["tcp-options"] == null) or (.["tcp-options"]["destination-port-range"] == null) or
                   ((.["tcp-options"]["destination-port-range"]["min"] // 0) <= 443 and (.["tcp-options"]["destination-port-range"]["max"] // 0) >= 443)
                then true else false end) as $covers443 |
                # Only output rules that cover at least one port
                select($covers80 or $covers443) |
                # Determine port type for tracking
                (if $covers80 and $covers443 then "both" elif $covers80 then "80" else "443" end) as $portType |
                "\(.source // "N/A")|\(if .protocol == "all" then "ALL" else "TCP" end)|\(if .protocol == "all" or .["tcp-options"] == null or .["tcp-options"]["destination-port-range"] == null then "ALL" else "\(.["tcp-options"]["destination-port-range"]["min"])-\(.["tcp-options"]["destination-port-range"]["max"])" end)|\(.description // "No description")|\($portType)"
            ' 2>/dev/null)
            
            # Track missing ports
            [[ "${nsg_has_80[$nsg_id]}" == "false" ]] && missing_rules+=("$nsg_id|$nsg_name|80")
            [[ "${nsg_has_443[$nsg_id]}" == "false" ]] && missing_rules+=("$nsg_id|$nsg_name|443")
        done
        
        # Display GOOD rules section
        local has_good_rules=false
        for nsg_id in "${!nsg_good_rules[@]}"; do
            [[ -n "${nsg_good_rules[$nsg_id]}" ]] && has_good_rules=true && break
        done
        
        if [[ "$has_good_rules" == "true" ]]; then
            echo -e "${BOLD}${GREEN}Good (ports 80/443 covered):${NC}"
            printf "  ${BOLD}%-25s %-25s %-8s %-10s %s${NC}\n" "NSG Name" "Source" "Protocol" "Ports" "Description"
            print_separator 100
            
            for nsg_id in "${!nsg_good_rules[@]}"; do
                local nsg_name="${NSG_NAMES[$nsg_id]}"
                [[ -z "${nsg_good_rules[$nsg_id]}" ]] && continue
                
                local first_line=true
                while IFS='|' read -r src proto ports desc; do
                    [[ -z "$src" ]] && continue
                    if [[ "$first_line" == "true" ]]; then
                        printf "  ${GREEN}%-25s${NC} ${CYAN}%-25s${NC} %-8s %-10s ${GRAY}%s${NC}\n" \
                            "${nsg_name:0:25}" "${src:0:25}" "$proto" "$ports" "${desc:0:40}"
                        first_line=false
                    else
                        printf "  ${GREEN}%-25s${NC} ${CYAN}%-25s${NC} %-8s %-10s ${GRAY}%s${NC}\n" \
                            "" "${src:0:25}" "$proto" "$ports" "${desc:0:40}"
                    fi
                done <<< "${nsg_good_rules[$nsg_id]}"
            done
            echo ""
        fi
        
        # Display MISSING rules section
        # Build unique missing NSG list with ports
        for missing in "${missing_rules[@]}"; do
            local m_nsg_id="${missing%%|*}"
            local temp="${missing#*|}"
            local m_nsg_name="${temp%%|*}"
            local m_port="${temp##*|}"
            
            if [[ -z "${missing_nsg_ports[$m_nsg_id]}" ]]; then
                missing_nsg_ports[$m_nsg_id]="$m_nsg_name|$m_port"
            else
                # Append port if not already there
                if [[ ! "${missing_nsg_ports[$m_nsg_id]}" =~ \|$m_port ]]; then
                    missing_nsg_ports[$m_nsg_id]="${missing_nsg_ports[$m_nsg_id]},$m_port"
                fi
            fi
        done
        
        if [[ ${#missing_nsg_ports[@]} -gt 0 ]]; then
            echo -e "${BOLD}${RED}Missing (need ingress rules):${NC}"
            printf "  ${BOLD}%-35s %-12s %-12s %s${NC}\n" "NSG Name" "Port 80" "Port 443" "OCID"
            print_separator 100
            
            for nsg_id in "${!missing_nsg_ports[@]}"; do
                local info="${missing_nsg_ports[$nsg_id]}"
                local nsg_name="${info%%|*}"
                local ports="${info#*|}"
                
                local p80_status="${GREEN}✓${NC}"
                local p443_status="${GREEN}✓${NC}"
                [[ "$ports" =~ 80 ]] && p80_status="${RED}✗ Missing${NC}"
                [[ "$ports" =~ 443 ]] && p443_status="${RED}✗ Missing${NC}"
                
                printf "  ${WHITE}%-35s${NC} %-20s %-20s ${GRAY}...%s${NC}\n" \
                    "${nsg_name:0:35}" "$(echo -e $p80_status)" "$(echo -e $p443_status)" "${nsg_id: -12}"
            done
            echo ""
        else
            echo -e "${GREEN}✓ All NSGs have port 80/443 ingress rules${NC}"
            echo ""
        fi
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # SECURITY LIST SECTION - Only check SLs on the PE's subnet
    # ═══════════════════════════════════════════════════════════════════════════
    echo -e "${BOLD}${MAGENTA}═══ Security Lists (Subnet: ${subnet_id:+...${subnet_id: -12}}) ═══${NC}"
    echo ""
    
    local sl_missing_rules=()
    declare -A sl_good_rules
    declare -A sl_has_80
    declare -A sl_has_443
    declare -A SL_NAMES
    local sl_count=0
    local sl_json=""
    
    if [[ -z "$subnet_id" || "$subnet_id" == "N/A" || "$subnet_id" == "null" ]]; then
        echo -e "${YELLOW}No subnet associated with Private Endpoint - cannot check Security Lists${NC}"
    else
        # Get the subnet's security list IDs
        local subnet_json
        subnet_json=$(oci network subnet get --subnet-id "$subnet_id" --output json 2>/dev/null)
        
        if [[ -z "$subnet_json" ]]; then
            echo -e "${RED}Failed to get subnet details${NC}"
        else
            local sl_ids_json
            sl_ids_json=$(echo "$subnet_json" | jq -r '.data["security-list-ids"] // []')
            sl_count=$(echo "$sl_ids_json" | jq 'length' 2>/dev/null || echo "0")
            
            if [[ "$sl_count" -eq 0 ]]; then
                echo -e "${GRAY}No security lists assigned to subnet${NC}"
            else
                echo -e "${GRAY}Checking $sl_count security list(s) on PE subnet...${NC}"
                echo ""
                
                # Check each security list
                while read -r sl_id; do
                    [[ -z "$sl_id" || "$sl_id" == "null" ]] && continue
                    
                    # Get security list details
                    local sl_detail
                    sl_detail=$(oci network security-list get --security-list-id "$sl_id" --output json 2>/dev/null)
                    
                    if [[ -z "$sl_detail" ]]; then
                        continue
                    fi
                    
                    local sl_name
                    sl_name=$(echo "$sl_detail" | jq -r '.data["display-name"] // "Unknown"')
                    SL_NAMES[$sl_id]="$sl_name"
                    sl_has_80[$sl_id]="false"
                    sl_has_443[$sl_id]="false"
                    sl_good_rules[$sl_id]=""
                    
                    # Store for wizard
                    sl_json="$sl_detail"
                    
                    # Get ingress rules
                    local ingress_rules
                    ingress_rules=$(echo "$sl_detail" | jq -c '.data["ingress-security-rules"] // []')
                    
                    if [[ -z "$ingress_rules" ]] || [[ "$ingress_rules" == "[]" ]]; then
                        sl_missing_rules+=("$sl_id|$sl_name|80")
                        sl_missing_rules+=("$sl_id|$sl_name|443")
                        continue
                    fi
                    
                    # Check rules
                    while IFS='|' read -r rule_source rule_protocol rule_ports rule_port_type; do
                        [[ -z "$rule_source" ]] && continue
                        
                        local rule_entry="$rule_source|$rule_protocol|$rule_ports"
                        if [[ -n "${sl_good_rules[$sl_id]}" ]]; then
                            sl_good_rules[$sl_id]="${sl_good_rules[$sl_id]}"$'\n'"$rule_entry"
                        else
                            sl_good_rules[$sl_id]="$rule_entry"
                        fi
                        
                        if [[ "$rule_port_type" == "80" || "$rule_port_type" == "both" ]]; then
                            sl_has_80[$sl_id]="true"
                        fi
                        if [[ "$rule_port_type" == "443" || "$rule_port_type" == "both" ]]; then
                            sl_has_443[$sl_id]="true"
                        fi
                    done < <(echo "$ingress_rules" | jq -r '
                        .[] |
                        select(.protocol == "6" or .protocol == "all") |
                        (if (.protocol == "all") or (.["tcp-options"] == null) or (.["tcp-options"]["destination-port-range"] == null) or
                           ((.["tcp-options"]["destination-port-range"]["min"] // 0) <= 80 and (.["tcp-options"]["destination-port-range"]["max"] // 0) >= 80)
                        then true else false end) as $covers80 |
                        (if (.protocol == "all") or (.["tcp-options"] == null) or (.["tcp-options"]["destination-port-range"] == null) or
                           ((.["tcp-options"]["destination-port-range"]["min"] // 0) <= 443 and (.["tcp-options"]["destination-port-range"]["max"] // 0) >= 443)
                        then true else false end) as $covers443 |
                        select($covers80 or $covers443) |
                        (if $covers80 and $covers443 then "both" elif $covers80 then "80" else "443" end) as $portType |
                        "\(.source // "N/A")|\(if .protocol == "all" then "ALL" else "TCP" end)|\(if .protocol == "all" or .["tcp-options"] == null or .["tcp-options"]["destination-port-range"] == null then "ALL" else "\(.["tcp-options"]["destination-port-range"]["min"])-\(.["tcp-options"]["destination-port-range"]["max"])" end)|\($portType)"
                    ' 2>/dev/null)
                    
                    [[ "${sl_has_80[$sl_id]}" == "false" ]] && sl_missing_rules+=("$sl_id|$sl_name|80")
                    [[ "${sl_has_443[$sl_id]}" == "false" ]] && sl_missing_rules+=("$sl_id|$sl_name|443")
                done < <(echo "$sl_ids_json" | jq -r '.[]' 2>/dev/null)
                
                # Display GOOD rules section
                local has_sl_good=false
                for sl_id in "${!sl_good_rules[@]}"; do
                    [[ -n "${sl_good_rules[$sl_id]}" ]] && has_sl_good=true && break
                done
                
                if [[ "$has_sl_good" == "true" ]]; then
                    echo -e "${BOLD}${GREEN}Good (ports 80/443 covered):${NC}"
                    printf "  ${BOLD}%-30s %-25s %-8s %-10s %s${NC}\n" "Security List Name" "Source CIDR" "Protocol" "Ports" "OCID"
                    print_separator 100
                    
                    for sl_id in "${!sl_good_rules[@]}"; do
                        local sl_name="${SL_NAMES[$sl_id]}"
                        [[ -z "${sl_good_rules[$sl_id]}" ]] && continue
                        
                        local first_line=true
                        while IFS='|' read -r src proto ports; do
                            [[ -z "$src" ]] && continue
                            if [[ "$first_line" == "true" ]]; then
                                printf "  ${GREEN}%-30s${NC} ${CYAN}%-25s${NC} %-8s %-10s ${GRAY}...%s${NC}\n" \
                                    "${sl_name:0:30}" "${src:0:25}" "$proto" "$ports" "${sl_id: -12}"
                                first_line=false
                            else
                                printf "  ${GREEN}%-30s${NC} ${CYAN}%-25s${NC} %-8s %-10s\n" \
                                    "" "${src:0:25}" "$proto" "$ports"
                            fi
                        done <<< "${sl_good_rules[$sl_id]}"
                    done
                    echo ""
                fi
                
                # Display MISSING rules section
                for missing in "${sl_missing_rules[@]}"; do
                    local m_sl_id="${missing%%|*}"
                    local temp="${missing#*|}"
                    local m_sl_name="${temp%%|*}"
                    local m_port="${temp##*|}"
                    
                    if [[ -z "${missing_sl_ports[$m_sl_id]}" ]]; then
                        missing_sl_ports[$m_sl_id]="$m_sl_name|$m_port"
                    else
                        if [[ ! "${missing_sl_ports[$m_sl_id]}" =~ \|$m_port ]]; then
                            missing_sl_ports[$m_sl_id]="${missing_sl_ports[$m_sl_id]},$m_port"
                        fi
                    fi
                done
                
                if [[ ${#missing_sl_ports[@]} -gt 0 ]]; then
                    echo -e "${BOLD}${RED}Missing (need ingress rules):${NC}"
                    printf "  ${BOLD}%-40s %-12s %-12s %s${NC}\n" "Security List Name" "Port 80" "Port 443" "OCID"
                    print_separator 100
                    
                    for sl_id in "${!missing_sl_ports[@]}"; do
                        local info="${missing_sl_ports[$sl_id]}"
                        local sl_name="${info%%|*}"
                        local ports="${info#*|}"
                        
                        local p80_status="${GREEN}✓${NC}"
                        local p443_status="${GREEN}✓${NC}"
                        [[ "$ports" =~ 80 ]] && p80_status="${RED}✗ Missing${NC}"
                        [[ "$ports" =~ 443 ]] && p443_status="${RED}✗ Missing${NC}"
                        
                        printf "  ${WHITE}%-40s${NC} %-20s %-20s ${GRAY}...%s${NC}\n" \
                            "${sl_name:0:40}" "$(echo -e $p80_status)" "$(echo -e $p443_status)" "${sl_id: -12}"
                    done
                    echo ""
                else
                    echo -e "${GREEN}✓ All Security Lists have port 80/443 ingress rules${NC}"
                    echo ""
                fi
            fi
        fi
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # SUMMARY AND ACTIONS
    # ═══════════════════════════════════════════════════════════════════════════
    echo -e "${BOLD}${WHITE}═══ Summary ═══${NC}"
    echo ""
    
    local nsgs_missing=${#missing_nsg_ports[@]}
    local sls_missing=${#missing_sl_ports[@]}
    
    if [[ "$nsgs_missing" -eq 0 && "$sls_missing" -eq 0 ]]; then
        echo -e "${GREEN}✓ All NSGs and Security Lists have port 80/443 ingress rules configured${NC}"
    else
        [[ "$nsgs_missing" -gt 0 ]] && echo -e "${RED}✗ $nsgs_missing NSG(s) missing port 80/443 rules${NC}"
        [[ "$sls_missing" -gt 0 ]] && echo -e "${RED}✗ $sls_missing Security List(s) missing port 80/443 rules${NC}"
    fi
    
    echo ""
    
    # Prompt to add rules if any are missing
    if [[ ${#missing_rules[@]} -gt 0 || ${#sl_missing_rules[@]} -gt 0 ]]; then
        echo -e "${BOLD}${YELLOW}Would you like to add missing ingress rules?${NC}"
        echo ""
        
        local add_choice=""
        if [[ ${#missing_rules[@]} -gt 0 && ${#sl_missing_rules[@]} -gt 0 ]]; then
            echo -e "  ${YELLOW}1${NC}) Add rules to NSGs ($nsgs_missing NSG(s) missing rules)"
            echo -e "  ${YELLOW}2${NC}) Add rules to Security Lists ($sls_missing SL(s) missing rules)"
            echo -e "  ${YELLOW}3${NC}) Skip"
            echo ""
            echo -n -e "${CYAN}Select option [3]: ${NC}"
            read -r add_choice
            [[ -z "$add_choice" ]] && add_choice="3"
        elif [[ ${#missing_rules[@]} -gt 0 ]]; then
            echo -n -e "${CYAN}Add rules to NSGs? (y/N): ${NC}"
            local yn
            read -r yn
            [[ "$yn" == "y" || "$yn" == "Y" ]] && add_choice="1"
        elif [[ ${#sl_missing_rules[@]} -gt 0 ]]; then
            echo -n -e "${CYAN}Add rules to Security Lists? (y/N): ${NC}"
            local yn
            read -r yn
            [[ "$yn" == "y" || "$yn" == "Y" ]] && add_choice="2"
        fi
        
        local rules_added=false
        case "$add_choice" in
            1)
                pe_add_nsg_rules_wizard "$compartment_id" missing_rules all_nsgs_json
                rules_added=true
                ;;
            2)
                pe_add_sl_rules_wizard "$compartment_id" sl_missing_rules sl_json
                rules_added=true
                ;;
        esac
        
        # Refresh NSG cache if rules were added
        if [[ "$rules_added" == "true" ]]; then
            echo ""
            echo -e "${GRAY}Refreshing NSG rules cache...${NC}"
            rm -rf "$NSG_RULES_DETAIL_DIR"
            mkdir -p "$NSG_RULES_DETAIL_DIR"
            echo -e "${GREEN}✓ NSG cache refreshed${NC}"
        fi
    fi
}

#--------------------------------------------------------------------------------
# PE - Add Security List Rules Wizard
#--------------------------------------------------------------------------------
pe_add_sl_rules_wizard() {
    local compartment_id="$1"
    local -n sl_missing_rules_ref=$2
    local -n sl_json_ref=$3
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Add Security List Rules Wizard ═══${NC}"
    echo ""
    
    # Collect unique SLs that need rules
    declare -A sl_missing_info
    local sl_list_idx=0
    declare -A SL_SELECT_MAP
    
    for missing in "${sl_missing_rules_ref[@]}"; do
        local m_sl_id="${missing%%|*}"
        local temp="${missing#*|}"
        local m_sl_name="${temp%%|*}"
        
        if [[ -z "${sl_missing_info[$m_sl_id]}" ]]; then
            ((sl_list_idx++))
            sl_missing_info[$m_sl_id]="$m_sl_name"
            SL_SELECT_MAP[$sl_list_idx]="$m_sl_id"
        fi
    done
    
    # Step 1: Select which SL(s) to add rules to
    echo -e "${WHITE}Step 1: Select target Security List(s) to add rules${NC}"
    echo ""
    printf "  ${BOLD}%-3s %-50s${NC}\n" "#" "Security List Name (missing rules)"
    print_separator 60
    
    for idx in $(seq 1 $sl_list_idx); do
        local slid="${SL_SELECT_MAP[$idx]}"
        local slname="${sl_missing_info[$slid]}"
        printf "  ${YELLOW}%-3s${NC} %-50s\n" "$idx" "${slname:0:48}"
    done
    
    echo ""
    echo -e "  ${GRAY}Enter: 'all' for all SLs, or specific numbers (e.g., 1,3 or 1-3)${NC}"
    echo -n -e "${CYAN}Select Security List(s) [all]: ${NC}"
    local sl_selection
    read -r sl_selection
    [[ -z "$sl_selection" ]] && sl_selection="all"
    
    # Parse selection
    declare -A selected_sls
    if [[ "$sl_selection" == "all" || "$sl_selection" == "ALL" ]]; then
        for idx in $(seq 1 $sl_list_idx); do
            selected_sls["${SL_SELECT_MAP[$idx]}"]=1
        done
    elif [[ "$sl_selection" =~ ^[0-9]+-[0-9]+$ ]]; then
        local start_num="${sl_selection%-*}"
        local end_num="${sl_selection#*-}"
        for idx in $(seq $start_num $end_num); do
            [[ -n "${SL_SELECT_MAP[$idx]}" ]] && selected_sls["${SL_SELECT_MAP[$idx]}"]=1
        done
    else
        IFS=',' read -ra nums <<< "$sl_selection"
        for num in "${nums[@]}"; do
            num=$(echo "$num" | tr -d ' ')
            [[ -n "${SL_SELECT_MAP[$num]}" ]] && selected_sls["${SL_SELECT_MAP[$num]}"]=1
        done
    fi
    
    if [[ ${#selected_sls[@]} -eq 0 ]]; then
        echo -e "${RED}No Security Lists selected. Aborting.${NC}"
        return
    fi
    
    echo -e "  ${GREEN}Selected ${#selected_sls[@]} Security List(s)${NC}"
    echo ""
    
    # Step 2: Enter source CIDR
    echo -e "${WHITE}Step 2: Enter source CIDR${NC}"
    echo -e "${GRAY}  Examples: 10.0.0.0/8, 10.0.0.0/16, 0.0.0.0/0 (any)${NC}"
    echo -n -e "${CYAN}Source CIDR [10.0.0.0/8]: ${NC}"
    local source_cidr
    read -r source_cidr
    [[ -z "$source_cidr" ]] && source_cidr="10.0.0.0/8"
    
    # Step 3: Choose which ports to add
    echo ""
    echo -e "${WHITE}Step 3: Select ports to add${NC}"
    echo -e "  ${YELLOW}1${NC}) Port 443 only (HTTPS) ${GREEN}← recommended${NC}"
    echo -e "  ${YELLOW}2${NC}) Port 80 only (HTTP)"
    echo -e "  ${YELLOW}3${NC}) Both ports 80 and 443"
    echo -e "  ${YELLOW}4${NC}) ALL protocols (no port restriction)"
    echo ""
    echo -n -e "${CYAN}Select ports [1]: ${NC}"
    local port_choice
    read -r port_choice
    [[ -z "$port_choice" ]] && port_choice="1"
    
    local ports_to_add=()
    local protocol_choice="6"
    local ports_display=""
    
    case "$port_choice" in
        1) ports_to_add=("443"); ports_display="443 (HTTPS)" ;;
        2) ports_to_add=("80"); ports_display="80 (HTTP)" ;;
        3) ports_to_add=("80" "443"); ports_display="80 (HTTP), 443 (HTTPS)" ;;
        4) 
            ports_to_add=("ALL")
            protocol_choice="all"
            ports_display="ALL protocols"
            ;;
        *) ports_to_add=("443"); ports_display="443 (HTTPS)" ;;
    esac
    
    # Summary before execution
    echo ""
    echo -e "${BOLD}${WHITE}═══ Configuration Summary ═══${NC}"
    echo ""
    echo -e "  ${CYAN}Source CIDR:${NC}      ${WHITE}$source_cidr${NC}"
    echo -e "  ${CYAN}Ports:${NC}            ${WHITE}$ports_display${NC}"
    echo -e "  ${CYAN}Target SLs:${NC}       ${WHITE}${#selected_sls[@]} Security List(s)${NC}"
    for sl_id in "${!selected_sls[@]}"; do
        echo -e "                    • ${GREEN}${sl_missing_info[$sl_id]}${NC}"
    done
    echo ""
    
    echo -n -e "${YELLOW}Proceed with adding rules? (Y/n): ${NC}"
    local proceed
    read -r proceed
    
    if [[ "$proceed" == "n" || "$proceed" == "N" ]]; then
        echo -e "${YELLOW}Aborted.${NC}"
        return
    fi
    
    echo ""
    
    # Process each selected Security List
    for sl_id in "${!selected_sls[@]}"; do
        local m_sl_name="${sl_missing_info[$sl_id]}"
        
        echo -e "${BOLD}${CYAN}Security List: $m_sl_name${NC}"
        echo -e "  ${GRAY}$sl_id${NC}"
        
        # Get existing ingress rules
        local existing_rules
        existing_rules=$(echo "$sl_json_ref" | jq --arg id "$sl_id" '.data[] | select(.id == $id) | .["ingress-security-rules"] // []')
        
        # Build new rules to add
        local new_rules="$existing_rules"
        
        for port in "${ports_to_add[@]}"; do
            local protocol_name="HTTP"
            [[ "$port" == "443" ]] && protocol_name="HTTPS"
            [[ "$port" == "ALL" ]] && protocol_name="ALL"
            
            local new_rule=""
            if [[ "$port" == "ALL" ]]; then
                new_rule=$(cat <<EOF
{
  "protocol": "all",
  "source": "$source_cidr",
  "source-type": "CIDR_BLOCK",
  "description": "Allow ALL access to Object Storage Private Endpoint",
  "is-stateless": false
}
EOF
)
            else
                new_rule=$(cat <<EOF
{
  "protocol": "6",
  "source": "$source_cidr",
  "source-type": "CIDR_BLOCK",
  "tcp-options": {
    "destination-port-range": {
      "min": $port,
      "max": $port
    }
  },
  "description": "Allow $protocol_name access to Object Storage Private Endpoint",
  "is-stateless": false
}
EOF
)
            fi
            
            new_rules=$(echo "$new_rules" | jq --argjson rule "$new_rule" '. + [$rule]')
            echo -e "  ${WHITE}Adding: Port $port ($protocol_name) ingress rule${NC}"
        done
        
        # Build command for display
        echo ""
        echo -e "${GRAY}Command:${NC}"
        echo "oci network security-list update \\"
        echo "  --security-list-id \"$sl_id\" \\"
        echo "  --ingress-security-rules '...'"
        echo ""
        
        # Confirm before executing
        echo -n -e "${YELLOW}Execute? (Y/n): ${NC}"
        local confirm_exec
        read -r confirm_exec
        
        if [[ "$confirm_exec" != "n" && "$confirm_exec" != "N" ]]; then
            # Log the action
            local log_file="${LOGS_DIR}/object_storage_actions_$(date +%Y%m%d).log"
            mkdir -p "$(dirname "$log_file")" 2>/dev/null
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] UPDATE SECURITY LIST: oci network security-list update --security-list-id \"$sl_id\" --ingress-security-rules '...' " >> "$log_file"
            
            # Execute the command
            local result
            result=$(oci network security-list update \
                --security-list-id "$sl_id" \
                --ingress-security-rules "$new_rules" \
                --force \
                --output json 2>&1)
            
            if echo "$result" | jq -e '.data' > /dev/null 2>&1; then
                echo -e "${GREEN}✓ Rules added successfully to $m_sl_name${NC}"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Added rules to $m_sl_name" >> "$log_file"
            else
                echo -e "${RED}✗ Failed to add rules to $m_sl_name${NC}"
                echo "$result"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
            fi
        else
            echo -e "${YELLOW}Skipped adding rules to $m_sl_name${NC}"
        fi
        echo ""
    done
    
    echo -e "${WHITE}Rule addition complete.${NC}"
}

#--------------------------------------------------------------------------------
# PE - Add NSG Rules Wizard
#--------------------------------------------------------------------------------
pe_add_nsg_rules_wizard() {
    local compartment_id="$1"
    local -n missing_rules_ref=$2
    local -n all_nsgs_json_ref=$3
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Add NSG Rules Wizard ═══${NC}"
    echo ""
    
    # Collect unique NSGs that need rules
    declare -A nsg_missing_info
    local nsg_list_idx=0
    declare -A NSG_SELECT_MAP
    
    for missing in "${missing_rules_ref[@]}"; do
        local m_nsg_id="${missing%%|*}"
        local temp="${missing#*|}"
        local m_nsg_name="${temp%%|*}"
        
        if [[ -z "${nsg_missing_info[$m_nsg_id]}" ]]; then
            ((nsg_list_idx++))
            nsg_missing_info[$m_nsg_id]="$m_nsg_name"
            NSG_SELECT_MAP[$nsg_list_idx]="$m_nsg_id"
        fi
    done
    
    # Step 0: Select which NSG(s) to add rules to
    echo -e "${WHITE}Step 1: Select target NSG(s) to add rules${NC}"
    echo ""
    printf "  ${BOLD}%-3s %-45s${NC}\n" "#" "NSG Name (missing rules)"
    print_separator 55
    
    for idx in $(seq 1 $nsg_list_idx); do
        local nid="${NSG_SELECT_MAP[$idx]}"
        local nname="${nsg_missing_info[$nid]}"
        printf "  ${YELLOW}%-3s${NC} %-45s\n" "$idx" "${nname:0:43}"
    done
    
    echo ""
    echo -e "  ${GRAY}Enter: 'all' for all NSGs, or specific numbers (e.g., 1,3 or 1-3)${NC}"
    echo -n -e "${CYAN}Select NSG(s) [all]: ${NC}"
    local nsg_selection
    read -r nsg_selection
    [[ -z "$nsg_selection" ]] && nsg_selection="all"
    
    # Parse selection
    declare -A selected_nsgs
    if [[ "$nsg_selection" == "all" || "$nsg_selection" == "ALL" ]]; then
        for idx in $(seq 1 $nsg_list_idx); do
            selected_nsgs["${NSG_SELECT_MAP[$idx]}"]=1
        done
    elif [[ "$nsg_selection" =~ ^[0-9]+-[0-9]+$ ]]; then
        # Range format: 1-3
        local start_num="${nsg_selection%-*}"
        local end_num="${nsg_selection#*-}"
        for idx in $(seq $start_num $end_num); do
            [[ -n "${NSG_SELECT_MAP[$idx]}" ]] && selected_nsgs["${NSG_SELECT_MAP[$idx]}"]=1
        done
    else
        # Comma-separated: 1,3,5
        IFS=',' read -ra nums <<< "$nsg_selection"
        for num in "${nums[@]}"; do
            num=$(echo "$num" | tr -d ' ')
            [[ -n "${NSG_SELECT_MAP[$num]}" ]] && selected_nsgs["${NSG_SELECT_MAP[$num]}"]=1
        done
    fi
    
    if [[ ${#selected_nsgs[@]} -eq 0 ]]; then
        echo -e "${RED}No NSGs selected. Aborting.${NC}"
        return
    fi
    
    echo -e "  ${GREEN}Selected ${#selected_nsgs[@]} NSG(s)${NC}"
    echo ""
    
    # Step 1: Choose source type (CIDR or NSG)
    echo -e "${WHITE}Step 2: Select source type${NC}"
    echo -e "  ${YELLOW}1${NC}) CIDR Block (e.g., 10.0.0.0/8)"
    echo -e "  ${YELLOW}2${NC}) Network Security Group (NSG)"
    echo ""
    echo -n -e "${CYAN}Select source type [1]: ${NC}"
    local source_type_choice
    read -r source_type_choice
    [[ -z "$source_type_choice" ]] && source_type_choice="1"
    
    local source_value=""
    local source_type=""
    local source_display=""
    
    if [[ "$source_type_choice" == "2" ]]; then
        # NSG source - list available NSGs
        source_type="NETWORK_SECURITY_GROUP"
        echo ""
        echo -e "${WHITE}Available NSGs in compartment:${NC}"
        
        local nsg_idx=0
        declare -A SOURCE_NSG_MAP
        SOURCE_NSG_MAP=()
        
        printf "  ${BOLD}%-3s %-45s${NC}\n" "#" "NSG Name"
        print_separator 55
        
        while IFS='|' read -r src_nsg_id src_nsg_name; do
            [[ -z "$src_nsg_id" ]] && continue
            ((nsg_idx++))
            SOURCE_NSG_MAP[$nsg_idx]="$src_nsg_id|$src_nsg_name"
            printf "  ${YELLOW}%-3s${NC} %-45s\n" "$nsg_idx" "${src_nsg_name:0:43}"
        done < <(echo "$all_nsgs_json_ref" | jq -r '.data[] | "\(.id)|\(.["display-name"])"' 2>/dev/null)
        
        echo ""
        echo -n -e "${CYAN}Select source NSG #: ${NC}"
        local nsg_choice
        read -r nsg_choice
        
        if [[ -n "${SOURCE_NSG_MAP[$nsg_choice]}" ]]; then
            source_value="${SOURCE_NSG_MAP[$nsg_choice]%%|*}"
            source_display="${SOURCE_NSG_MAP[$nsg_choice]#*|}"
            echo -e "  ${GREEN}Selected: $source_display${NC}"
        else
            echo -e "${RED}Invalid selection. Using default CIDR.${NC}"
            source_type="CIDR_BLOCK"
            source_value="10.0.0.0/8"
            source_display="10.0.0.0/8"
        fi
    else
        # CIDR source
        source_type="CIDR_BLOCK"
        echo ""
        echo -e "${WHITE}Enter source CIDR:${NC}"
        echo -e "${GRAY}  Examples: 10.0.0.0/8, 10.0.0.0/16, 0.0.0.0/0 (any)${NC}"
        echo -n -e "${CYAN}Source CIDR [10.0.0.0/8]: ${NC}"
        read -r source_value
        [[ -z "$source_value" ]] && source_value="10.0.0.0/8"
        source_display="$source_value"
    fi
    
    # Step 2: Choose which ports to add
    echo ""
    echo -e "${WHITE}Step 3: Select ports to add${NC}"
    echo -e "  ${YELLOW}1${NC}) Port 443 only (HTTPS) ${GREEN}← recommended${NC}"
    echo -e "  ${YELLOW}2${NC}) Port 80 only (HTTP)"
    echo -e "  ${YELLOW}3${NC}) Both ports 80 and 443"
    echo -e "  ${YELLOW}4${NC}) ALL protocols (no port restriction)"
    echo ""
    echo -n -e "${CYAN}Select ports [1]: ${NC}"
    local port_choice
    read -r port_choice
    [[ -z "$port_choice" ]] && port_choice="1"
    
    local ports_to_add=()
    local protocol_choice="6"  # TCP by default
    local ports_display=""
    
    case "$port_choice" in
        1) ports_to_add=("443"); ports_display="443 (HTTPS)" ;;
        2) ports_to_add=("80"); ports_display="80 (HTTP)" ;;
        3) ports_to_add=("80" "443"); ports_display="80 (HTTP), 443 (HTTPS)" ;;
        4) 
            ports_to_add=("ALL")
            protocol_choice="all"
            ports_display="ALL protocols"
            ;;
        *) ports_to_add=("443"); ports_display="443 (HTTPS)" ;;
    esac
    
    # Summary before execution
    echo ""
    echo -e "${BOLD}${WHITE}═══ Configuration Summary ═══${NC}"
    echo ""
    echo -e "  ${CYAN}Source Type:${NC}  ${WHITE}$source_type${NC}"
    echo -e "  ${CYAN}Source:${NC}       ${WHITE}$source_display${NC}"
    echo -e "  ${CYAN}Ports:${NC}        ${WHITE}$ports_display${NC}"
    echo -e "  ${CYAN}Target NSGs:${NC}  ${WHITE}${#selected_nsgs[@]} NSG(s)${NC}"
    for nsg_id in "${!selected_nsgs[@]}"; do
        echo -e "                • ${GREEN}${nsg_missing_info[$nsg_id]}${NC}"
    done
    echo ""
    
    echo -n -e "${YELLOW}Proceed with adding rules? (Y/n): ${NC}"
    local proceed
    read -r proceed
    
    if [[ "$proceed" == "n" || "$proceed" == "N" ]]; then
        echo -e "${YELLOW}Aborted.${NC}"
        return
    fi
    
    echo ""
    
    # Process each selected NSG
    for nsg_id in "${!selected_nsgs[@]}"; do
        local m_nsg_name="${nsg_missing_info[$nsg_id]}"
        
        echo -e "${BOLD}${CYAN}NSG: $m_nsg_name${NC}"
        echo -e "  ${GRAY}$nsg_id${NC}"
        
        # Build security rules JSON
        local rules_json="["
        local first_rule=true
        
        for port in "${ports_to_add[@]}"; do
            [[ "$first_rule" == "false" ]] && rules_json+=","
            first_rule=false
            
            local protocol_name="HTTP"
            [[ "$port" == "443" ]] && protocol_name="HTTPS"
            [[ "$port" == "ALL" ]] && protocol_name="ALL"
            
            rules_json+="{"
            rules_json+="\"direction\": \"INGRESS\","
            rules_json+="\"protocol\": \"$protocol_choice\","
            rules_json+="\"source\": \"$source_value\","
            rules_json+="\"source-type\": \"$source_type\","
            
            if [[ "$port" != "ALL" ]]; then
                rules_json+="\"tcp-options\": {"
                rules_json+="\"destination-port-range\": {"
                rules_json+="\"min\": $port,"
                rules_json+="\"max\": $port"
                rules_json+="}"
                rules_json+="},"
            fi
            
            rules_json+="\"description\": \"Allow $protocol_name access to Object Storage Private Endpoint\","
            rules_json+="\"is-stateless\": false"
            rules_json+="}"
            
            echo -e "  ${WHITE}Adding: Port $port ($protocol_name) ingress rule${NC}"
        done
        rules_json+="]"
        
        # Build command for display and logging
        echo ""
        echo -e "${GRAY}Command:${NC}"
        echo "oci network nsg rules add \\"
        echo "  --nsg-id \"$nsg_id\" \\"
        echo "  --security-rules '$rules_json'"
        echo ""
        
        # Confirm before executing
        echo -n -e "${YELLOW}Execute? (Y/n): ${NC}"
        local confirm_exec
        read -r confirm_exec
        
        if [[ "$confirm_exec" != "n" && "$confirm_exec" != "N" ]]; then
            # Log the action
            local log_file="${LOGS_DIR}/object_storage_actions_$(date +%Y%m%d).log"
            mkdir -p "$(dirname "$log_file")" 2>/dev/null
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] ADD NSG RULES: oci network nsg rules add --nsg-id \"$nsg_id\" --security-rules '...' " >> "$log_file"
            
            # Execute the command
            local result
            result=$(oci network nsg rules add \
                --nsg-id "$nsg_id" \
                --security-rules "$rules_json" \
                --output json 2>&1)
            
            if echo "$result" | jq -e '.data' > /dev/null 2>&1; then
                echo -e "${GREEN}✓ Rules added successfully to $m_nsg_name${NC}"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Added rules to $m_nsg_name" >> "$log_file"
                
                # Invalidate cache for this NSG
                local cache_file="${NSG_CACHE_DIR}/${nsg_id}.json"
                rm -f "$cache_file" 2>/dev/null
            else
                echo -e "${RED}✗ Failed to add rules to $m_nsg_name${NC}"
                echo "$result"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
            fi
        else
            echo -e "${YELLOW}Skipped adding rules to $m_nsg_name${NC}"
        fi
        echo ""
    done
    
    echo -e "${WHITE}Rule addition complete.${NC}"
}

#--------------------------------------------------------------------------------
# Object Storage - View NSG Rules
#--------------------------------------------------------------------------------
os_view_nsg_rules() {
    local nsg_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ NSG Rules ═══${NC}"
    echo ""
    
    # Try to get from cache first
    local cached_data nsg_name rules_json
    cached_data=$(get_cached_nsg_rules "$nsg_id")
    
    if [[ -n "$cached_data" ]]; then
        nsg_name=$(echo "$cached_data" | jq -r '.nsg_name // "Unknown"')
        # Wrap rules in data format for display_nsg_rules_table
        rules_json=$(echo "$cached_data" | jq '{data: .rules}')
    else
        # Fallback to direct fetch if not cached
        local nsg_json
        nsg_json=$(oci network nsg get --nsg-id "$nsg_id" --output json 2>/dev/null)
        nsg_name=$(echo "$nsg_json" | jq -r '.data["display-name"] // "Unknown"')
        rules_json=$(oci network nsg rules list --nsg-id "$nsg_id" --all --output json 2>/dev/null)
    fi
    
    echo -e "${CYAN}NSG Name:${NC} ${WHITE}$nsg_name${NC}"
    echo -e "${CYAN}NSG OCID:${NC} ${YELLOW}$nsg_id${NC}"
    echo ""
    
    # Use shared function (no cache lookup - fetch NSG names on demand)
    display_nsg_rules_table "$rules_json" "false"
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Object Storage - Create Private Endpoint
#--------------------------------------------------------------------------------
os_create_private_endpoint() {
    local compartment_id="$1"
    local namespace="$2"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Create Private Endpoint ═══${NC}"
    echo ""
    
    # Get endpoint name
    echo -n -e "${CYAN}Enter private endpoint name: ${NC}"
    read -r pe_name
    
    if [[ -z "$pe_name" ]]; then
        echo -e "${RED}Name is required${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Get prefix
    echo ""
    echo -e "${GRAY}Prefix is a unique identifier for DNS resolution (e.g., 'myprefix')${NC}"
    echo -e "${GRAY}The FQDN will be: <prefix>.objectstorage.<region>.oci.customer-oci.com${NC}"
    echo -n -e "${CYAN}Enter prefix: ${NC}"
    read -r pe_prefix
    
    if [[ -z "$pe_prefix" ]]; then
        echo -e "${RED}Prefix is required${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # List subnets for selection
    echo ""
    echo -e "${CYAN}Fetching subnets...${NC}"
    
    local subnets_json
    subnets_json=$(oci network subnet list --compartment-id "$compartment_id" --output json 2>/dev/null)
    
    if [[ -z "$subnets_json" || "$subnets_json" == "null" ]]; then
        echo -e "${RED}Failed to list subnets${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local subnet_count
    subnet_count=$(echo "$subnets_json" | jq '.data | length // 0' 2>/dev/null)
    
    if [[ "$subnet_count" -eq 0 ]]; then
        echo -e "${RED}No subnets found in compartment${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo ""
    echo -e "${WHITE}Select a subnet:${NC}"
    printf "  ${BOLD}%-3s %-35s %-20s %-12s${NC}\n" "#" "Subnet Name" "CIDR" "Access"
    print_separator 80
    
    local subnet_idx=0
    declare -A SUBNET_MAP
    SUBNET_MAP=()
    
    while IFS='|' read -r subnet_name subnet_cidr subnet_access subnet_id; do
        [[ -z "$subnet_name" ]] && continue
        ((subnet_idx++))
        
        SUBNET_MAP[$subnet_idx]="$subnet_id"
        
        local access_display="Private"
        local access_color="$GREEN"
        if [[ "$subnet_access" == "true" ]]; then
            access_display="Public"
            access_color="$YELLOW"
        fi
        
        printf "  ${YELLOW}%-3s${NC} %-35s %-20s ${access_color}%-12s${NC}\n" \
            "$subnet_idx" "${subnet_name:0:33}" "$subnet_cidr" "$access_display"
            
    done < <(echo "$subnets_json" | jq -r '.data[] | "\(.["display-name"])|\(.["cidr-block"])|\(.["prohibit-public-ip-on-vnic"] | not)|\(.id)"' 2>/dev/null)
    
    echo ""
    echo -n -e "${CYAN}Select subnet #: ${NC}"
    read -r subnet_selection
    
    if [[ -z "${SUBNET_MAP[$subnet_selection]}" ]]; then
        echo -e "${RED}Invalid subnet selection${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local selected_subnet="${SUBNET_MAP[$subnet_selection]}"
    
    # Optional: NSG selection
    echo ""
    echo -e "${BOLD}${YELLOW}⚠ IMPORTANT:${NC} ${WHITE}NSGs cannot be added after Private Endpoint creation.${NC}"
    echo -e "${WHITE}  You must delete and recreate the PE to change NSGs.${NC}"
    echo ""
    echo -n -e "${CYAN}Add NSG(s)? (Y/n): ${NC}"
    read -r add_nsg
    
    local selected_nsg_ids=()
    if [[ "$add_nsg" != "n" && "$add_nsg" != "N" ]]; then
        local nsgs_json
        nsgs_json=$(oci network nsg list --compartment-id "$compartment_id" --output json 2>/dev/null)
        
        if [[ -n "$nsgs_json" && "$nsgs_json" != "null" ]]; then
            local nsg_count
            nsg_count=$(echo "$nsgs_json" | jq '.data | length // 0' 2>/dev/null)
            
            if [[ "$nsg_count" -gt 0 ]]; then
                echo ""
                echo -e "${WHITE}Available NSGs:${NC}"
                printf "  ${BOLD}%-3s %-40s${NC}\n" "#" "NSG Name"
                print_separator 50
                
                local nsg_idx=0
                declare -A NSG_MAP
                declare -A NSG_NAME_MAP
                NSG_MAP=()
                NSG_NAME_MAP=()
                
                while IFS='|' read -r nsg_name nsg_id; do
                    [[ -z "$nsg_name" ]] && continue
                    ((nsg_idx++))
                    NSG_MAP[$nsg_idx]="$nsg_id"
                    NSG_NAME_MAP[$nsg_idx]="$nsg_name"
                    printf "  ${YELLOW}%-3s${NC} %-40s\n" "$nsg_idx" "${nsg_name:0:38}"
                done < <(echo "$nsgs_json" | jq -r '.data[] | "\(.["display-name"])|\(.id)"' 2>/dev/null)
                
                # NSG selection loop with validation for max 5
                local max_nsgs=5
                while true; do
                    selected_nsg_ids=()
                    
                    echo ""
                    echo -e "${GRAY}Selection formats: ${WHITE}1,3,5${GRAY} | ${WHITE}1-3${GRAY} | ${WHITE}all${GRAY} | Enter to skip${NC}"
                    echo -e "${GRAY}Note: Maximum ${max_nsgs} NSGs can be attached to a Private Endpoint${NC}"
                    echo -n -e "${CYAN}Select NSG(s): ${NC}"
                    read -r nsg_selection
                    
                    if [[ -z "$nsg_selection" ]]; then
                        # User skipped NSG selection
                        break
                    fi
                    
                    # Parse selection
                    if [[ "$nsg_selection" == "all" || "$nsg_selection" == "ALL" ]]; then
                        # Select all NSGs
                        for i in $(seq 1 $nsg_idx); do
                            selected_nsg_ids+=("${NSG_MAP[$i]}")
                        done
                    elif [[ "$nsg_selection" =~ ^[0-9]+-[0-9]+$ ]]; then
                        # Range format: 1-3
                        local start_num="${nsg_selection%-*}"
                        local end_num="${nsg_selection#*-}"
                        for i in $(seq $start_num $end_num); do
                            if [[ -n "${NSG_MAP[$i]}" ]]; then
                                selected_nsg_ids+=("${NSG_MAP[$i]}")
                            fi
                        done
                    elif [[ "$nsg_selection" =~ ^[0-9,]+$ ]]; then
                        # Comma-separated: 1,3,5
                        IFS=',' read -ra nums <<< "$nsg_selection"
                        for num in "${nums[@]}"; do
                            num=$(echo "$num" | tr -d ' ')
                            if [[ -n "${NSG_MAP[$num]}" ]]; then
                                selected_nsg_ids+=("${NSG_MAP[$num]}")
                            fi
                        done
                    elif [[ "$nsg_selection" =~ ^[0-9]+$ ]]; then
                        # Single number
                        if [[ -n "${NSG_MAP[$nsg_selection]}" ]]; then
                            selected_nsg_ids+=("${NSG_MAP[$nsg_selection]}")
                        fi
                    fi
                    
                    # Validate max 5 NSGs
                    if [[ ${#selected_nsg_ids[@]} -gt $max_nsgs ]]; then
                        echo ""
                        echo -e "${RED}✗ Error: Selected ${#selected_nsg_ids[@]} NSGs, but maximum is ${max_nsgs}.${NC}"
                        echo -e "${YELLOW}  Please select ${max_nsgs} or fewer NSGs.${NC}"
                        continue
                    fi
                    
                    # Show selected NSGs and exit loop
                    if [[ ${#selected_nsg_ids[@]} -gt 0 ]]; then
                        echo ""
                        echo -e "${GREEN}Selected ${#selected_nsg_ids[@]} NSG(s):${NC}"
                        for nsg_id in "${selected_nsg_ids[@]}"; do
                            # Find name for this ID
                            for i in $(seq 1 $nsg_idx); do
                                if [[ "${NSG_MAP[$i]}" == "$nsg_id" ]]; then
                                    echo -e "  ${WHITE}• ${NSG_NAME_MAP[$i]}${NC}"
                                    break
                                fi
                            done
                        done
                    fi
                    break
                done
            fi
        fi
    fi
    
    # Access Targets configuration
    echo ""
    echo -e "${BOLD}${WHITE}─── Access Targets ───${NC}"
    echo -e "${GRAY}Configure which buckets can be accessed through this Private Endpoint${NC}"
    echo -e "${GRAY}Use '*' for wildcard access (all buckets/compartments)${NC}"
    echo ""
    
    # Prompt for bucket
    echo -n -e "${CYAN}Enter bucket name [*]: ${NC}"
    read -r access_bucket
    [[ -z "$access_bucket" ]] && access_bucket="*"
    
    # Prompt for compartment-id
    echo -n -e "${CYAN}Enter compartment-id [*]: ${NC}"
    read -r access_compartment
    [[ -z "$access_compartment" ]] && access_compartment="*"
    
    # Create access targets JSON file
    local access_targets_file="${TEMP_DIR:-/tmp}/pe_access_targets_$$.json"
    mkdir -p "$(dirname "$access_targets_file")" 2>/dev/null
    
    cat > "$access_targets_file" << EOF
[
  {
    "bucket": "$access_bucket",
    "compartment-id": "$access_compartment",
    "namespace": "$namespace"
  }
]
EOF
    
    echo ""
    echo -e "${WHITE}Access Targets JSON:${NC}"
    cat "$access_targets_file"
    echo ""
    
    # Build NSG IDs JSON array
    local nsg_ids_json=""
    if [[ ${#selected_nsg_ids[@]} -gt 0 ]]; then
        nsg_ids_json=$(printf '%s\n' "${selected_nsg_ids[@]}" | jq -R . | jq -s .)
    fi
    
    # Build and display command
    local create_cmd="oci os private-endpoint create \\
    --compartment-id \"$compartment_id\" \\
    --name \"$pe_name\" \\
    --namespace-name \"$namespace\" \\
    --prefix \"$pe_prefix\" \\
    --subnet-id \"$selected_subnet\" \\
    --access-targets file://$access_targets_file"
    
    if [[ -n "$nsg_ids_json" ]]; then
        create_cmd="$create_cmd \\
    --nsg-ids '$nsg_ids_json'"
    fi
    
    echo ""
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$create_cmd${NC}"
    echo ""
    
    echo -n -e "${YELLOW}Proceed with creation? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        rm -f "$access_targets_file" 2>/dev/null
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Log the action
    local log_file="${LOGS_DIR}/object_storage_actions_$(date +%Y%m%d).log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] CREATE PRIVATE ENDPOINT: $create_cmd" >> "$log_file"
    
    local result
    if [[ -n "$nsg_ids_json" ]]; then
        result=$(oci os private-endpoint create \
            --compartment-id "$compartment_id" \
            --name "$pe_name" \
            --namespace-name "$namespace" \
            --prefix "$pe_prefix" \
            --subnet-id "$selected_subnet" \
            --access-targets "file://$access_targets_file" \
            --nsg-ids "$nsg_ids_json" \
            --output json 2>&1)
    else
        result=$(oci os private-endpoint create \
            --compartment-id "$compartment_id" \
            --name "$pe_name" \
            --namespace-name "$namespace" \
            --prefix "$pe_prefix" \
            --subnet-id "$selected_subnet" \
            --access-targets "file://$access_targets_file" \
            --output json 2>&1)
    fi
    
    # Clean up temp file
    rm -f "$access_targets_file" 2>/dev/null
    
    # Check for work request (async operation)
    local work_request_id
    work_request_id=$(echo "$result" | jq -r '.["opc-work-request-id"] // empty' 2>/dev/null)
    
    if [[ -n "$work_request_id" ]]; then
        echo -e "${GREEN}✓ Private endpoint creation initiated${NC}"
        echo -e "  ${CYAN}Name:${NC}         ${WHITE}$pe_name${NC}"
        echo -e "  ${CYAN}Prefix:${NC}       ${WHITE}$pe_prefix${NC}"
        echo -e "  ${CYAN}Work Request:${NC} ${YELLOW}$work_request_id${NC}"
        echo -e "  ${GRAY}Endpoint will show CREATING state until complete${NC}"
        echo -e "  ${GRAY}Use 'w' from Object Storage menu to view work request status${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Creation initiated, work-request: $work_request_id" >> "$log_file"
    elif echo "$result" | jq -e '.data.name' > /dev/null 2>&1; then
        echo -e "${GREEN}✓ Private endpoint created${NC}"
        echo -e "  ${CYAN}Name:${NC}      ${WHITE}$pe_name${NC}"
        echo -e "  ${CYAN}Namespace:${NC} ${WHITE}$namespace${NC}"
        echo -e "  ${CYAN}Prefix:${NC}    ${WHITE}$pe_prefix${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created $pe_name in namespace $namespace" >> "$log_file"
    else
        echo -e "${RED}Failed to create private endpoint${NC}"
        echo "$result"
        echo -e "  ${GRAY}Use 'w' from Object Storage menu to view work request errors${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Object Storage - Delete Private Endpoint
#--------------------------------------------------------------------------------
os_delete_private_endpoint() {
    local compartment_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Delete Private Endpoint ═══${NC}"
    echo ""
    
    # List private endpoints for selection
    local pe_json
    pe_json=$(oci os private-endpoint list --compartment-id "$compartment_id" --output json 2>/dev/null)
    
    if [[ -z "$pe_json" ]] || ! echo "$pe_json" | jq -e '.data' > /dev/null 2>&1; then
        echo -e "${YELLOW}No private endpoints found${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local pe_count
    pe_count=$(echo "$pe_json" | jq '.data | length // 0' 2>/dev/null)
    
    if [[ "$pe_count" -eq 0 ]]; then
        echo -e "${YELLOW}No private endpoints found${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo -e "${WHITE}Select a private endpoint to delete:${NC}"
    printf "  ${BOLD}%-4s %-30s %-12s %-15s %s${NC}\n" "p#" "Name" "State" "Namespace" "Prefix"
    print_separator 120
    
    local idx=0
    declare -A PE_DEL_MAP
    PE_DEL_MAP=()
    
    while IFS='|' read -r pe_name pe_state pe_namespace pe_prefix; do
        [[ -z "$pe_name" ]] && continue
        ((idx++))
        
        # Store name|namespace for deletion
        PE_DEL_MAP[$idx]="${pe_name}|${pe_namespace}"
        
        local state_color="$GREEN"
        case "$pe_state" in
            ACTIVE) state_color="$GREEN" ;;
            CREATING|UPDATING) state_color="$YELLOW" ;;
            *) state_color="$RED" ;;
        esac
        
        local ns_display="${pe_namespace:-N/A}"
        local prefix_display="${pe_prefix:-N/A}"
        
        printf "  ${YELLOW}%-4s${NC} %-30s ${state_color}%-12s${NC} %-15s %s\n" \
            "p${idx}" "${pe_name:0:28}" "$pe_state" "${ns_display:0:13}" "$prefix_display"
            
    done < <(echo "$pe_json" | jq -r '.data[] | "\(.name)|\(.["lifecycle-state"])|\(.namespace)|\(.prefix // "N/A")"' 2>/dev/null)
    
    echo ""
    echo -n -e "${CYAN}Select p# to delete (e.g., p1) or Enter to cancel: ${NC}"
    read -r del_selection
    
    # Handle both "p1" and "1" format
    local del_num="${del_selection#p}"
    
    if [[ -z "$del_num" || -z "${PE_DEL_MAP[$del_num]}" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        return
    fi
    
    local selected_pe_name selected_pe_namespace
    IFS='|' read -r selected_pe_name selected_pe_namespace <<< "${PE_DEL_MAP[$del_num]}"
    
    echo ""
    echo -e "${RED}WARNING: This will permanently delete the private endpoint:${NC}"
    echo -e "  ${CYAN}Name:${NC}      ${WHITE}$selected_pe_name${NC}"
    echo -e "  ${CYAN}Namespace:${NC} ${WHITE}$selected_pe_namespace${NC}"
    echo ""
    
    local delete_cmd="oci os private-endpoint delete --pe-name \"$selected_pe_name\" --namespace-name \"$selected_pe_namespace\" --force"
    echo -e "${GRAY}Command to execute:${NC}"
    echo -e "${WHITE}$delete_cmd${NC}"
    echo ""
    
    echo -n -e "${RED}Type 'DELETE' to confirm: ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "DELETE" ]]; then
        echo -e "${YELLOW}Cancelled${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Log the action
    local log_file="${LOGS_DIR}/object_storage_actions_$(date +%Y%m%d).log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] DELETE PRIVATE ENDPOINT: $delete_cmd" >> "$log_file"
    
    local result
    result=$(oci os private-endpoint delete --pe-name "$selected_pe_name" --namespace-name "$selected_pe_namespace" --force 2>&1)
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}✓ Private endpoint deletion initiated${NC}"
        echo -e "  ${GRAY}Endpoint will show DELETING state until removed${NC}"
        echo -e "  ${GRAY}Use 'w' from Object Storage menu to view work request status${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted $selected_pe_name (namespace: $selected_pe_namespace)" >> "$log_file"
    else
        echo -e "${RED}Failed to delete private endpoint${NC}"
        echo "$result"
        echo -e "  ${GRAY}Use 'w' from Object Storage menu to view work request errors${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#===============================================================================
# CUSTOM IMAGES MANAGEMENT
#===============================================================================

manage_custom_images() {
    local compartment_id="${EFFECTIVE_COMPARTMENT_ID:-$COMPARTMENT_ID}"
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    while true; do
        echo ""
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo -e "${BOLD}${CYAN}                                              CUSTOM IMAGES MANAGEMENT                                              ${NC}"
        echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════${NC}"
        echo ""
        echo -e "${BOLD}${WHITE}Environment:${NC}"
        echo -e "  ${CYAN}Region:${NC}      ${WHITE}${region}${NC}"
        echo -e "  ${CYAN}Compartment:${NC} ${WHITE}$(resolve_compartment_name "${compartment_id}")${NC} ${GRAY}(${compartment_id})${NC}"
        echo ""
        
        # Fetch and display custom images (all states, not just AVAILABLE)
        echo -e "${GRAY}Fetching custom images...${NC}"
        
        local images_json
        images_json=$(oci compute image list \
            --compartment-id "$compartment_id" \
            --sort-by TIMECREATED \
            --sort-order DESC \
            --all \
            --output json 2>/dev/null)
        
        # Filter to only show custom images (images where compartment-id matches user's compartment)
        # Oracle platform images have a different compartment-id
        local custom_images_json
        if [[ -n "$images_json" ]] && echo "$images_json" | jq -e '.data' > /dev/null 2>&1; then
            custom_images_json=$(echo "$images_json" | jq --arg comp_id "$compartment_id" '{data: [.data[] | select(.["compartment-id"] == $comp_id)]}')
        else
            custom_images_json='{"data":[]}'
        fi
        
        local image_count=0
        if [[ -n "$custom_images_json" ]] && echo "$custom_images_json" | jq -e '.data' > /dev/null 2>&1; then
            image_count=$(echo "$custom_images_json" | jq '.data | length' 2>/dev/null)
        fi
        [[ -z "$image_count" || "$image_count" == "null" ]] && image_count=0
        
        # Count by lifecycle state
        local count_available count_importing count_provisioning count_disabled count_other
        count_available=$(echo "$custom_images_json" | jq '[.data[] | select(.["lifecycle-state"] == "AVAILABLE")] | length' 2>/dev/null || echo "0")
        count_importing=$(echo "$custom_images_json" | jq '[.data[] | select(.["lifecycle-state"] == "IMPORTING")] | length' 2>/dev/null || echo "0")
        count_provisioning=$(echo "$custom_images_json" | jq '[.data[] | select(.["lifecycle-state"] == "PROVISIONING")] | length' 2>/dev/null || echo "0")
        count_disabled=$(echo "$custom_images_json" | jq '[.data[] | select(.["lifecycle-state"] == "DISABLED")] | length' 2>/dev/null || echo "0")
        count_other=$(( image_count - count_available - count_importing - count_provisioning - count_disabled ))
        [[ "$count_other" -lt 0 ]] && count_other=0
        
        echo ""
        echo -e "${BOLD}${WHITE}═══ Custom Images Summary ═══${NC}"
        echo -e "  ${CYAN}Total Custom Images:${NC} ${WHITE}${image_count}${NC}"
        if [[ "$count_available" -gt 0 ]]; then
            echo -e "  ${GREEN}Available:${NC}           ${WHITE}${count_available}${NC}"
        fi
        if [[ "$count_importing" -gt 0 ]]; then
            echo -e "  ${YELLOW}Importing:${NC}           ${WHITE}${count_importing}${NC}"
        fi
        if [[ "$count_provisioning" -gt 0 ]]; then
            echo -e "  ${YELLOW}Provisioning:${NC}        ${WHITE}${count_provisioning}${NC}"
        fi
        if [[ "$count_disabled" -gt 0 ]]; then
            echo -e "  ${RED}Disabled:${NC}            ${WHITE}${count_disabled}${NC}"
        fi
        if [[ "$count_other" -gt 0 ]]; then
            echo -e "  ${GRAY}Other:${NC}               ${WHITE}${count_other}${NC}"
        fi
        echo -e "  ${GRAY}(Filtered to show only images created in this compartment)${NC}"
        echo ""
        
        # Build image map for selection
        declare -A IMAGE_MAP
        IMAGE_MAP=()
        local idx=0
        
        if [[ "$image_count" -gt 0 ]]; then
            echo -e "${BOLD}${WHITE}─── Custom Images ───${NC}"
            printf "  ${BOLD}%-3s %-105s %-20s %-14s %-12s %-12s${NC}\n" "#" "Image Name" "OS" "Status" "Billable GB" "Created"
            print_separator 175
            
            while IFS='|' read -r img_id img_name img_os img_billable_gb img_created img_state; do
                [[ -z "$img_id" ]] && continue
                ((idx++))
                
                IMAGE_MAP[$idx]="$img_id"
                
                # Format billable size (already in GB from billable-size-in-gbs)
                local size_gb="N/A"
                if [[ -n "$img_billable_gb" && "$img_billable_gb" != "null" && "$img_billable_gb" != "0" ]]; then
                    size_gb="${img_billable_gb}"
                fi
                
                # Format date: YYYY-MM-DD → MM-DD-YYYY
                local created_display="${img_created:0:10}"
                if [[ "$created_display" =~ ^([0-9]{4})-([0-9]{2})-([0-9]{2})$ ]]; then
                    created_display="${BASH_REMATCH[2]}-${BASH_REMATCH[3]}-${BASH_REMATCH[1]}"
                fi
                
                # Color-code status
                local state_color="${WHITE}"
                case "$img_state" in
                    AVAILABLE)    state_color="${GREEN}" ;;
                    IMPORTING|PROVISIONING|EXPORTING) state_color="${YELLOW}" ;;
                    DISABLED|DELETED) state_color="${RED}" ;;
                    *)            state_color="${GRAY}" ;;
                esac
                
                printf "  ${YELLOW}%-3s${NC} %-105s %-20s ${state_color}%-14s${NC} %-12s %-12s\n" \
                    "$idx" "$img_name" "$img_os" "$img_state" "$size_gb" "$created_display"
                    
            done < <(echo "$custom_images_json" | jq -r '.data[] | "\(.id)|\(.["display-name"] // "Unnamed")|\(.["operating-system"] // "N/A")|\(.["billable-size-in-gbs"] // "null")|\(.["time-created"] // "N/A")|\(.["lifecycle-state"] // "UNKNOWN")"' 2>/dev/null)
            echo ""
        else
            echo -e "  ${GRAY}No custom images found in this compartment${NC}"
            echo ""
        fi
        
        # Menu options
        echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
        if [[ "$idx" -gt 0 ]]; then
            echo -e "  ${YELLOW}1-${idx}${NC})  View image details"
        fi
        echo -e "  ${GREEN}i${NC})    Import image from URL"
        echo -e "  ${GREEN}c${NC})    Create image from instance"
        echo -e "  ${GREEN}e${NC})    Export image to Object Storage"
        echo -e "  ${CYAN}s${NC})    Shape compatibility (view/add)"
        echo -e "  ${RED}d${NC})    Delete custom image"
        echo -e "  ${MAGENTA}r${NC})    Refresh list"
        echo -e "  ${CYAN}q${NC})    Back to main menu"
        echo ""
        echo -n -e "${BOLD}${CYAN}[Custom Images] Enter selection: ${NC}"
        read -r choice
        
        case "$choice" in
            [0-9]*)
                if [[ -n "${IMAGE_MAP[$choice]}" ]]; then
                    custom_image_view_details "${IMAGE_MAP[$choice]}"
                else
                    echo -e "${RED}Invalid selection${NC}"
                    sleep 1
                fi
                ;;
            i|I)
                custom_image_import "$compartment_id"
                ;;
            c|C)
                custom_image_create_from_instance "$compartment_id"
                ;;
            e|E)
                custom_image_export "$compartment_id"
                ;;
            s|S)
                custom_image_shape_compatibility "$compartment_id"
                ;;
            d|D)
                custom_image_delete "$compartment_id"
                ;;
            r|R)
                # Just refresh - loop continues
                ;;
            q|Q|"")
                break
                ;;
            *)
                echo -e "${RED}Invalid selection${NC}"
                sleep 1
                ;;
        esac
    done
}

#--------------------------------------------------------------------------------
# Custom Images - View Details
#--------------------------------------------------------------------------------
custom_image_view_details() {
    local image_id="$1"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Image Details ═══${NC}"
    echo ""
    echo -e "${GRAY}Fetching image details...${NC}"
    
    local img_json
    img_json=$(oci compute image get --image-id "$image_id" --output json 2>/dev/null)
    
    if [[ -z "$img_json" ]] || ! echo "$img_json" | jq -e '.data' > /dev/null 2>&1; then
        echo -e "${RED}Failed to fetch image details${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Extract fields
    local name os os_version billable_gb launch_mode create_type
    local time_created base_image_id compartment_id state
    
    name=$(echo "$img_json" | jq -r '.data["display-name"] // "N/A"')
    os=$(echo "$img_json" | jq -r '.data["operating-system"] // "N/A"')
    os_version=$(echo "$img_json" | jq -r '.data["operating-system-version"] // "N/A"')
    billable_gb=$(echo "$img_json" | jq -r '.data["billable-size-in-gbs"] // 0')
    launch_mode=$(echo "$img_json" | jq -r '.data["launch-mode"] // "N/A"')
    create_type=$(echo "$img_json" | jq -r '.data["create-image-allowed"] // "N/A"')
    time_created=$(echo "$img_json" | jq -r '.data["time-created"] // "N/A"')
    base_image_id=$(echo "$img_json" | jq -r '.data["base-image-id"] // "N/A"')
    compartment_id=$(echo "$img_json" | jq -r '.data["compartment-id"] // "N/A"')
    state=$(echo "$img_json" | jq -r '.data["lifecycle-state"] // "N/A"')
    
    # Format billable size (already in GB)
    local size_gb="N/A"
    if [[ -n "$billable_gb" && "$billable_gb" != "0" && "$billable_gb" != "null" ]]; then
        size_gb="${billable_gb}"
    fi
    
    # Format date: YYYY-MM-DDTHH:MM:SS → MM-DD-YYYY HH:MM:SS
    local created_display="${time_created/T/ }"
    if [[ "$time_created" =~ ^([0-9]{4})-([0-9]{2})-([0-9]{2})T(.+)$ ]]; then
        created_display="${BASH_REMATCH[2]}-${BASH_REMATCH[3]}-${BASH_REMATCH[1]} ${BASH_REMATCH[4]}"
    fi
    
    echo ""
    echo -e "${BOLD}${CYAN}─── Basic Information ───${NC}"
    echo -e "  ${CYAN}Name:${NC}           ${WHITE}$name${NC}"
    echo -e "  ${CYAN}State:${NC}          ${GREEN}$state${NC}"
    echo -e "  ${CYAN}OS:${NC}             ${WHITE}$os $os_version${NC}"
    echo -e "  ${CYAN}Billable Size:${NC}  ${WHITE}${size_gb} GB${NC}"
    echo -e "  ${CYAN}Launch Mode:${NC}    ${WHITE}$launch_mode${NC}"
    echo -e "  ${CYAN}Created:${NC}        ${WHITE}${created_display}${NC}"
    echo ""
    echo -e "${BOLD}${CYAN}─── Identifiers ───${NC}"
    echo -e "  ${CYAN}Image OCID:${NC}     ${YELLOW}$image_id${NC}"
    echo -e "  ${CYAN}Compartment:${NC}    ${WHITE}$(resolve_compartment_name "$compartment_id")${NC} ${GRAY}($compartment_id)${NC}"
    if [[ "$base_image_id" != "N/A" && "$base_image_id" != "null" ]]; then
        echo -e "  ${CYAN}Base Image:${NC}     ${YELLOW}$base_image_id${NC}"
    fi
    echo ""
    
    # Show launch options
    local launch_options
    launch_options=$(echo "$img_json" | jq -r '.data["launch-options"] // {}')
    if [[ -n "$launch_options" && "$launch_options" != "{}" ]]; then
        echo -e "${BOLD}${CYAN}─── Launch Options ───${NC}"
        local boot_vol_type firmware network_type
        boot_vol_type=$(echo "$launch_options" | jq -r '.["boot-volume-type"] // "N/A"')
        firmware=$(echo "$launch_options" | jq -r '.firmware // "N/A"')
        network_type=$(echo "$launch_options" | jq -r '.["network-type"] // "N/A"')
        echo -e "  ${CYAN}Boot Volume Type:${NC} ${WHITE}$boot_vol_type${NC}"
        echo -e "  ${CYAN}Firmware:${NC}         ${WHITE}$firmware${NC}"
        echo -e "  ${CYAN}Network Type:${NC}     ${WHITE}$network_type${NC}"
        echo ""
    fi
    
    # Show compatible shapes
    echo -e "${BOLD}${CYAN}─── Compatible Shapes ───${NC}"
    local shapes
    shapes=$(echo "$img_json" | jq -r '.data["agent-features"]["is-monitoring-supported"] // "N/A"' 2>/dev/null)
    
    # Try to get shape compatibility
    local compat_json
    compat_json=$(oci compute image-shape-compatibility-entry list --image-id "$image_id" --output json 2>/dev/null)
    if [[ -n "$compat_json" ]] && echo "$compat_json" | jq -e '.data' > /dev/null 2>&1; then
        local shape_count
        shape_count=$(echo "$compat_json" | jq '.data | length')
        echo -e "  ${WHITE}$shape_count compatible shape(s)${NC}"
        echo "$compat_json" | jq -r '.data[].shape' 2>/dev/null | head -10 | while read -r shape; do
            echo -e "    ${GRAY}• $shape${NC}"
        done
        if [[ "$shape_count" -gt 10 ]]; then
            echo -e "    ${GRAY}... and $((shape_count - 10)) more${NC}"
        fi
    else
        echo -e "  ${GRAY}Unable to retrieve shape compatibility${NC}"
    fi
    echo ""
    
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Custom Images - Import from URL
#--------------------------------------------------------------------------------
custom_image_import() {
    local compartment_id="$1"
    local log_file="${LOGS_DIR}/custom_images_actions.log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Import Image from URL ═══${NC}"
    echo ""
    echo -e "${GRAY}Provide a publicly accessible URL or a pre-authenticated request (PAR) URL${NC}"
    echo -e "${GRAY}pointing to a QCOW2, VMDK, or OCI image file.${NC}"
    echo ""
    
    # Get URL
    echo -n -e "${CYAN}Enter image URL: ${NC}"
    read -r image_url
    
    if [[ -z "$image_url" ]]; then
        echo -e "${YELLOW}Import cancelled - no URL provided${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Validate URL format
    if [[ ! "$image_url" =~ ^https?:// ]]; then
        echo -e "${RED}Invalid URL - must start with http:// or https://${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Extract display name from URL
    # For Object Storage URLs: .../o/ImageName or .../o/ImageName?params
    # For other URLs: use basename of the path
    echo ""
    local default_name=""
    local url_no_params="${image_url%%\?*}"   # strip query params
    if [[ "$url_no_params" =~ /o/(.+)$ ]]; then
        # Object Storage URL - extract everything after /o/
        default_name="${BASH_REMATCH[1]}"
    else
        default_name=$(basename "$url_no_params")
        default_name="${default_name%.*}"   # strip extension for non-ObjStorage URLs
    fi
    [[ -z "$default_name" || "$default_name" == "/" ]] && default_name="imported-image"
    
    echo -n -e "${CYAN}Enter display name [${default_name}]: ${NC}"
    read -r image_name
    [[ -z "$image_name" ]] && image_name="$default_name"
    
    # Auto-detect OS from image name
    # Pattern: <OS-Name>-<Version>-<rest>  e.g. Canonical-Ubuntu-22.04-aarch64-...
    # OS is everything before the first version pattern (digits.digits)
    # Replace hyphens with spaces in the OS portion
    local auto_os=""
    if [[ "$image_name" =~ ^([A-Za-z]([A-Za-z0-9]*-)*[A-Za-z0-9]*)-[0-9]+\.[0-9]+ ]]; then
        auto_os="${BASH_REMATCH[1]}"
        # Replace hyphens with spaces
        auto_os="${auto_os//-/ }"
    fi
    
    # Check if image with same display name already exists
    echo ""
    echo -e "${GRAY}Checking for existing image with same name...${NC}"
    local existing_images
    existing_images=$(oci compute image list \
        --compartment-id "$compartment_id" \
        --display-name "$image_name" \
        --lifecycle-state AVAILABLE \
        --output json 2>/dev/null)
    
    local existing_count=0
    if [[ -n "$existing_images" ]] && echo "$existing_images" | jq -e '.data[0]' &>/dev/null; then
        existing_count=$(echo "$existing_images" | jq '.data | length' 2>/dev/null)
    fi
    
    if [[ "$existing_count" -gt 0 ]]; then
        local existing_id existing_os
        existing_id=$(echo "$existing_images" | jq -r '.data[0].id' 2>/dev/null)
        existing_os=$(echo "$existing_images" | jq -r '.data[0]["operating-system"] // "N/A"' 2>/dev/null)
        echo -e "${YELLOW}⚠ An image named '${image_name}' already exists:${NC}"
        echo -e "  ${CYAN}OCID:${NC} ${YELLOW}$existing_id${NC}"
        echo -e "  ${CYAN}OS:${NC}   ${WHITE}$existing_os${NC}"
        echo ""
        echo -n -e "${YELLOW}Continue with import anyway? (y/N): ${NC}"
        read -r dup_confirm
        if [[ "$dup_confirm" != "y" && "$dup_confirm" != "Y" ]]; then
            echo -e "${YELLOW}Import cancelled${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
    else
        echo -e "  ${GREEN}✓${NC} No duplicate found"
    fi
    
    # Get operating system name (with auto-detected default)
    echo ""
    if [[ -n "$auto_os" ]]; then
        echo -e "${GRAY}Auto-detected OS from image name: ${WHITE}${auto_os}${NC}"
        echo -n -e "${CYAN}Enter operating system name [${auto_os}]: ${NC}"
    else
        echo -e "${GRAY}Examples: Canonical Ubuntu, Oracle Linux, CentOS, Windows, Custom${NC}"
        echo -n -e "${CYAN}Enter operating system name: ${NC}"
    fi
    read -r os_name
    [[ -z "$os_name" && -n "$auto_os" ]] && os_name="$auto_os"
    
    if [[ -z "$os_name" ]]; then
        echo -e "${RED}Operating system name is required${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Determine source image type
    # OCI CLI only supports QCOW2 and VMDK for --source-image-type
    # For native OCI images, the flag is omitted entirely
    echo ""
    echo -e "${BOLD}${WHITE}─── Source Image Type ───${NC}"
    echo -e "  ${YELLOW}1${NC}) QCOW2"
    echo -e "  ${YELLOW}2${NC}) VMDK"
    echo -e "  ${YELLOW}3${NC}) None - OCI native format (omit source type flag)"
    echo ""
    echo -n -e "${CYAN}Select source type [3]: ${NC}"
    read -r type_choice
    
    local source_type=""
    case "$type_choice" in
        1) source_type="QCOW2" ;;
        2) source_type="VMDK" ;;
        *) source_type="" ;;
    esac
    
    # Build the command
    local cmd="oci compute image import from-object-uri"
    cmd+=" --uri \"$image_url\""
    cmd+=" --compartment-id \"$compartment_id\""
    cmd+=" --operating-system \"$os_name\""
    cmd+=" --display-name \"$image_name\""
    [[ -n "$source_type" ]] && cmd+=" --source-image-type \"$source_type\""
    
    local source_type_display="${source_type:-None (OCI native)}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Confirm Import ═══${NC}"
    echo ""
    echo -e "${CYAN}URL:${NC}              $image_url"
    echo -e "${CYAN}Display Name:${NC}     $image_name"
    echo -e "${CYAN}Operating System:${NC} $os_name"
    echo -e "${CYAN}Source Type:${NC}      $source_type_display"
    echo ""
    echo -e "${BOLD}${WHITE}Command to execute:${NC}"
    echo -e "${GRAY}$cmd${NC}"
    echo ""
    echo -n -e "${YELLOW}Proceed with import? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Import cancelled${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Execute import
    echo ""
    echo -e "${GRAY}Importing image (this may take several minutes)...${NC}"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: $cmd" >> "$log_file"
    echo -e "${WHITE}$ $cmd${NC}"
    
    local result
    result=$(eval "$cmd" 2>&1)
    
    if echo "$result" | jq -e '.data.id' > /dev/null 2>&1; then
        local new_image_id
        new_image_id=$(echo "$result" | jq -r '.data.id')
        echo -e "${GREEN}✓ Image import initiated successfully${NC}"
        echo -e "  ${CYAN}Image OCID:${NC} ${YELLOW}$new_image_id${NC}"
        echo -e "  ${GRAY}Image will be available once import completes${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Imported image $image_name (OS: $os_name) -> $new_image_id" >> "$log_file"
    else
        echo -e "${RED}Failed to import image${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Custom Images - Create from Instance
#--------------------------------------------------------------------------------
custom_image_create_from_instance() {
    local compartment_id="$1"
    local log_file="${LOGS_DIR}/custom_images_actions.log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Create Image from Instance ═══${NC}"
    echo ""
    
    # Prompt for compartment
    local comp_name
    comp_name=$(resolve_compartment_name "$compartment_id")
    echo -e "${CYAN}Compartment:${NC} ${WHITE}$comp_name${NC} ${GRAY}($compartment_id)${NC}"
    echo -n -e "${CYAN}Use this compartment? (Y/n): ${NC}"
    read -r comp_confirm
    if [[ "$comp_confirm" == "n" || "$comp_confirm" == "N" ]]; then
        echo -n -e "${CYAN}Enter compartment OCID: ${NC}"
        read -r compartment_id
        if [[ -z "$compartment_id" ]]; then
            echo -e "${RED}No compartment provided - cancelled${NC}"
            echo -e "Press Enter to continue..."
            read -r
            return
        fi
    fi
    echo ""
    
    # List all instances (not just running - same pattern as --manage 5)
    echo -e "${GRAY}Fetching instances...${NC}"
    local instances_json
    instances_json=$(oci compute instance list \
        --compartment-id "$compartment_id" \
        --region "$region" \
        --all \
        --output json 2>/dev/null)
    
    if [[ -z "$instances_json" ]] || ! echo "$instances_json" | jq -e '.data[0]' > /dev/null 2>&1; then
        echo -e "${RED}No instances found in this compartment${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Fetch K8s nodes for lookup
    local k8s_lookup=""
    local k8s_nodes_json
    k8s_nodes_json=$(kubectl get nodes -o json 2>/dev/null)
    if [[ -n "$k8s_nodes_json" ]] && echo "$k8s_nodes_json" | jq -e '.items[0]' &>/dev/null; then
        k8s_lookup=$(echo "$k8s_nodes_json" | jq -r '
            .items[] |
            "\(.spec.providerID)|\(.metadata.name)|\(.status.conditions[] | select(.type=="Ready") | .status)"
        ' 2>/dev/null)
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}─── Select Instance ───${NC}"
    printf "  ${BOLD}%-4s %-45s %-10s %-8s %-22s %-12s %-10s${NC}\n" \
        "#" "Display Name" "State" "K8s" "Shape" "Launch Mode" "AD"
    print_separator 125
    
    declare -A CI_INSTANCE_MAP=()
    declare -A CI_INSTANCE_LAUNCH_MODE=()
    local idx=0
    
    while IFS='|' read -r inst_id inst_name inst_state inst_shape inst_ad inst_launch_mode; do
        [[ -z "$inst_id" ]] && continue
        # Skip terminated instances
        [[ "$inst_state" == "TERMINATED" ]] && continue
        ((idx++))
        
        CI_INSTANCE_MAP[$idx]="$inst_id"
        CI_INSTANCE_LAUNCH_MODE[$idx]="${inst_launch_mode:-NATIVE}"
        
        # Color state
        local state_color="$GREEN"
        case "$inst_state" in
            RUNNING) state_color="$GREEN" ;;
            STOPPED) state_color="$RED" ;;
            STARTING|STOPPING) state_color="$YELLOW" ;;
            *) state_color="$WHITE" ;;
        esac
        
        # Check K8s status
        local k8s_status="-"
        local k8s_color="$GRAY"
        if [[ -n "$k8s_lookup" ]]; then
            local k8s_match
            k8s_match=$(echo "$k8s_lookup" | grep "$inst_id" 2>/dev/null)
            if [[ -n "$k8s_match" ]]; then
                local k8s_ready
                k8s_ready=$(echo "$k8s_match" | cut -d'|' -f3)
                if [[ "$k8s_ready" == "True" ]]; then
                    k8s_status="Ready"
                    k8s_color="$GREEN"
                else
                    k8s_status="NotRdy"
                    k8s_color="$RED"
                fi
            fi
        fi
        
        local ad_short="${inst_ad##*:}"
        
        printf "  ${YELLOW}%-4s${NC} %-45s ${state_color}%-10s${NC} ${k8s_color}%-8s${NC} %-22s %-12s %-10s\n" \
            "$idx" "$inst_name" "$inst_state" "$k8s_status" "${inst_shape:0:22}" "${inst_launch_mode:-N/A}" "$ad_short"
            
    done < <(echo "$instances_json" | jq -r '
        .data[] |
        "\(.id)|\(.["display-name"] // "Unnamed")|\(.["lifecycle-state"])|\(.shape // "N/A")|\(.["availability-domain"] // "N/A")|\(.["launch-mode"] // "NATIVE")"
    ' 2>/dev/null | sort -t'|' -k2,2)
    
    if [[ $idx -eq 0 ]]; then
        echo -e "  ${GRAY}No instances found (excluding TERMINATED)${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo ""
    echo -n -e "${CYAN}Select instance #: ${NC}"
    read -r inst_choice
    
    local selected_instance="${CI_INSTANCE_MAP[$inst_choice]}"
    if [[ -z "$selected_instance" ]]; then
        echo -e "${RED}Invalid instance selection${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Get instance details for defaults
    local instance_name inst_launch_mode
    instance_name=$(echo "$instances_json" | jq -r --arg id "$selected_instance" \
        '.data[] | select(.id == $id) | .["display-name"] // "custom-image"')
    inst_launch_mode="${CI_INSTANCE_LAUNCH_MODE[$inst_choice]}"
    
    # Get image name
    echo ""
    local default_name="${instance_name}-image-$(date +%Y%m%d)"
    echo -n -e "${CYAN}Enter image display name [${default_name}]: ${NC}"
    read -r image_name
    [[ -z "$image_name" ]] && image_name="$default_name"
    
    # Build the command (use same launch-mode as instance)
    local cmd="oci compute image create"
    cmd+=" --compartment-id \"$compartment_id\""
    cmd+=" --instance-id \"$selected_instance\""
    cmd+=" --display-name \"$image_name\""
    if [[ -n "$inst_launch_mode" && "$inst_launch_mode" != "null" && "$inst_launch_mode" != "N/A" ]]; then
        cmd+=" --launch-mode \"$inst_launch_mode\""
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Confirm Image Creation ═══${NC}"
    echo ""
    echo -e "${CYAN}Instance:${NC}    $instance_name"
    echo -e "${CYAN}Instance ID:${NC} ${YELLOW}$selected_instance${NC}"
    echo -e "${CYAN}Image Name:${NC}  $image_name"
    echo -e "${CYAN}Launch Mode:${NC} $inst_launch_mode"
    echo ""
    echo -e "${BOLD}${WHITE}Command to execute:${NC}"
    echo -e "${GRAY}$cmd${NC}"
    echo ""
    echo -e "${YELLOW}NOTE: The instance will remain running during image creation${NC}"
    echo ""
    echo -n -e "${YELLOW}Proceed with image creation? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Image creation cancelled${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Execute creation
    echo ""
    echo -e "${GRAY}Creating image (this may take several minutes)...${NC}"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: $cmd" >> "$log_file"
    echo -e "${WHITE}$ $cmd${NC}"
    
    local result
    result=$(eval "$cmd" 2>&1)
    
    if echo "$result" | jq -e '.data.id' > /dev/null 2>&1; then
        local new_image_id
        new_image_id=$(echo "$result" | jq -r '.data.id')
        echo -e "${GREEN}✓ Image creation initiated successfully${NC}"
        echo -e "  ${CYAN}Image OCID:${NC} ${YELLOW}$new_image_id${NC}"
        echo -e "  ${CYAN}Launch Mode:${NC} ${WHITE}$inst_launch_mode${NC}"
        echo -e "  ${GRAY}Image will be available once creation completes${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Created image $image_name (launch-mode: $inst_launch_mode) from $instance_name -> $new_image_id" >> "$log_file"
    else
        echo -e "${RED}Failed to create image${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Custom Images - Export to Object Storage
#--------------------------------------------------------------------------------
custom_image_export() {
    local compartment_id="$1"
    local log_file="${LOGS_DIR}/custom_images_actions.log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Export Image to Object Storage ═══${NC}"
    echo ""
    
    # Get namespace
    local namespace
    namespace=$(oci os ns get --output json 2>/dev/null | jq -r '.data // empty')
    
    if [[ -z "$namespace" ]]; then
        echo -e "${RED}Failed to get Object Storage namespace${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # List custom images
    echo -e "${GRAY}Fetching custom images...${NC}"
    local images_json
    images_json=$(oci compute image list \
        --compartment-id "$compartment_id" \
        --lifecycle-state AVAILABLE \
        --sort-by TIMECREATED \
        --sort-order DESC \
        --all \
        --output json 2>/dev/null)
    
    # Filter to only show custom images (images where compartment-id matches user's compartment)
    local custom_images_json
    if [[ -n "$images_json" ]] && echo "$images_json" | jq -e '.data' > /dev/null 2>&1; then
        custom_images_json=$(echo "$images_json" | jq --arg comp_id "$compartment_id" '{data: [.data[] | select(.["compartment-id"] == $comp_id)]}')
    else
        custom_images_json='{"data":[]}'
    fi
    
    local img_count=0
    img_count=$(echo "$custom_images_json" | jq '.data | length' 2>/dev/null || echo "0")
    
    if [[ "$img_count" -eq 0 ]]; then
        echo -e "${RED}No custom images found in this compartment${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}─── Select Image to Export ───${NC}"
    printf "  ${BOLD}%-4s %-105s %-18s %-10s %-12s${NC}\n" "#" "Image Name" "OS" "Size (GB)" "Created"
    print_separator 160
    
    declare -A EXPORT_IMAGE_MAP=()
    local idx=0
    
    while IFS='|' read -r img_id img_name img_os img_billable_gb img_created; do
        [[ -z "$img_id" ]] && continue
        ((idx++))
        EXPORT_IMAGE_MAP[$idx]="$img_id|$img_name"
        
        local size_gb="N/A"
        if [[ -n "$img_billable_gb" && "$img_billable_gb" != "null" && "$img_billable_gb" != "0" ]]; then
            size_gb="${img_billable_gb}"
        fi
        # Format date: YYYY-MM-DD → MM-DD-YYYY
        local created_display="${img_created:0:10}"
        if [[ "$created_display" =~ ^([0-9]{4})-([0-9]{2})-([0-9]{2})$ ]]; then
            created_display="${BASH_REMATCH[2]}-${BASH_REMATCH[3]}-${BASH_REMATCH[1]}"
        fi
        
        printf "  ${YELLOW}%-4s${NC} %-105s %-18s %-10s %-12s\n" \
            "$idx" "$img_name" "$img_os" "$size_gb" "$created_display"
    done < <(echo "$custom_images_json" | jq -r '.data[] | "\(.id)|\(.["display-name"] // "Unnamed")|\(.["operating-system"] // "N/A")|\(.["billable-size-in-gbs"] // "null")|\(.["time-created"] // "N/A")"' 2>/dev/null)
    
    echo ""
    echo -n -e "${CYAN}Select image #: ${NC}"
    read -r img_choice
    
    local selected_entry="${EXPORT_IMAGE_MAP[$img_choice]}"
    if [[ -z "$selected_entry" ]]; then
        echo -e "${RED}Invalid image selection${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local selected_image selected_image_name
    IFS='|' read -r selected_image selected_image_name <<< "$selected_entry"
    
    # List buckets
    echo ""
    echo -e "${GRAY}Fetching buckets...${NC}"
    local buckets_json
    buckets_json=$(oci os bucket list --compartment-id "$compartment_id" --namespace-name "$namespace" --output json 2>/dev/null)
    
    if [[ -z "$buckets_json" ]] || ! echo "$buckets_json" | jq -e '.data[0]' > /dev/null 2>&1; then
        echo -e "${RED}No buckets found${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}─── Select Destination Bucket ───${NC}"
    declare -A BUCKET_MAP
    idx=0
    
    while read -r bucket_name; do
        [[ -z "$bucket_name" ]] && continue
        ((idx++))
        BUCKET_MAP[$idx]="$bucket_name"
        echo -e "  ${YELLOW}${idx}${NC}) $bucket_name"
    done < <(echo "$buckets_json" | jq -r '.data[].name' 2>/dev/null)
    
    echo ""
    echo -n -e "${CYAN}Select bucket #: ${NC}"
    read -r bucket_choice
    
    local selected_bucket="${BUCKET_MAP[$bucket_choice]}"
    if [[ -z "$selected_bucket" ]]; then
        echo -e "${RED}Invalid bucket selection${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Get object name
    echo ""
    local default_name="${selected_image_name// /-}-$(date +%Y%m%d).oci"
    echo -n -e "${CYAN}Enter object name [${default_name}]: ${NC}"
    read -r object_name
    [[ -z "$object_name" ]] && object_name="$default_name"
    
    # Select export format
    echo ""
    echo -e "${BOLD}${WHITE}─── Export Format ───${NC}"
    echo -e "  ${YELLOW}1${NC}) OCI (Oracle Cloud Image format)"
    echo -e "  ${YELLOW}2${NC}) QCOW2"
    echo -e "  ${YELLOW}3${NC}) VMDK"
    echo ""
    echo -n -e "${CYAN}Select format [1]: ${NC}"
    read -r format_choice
    
    local export_format="OCI"
    case "$format_choice" in
        2) export_format="QCOW2"; [[ ! "$object_name" =~ \.qcow2$ ]] && object_name="${object_name%.oci}.qcow2" ;;
        3) export_format="VMDK"; [[ ! "$object_name" =~ \.vmdk$ ]] && object_name="${object_name%.oci}.vmdk" ;;
        *) export_format="OCI" ;;
    esac
    
    # Build the command
    local cmd="oci compute image export to-object"
    cmd+=" --image-id \"$selected_image\""
    cmd+=" --namespace \"$namespace\""
    cmd+=" --bucket-name \"$selected_bucket\""
    cmd+=" --name \"$object_name\""
    cmd+=" --export-format \"$export_format\""
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Confirm Export ═══${NC}"
    echo ""
    echo -e "${CYAN}Image:${NC}       $selected_image_name"
    echo -e "${CYAN}Bucket:${NC}      $selected_bucket"
    echo -e "${CYAN}Object Name:${NC} $object_name"
    echo -e "${CYAN}Format:${NC}      $export_format"
    echo ""
    echo -e "${BOLD}${WHITE}Command to execute:${NC}"
    echo -e "${GRAY}$cmd${NC}"
    echo ""
    echo -n -e "${YELLOW}Proceed with export? (y/N): ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}Export cancelled${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Execute export
    echo ""
    echo -e "${GRAY}Exporting image (this may take several minutes)...${NC}"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: $cmd" >> "$log_file"
    
    local result
    result=$(eval "$cmd" 2>&1)
    
    if echo "$result" | jq -e '.data' > /dev/null 2>&1; then
        echo -e "${GREEN}✓ Image export initiated successfully${NC}"
        echo -e "  ${CYAN}Destination:${NC} ${WHITE}$selected_bucket/$object_name${NC}"
        echo -e "  ${GRAY}Export will complete in background${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Exported $selected_image_name to $selected_bucket/$object_name" >> "$log_file"
    else
        echo -e "${RED}Failed to export image${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Custom Images - Shape Compatibility (View / Add)
#--------------------------------------------------------------------------------
custom_image_shape_compatibility() {
    local compartment_id="$1"
    local log_file="${LOGS_DIR}/custom_images_actions.log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    local region="${EFFECTIVE_REGION:-$REGION}"
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Image Shape Compatibility ═══${NC}"
    echo ""
    
    # List custom images
    echo -e "${GRAY}Fetching custom images...${NC}"
    local images_json
    images_json=$(oci compute image list \
        --compartment-id "$compartment_id" \
        --lifecycle-state AVAILABLE \
        --sort-by TIMECREATED \
        --sort-order DESC \
        --all \
        --output json 2>/dev/null)
    
    local custom_images_json
    if [[ -n "$images_json" ]] && echo "$images_json" | jq -e '.data' > /dev/null 2>&1; then
        custom_images_json=$(echo "$images_json" | jq --arg comp_id "$compartment_id" '{data: [.data[] | select(.["compartment-id"] == $comp_id)]}')
    else
        custom_images_json='{"data":[]}'
    fi
    
    local img_count=0
    img_count=$(echo "$custom_images_json" | jq '.data | length' 2>/dev/null || echo "0")
    
    if [[ "$img_count" -eq 0 ]]; then
        echo -e "${RED}No custom images found in this compartment${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}─── Select Image ───${NC}"
    printf "  ${BOLD}%-4s %-105s %-18s %-12s${NC}\n" "#" "Image Name" "OS" "Created"
    print_separator 145
    
    declare -A SC_IMAGE_MAP=()
    local idx=0
    
    while IFS='|' read -r img_id img_name img_os img_created; do
        [[ -z "$img_id" ]] && continue
        ((idx++))
        SC_IMAGE_MAP[$idx]="$img_id"
        # Format date: YYYY-MM-DD → MM-DD-YYYY
        local created_display="${img_created:0:10}"
        if [[ "$created_display" =~ ^([0-9]{4})-([0-9]{2})-([0-9]{2})$ ]]; then
            created_display="${BASH_REMATCH[2]}-${BASH_REMATCH[3]}-${BASH_REMATCH[1]}"
        fi
        printf "  ${YELLOW}%-4s${NC} %-105s %-18s %-12s\n" \
            "$idx" "$img_name" "$img_os" "$created_display"
    done < <(echo "$custom_images_json" | jq -r '.data[] | "\(.id)|\(.["display-name"] // "Unnamed")|\(.["operating-system"] // "N/A")|\(.["time-created"] // "N/A")"' 2>/dev/null)
    
    echo ""
    echo -n -e "${CYAN}Select image #: ${NC}"
    read -r img_choice
    
    local selected_image="${SC_IMAGE_MAP[$img_choice]}"
    if [[ -z "$selected_image" ]]; then
        echo -e "${RED}Invalid image selection${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local selected_image_name
    selected_image_name=$(echo "$custom_images_json" | jq -r --arg id "$selected_image" \
        '.data[] | select(.id == $id) | .["display-name"] // "N/A"' 2>/dev/null)
    
    # Fetch current shape compatibility
    echo ""
    echo -e "${GRAY}Fetching shape compatibility for: ${WHITE}$selected_image_name${NC}..."
    local compat_json
    compat_json=$(oci compute image-shape-compatibility-entry list --image-id "$selected_image" --output json 2>/dev/null)
    
    echo ""
    echo -e "${BOLD}${WHITE}─── Current Compatible Shapes ───${NC}"
    echo -e "${CYAN}Image:${NC} ${WHITE}$selected_image_name${NC}"
    echo -e "${CYAN}OCID:${NC}  ${YELLOW}$selected_image${NC}"
    echo ""
    
    declare -A COMPAT_SHAPES=()
    local compat_count=0
    
    if [[ -n "$compat_json" ]] && echo "$compat_json" | jq -e '.data[0]' &>/dev/null; then
        compat_count=$(echo "$compat_json" | jq '.data | length' 2>/dev/null)
        echo -e "  ${WHITE}$compat_count compatible shape(s):${NC}"
        echo ""
        
        local cidx=0
        while read -r shape_name; do
            [[ -z "$shape_name" ]] && continue
            ((cidx++))
            COMPAT_SHAPES["$shape_name"]=1
            printf "    ${GRAY}%-4s${NC} %s\n" "$cidx)" "$shape_name"
        done < <(echo "$compat_json" | jq -r '.data[].shape' 2>/dev/null | sort)
    else
        echo -e "  ${GRAY}No shape compatibility entries found${NC}"
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}═══ Actions ═══${NC}"
    echo -e "  ${GREEN}a${NC})  Add shape compatibility"
    echo -e "  ${RED}rm${NC}) Remove shape compatibility"
    echo -e "  ${CYAN}b${NC})  Back"
    echo ""
    echo -n -e "${CYAN}Select action: ${NC}"
    read -r action
    
    case "$action" in
        a|A)
            # Add shape compatibility
            echo ""
            echo -e "${BOLD}${WHITE}─── Add Shape Compatibility ───${NC}"
            echo ""
            
            # Fetch available shapes in the region
            echo -e "${GRAY}Fetching available shapes in region ${region}...${NC}"
            local shapes_json
            shapes_json=$(oci compute shape list --compartment-id "$compartment_id" --all --output json 2>/dev/null)
            
            if [[ -n "$shapes_json" ]] && echo "$shapes_json" | jq -e '.data[0]' &>/dev/null; then
                # Only show shapes NOT already in the compatibility list
                declare -A SHAPE_MAP=()
                local sidx=0
                local skipped=0
                
                echo ""
                printf "  ${BOLD}%-4s %-35s %-8s %-8s %-6s${NC}\n" "#" "Shape" "OCPUs" "Mem(GB)" "GPUs"
                print_separator 70
                
                while IFS='|' read -r shape_name shape_ocpus shape_mem shape_gpus; do
                    [[ -z "$shape_name" ]] && continue
                    
                    # Skip shapes already in compatibility list
                    if [[ -n "${COMPAT_SHAPES[$shape_name]}" ]]; then
                        ((skipped++))
                        continue
                    fi
                    
                    ((sidx++))
                    SHAPE_MAP[$sidx]="$shape_name"
                    
                    printf "  ${YELLOW}%-4s${NC} %-35s %-8s %-8s %-6s\n" \
                        "$sidx" "$shape_name" "${shape_ocpus:-N/A}" "${shape_mem:-N/A}" "${shape_gpus:-0}"
                done < <(echo "$shapes_json" | jq -r '
                    [.data[] | {shape: .shape, ocpus: (.ocpus // "flex"), mem: (."memory-in-gbs" // "flex"), gpus: (.gpus // 0)}] | 
                    unique_by(.shape) | sort_by(.shape)[] |
                    "\(.shape)|\(.ocpus)|\(.mem)|\(.gpus)"
                ' 2>/dev/null)
                
                echo ""
                echo -e "  ${GRAY}(${skipped} shape(s) already compatible - hidden)${NC}"
                
                if [[ "$sidx" -eq 0 ]]; then
                    echo -e "  ${GREEN}All available shapes are already compatible${NC}"
                    echo ""
                fi
                
                echo ""
                echo -e "  ${GREEN}c${NC})  Enter custom shape name (for shapes not listed above)"
                echo ""
                echo -n -e "${CYAN}Select shape # or 'c' for custom: ${NC}"
                read -r shape_input
                
                local shape_to_add=""
                if [[ "$shape_input" == "c" || "$shape_input" == "C" ]]; then
                    echo ""
                    echo -e "${GRAY}Enter the exact shape name (e.g., BM.GPU.H100.8, BM.GPU.A100-v2.8, VM.GPU.A10.1)${NC}"
                    echo -n -e "${CYAN}Custom shape name: ${NC}"
                    read -r shape_to_add
                elif [[ "$shape_input" =~ ^[0-9]+$ && -n "${SHAPE_MAP[$shape_input]}" ]]; then
                    shape_to_add="${SHAPE_MAP[$shape_input]}"
                elif [[ -n "$shape_input" ]]; then
                    # Allow direct shape name entry too
                    shape_to_add="$shape_input"
                fi
                
                if [[ -z "$shape_to_add" ]]; then
                    echo -e "${RED}No shape specified${NC}"
                    echo -e "Press Enter to continue..."
                    read -r
                    return
                fi
                
                # Check if already compatible
                if [[ -n "${COMPAT_SHAPES[$shape_to_add]}" ]]; then
                    echo -e "${YELLOW}Shape '$shape_to_add' is already compatible with this image${NC}"
                    echo -e "Press Enter to continue..."
                    read -r
                    return
                fi
                
                local cmd="oci compute image-shape-compatibility-entry add --image-id \"$selected_image\" --shape-name \"$shape_to_add\""
                
                echo ""
                echo -e "${BOLD}${WHITE}Command to execute:${NC}"
                echo -e "${GRAY}$cmd${NC}"
                echo ""
                echo -n -e "${YELLOW}Add shape compatibility for '$shape_to_add'? (y/N): ${NC}"
                read -r confirm
                
                if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: $cmd" >> "$log_file"
                    echo -e "${WHITE}$ $cmd${NC}"
                    local result
                    result=$(eval "$cmd" 2>&1)
                    
                    if [[ -z "$result" ]] || echo "$result" | jq -e '.data' &>/dev/null 2>&1; then
                        echo -e "${GREEN}✓ Shape compatibility added: $shape_to_add${NC}"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Added shape compat $shape_to_add to $selected_image_name" >> "$log_file"
                    else
                        echo -e "${RED}Failed to add shape compatibility${NC}"
                        echo "$result"
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
                    fi
                else
                    echo -e "${YELLOW}Cancelled${NC}"
                fi
            else
                echo -e "${GRAY}Could not fetch shapes from region. Enter shape name manually:${NC}"
                echo -e "${GRAY}Examples: BM.GPU.H100.8, BM.GPU.A100-v2.8, VM.GPU.A10.1, BM.Standard.E5.192${NC}"
                echo -n -e "${CYAN}Custom shape name: ${NC}"
                read -r manual_shape
                
                if [[ -n "$manual_shape" ]]; then
                    # Check if already compatible
                    if [[ -n "${COMPAT_SHAPES[$manual_shape]}" ]]; then
                        echo -e "${YELLOW}Shape '$manual_shape' is already compatible with this image${NC}"
                        echo -e "Press Enter to continue..."
                        read -r
                        return
                    fi
                    
                    local cmd="oci compute image-shape-compatibility-entry add --image-id \"$selected_image\" --shape-name \"$manual_shape\""
                    echo ""
                    echo -e "${BOLD}${WHITE}Command to execute:${NC}"
                    echo -e "${GRAY}$cmd${NC}"
                    echo ""
                    echo -n -e "${YELLOW}Add shape compatibility for '$manual_shape'? (y/N): ${NC}"
                    read -r confirm
                    
                    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: $cmd" >> "$log_file"
                        echo -e "${WHITE}$ $cmd${NC}"
                        local result
                        result=$(eval "$cmd" 2>&1)
                        if [[ -z "$result" ]] || echo "$result" | jq -e '.data' &>/dev/null 2>&1; then
                            echo -e "${GREEN}✓ Shape compatibility added: $manual_shape${NC}"
                            echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Added shape compat $manual_shape to $selected_image_name" >> "$log_file"
                        else
                            echo -e "${RED}Failed to add shape compatibility${NC}"
                            echo "$result"
                            echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
                        fi
                    fi
                fi
            fi
            ;;
        rm|RM|r)
            # Remove shape compatibility
            echo ""
            echo -e "${BOLD}${RED}─── Remove Shape Compatibility ───${NC}"
            echo ""
            
            if [[ "$compat_count" -eq 0 ]]; then
                echo -e "${GRAY}No shapes to remove${NC}"
                echo -e "Press Enter to continue..."
                read -r
                return
            fi
            
            # List current shapes with numbers for removal
            declare -A RM_SHAPE_MAP=()
            local ridx=0
            while read -r shape_name; do
                [[ -z "$shape_name" ]] && continue
                ((ridx++))
                RM_SHAPE_MAP[$ridx]="$shape_name"
                printf "  ${YELLOW}%-4s${NC} %s\n" "$ridx" "$shape_name"
            done < <(echo "$compat_json" | jq -r '.data[].shape' 2>/dev/null | sort)
            
            echo ""
            echo -n -e "${CYAN}Select shape # to remove: ${NC}"
            read -r rm_choice
            
            local shape_to_remove="${RM_SHAPE_MAP[$rm_choice]}"
            if [[ -z "$shape_to_remove" ]]; then
                echo -e "${RED}Invalid selection${NC}"
                echo -e "Press Enter to continue..."
                read -r
                return
            fi
            
            local cmd="oci compute image-shape-compatibility-entry remove --image-id \"$selected_image\" --shape-name \"$shape_to_remove\" --force"
            
            echo ""
            echo -e "${BOLD}${WHITE}Command to execute:${NC}"
            echo -e "${GRAY}$cmd${NC}"
            echo ""
            echo -n -e "${RED}Remove shape compatibility for '$shape_to_remove'? (y/N): ${NC}"
            read -r confirm
            
            if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: $cmd" >> "$log_file"
                echo -e "${WHITE}$ $cmd${NC}"
                local result
                result=$(eval "$cmd" 2>&1)
                echo -e "${GREEN}✓ Shape compatibility removed: $shape_to_remove${NC}"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Removed shape compat $shape_to_remove from $selected_image_name" >> "$log_file"
            else
                echo -e "${YELLOW}Cancelled${NC}"
            fi
            ;;
        *)
            return
            ;;
    esac
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#--------------------------------------------------------------------------------
# Custom Images - Delete
#--------------------------------------------------------------------------------
custom_image_delete() {
    local compartment_id="$1"
    local log_file="${LOGS_DIR}/custom_images_actions.log"
    mkdir -p "$(dirname "$log_file")" 2>/dev/null
    
    echo ""
    echo -e "${BOLD}${RED}═══ Delete Custom Image ═══${NC}"
    echo ""
    
    # List images (all states - user may want to delete IMPORTING/DISABLED images too)
    echo -e "${GRAY}Fetching custom images...${NC}"
    local images_json
    images_json=$(oci compute image list \
        --compartment-id "$compartment_id" \
        --sort-by TIMECREATED \
        --sort-order DESC \
        --all \
        --output json 2>/dev/null)
    
    # Filter to only show custom images (images where compartment-id matches user's compartment)
    local custom_images_json
    if [[ -n "$images_json" ]] && echo "$images_json" | jq -e '.data' > /dev/null 2>&1; then
        custom_images_json=$(echo "$images_json" | jq --arg comp_id "$compartment_id" '{data: [.data[] | select(.["compartment-id"] == $comp_id)]}')
    else
        custom_images_json='{"data":[]}'
    fi
    
    if [[ -z "$custom_images_json" ]] || ! echo "$custom_images_json" | jq -e '.data[0]' > /dev/null 2>&1; then
        echo -e "${RED}No custom images found${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    echo ""
    echo -e "${BOLD}${WHITE}─── Select Image to Delete ───${NC}"
    printf "  ${BOLD}%-3s %-105s %-20s %-14s${NC}\n" "#" "Image Name" "OS" "Status"
    print_separator 150
    
    declare -A IMAGE_MAP
    local idx=0
    
    while IFS='|' read -r img_id img_name img_os img_state; do
        [[ -z "$img_id" ]] && continue
        ((idx++))
        IMAGE_MAP[$idx]="$img_id|$img_name"
        
        # Color-code status
        local state_color="${WHITE}"
        case "$img_state" in
            AVAILABLE)    state_color="${GREEN}" ;;
            IMPORTING|PROVISIONING|EXPORTING) state_color="${YELLOW}" ;;
            DISABLED|DELETED) state_color="${RED}" ;;
            *)            state_color="${GRAY}" ;;
        esac
        
        printf "  ${YELLOW}%-3s${NC} %-105s %-20s ${state_color}%-14s${NC}\n" "$idx" "$img_name" "$img_os" "$img_state"
    done < <(echo "$custom_images_json" | jq -r '.data[] | "\(.id)|\(.["display-name"] // "Unnamed")|\(.["operating-system"] // "N/A")|\(.["lifecycle-state"] // "UNKNOWN")"' 2>/dev/null)
    
    echo ""
    echo -n -e "${CYAN}Select image # to delete: ${NC}"
    read -r img_choice
    
    local selected_entry="${IMAGE_MAP[$img_choice]}"
    if [[ -z "$selected_entry" ]]; then
        echo -e "${RED}Invalid image selection${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    local selected_image selected_image_name
    IFS='|' read -r selected_image selected_image_name <<< "$selected_entry"
    
    # Build the command
    local cmd="oci compute image delete --image-id \"$selected_image\" --force"
    
    echo ""
    echo -e "${BOLD}${RED}═══ Confirm Deletion ═══${NC}"
    echo ""
    echo -e "${RED}WARNING: This action cannot be undone!${NC}"
    echo ""
    echo -e "${CYAN}Image Name:${NC} ${WHITE}$selected_image_name${NC}"
    echo -e "${CYAN}Image OCID:${NC} ${YELLOW}$selected_image${NC}"
    echo ""
    echo -e "${BOLD}${WHITE}Command to execute:${NC}"
    echo -e "${GRAY}$cmd${NC}"
    echo ""
    echo -n -e "${RED}Type 'DELETE' to confirm deletion: ${NC}"
    read -r confirm
    
    if [[ "$confirm" != "DELETE" ]]; then
        echo -e "${YELLOW}Deletion cancelled${NC}"
        echo -e "Press Enter to continue..."
        read -r
        return
    fi
    
    # Execute deletion
    echo ""
    echo -e "${GRAY}Deleting image...${NC}"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] EXECUTE: $cmd" >> "$log_file"
    
    local result
    result=$(eval "$cmd" 2>&1)
    
    if [[ -z "$result" || "$result" == "{}" ]]; then
        echo -e "${GREEN}✓ Image deleted successfully${NC}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] SUCCESS: Deleted image $selected_image_name ($selected_image)" >> "$log_file"
    else
        echo -e "${RED}Failed to delete image${NC}"
        echo "$result"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAILED: $result" >> "$log_file"
    fi
    
    echo ""
    echo -e "Press Enter to continue..."
    read -r
}

#===============================================================================
# HELP AND USAGE
#===============================================================================

show_help() {
    echo -e "${BOLD}Usage:${NC} $0 [OPTIONS] [instance-ocid] [OPTIONS]"
    echo ""
    echo "If no instance-ocid is provided, lists all instances in the compartment with fabric details"
    echo "(Use INSTANCE_FILTER in variables.sh to filter: all, gpu, or non-gpu)"
    echo ""
    echo -e "${BOLD}Global Options:${NC}"
    echo "  --compartment-id <ocid>   Override compartment ID from variables.sh"
    echo "  --region <region>         Override region from variables.sh"
    echo "  --debug                   Enable debug mode for OCI CLI commands (verbose output)"
    echo ""
    echo -e "${BOLD}Instance Options:${NC}"
    echo "  --labels           Show all labels for the node"
    echo "  --clique           Show GPU clique information, OCI tags, cluster state, and fabric details"
    echo "  --count-clique     Count and list all nodes in the same clique with OCI tags and fabric info"
    echo "  --all              Show everything (labels + clique + count + OCI tags + fabric)"
    echo "  --details          Show full instance details including network, boot volume, block volumes"
    echo "  --console-history  Capture and display console history for the instance"
    echo "                     Useful for debugging instances that fail to join Kubernetes"
    echo "  --get-user-data    Extract and display the decoded cloud-init user-data from the instance"
    echo "                     Useful for reviewing or backing up cloud-init configurations"
    echo ""
    echo -e "${BOLD}Clique Analysis:${NC}"
    echo "  --list-cliques      List all unique cliques with nodes grouped by GPU memory cluster and fabric"
    echo "                      Also shows fabrics without active clusters and instances not in K8s"
    echo "  --cliques-summary   Show summary table of all cliques with fabric info"
    echo "                      Also shows fabrics without active clusters and instances not in K8s"
    echo ""
    echo -e "${BOLD}GPU Cluster Search:${NC}"
    echo "  <gpu-cluster-id> --list-cluster"
    echo "    List all instances in a specific GPU memory cluster with fabric details"
    echo ""
    echo -e "${BOLD}Instance Configuration:${NC}"
    echo "  <instance-config-ocid> --get-user-data-config"
    echo "    Extract and display the decoded cloud-init user-data from an instance configuration"
    echo "    Useful for reviewing instance configuration cloud-init templates"
    echo ""
    echo -e "${BOLD}Instance Termination:${NC}"
    echo "  <instance-ocid> --terminate"
    echo "    Interactively terminate an instance with full details and confirmation"
    echo "    Shows: instance details, K8s node status, running pods, termination command"
    echo "    Logs all actions to ./logs/k8s_maintenance_YYYYMMDD.log"
    echo ""
    echo -e "${BOLD}Resource Management:${NC}"
    echo "  --manage            Interactive resource management mode"
    echo "                      - OKE Cluster environment view"
    echo "                      - Network resources (subnets, NSGs)"
    echo "                      - GPU Memory Fabrics & Clusters (create, update, view)"
    echo "                      - Compute Instances (view details, IPs, volumes)"
    echo "                      - Instance Configurations (create, view, compare, delete)"
    echo "                      - Compute Clusters (create, view, delete)"
    echo "                      - GPU Instance Tagging (namespace and tags)"
    echo "                      - NVIDIA GPU Stack Health (GPU Operator & DRA per node)"
    echo "                      - Resource Manager Stacks (view stacks, jobs, logs, state)"
    echo "                      - Work Requests (view status, errors, logs)"
    echo "                      - File Storage (FSS) - file systems, mount targets, exports"
    echo "                      - Lustre File Systems - create, mount, Object Storage links"
    echo ""
    echo -e "${BOLD}Setup & Maintenance:${NC}"
    echo "  --setup             Run initial setup to create/update variables.sh"
    echo "                      Auto-detects environment from IMDS and allows resource selection"
    echo "  --refresh           Clear all cached data to force fresh fetch from OCI"
    echo "                      Useful after infrastructure changes or stale data"
    echo "  --maintenance       Show instances requiring maintenance attention"
    echo "                      Lists instances with DEGRADED capacity topology or active announcements"
    echo "  --maintenance-events  View/manage instance maintenance events (reschedule)"
    echo "                      Cached for 1 hour; shows fault details, allows rescheduling"
    echo "  --announcements     Show all announcements with affected resource details"
    echo "                      Validates if affected instances still exist in OCI"
    echo ""
    echo -e "${BOLD}Interactive Features:${NC}"
    echo "  When listing GPU instances, if instances not in kubernetes (running in OCI but not in K8s)"
    echo "  are found, you will be prompted to select one to view its console history."
    echo "  This helps diagnose why an instance failed to join the Kubernetes cluster."
    echo ""
    echo -e "${BOLD}Examples:${NC}"
    echo "  $0                                                    # List all instances with fabric info"
    echo "  $0 --refresh                                          # Clear cache and force fresh data"
    echo "  $0 --maintenance                                      # Show instances needing maintenance"
    echo "  $0 --maintenance-events                               # View/reschedule maintenance events"
    echo "  $0 --announcements                                    # Show all announcements with resources"
    echo "  $0 --compartment-id ocid1.compartment.oc1..xxx        # Use different compartment"
    echo "  $0 --region us-ashburn-1                              # Use different region"
    echo "  $0 --list-cliques                                     # List all cliques with fabric details"
    echo "  $0 --cliques-summary                                  # Summary table of cliques with fabric"
    echo "  $0 --manage                                           # Interactive resource management"
    echo "  $0 --manage --debug                                   # Resource management with debug output"
    echo "  $0 --setup                                            # Run initial setup wizard"
    echo "  $0 ocid1.instance.oc1.us-dallas-1.xxx                 # Basic node info"
    echo "  $0 ocid1.instance.oc1.us-dallas-1.xxx --labels        # Show labels"
    echo "  $0 ocid1.instance.oc1.us-dallas-1.xxx --clique        # Show clique info + fabric"
    echo "  $0 ocid1.instance.oc1.us-dallas-1.xxx --count-clique  # Show clique members + fabric"
    echo "  $0 ocid1.instance.oc1.us-dallas-1.xxx --all           # Show everything"
    echo "  $0 ocid1.instance.oc1.us-dallas-1.xxx --details       # Full details (network, volumes)"
    echo "  $0 ocid1.instance.oc1.us-dallas-1.xxx --console-history  # View console history"
    echo "  $0 ocid1.instance.oc1.us-dallas-1.xxx --get-user-data    # Extract cloud-init from instance"
    echo "  $0 ocid1.computegpumemorycluster.xxx --list-cluster    # List cluster instances + fabric"
    echo "  $0 ocid1.instanceconfig.xxx --get-user-data-config    # Extract cloud-init from instance config"
    echo "  $0 ocid1.instance.xxx --terminate                     # Interactively terminate instance with details"
}

#===============================================================================
# MAIN
#===============================================================================

#===============================================================================
# INITIAL SETUP FUNCTIONS
#===============================================================================

# IMDS v2 endpoint
readonly IMDS_BASE="http://169.254.169.254/opc/v2"
readonly IMDS_HEADER="Authorization: Bearer Oracle"

#--------------------------------------------------------------------------------
# Check if running on OCI instance with IMDS available
#--------------------------------------------------------------------------------
is_oci_instance() {
    curl -sS -H "$IMDS_HEADER" "${IMDS_BASE}/instance/" -o /dev/null 2>/dev/null
}

#--------------------------------------------------------------------------------
# Wait for IMDS to be available
#--------------------------------------------------------------------------------
wait_for_imds() {
    local timeout=60
    local elapsed=0
    
    echo -e "${YELLOW}Waiting for IMDS...${NC}"
    while true; do
        if curl -sS -H "$IMDS_HEADER" "${IMDS_BASE}/instance/" -o /dev/null 2>/dev/null; then
            echo -e "${GREEN}IMDS available${NC}"
            return 0
        fi
        sleep 2
        elapsed=$((elapsed + 2))
        if [[ $elapsed -ge $timeout ]]; then
            echo -e "${RED}ERROR: Timeout waiting for IMDS${NC}" >&2
            return 1
        fi
    done
}

#--------------------------------------------------------------------------------
# Fetch instance metadata from IMDS
#--------------------------------------------------------------------------------
fetch_imds_metadata() {
    echo -e "${YELLOW}Fetching instance metadata...${NC}"
    
    local instance_json
    instance_json=$(curl -sH "$IMDS_HEADER" -L "${IMDS_BASE}/instance/" 2>/dev/null)
    
    if [[ -z "$instance_json" ]]; then
        echo -e "${RED}ERROR: Failed to fetch instance metadata${NC}" >&2
        return 1
    fi
    
    # Extract values
    SETUP_TENANCY_ID=$(echo "$instance_json" | jq -r '.tenantId // empty')
    SETUP_COMPARTMENT_ID=$(echo "$instance_json" | jq -r '.compartmentId // empty')
    SETUP_REGION=$(echo "$instance_json" | jq -r '.canonicalRegionName // empty')
    SETUP_AD=$(echo "$instance_json" | jq -r '.availabilityDomain // empty')
    
    if [[ -z "$SETUP_TENANCY_ID" || -z "$SETUP_COMPARTMENT_ID" || -z "$SETUP_REGION" ]]; then
        echo -e "${RED}ERROR: Missing required metadata fields${NC}" >&2
        return 1
    fi
    
    echo -e "${GREEN}Metadata fetched successfully${NC}"
    return 0
}

#--------------------------------------------------------------------------------
# Check OCI CLI with instance principal auth
#--------------------------------------------------------------------------------
check_oci_instance_principal() {
    if ! command -v oci &>/dev/null; then
        echo -e "${RED}ERROR: OCI CLI not found${NC}" >&2
        return 1
    fi
    
    if ! oci iam region list --auth instance_principal &>/dev/null; then
        echo -e "${RED}ERROR: Instance principal authentication failed${NC}" >&2
        return 1
    fi
    
    echo -e "${GREEN}OCI CLI available with instance principal auth${NC}"
    return 0
}

#--------------------------------------------------------------------------------
# Select from list helper for initial setup
#--------------------------------------------------------------------------------
setup_select_from_list() {
    local prompt="$1"
    local -n items_ref=$2
    local -n result_ref=$3
    local allow_skip="${4:-false}"
    
    if [[ ${#items_ref[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No items available${NC}"
        result_ref=""
        return 1
    fi
    
    declare -A local_map
    local idx=1
    for item in "${items_ref[@]}"; do
        local name=$(echo "$item" | cut -d'|' -f1)
        local id=$(echo "$item" | cut -d'|' -f2)
        local extra=$(echo "$item" | cut -d'|' -f3-)
        
        if [[ -n "$extra" ]]; then
            printf "${YELLOW}%3d${NC}) ${CYAN}%-50s${NC} ${GRAY}%s${NC}\n" "$idx" "$name" "$extra"
        else
            printf "${YELLOW}%3d${NC}) ${CYAN}%-50s${NC}\n" "$idx" "$name"
        fi
        
        local_map[$idx]="$id"
        ((idx++))
    done
    
    if [[ "$allow_skip" == "true" ]]; then
        echo -e "${GRAY}  0) Skip / Enter manually later${NC}"
    fi
    
    echo ""
    while true; do
        echo -n -e "${WHITE}$prompt ${NC}"
        read -r selection
        
        if [[ "$allow_skip" == "true" && "$selection" == "0" ]]; then
            result_ref=""
            return 0
        fi
        
        if [[ "$selection" =~ ^[0-9]+$ ]] && [[ -n "${local_map[$selection]:-}" ]]; then
            result_ref="${local_map[$selection]}"
            return 0
        fi
        
        echo -e "${RED}Invalid selection. Please try again.${NC}"
    done
}

#--------------------------------------------------------------------------------
# Run initial setup to create variables.sh
#--------------------------------------------------------------------------------
run_initial_setup() {
    echo ""
    echo -e "${BOLD}${BLUE}═══════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${WHITE}  Initial Setup - Creating variables.sh${NC}"
    echo -e "${BOLD}${BLUE}═══════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    
    # Check if on OCI instance
    if ! is_oci_instance; then
        echo -e "${RED}ERROR: Not running on an OCI instance or IMDS not available${NC}"
        echo -e "${YELLOW}Please create variables.sh manually with:${NC}"
        echo -e "  REGION=\"your-region\""
        echo -e "  TENANCY_ID=\"ocid1.tenancy...\""
        echo -e "  COMPARTMENT_ID=\"ocid1.compartment...\""
        return 1
    fi
    
    wait_for_imds || return 1
    fetch_imds_metadata || return 1
    check_oci_instance_principal || return 1
    
    echo ""
    echo -e "${WHITE}Base environment detected:${NC}"
    echo -e "  Region: ${CYAN}$SETUP_REGION${NC}"
    echo -e "  Compartment: ${CYAN}${SETUP_COMPARTMENT_ID:0:50}...${NC}"
    echo -e "  AD: ${CYAN}$SETUP_AD${NC}"
    
    # Initialize variables
    local oke_cluster_id="" oke_cluster_name="" vcn_id=""
    local worker_subnet_id="" worker_nsg_id="" pod_subnet_id="" pod_nsg_id=""
    local cc_id="" ic_id="" gpu_fabric_id="" image_id=""
    
    # Select OKE Cluster
    echo ""
    echo -e "${BOLD}${CYAN}─── OKE Clusters ───${NC}"
    echo ""
    echo -e "${YELLOW}Fetching OKE clusters...${NC}"
    
    local clusters_json
    clusters_json=$(oci ce cluster list \
        --compartment-id "$SETUP_COMPARTMENT_ID" \
        --auth instance_principal \
        --lifecycle-state ACTIVE \
        --all \
        --output json 2>/dev/null)
    
    local -a clusters=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && clusters+=("$line")
    done < <(echo "$clusters_json" | jq -r '.data[] | "\(.name)|\(.id)|\(.["kubernetes-version"])"' 2>/dev/null)
    
    if [[ ${#clusters[@]} -eq 1 ]]; then
        oke_cluster_name=$(echo "${clusters[0]}" | cut -d'|' -f1)
        oke_cluster_id=$(echo "${clusters[0]}" | cut -d'|' -f2)
        local k8s_version=$(echo "${clusters[0]}" | cut -d'|' -f3)
        
        echo -e "${GREEN}Auto-selected (only cluster):${NC}"
        echo -e "  ${CYAN}Name:${NC}    ${WHITE}$oke_cluster_name${NC}"
        echo -e "  ${CYAN}Version:${NC} ${WHITE}$k8s_version${NC}"
        echo ""
        echo -n -e "${CYAN}Use this cluster? (y/n): ${NC}"
        read -r confirm
        [[ ! "$confirm" =~ ^[Yy]$ && -n "$confirm" ]] && oke_cluster_id=""
    elif [[ ${#clusters[@]} -gt 1 ]]; then
        setup_select_from_list "Select OKE Cluster:" clusters oke_cluster_id true
        [[ -n "$oke_cluster_id" ]] && oke_cluster_name=$(echo "$clusters_json" | jq -r --arg id "$oke_cluster_id" '.data[] | select(.id == $id) | .name')
    fi
    
    # Get VCN from cluster
    if [[ -n "$oke_cluster_id" ]]; then
        vcn_id=$(oci ce cluster get --cluster-id "$oke_cluster_id" --auth instance_principal --query 'data."vcn-id"' --raw-output 2>/dev/null)
        echo -e "${GREEN}Selected: ${WHITE}$oke_cluster_name${NC}"
    fi
    
    # Auto-detect network resources if VCN available
    if [[ -n "$vcn_id" ]]; then
        echo ""
        echo -e "${BOLD}${CYAN}─── Network Configuration ───${NC}"
        echo ""
        echo -e "${YELLOW}Auto-detecting network resources...${NC}"
        
        local subnets_json nsgs_json
        subnets_json=$(oci network subnet list --compartment-id "$SETUP_COMPARTMENT_ID" --vcn-id "$vcn_id" --auth instance_principal --all --output json 2>/dev/null)
        nsgs_json=$(oci network nsg list --compartment-id "$SETUP_COMPARTMENT_ID" --vcn-id "$vcn_id" --auth instance_principal --all --output json 2>/dev/null)
        
        # Auto-detect by name patterns - get both ID and name
        local worker_subnet_name="" pod_subnet_name="" worker_nsg_name="" pod_nsg_name=""
        
        worker_subnet_id=$(echo "$subnets_json" | jq -r '.data[] | select(.["display-name"] | test("worker"; "i")) | .id' 2>/dev/null | head -1)
        [[ -n "$worker_subnet_id" ]] && worker_subnet_name=$(echo "$subnets_json" | jq -r --arg id "$worker_subnet_id" '.data[] | select(.id == $id) | .["display-name"]' 2>/dev/null)
        
        pod_subnet_id=$(echo "$subnets_json" | jq -r '.data[] | select(.["display-name"] | test("pod"; "i")) | .id' 2>/dev/null | head -1)
        [[ -n "$pod_subnet_id" ]] && pod_subnet_name=$(echo "$subnets_json" | jq -r --arg id "$pod_subnet_id" '.data[] | select(.id == $id) | .["display-name"]' 2>/dev/null)
        
        worker_nsg_id=$(echo "$nsgs_json" | jq -r '.data[] | select(.["display-name"] | test("worker"; "i")) | .id' 2>/dev/null | head -1)
        [[ -n "$worker_nsg_id" ]] && worker_nsg_name=$(echo "$nsgs_json" | jq -r --arg id "$worker_nsg_id" '.data[] | select(.id == $id) | .["display-name"]' 2>/dev/null)
        
        pod_nsg_id=$(echo "$nsgs_json" | jq -r '.data[] | select(.["display-name"] | test("pod"; "i")) | .id' 2>/dev/null | head -1)
        [[ -n "$pod_nsg_id" ]] && pod_nsg_name=$(echo "$nsgs_json" | jq -r --arg id "$pod_nsg_id" '.data[] | select(.id == $id) | .["display-name"]' 2>/dev/null)
        
        # Display detected with names
        echo ""
        echo -e "${BOLD}${WHITE}Auto-detected Network Configuration:${NC}"
        [[ -n "$worker_subnet_id" ]] && echo -e "  ${GREEN}✓${NC} Worker Subnet: ${WHITE}$worker_subnet_name${NC}" || echo -e "  ${YELLOW}○${NC} Worker Subnet: ${GRAY}(not detected)${NC}"
        [[ -n "$worker_nsg_id" ]] && echo -e "  ${GREEN}✓${NC} Worker NSG:    ${WHITE}$worker_nsg_name${NC}" || echo -e "  ${YELLOW}○${NC} Worker NSG:    ${GRAY}(not detected)${NC}"
        [[ -n "$pod_subnet_id" ]] && echo -e "  ${GREEN}✓${NC} Pod Subnet:    ${WHITE}$pod_subnet_name${NC}" || echo -e "  ${YELLOW}○${NC} Pod Subnet:    ${GRAY}(not detected)${NC}"
        [[ -n "$pod_nsg_id" ]] && echo -e "  ${GREEN}✓${NC} Pod NSG:       ${WHITE}$pod_nsg_name${NC}" || echo -e "  ${YELLOW}○${NC} Pod NSG:       ${GRAY}(not detected)${NC}"
        
        echo ""
        echo -n -e "${CYAN}Accept detected network settings? (y/n): ${NC}"
        read -r net_confirm
        if [[ "$net_confirm" =~ ^[Nn]$ ]]; then
            worker_subnet_id="" worker_nsg_id="" pod_subnet_id="" pod_nsg_id=""
        fi
    fi
    
    # Select Compute Cluster
    echo ""
    echo -e "${BOLD}${CYAN}─── Compute Cluster ───${NC}"
    echo ""
    echo -e "${YELLOW}Fetching compute clusters...${NC}"
    
    local cc_json
    cc_json=$(oci compute compute-cluster list \
        --compartment-id "$SETUP_COMPARTMENT_ID" \
        --availability-domain "$SETUP_AD" \
        --auth instance_principal \
        --all \
        --output json 2>/dev/null)
    
    local -a compute_clusters=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && compute_clusters+=("$line")
    done < <(echo "$cc_json" | jq -r '.data.items[] | "\(.["display-name"])|\(.id)"' 2>/dev/null)
    
    if [[ ${#compute_clusters[@]} -gt 0 ]]; then
        setup_select_from_list "Select Compute Cluster:" compute_clusters cc_id true
    else
        echo -e "${YELLOW}No compute clusters found${NC}"
    fi
    
    # Select Instance Configuration
    echo ""
    echo -e "${BOLD}${CYAN}─── Instance Configuration ───${NC}"
    echo ""
    echo -e "${YELLOW}Fetching instance configurations...${NC}"
    
    local ic_json
    ic_json=$(oci compute-management instance-configuration list \
        --compartment-id "$SETUP_COMPARTMENT_ID" \
        --auth instance_principal \
        --all \
        --output json 2>/dev/null)
    
    local -a instance_configs=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && instance_configs+=("$line")
    done < <(echo "$ic_json" | jq -r '.data[] | "\(.["display-name"])|\(.id)"' 2>/dev/null)
    
    if [[ ${#instance_configs[@]} -gt 0 ]]; then
        setup_select_from_list "Select Instance Configuration:" instance_configs ic_id true
    else
        echo -e "${YELLOW}No instance configurations found${NC}"
    fi
    
    # Select GPU Memory Fabric (only if fabrics exist in region)
    local fabric_json
    fabric_json=$(oci compute compute-gpu-memory-fabric list \
        --compartment-id "$SETUP_TENANCY_ID" \
        --auth instance_principal \
        --all \
        --output json 2>/dev/null)
    
    local -a fabrics=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && fabrics+=("$line")
    done < <(echo "$fabric_json" | jq -r --arg region "$SETUP_REGION" '.data.items[] | select(.id | contains($region)) | "\(.["display-name"])|\(.id)|\(.["lifecycle-state"]) avail=\(.["available-host-count"])"' 2>/dev/null)
    
    if [[ ${#fabrics[@]} -gt 0 ]]; then
        echo ""
        echo -e "${BOLD}${CYAN}─── GPU Memory Fabric ───${NC}"
        echo ""
        setup_select_from_list "Select GPU Memory Fabric:" fabrics gpu_fabric_id true
    fi
    
    # Select Custom Image
    echo ""
    echo -e "${BOLD}${CYAN}─── Custom Image ───${NC}"
    echo ""
    echo -e "${YELLOW}Fetching custom images...${NC}"
    
    local images_json
    images_json=$(oci compute image list \
        --compartment-id "$SETUP_COMPARTMENT_ID" \
        --auth instance_principal \
        --all \
        --lifecycle-state AVAILABLE \
        --sort-by TIMECREATED \
        --sort-order DESC \
        --output json 2>/dev/null)
    
    local -a images=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && images+=("$line")
    done < <(echo "$images_json" | jq -r --arg comp "$SETUP_COMPARTMENT_ID" '.data[] | select(.["compartment-id"] == $comp) | "\(.["display-name"][:50])|\(.id)|\(.["time-created"][:10])"' 2>/dev/null)
    
    if [[ ${#images[@]} -gt 0 ]]; then
        setup_select_from_list "Select Image:" images image_id true
    else
        echo -e "${YELLOW}No custom images found${NC}"
    fi
    
    # Display summary
    echo ""
    echo -e "${BOLD}${BLUE}═══════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${WHITE}  Configuration Summary${NC}"
    echo -e "${BOLD}${BLUE}═══════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${BOLD}${WHITE}Base Environment:${NC}"
    echo -e "  ${CYAN}Region:${NC}         $SETUP_REGION"
    echo -e "  ${CYAN}Tenancy:${NC}        $SETUP_TENANCY_ID"
    echo -e "  ${CYAN}Compartment:${NC}    $SETUP_COMPARTMENT_ID"
    echo -e "  ${CYAN}AD:${NC}             $SETUP_AD"
    echo ""
    echo -e "${BOLD}${WHITE}Selected Resources:${NC}"
    [[ -n "$oke_cluster_id" ]] && echo -e "  ${GREEN}✓${NC} OKE Cluster: $oke_cluster_name" || echo -e "  ${YELLOW}○${NC} OKE Cluster: (not set)"
    [[ -n "$worker_subnet_id" ]] && echo -e "  ${GREEN}✓${NC} Worker Subnet" || echo -e "  ${YELLOW}○${NC} Worker Subnet: (not set)"
    [[ -n "$worker_nsg_id" ]] && echo -e "  ${GREEN}✓${NC} Worker NSG" || echo -e "  ${YELLOW}○${NC} Worker NSG: (not set)"
    [[ -n "$pod_subnet_id" ]] && echo -e "  ${GREEN}✓${NC} Pod Subnet" || echo -e "  ${YELLOW}○${NC} Pod Subnet: (not set)"
    [[ -n "$pod_nsg_id" ]] && echo -e "  ${GREEN}✓${NC} Pod NSG" || echo -e "  ${YELLOW}○${NC} Pod NSG: (not set)"
    [[ -n "$cc_id" ]] && echo -e "  ${GREEN}✓${NC} Compute Cluster" || echo -e "  ${YELLOW}○${NC} Compute Cluster: (not set)"
    [[ -n "$ic_id" ]] && echo -e "  ${GREEN}✓${NC} Instance Config" || echo -e "  ${YELLOW}○${NC} Instance Config: (not set)"
    [[ -n "$gpu_fabric_id" ]] && echo -e "  ${GREEN}✓${NC} GPU Fabric" || echo -e "  ${YELLOW}○${NC} GPU Fabric: (not set)"
    [[ -n "$image_id" ]] && echo -e "  ${GREEN}✓${NC} Image" || echo -e "  ${YELLOW}○${NC} Image: (not set)"
    
    # Save configuration
    echo ""
    echo -n -e "${CYAN}Save configuration to variables.sh? (y/n): ${NC}"
    read -r save_choice
    
    if [[ ! "$save_choice" =~ ^[Yy]$ && -n "$save_choice" ]]; then
        echo -e "${YELLOW}Configuration not saved${NC}"
        return 1
    fi
    
    local output_file="./variables.sh"
    cat > "$output_file" <<EOF
#!/bin/bash
#===============================================================================
# OCI Environment Configuration
# Auto-generated on $(date -u +"%Y-%m-%d %H:%M:%S UTC")
#===============================================================================

# Tenancy Variables
REGION="$SETUP_REGION"
TENANCY_ID="$SETUP_TENANCY_ID"

# Compartment where the OKE Cluster and worker nodes reside
COMPARTMENT_ID="$SETUP_COMPARTMENT_ID"

# OCI AD name for the region
AD="$SETUP_AD"

# OKE Cluster OCID (used by --manage to determine which cluster to display)
OKE_CLUSTER_ID="$oke_cluster_id"
CLUSTER_NAME="$oke_cluster_name"

# OKE Worker and POD Subnets
WORKER_SUBNET_ID="$worker_subnet_id"
WORKER_SUBNET_NSG_ID="$worker_nsg_id"
POD_SUBNET_ID="$pod_subnet_id"
POD_SUBNET_NSG_ID="$pod_nsg_id"

# Image for OKE Worker Nodes
IMAGE_ID="$image_id"

# Shape for GPU nodes
SHAPE_NAME="BM.GPU.GB200-v3.4"

# Compute Cluster OCID
CC_ID="$cc_id"

# Instance Configuration OCID
IC_ID="$ic_id"

# GPU Memory Fabric ID
GPU_MEMORY_FABRIC_ID="$gpu_fabric_id"

# GPU Memory Cluster size
GPU_MEMORY_CLUSTER_SIZE=18

# Instance filter for listing: "gpu", "non-gpu", or "all"
# gpu     = Only show GPU instances (BM.GPU.*)
# non-gpu = Only show non-GPU instances
# all     = Show all instances
INSTANCE_FILTER="all"
EOF

    chmod +x "$output_file"
    echo -e "${GREEN}Configuration saved to: ${WHITE}$output_file${NC}"
    echo ""
    
    return 0
}

#--------------------------------------------------------------------------------
# Check if variables.sh has required values populated
#--------------------------------------------------------------------------------
check_variables_populated() {
    # Check minimum required variables
    if [[ -z "${COMPARTMENT_ID:-}" || -z "${REGION:-}" || -z "${TENANCY_ID:-}" ]]; then
        return 1
    fi
    return 0
}

#===============================================================================
# MAIN FUNCTION
#===============================================================================

main() {
    # Check dependencies first
    check_dependencies || exit 1
    
    # Source variables file
    local variables_found=false
    if [[ -f "$SCRIPT_DIR/variables.sh" ]]; then
        # shellcheck source=/dev/null
        source "$SCRIPT_DIR/variables.sh"
        variables_found=true
    elif [[ -f "./variables.sh" ]]; then
        # shellcheck source=/dev/null
        source "./variables.sh"
        variables_found=true
    fi
    
    # Check if variables.sh exists and has required values
    if [[ "$variables_found" == "false" ]]; then
        echo -e "${YELLOW}variables.sh not found.${NC}"
        echo ""
        echo -n -e "${CYAN}Would you like to run initial setup? (y/n): ${NC}"
        read -r setup_choice
        
        if [[ "$setup_choice" =~ ^[Yy]$ || -z "$setup_choice" ]]; then
            if run_initial_setup; then
                # Re-source the newly created file
                source "./variables.sh"
            else
                echo -e "${RED}Setup failed or cancelled. Exiting.${NC}"
                exit 1
            fi
        else
            echo -e "${YELLOW}Please create variables.sh with COMPARTMENT_ID, REGION, and TENANCY_ID.${NC}"
            exit 1
        fi
    elif ! check_variables_populated; then
        echo -e "${YELLOW}variables.sh exists but required values (COMPARTMENT_ID, REGION, TENANCY_ID) are not set.${NC}"
        echo ""
        echo -n -e "${CYAN}Would you like to run setup to populate values? (y/n): ${NC}"
        read -r setup_choice
        
        if [[ "$setup_choice" =~ ^[Yy]$ || -z "$setup_choice" ]]; then
            if run_initial_setup; then
                # Re-source the file
                source "./variables.sh"
            else
                echo -e "${RED}Setup failed or cancelled.${NC}"
                exit 1
            fi
        fi
    fi
    
    # Create cache and temp directories
    mkdir -p "$CACHE_DIR"
    mkdir -p "$TEMP_DIR"
    
    # Cleanup temp files on exit
    trap 'rm -rf "${TEMP_DIR:?}"/* 2>/dev/null' EXIT
    
    # Parse global options
    local custom_compartment=""
    local custom_region=""
    local args=("$@")
    local new_args=()
    local i=0
    
    while [[ $i -lt ${#args[@]} ]]; do
        case "${args[$i]}" in
            --compartment-id)
                if [[ $((i + 1)) -lt ${#args[@]} ]]; then
                    custom_compartment="${args[$((i + 1))]}"
                    i=$((i + 2))
                else
                    log_error "--compartment-id requires a value"
                    exit 1
                fi
                ;;
            --region)
                if [[ $((i + 1)) -lt ${#args[@]} ]]; then
                    custom_region="${args[$((i + 1))]}"
                    i=$((i + 2))
                else
                    log_error "--region requires a value"
                    exit 1
                fi
                ;;
            --debug)
                DEBUG_MODE=true
                i=$((i + 1))
                ;;
            *)
                new_args+=("${args[$i]}")
                i=$((i + 1))
                ;;
        esac
    done
    
    # Set effective values (global scope for other functions)
    EFFECTIVE_COMPARTMENT_ID="${custom_compartment:-$COMPARTMENT_ID}"
    EFFECTIVE_REGION="${custom_region:-$REGION}"
    
    # Restore positional parameters
    set -- "${new_args[@]}"
    
    # Route to appropriate function based on arguments
    case "${1:-}" in
        "")
            list_all_instances "$EFFECTIVE_COMPARTMENT_ID" "$EFFECTIVE_REGION"
            ;;
        --setup)
            run_initial_setup
            ;;
        --list-cliques)
            list_all_cliques
            ;;
        --cliques-summary)
            list_cliques_summary
            ;;
        --manage)
            interactive_management_main_menu
            ;;
        --maintenance)
            list_maintenance_instances "$EFFECTIVE_COMPARTMENT_ID" "$EFFECTIVE_REGION"
            ;;
        --maintenance-events)
            list_maintenance_events "$EFFECTIVE_COMPARTMENT_ID" "$EFFECTIVE_REGION"
            ;;
        --announcements)
            list_all_announcements "$EFFECTIVE_COMPARTMENT_ID" "$EFFECTIVE_REGION"
            ;;
        --refresh)
            refresh_all_caches
            ;;
        --help|-h)
            show_help
            ;;
        *)
            # Assume it's an instance OCID or instance config OCID or GPU cluster OCID
            local instance_id="$1"
            local show_labels="false"
            local show_clique="false"
            local count_clique="false"
            local show_console_history="false"
            local show_instance_details="false"
            local show_user_data="false"
            local show_config_user_data="false"
            local show_list_cluster="false"
            local do_terminate="false"
            
            shift
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --labels)
                        show_labels="true"
                        shift
                        ;;
                    --clique)
                        show_clique="true"
                        shift
                        ;;
                    --count-clique)
                        count_clique="true"
                        show_clique="true"
                        shift
                        ;;
                    --all)
                        show_labels="true"
                        show_clique="true"
                        count_clique="true"
                        shift
                        ;;
                    --console-history)
                        show_console_history="true"
                        shift
                        ;;
                    --details)
                        show_instance_details="true"
                        shift
                        ;;
                    --get-user-data)
                        show_user_data="true"
                        shift
                        ;;
                    --get-user-data-config)
                        show_config_user_data="true"
                        shift
                        ;;
                    --list-cluster)
                        show_list_cluster="true"
                        shift
                        ;;
                    --terminate)
                        do_terminate="true"
                        shift
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            
            if [[ "$do_terminate" == "true" ]]; then
                terminate_instance_interactive "$instance_id"
            elif [[ "$show_list_cluster" == "true" ]]; then
                list_instances_by_gpu_cluster "$instance_id" "$EFFECTIVE_COMPARTMENT_ID" "$EFFECTIVE_REGION"
            elif [[ "$show_config_user_data" == "true" ]]; then
                get_instance_config_user_data "$instance_id"
            elif [[ "$show_user_data" == "true" ]]; then
                get_instance_user_data "$instance_id"
            elif [[ "$show_console_history" == "true" ]]; then
                get_console_history "$instance_id"
            elif [[ "$show_instance_details" == "true" ]]; then
                # Loop to handle refresh requests
                while true; do
                    display_instance_details "$instance_id"
                    local ret=$?
                    [[ $ret -ne 2 ]] && break  # Exit loop unless refresh requested
                done
            else
                get_node_info "$instance_id" "$show_labels" "$show_clique" "$count_clique"
            fi
            ;;
    esac
}

# Run main function
main "$@"
